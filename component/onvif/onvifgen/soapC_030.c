/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:06 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StorageReferencePathExtension(struct soap *soap, struct tt__StorageReferencePathExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StorageReferencePathExtension))
		soap_serialize_tt__StorageReferencePathExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StorageReferencePathExtension(struct soap *soap, const char *tag, int id, struct tt__StorageReferencePathExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StorageReferencePathExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StorageReferencePathExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__StorageReferencePathExtension ** SOAP_FMAC4 soap_in_PointerTott__StorageReferencePathExtension(struct soap *soap, const char *tag, struct tt__StorageReferencePathExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__StorageReferencePathExtension **)soap_malloc(soap, sizeof(struct tt__StorageReferencePathExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StorageReferencePathExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__StorageReferencePathExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StorageReferencePathExtension, sizeof(struct tt__StorageReferencePathExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StorageReferencePathExtension(struct soap *soap, struct tt__StorageReferencePathExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StorageReferencePathExtension(soap, tag ? tag : "tt:StorageReferencePathExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StorageReferencePathExtension ** SOAP_FMAC4 soap_get_PointerTott__StorageReferencePathExtension(struct soap *soap, struct tt__StorageReferencePathExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StorageReferencePathExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, struct tt__ArrayOfFileProgressExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ArrayOfFileProgressExtension))
		soap_serialize_tt__ArrayOfFileProgressExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, const char *tag, int id, struct tt__ArrayOfFileProgressExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ArrayOfFileProgressExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ArrayOfFileProgressExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgressExtension ** SOAP_FMAC4 soap_in_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, const char *tag, struct tt__ArrayOfFileProgressExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ArrayOfFileProgressExtension **)soap_malloc(soap, sizeof(struct tt__ArrayOfFileProgressExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ArrayOfFileProgressExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ArrayOfFileProgressExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ArrayOfFileProgressExtension, sizeof(struct tt__ArrayOfFileProgressExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, struct tt__ArrayOfFileProgressExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ArrayOfFileProgressExtension(soap, tag ? tag : "tt:ArrayOfFileProgressExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgressExtension ** SOAP_FMAC4 soap_get_PointerTott__ArrayOfFileProgressExtension(struct soap *soap, struct tt__ArrayOfFileProgressExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ArrayOfFileProgressExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FileProgress(struct soap *soap, struct tt__FileProgress *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FileProgress))
		soap_serialize_tt__FileProgress(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FileProgress(struct soap *soap, const char *tag, int id, struct tt__FileProgress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FileProgress, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FileProgress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FileProgress ** SOAP_FMAC4 soap_in_PointerTott__FileProgress(struct soap *soap, const char *tag, struct tt__FileProgress **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FileProgress **)soap_malloc(soap, sizeof(struct tt__FileProgress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FileProgress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FileProgress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FileProgress, sizeof(struct tt__FileProgress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FileProgress(struct soap *soap, struct tt__FileProgress *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FileProgress(soap, tag ? tag : "tt:FileProgress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FileProgress ** SOAP_FMAC4 soap_get_PointerTott__FileProgress(struct soap *soap, struct tt__FileProgress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FileProgress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, struct tt__OSDConfigurationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension))
		soap_serialize_tt__OSDConfigurationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__OSDConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDConfigurationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDConfigurationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDConfigurationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__OSDConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDConfigurationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(struct tt__OSDConfigurationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, struct tt__OSDConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfigurationOptionsExtension(soap, tag ? tag : "tt:OSDConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, struct tt__OSDConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgOptions(struct soap *soap, struct tt__OSDImgOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgOptions))
		soap_serialize_tt__OSDImgOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgOptions(struct soap *soap, const char *tag, int id, struct tt__OSDImgOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDImgOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDImgOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDImgOptions(struct soap *soap, const char *tag, struct tt__OSDImgOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDImgOptions **)soap_malloc(soap, sizeof(struct tt__OSDImgOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDImgOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgOptions, sizeof(struct tt__OSDImgOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgOptions(struct soap *soap, struct tt__OSDImgOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgOptions(soap, tag ? tag : "tt:OSDImgOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDImgOptions(struct soap *soap, struct tt__OSDImgOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextOptions(struct soap *soap, struct tt__OSDTextOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextOptions))
		soap_serialize_tt__OSDTextOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextOptions(struct soap *soap, const char *tag, int id, struct tt__OSDTextOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDTextOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDTextOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDTextOptions(struct soap *soap, const char *tag, struct tt__OSDTextOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDTextOptions **)soap_malloc(soap, sizeof(struct tt__OSDTextOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDTextOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextOptions, sizeof(struct tt__OSDTextOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextOptions(struct soap *soap, struct tt__OSDTextOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextOptions(soap, tag ? tag : "tt:OSDTextOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDTextOptions(struct soap *soap, struct tt__OSDTextOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDType(struct soap *soap, enum tt__OSDType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__OSDType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDType(struct soap *soap, const char *tag, int id, enum tt__OSDType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__OSDType ** SOAP_FMAC4 soap_in_PointerTott__OSDType(struct soap *soap, const char *tag, enum tt__OSDType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__OSDType **)soap_malloc(soap, sizeof(enum tt__OSDType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__OSDType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDType, sizeof(enum tt__OSDType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDType(struct soap *soap, enum tt__OSDType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDType(soap, tag ? tag : "tt:OSDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__OSDType ** SOAP_FMAC4 soap_get_PointerTott__OSDType(struct soap *soap, enum tt__OSDType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MaximumNumberOfOSDs(struct soap *soap, struct tt__MaximumNumberOfOSDs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MaximumNumberOfOSDs))
		soap_serialize_tt__MaximumNumberOfOSDs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MaximumNumberOfOSDs(struct soap *soap, const char *tag, int id, struct tt__MaximumNumberOfOSDs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MaximumNumberOfOSDs, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MaximumNumberOfOSDs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MaximumNumberOfOSDs ** SOAP_FMAC4 soap_in_PointerTott__MaximumNumberOfOSDs(struct soap *soap, const char *tag, struct tt__MaximumNumberOfOSDs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MaximumNumberOfOSDs **)soap_malloc(soap, sizeof(struct tt__MaximumNumberOfOSDs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MaximumNumberOfOSDs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MaximumNumberOfOSDs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(struct tt__MaximumNumberOfOSDs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MaximumNumberOfOSDs(struct soap *soap, struct tt__MaximumNumberOfOSDs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MaximumNumberOfOSDs(soap, tag ? tag : "tt:MaximumNumberOfOSDs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MaximumNumberOfOSDs ** SOAP_FMAC4 soap_get_PointerTott__MaximumNumberOfOSDs(struct soap *soap, struct tt__MaximumNumberOfOSDs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MaximumNumberOfOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgOptionsExtension(struct soap *soap, struct tt__OSDImgOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgOptionsExtension))
		soap_serialize_tt__OSDImgOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__OSDImgOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDImgOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDImgOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDImgOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDImgOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDImgOptionsExtension **)soap_malloc(soap, sizeof(struct tt__OSDImgOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDImgOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(struct tt__OSDImgOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgOptionsExtension(struct soap *soap, struct tt__OSDImgOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgOptionsExtension(soap, tag ? tag : "tt:OSDImgOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDImgOptionsExtension(struct soap *soap, struct tt__OSDImgOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextOptionsExtension(struct soap *soap, struct tt__OSDTextOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextOptionsExtension))
		soap_serialize_tt__OSDTextOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__OSDTextOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDTextOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDTextOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDTextOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDTextOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDTextOptionsExtension **)soap_malloc(soap, sizeof(struct tt__OSDTextOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDTextOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(struct tt__OSDTextOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextOptionsExtension(struct soap *soap, struct tt__OSDTextOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextOptionsExtension(soap, tag ? tag : "tt:OSDTextOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDTextOptionsExtension(struct soap *soap, struct tt__OSDTextOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDColorOptions(struct soap *soap, struct tt__OSDColorOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDColorOptions))
		soap_serialize_tt__OSDColorOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDColorOptions(struct soap *soap, const char *tag, int id, struct tt__OSDColorOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDColorOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDColorOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDColorOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDColorOptions(struct soap *soap, const char *tag, struct tt__OSDColorOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDColorOptions **)soap_malloc(soap, sizeof(struct tt__OSDColorOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDColorOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDColorOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColorOptions, sizeof(struct tt__OSDColorOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDColorOptions(struct soap *soap, struct tt__OSDColorOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDColorOptions(soap, tag ? tag : "tt:OSDColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColorOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDColorOptions(struct soap *soap, struct tt__OSDColorOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDColorOptionsExtension(struct soap *soap, struct tt__OSDColorOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDColorOptionsExtension))
		soap_serialize_tt__OSDColorOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDColorOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__OSDColorOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDColorOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDColorOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDColorOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDColorOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDColorOptionsExtension **)soap_malloc(soap, sizeof(struct tt__OSDColorOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDColorOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDColorOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(struct tt__OSDColorOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDColorOptionsExtension(struct soap *soap, struct tt__OSDColorOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDColorOptionsExtension(soap, tag ? tag : "tt:OSDColorOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDColorOptionsExtension(struct soap *soap, struct tt__OSDColorOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDColorOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorOptions(struct soap *soap, struct tt__ColorOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorOptions))
		soap_serialize_tt__ColorOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorOptions(struct soap *soap, const char *tag, int id, struct tt__ColorOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorOptions ** SOAP_FMAC4 soap_in_PointerTott__ColorOptions(struct soap *soap, const char *tag, struct tt__ColorOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorOptions **)soap_malloc(soap, sizeof(struct tt__ColorOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorOptions, sizeof(struct tt__ColorOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorOptions(struct soap *soap, struct tt__ColorOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorOptions(soap, tag ? tag : "tt:ColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorOptions ** SOAP_FMAC4 soap_get_PointerTott__ColorOptions(struct soap *soap, struct tt__ColorOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorspaceRange(struct soap *soap, struct tt__ColorspaceRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorspaceRange))
		soap_serialize_tt__ColorspaceRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorspaceRange(struct soap *soap, const char *tag, int id, struct tt__ColorspaceRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorspaceRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorspaceRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorspaceRange ** SOAP_FMAC4 soap_in_PointerTott__ColorspaceRange(struct soap *soap, const char *tag, struct tt__ColorspaceRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorspaceRange **)soap_malloc(soap, sizeof(struct tt__ColorspaceRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorspaceRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorspaceRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorspaceRange, sizeof(struct tt__ColorspaceRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorspaceRange(struct soap *soap, struct tt__ColorspaceRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorspaceRange(soap, tag ? tag : "tt:ColorspaceRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorspaceRange ** SOAP_FMAC4 soap_get_PointerTott__ColorspaceRange(struct soap *soap, struct tt__ColorspaceRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorspaceRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgConfigurationExtension(struct soap *soap, struct tt__OSDImgConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgConfigurationExtension))
		soap_serialize_tt__OSDImgConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__OSDImgConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDImgConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDImgConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDImgConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDImgConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__OSDImgConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDImgConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(struct tt__OSDImgConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgConfigurationExtension(struct soap *soap, struct tt__OSDImgConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgConfigurationExtension(soap, tag ? tag : "tt:OSDImgConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDImgConfigurationExtension(struct soap *soap, struct tt__OSDImgConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextConfigurationExtension(struct soap *soap, struct tt__OSDTextConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextConfigurationExtension))
		soap_serialize_tt__OSDTextConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__OSDTextConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDTextConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDTextConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDTextConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDTextConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__OSDTextConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDTextConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(struct tt__OSDTextConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextConfigurationExtension(struct soap *soap, struct tt__OSDTextConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextConfigurationExtension(soap, tag ? tag : "tt:OSDTextConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDTextConfigurationExtension(struct soap *soap, struct tt__OSDTextConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDColor(struct soap *soap, struct tt__OSDColor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDColor))
		soap_serialize_tt__OSDColor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDColor(struct soap *soap, const char *tag, int id, struct tt__OSDColor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDColor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDColor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDColor ** SOAP_FMAC4 soap_in_PointerTott__OSDColor(struct soap *soap, const char *tag, struct tt__OSDColor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDColor **)soap_malloc(soap, sizeof(struct tt__OSDColor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDColor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDColor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColor, sizeof(struct tt__OSDColor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDColor(struct soap *soap, struct tt__OSDColor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDColor(soap, tag ? tag : "tt:OSDColor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColor ** SOAP_FMAC4 soap_get_PointerTott__OSDColor(struct soap *soap, struct tt__OSDColor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDColor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Color(struct soap *soap, struct tt__Color *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Color))
		soap_serialize_tt__Color(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Color(struct soap *soap, const char *tag, int id, struct tt__Color *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Color, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Color(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Color ** SOAP_FMAC4 soap_in_PointerTott__Color(struct soap *soap, const char *tag, struct tt__Color **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Color **)soap_malloc(soap, sizeof(struct tt__Color *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Color(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Color **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Color(struct soap *soap, struct tt__Color *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Color(soap, tag ? tag : "tt:Color", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Color ** SOAP_FMAC4 soap_get_PointerTott__Color(struct soap *soap, struct tt__Color **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDPosConfigurationExtension(struct soap *soap, struct tt__OSDPosConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDPosConfigurationExtension))
		soap_serialize_tt__OSDPosConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDPosConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__OSDPosConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDPosConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDPosConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDPosConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDPosConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDPosConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__OSDPosConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDPosConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDPosConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(struct tt__OSDPosConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDPosConfigurationExtension(struct soap *soap, struct tt__OSDPosConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDPosConfigurationExtension(soap, tag ? tag : "tt:OSDPosConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDPosConfigurationExtension(struct soap *soap, struct tt__OSDPosConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDPosConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileStatusExtension(struct soap *soap, struct tt__ProfileStatusExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileStatusExtension))
		soap_serialize_tt__ProfileStatusExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileStatusExtension(struct soap *soap, const char *tag, int id, struct tt__ProfileStatusExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileStatusExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ProfileStatusExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileStatusExtension ** SOAP_FMAC4 soap_in_PointerTott__ProfileStatusExtension(struct soap *soap, const char *tag, struct tt__ProfileStatusExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ProfileStatusExtension **)soap_malloc(soap, sizeof(struct tt__ProfileStatusExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ProfileStatusExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileStatusExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(struct tt__ProfileStatusExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileStatusExtension(struct soap *soap, struct tt__ProfileStatusExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileStatusExtension(soap, tag ? tag : "tt:ProfileStatusExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileStatusExtension ** SOAP_FMAC4 soap_get_PointerTott__ProfileStatusExtension(struct soap *soap, struct tt__ProfileStatusExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ActiveConnection(struct soap *soap, struct tt__ActiveConnection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ActiveConnection))
		soap_serialize_tt__ActiveConnection(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ActiveConnection(struct soap *soap, const char *tag, int id, struct tt__ActiveConnection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ActiveConnection, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ActiveConnection(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ActiveConnection ** SOAP_FMAC4 soap_in_PointerTott__ActiveConnection(struct soap *soap, const char *tag, struct tt__ActiveConnection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ActiveConnection **)soap_malloc(soap, sizeof(struct tt__ActiveConnection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ActiveConnection(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ActiveConnection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ActiveConnection, sizeof(struct tt__ActiveConnection), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ActiveConnection(struct soap *soap, struct tt__ActiveConnection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ActiveConnection(soap, tag ? tag : "tt:ActiveConnection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActiveConnection ** SOAP_FMAC4 soap_get_PointerTott__ActiveConnection(struct soap *soap, struct tt__ActiveConnection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ActiveConnection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioClassDescriptorExtension(struct soap *soap, struct tt__AudioClassDescriptorExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioClassDescriptorExtension))
		soap_serialize_tt__AudioClassDescriptorExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioClassDescriptorExtension(struct soap *soap, const char *tag, int id, struct tt__AudioClassDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioClassDescriptorExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioClassDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__AudioClassDescriptorExtension(struct soap *soap, const char *tag, struct tt__AudioClassDescriptorExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioClassDescriptorExtension **)soap_malloc(soap, sizeof(struct tt__AudioClassDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioClassDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioClassDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(struct tt__AudioClassDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioClassDescriptorExtension(struct soap *soap, struct tt__AudioClassDescriptorExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioClassDescriptorExtension(soap, tag ? tag : "tt:AudioClassDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__AudioClassDescriptorExtension(struct soap *soap, struct tt__AudioClassDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioClassCandidate(struct soap *soap, struct tt__AudioClassCandidate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioClassCandidate))
		soap_serialize_tt__AudioClassCandidate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioClassCandidate(struct soap *soap, const char *tag, int id, struct tt__AudioClassCandidate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioClassCandidate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioClassCandidate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioClassCandidate ** SOAP_FMAC4 soap_in_PointerTott__AudioClassCandidate(struct soap *soap, const char *tag, struct tt__AudioClassCandidate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioClassCandidate **)soap_malloc(soap, sizeof(struct tt__AudioClassCandidate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioClassCandidate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioClassCandidate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioClassCandidate, sizeof(struct tt__AudioClassCandidate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioClassCandidate(struct soap *soap, struct tt__AudioClassCandidate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioClassCandidate(soap, tag ? tag : "tt:AudioClassCandidate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassCandidate ** SOAP_FMAC4 soap_get_PointerTott__AudioClassCandidate(struct soap *soap, struct tt__AudioClassCandidate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension))
		soap_serialize_tt__ActionEngineEventPayloadExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, int id, struct tt__ActionEngineEventPayloadExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ActionEngineEventPayloadExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension ** SOAP_FMAC4 soap_in_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, struct tt__ActionEngineEventPayloadExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ActionEngineEventPayloadExtension **)soap_malloc(soap, sizeof(struct tt__ActionEngineEventPayloadExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ActionEngineEventPayloadExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ActionEngineEventPayloadExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(struct tt__ActionEngineEventPayloadExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ActionEngineEventPayloadExtension(soap, tag ? tag : "tt:ActionEngineEventPayloadExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension ** SOAP_FMAC4 soap_get_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ActionEngineEventPayloadExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Fault))
		soap_serialize_SOAP_ENV__Fault(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Fault(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Fault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Fault, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Fault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Fault ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Fault **)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Fault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Envelope))
		soap_serialize_SOAP_ENV__Envelope(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Envelope(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Envelope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Envelope, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Envelope(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Envelope(struct soap *soap, const char *tag, struct SOAP_ENV__Envelope **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Envelope **)soap_malloc(soap, sizeof(struct SOAP_ENV__Envelope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Envelope(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Envelope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, tag ? tag : "SOAP-ENV:Envelope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Envelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsState))
		soap_serialize_tt__AnalyticsState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsState(struct soap *soap, const char *tag, int id, struct tt__AnalyticsState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsState ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsState(struct soap *soap, const char *tag, struct tt__AnalyticsState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsState **)soap_malloc(soap, sizeof(struct tt__AnalyticsState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsState(soap, tag ? tag : "tt:AnalyticsState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsState ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsState(struct soap *soap, struct tt__AnalyticsState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataInputExtension))
		soap_serialize_tt__MetadataInputExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataInputExtension(struct soap *soap, const char *tag, int id, struct tt__MetadataInputExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataInputExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataInputExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataInputExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataInputExtension(struct soap *soap, const char *tag, struct tt__MetadataInputExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataInputExtension **)soap_malloc(soap, sizeof(struct tt__MetadataInputExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataInputExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInputExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataInputExtension(soap, tag ? tag : "tt:MetadataInputExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInputExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataInputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceIdentificationExtension))
		soap_serialize_tt__SourceIdentificationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceIdentificationExtension(struct soap *soap, const char *tag, int id, struct tt__SourceIdentificationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceIdentificationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SourceIdentificationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension ** SOAP_FMAC4 soap_in_PointerTott__SourceIdentificationExtension(struct soap *soap, const char *tag, struct tt__SourceIdentificationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SourceIdentificationExtension **)soap_malloc(soap, sizeof(struct tt__SourceIdentificationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SourceIdentificationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SourceIdentificationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SourceIdentificationExtension(soap, tag ? tag : "tt:SourceIdentificationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension ** SOAP_FMAC4 soap_get_PointerTott__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceIdentificationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension))
		soap_serialize_tt__AnalyticsEngineInputInfoExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineInputInfoExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineInputInfoExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfoExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineInputInfoExtension **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineInputInfoExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineInputInfoExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfoExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineInputInfoExtension(soap, tag ? tag : "tt:AnalyticsEngineInputInfoExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineInputInfoExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineInputInfo))
		soap_serialize_tt__AnalyticsEngineInputInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineInputInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineInputInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineInputInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineInputInfo **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineInputInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineInputInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineInputInfo(soap, tag ? tag : "tt:AnalyticsEngineInputInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineInputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension))
		soap_serialize_tt__AnalyticsDeviceEngineConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__AnalyticsDeviceEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsDeviceEngineConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsDeviceEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EngineConfiguration))
		soap_serialize_tt__EngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__EngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__EngineConfiguration(struct soap *soap, const char *tag, struct tt__EngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EngineConfiguration **)soap_malloc(soap, sizeof(struct tt__EngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EngineConfiguration, sizeof(struct tt__EngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EngineConfiguration(soap, tag ? tag : "tt:EngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobConfiguration))
		soap_serialize_tt__RecordingJobConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobConfiguration(struct soap *soap, const char *tag, int id, struct tt__RecordingJobConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobConfiguration(struct soap *soap, const char *tag, struct tt__RecordingJobConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobConfiguration **)soap_malloc(soap, sizeof(struct tt__RecordingJobConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(struct tt__RecordingJobConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobConfiguration(soap, tag ? tag : "tt:RecordingJobConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateTrack))
		soap_serialize_tt__RecordingJobStateTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateTrack, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, struct tt__RecordingJobStateTrack **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateTrack **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(struct tt__RecordingJobStateTrack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateTrack(soap, tag ? tag : "tt:RecordingJobStateTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateTracks))
		soap_serialize_tt__RecordingJobStateTracks(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateTracks(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateTracks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateTracks, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateTracks(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateTracks(struct soap *soap, const char *tag, struct tt__RecordingJobStateTracks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateTracks **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateTracks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateTracks(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateTracks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(struct tt__RecordingJobStateTracks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateTracks(soap, tag ? tag : "tt:RecordingJobStateTracks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateTracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateInformationExtension))
		soap_serialize_tt__RecordingJobStateInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, struct tt__RecordingJobStateInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateInformationExtension **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(struct tt__RecordingJobStateInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateInformationExtension(soap, tag ? tag : "tt:RecordingJobStateInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateSource))
		soap_serialize_tt__RecordingJobStateSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateSource, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateSource ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, struct tt__RecordingJobStateSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateSource **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(struct tt__RecordingJobStateSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateSource(soap, tag ? tag : "tt:RecordingJobStateSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateSource ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobSourceExtension))
		soap_serialize_tt__RecordingJobSourceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobSourceExtension(struct soap *soap, const char *tag, int id, struct tt__RecordingJobSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobSourceExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobSourceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobSourceExtension(struct soap *soap, const char *tag, struct tt__RecordingJobSourceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobSourceExtension **)soap_malloc(soap, sizeof(struct tt__RecordingJobSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobSourceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(struct tt__RecordingJobSourceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobSourceExtension(soap, tag ? tag : "tt:RecordingJobSourceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobTrack))
		soap_serialize_tt__RecordingJobTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobTrack(struct soap *soap, const char *tag, int id, struct tt__RecordingJobTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobTrack, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobTrack ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobTrack(struct soap *soap, const char *tag, struct tt__RecordingJobTrack **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobTrack **)soap_malloc(soap, sizeof(struct tt__RecordingJobTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobTrack, sizeof(struct tt__RecordingJobTrack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobTrack(soap, tag ? tag : "tt:RecordingJobTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobTrack ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobConfigurationExtension))
		soap_serialize_tt__RecordingJobConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__RecordingJobConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, struct tt__RecordingJobConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__RecordingJobConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(struct tt__RecordingJobConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobConfigurationExtension(soap, tag ? tag : "tt:RecordingJobConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobSource))
		soap_serialize_tt__RecordingJobSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobSource(struct soap *soap, const char *tag, int id, struct tt__RecordingJobSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobSource, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobSource ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobSource(struct soap *soap, const char *tag, struct tt__RecordingJobSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobSource **)soap_malloc(soap, sizeof(struct tt__RecordingJobSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobSource, sizeof(struct tt__RecordingJobSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobSource(soap, tag ? tag : "tt:RecordingJobSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobSource ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackConfiguration))
		soap_serialize_tt__TrackConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackConfiguration(struct soap *soap, const char *tag, int id, struct tt__TrackConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TrackConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TrackConfiguration ** SOAP_FMAC4 soap_in_PointerTott__TrackConfiguration(struct soap *soap, const char *tag, struct tt__TrackConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TrackConfiguration **)soap_malloc(soap, sizeof(struct tt__TrackConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TrackConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TrackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackConfiguration, sizeof(struct tt__TrackConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TrackConfiguration(soap, tag ? tag : "tt:TrackConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackConfiguration ** SOAP_FMAC4 soap_get_PointerTott__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetTracksResponseItem))
		soap_serialize_tt__GetTracksResponseItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, int id, struct tt__GetTracksResponseItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetTracksResponseItem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GetTracksResponseItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GetTracksResponseItem ** SOAP_FMAC4 soap_in_PointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, struct tt__GetTracksResponseItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GetTracksResponseItem **)soap_malloc(soap, sizeof(struct tt__GetTracksResponseItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GetTracksResponseItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GetTracksResponseItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(struct tt__GetTracksResponseItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GetTracksResponseItem(soap, tag ? tag : "tt:GetTracksResponseItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetTracksResponseItem ** SOAP_FMAC4 soap_get_PointerTott__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetTracksResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetTracksResponseList))
		soap_serialize_tt__GetTracksResponseList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetTracksResponseList(struct soap *soap, const char *tag, int id, struct tt__GetTracksResponseList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetTracksResponseList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GetTracksResponseList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GetTracksResponseList ** SOAP_FMAC4 soap_in_PointerTott__GetTracksResponseList(struct soap *soap, const char *tag, struct tt__GetTracksResponseList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GetTracksResponseList **)soap_malloc(soap, sizeof(struct tt__GetTracksResponseList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GetTracksResponseList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GetTracksResponseList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetTracksResponseList, sizeof(struct tt__GetTracksResponseList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GetTracksResponseList(soap, tag ? tag : "tt:GetTracksResponseList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetTracksResponseList ** SOAP_FMAC4 soap_get_PointerTott__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetTracksResponseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingConfiguration))
		soap_serialize_tt__RecordingConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingConfiguration(struct soap *soap, const char *tag, int id, struct tt__RecordingConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RecordingConfiguration(struct soap *soap, const char *tag, struct tt__RecordingConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingConfiguration **)soap_malloc(soap, sizeof(struct tt__RecordingConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingConfiguration, sizeof(struct tt__RecordingConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingConfiguration(soap, tag ? tag : "tt:RecordingConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackAttributesExtension))
		soap_serialize_tt__TrackAttributesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackAttributesExtension(struct soap *soap, const char *tag, int id, struct tt__TrackAttributesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackAttributesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TrackAttributesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TrackAttributesExtension ** SOAP_FMAC4 soap_in_PointerTott__TrackAttributesExtension(struct soap *soap, const char *tag, struct tt__TrackAttributesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TrackAttributesExtension **)soap_malloc(soap, sizeof(struct tt__TrackAttributesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TrackAttributesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TrackAttributesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(struct tt__TrackAttributesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TrackAttributesExtension(soap, tag ? tag : "tt:TrackAttributesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackAttributesExtension ** SOAP_FMAC4 soap_get_PointerTott__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackAttributesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataAttributes))
		soap_serialize_tt__MetadataAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataAttributes(struct soap *soap, const char *tag, int id, struct tt__MetadataAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataAttributes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataAttributes ** SOAP_FMAC4 soap_in_PointerTott__MetadataAttributes(struct soap *soap, const char *tag, struct tt__MetadataAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataAttributes **)soap_malloc(soap, sizeof(struct tt__MetadataAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataAttributes, sizeof(struct tt__MetadataAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataAttributes(soap, tag ? tag : "tt:MetadataAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataAttributes ** SOAP_FMAC4 soap_get_PointerTott__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioAttributes(struct soap *soap, struct tt__AudioAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioAttributes))
		soap_serialize_tt__AudioAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioAttributes(struct soap *soap, const char *tag, int id, struct tt__AudioAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioAttributes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioAttributes ** SOAP_FMAC4 soap_in_PointerTott__AudioAttributes(struct soap *soap, const char *tag, struct tt__AudioAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioAttributes **)soap_malloc(soap, sizeof(struct tt__AudioAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioAttributes, sizeof(struct tt__AudioAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioAttributes(struct soap *soap, struct tt__AudioAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioAttributes(soap, tag ? tag : "tt:AudioAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioAttributes ** SOAP_FMAC4 soap_get_PointerTott__AudioAttributes(struct soap *soap, struct tt__AudioAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAttributes(struct soap *soap, struct tt__VideoAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAttributes))
		soap_serialize_tt__VideoAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAttributes(struct soap *soap, const char *tag, int id, struct tt__VideoAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAttributes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoAttributes ** SOAP_FMAC4 soap_in_PointerTott__VideoAttributes(struct soap *soap, const char *tag, struct tt__VideoAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoAttributes **)soap_malloc(soap, sizeof(struct tt__VideoAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAttributes, sizeof(struct tt__VideoAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAttributes(struct soap *soap, struct tt__VideoAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoAttributes(soap, tag ? tag : "tt:VideoAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAttributes ** SOAP_FMAC4 soap_get_PointerTott__VideoAttributes(struct soap *soap, struct tt__VideoAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackAttributes(struct soap *soap, struct tt__TrackAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackAttributes))
		soap_serialize_tt__TrackAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackAttributes(struct soap *soap, const char *tag, int id, struct tt__TrackAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackAttributes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TrackAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TrackAttributes ** SOAP_FMAC4 soap_in_PointerTott__TrackAttributes(struct soap *soap, const char *tag, struct tt__TrackAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TrackAttributes **)soap_malloc(soap, sizeof(struct tt__TrackAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TrackAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TrackAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackAttributes, sizeof(struct tt__TrackAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackAttributes(struct soap *soap, struct tt__TrackAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TrackAttributes(soap, tag ? tag : "tt:TrackAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackAttributes ** SOAP_FMAC4 soap_get_PointerTott__TrackAttributes(struct soap *soap, struct tt__TrackAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackInformation(struct soap *soap, struct tt__TrackInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackInformation))
		soap_serialize_tt__TrackInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackInformation(struct soap *soap, const char *tag, int id, struct tt__TrackInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TrackInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TrackInformation ** SOAP_FMAC4 soap_in_PointerTott__TrackInformation(struct soap *soap, const char *tag, struct tt__TrackInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TrackInformation **)soap_malloc(soap, sizeof(struct tt__TrackInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TrackInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TrackInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackInformation, sizeof(struct tt__TrackInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackInformation(struct soap *soap, struct tt__TrackInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TrackInformation(soap, tag ? tag : "tt:TrackInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackInformation ** SOAP_FMAC4 soap_get_PointerTott__TrackInformation(struct soap *soap, struct tt__TrackInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingSourceInformation))
		soap_serialize_tt__RecordingSourceInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingSourceInformation(struct soap *soap, const char *tag, int id, struct tt__RecordingSourceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingSourceInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingSourceInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingSourceInformation ** SOAP_FMAC4 soap_in_PointerTott__RecordingSourceInformation(struct soap *soap, const char *tag, struct tt__RecordingSourceInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingSourceInformation **)soap_malloc(soap, sizeof(struct tt__RecordingSourceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingSourceInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingSourceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(struct tt__RecordingSourceInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingSourceInformation(soap, tag ? tag : "tt:RecordingSourceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingSourceInformation ** SOAP_FMAC4 soap_get_PointerTott__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingSourceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindMetadataResult))
		soap_serialize_tt__FindMetadataResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindMetadataResult(struct soap *soap, const char *tag, int id, struct tt__FindMetadataResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindMetadataResult, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindMetadataResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindMetadataResult ** SOAP_FMAC4 soap_in_PointerTott__FindMetadataResult(struct soap *soap, const char *tag, struct tt__FindMetadataResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindMetadataResult **)soap_malloc(soap, sizeof(struct tt__FindMetadataResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindMetadataResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindMetadataResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindMetadataResult, sizeof(struct tt__FindMetadataResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindMetadataResult(soap, tag ? tag : "tt:FindMetadataResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindMetadataResult ** SOAP_FMAC4 soap_get_PointerTott__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindPTZPositionResult))
		soap_serialize_tt__FindPTZPositionResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, int id, struct tt__FindPTZPositionResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindPTZPositionResult, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindPTZPositionResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindPTZPositionResult ** SOAP_FMAC4 soap_in_PointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, struct tt__FindPTZPositionResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindPTZPositionResult **)soap_malloc(soap, sizeof(struct tt__FindPTZPositionResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindPTZPositionResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindPTZPositionResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(struct tt__FindPTZPositionResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindPTZPositionResult(soap, tag ? tag : "tt:FindPTZPositionResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindPTZPositionResult ** SOAP_FMAC4 soap_get_PointerTott__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindPTZPositionResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotificationMessageHolderType))
		soap_serialize_wsnt__NotificationMessageHolderType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, struct wsnt__NotificationMessageHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotificationMessageHolderType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__NotificationMessageHolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, struct wsnt__NotificationMessageHolderType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__NotificationMessageHolderType **)soap_malloc(soap, sizeof(struct wsnt__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__NotificationMessageHolderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindEventResult(struct soap *soap, struct tt__FindEventResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindEventResult))
		soap_serialize_tt__FindEventResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindEventResult(struct soap *soap, const char *tag, int id, struct tt__FindEventResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindEventResult, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindEventResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindEventResult ** SOAP_FMAC4 soap_in_PointerTott__FindEventResult(struct soap *soap, const char *tag, struct tt__FindEventResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindEventResult **)soap_malloc(soap, sizeof(struct tt__FindEventResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindEventResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindEventResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindEventResult, sizeof(struct tt__FindEventResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindEventResult(struct soap *soap, struct tt__FindEventResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindEventResult(soap, tag ? tag : "tt:FindEventResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindEventResult ** SOAP_FMAC4 soap_get_PointerTott__FindEventResult(struct soap *soap, struct tt__FindEventResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindEventResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingInformation(struct soap *soap, struct tt__RecordingInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingInformation))
		soap_serialize_tt__RecordingInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingInformation(struct soap *soap, const char *tag, int id, struct tt__RecordingInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingInformation ** SOAP_FMAC4 soap_in_PointerTott__RecordingInformation(struct soap *soap, const char *tag, struct tt__RecordingInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingInformation **)soap_malloc(soap, sizeof(struct tt__RecordingInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingInformation, sizeof(struct tt__RecordingInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingInformation(struct soap *soap, struct tt__RecordingInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingInformation(soap, tag ? tag : "tt:RecordingInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingInformation ** SOAP_FMAC4 soap_get_PointerTott__RecordingInformation(struct soap *soap, struct tt__RecordingInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SearchScopeExtension))
		soap_serialize_tt__SearchScopeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SearchScopeExtension(struct soap *soap, const char *tag, int id, struct tt__SearchScopeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SearchScopeExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SearchScopeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SearchScopeExtension ** SOAP_FMAC4 soap_in_PointerTott__SearchScopeExtension(struct soap *soap, const char *tag, struct tt__SearchScopeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SearchScopeExtension **)soap_malloc(soap, sizeof(struct tt__SearchScopeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SearchScopeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SearchScopeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchScopeExtension, sizeof(struct tt__SearchScopeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SearchScopeExtension(soap, tag ? tag : "tt:SearchScopeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchScopeExtension ** SOAP_FMAC4 soap_get_PointerTott__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SearchScopeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingReference(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingReference))
		soap_serialize_tt__RecordingReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingReference(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingReference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__RecordingReference(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingReference, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingReference(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingReference(soap, tag ? tag : "tt:RecordingReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__RecordingReference(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceReference(struct soap *soap, struct tt__SourceReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceReference))
		soap_serialize_tt__SourceReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceReference(struct soap *soap, const char *tag, int id, struct tt__SourceReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceReference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SourceReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SourceReference ** SOAP_FMAC4 soap_in_PointerTott__SourceReference(struct soap *soap, const char *tag, struct tt__SourceReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SourceReference **)soap_malloc(soap, sizeof(struct tt__SourceReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SourceReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SourceReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceReference, sizeof(struct tt__SourceReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceReference(struct soap *soap, struct tt__SourceReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SourceReference(soap, tag ? tag : "tt:SourceReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceReference ** SOAP_FMAC4 soap_get_PointerTott__SourceReference(struct soap *soap, struct tt__SourceReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StreamSetup(struct soap *soap, struct tt__StreamSetup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StreamSetup))
		soap_serialize_tt__StreamSetup(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StreamSetup(struct soap *soap, const char *tag, int id, struct tt__StreamSetup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StreamSetup, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StreamSetup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__StreamSetup ** SOAP_FMAC4 soap_in_PointerTott__StreamSetup(struct soap *soap, const char *tag, struct tt__StreamSetup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__StreamSetup **)soap_malloc(soap, sizeof(struct tt__StreamSetup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StreamSetup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__StreamSetup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StreamSetup, sizeof(struct tt__StreamSetup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StreamSetup(struct soap *soap, struct tt__StreamSetup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StreamSetup(soap, tag ? tag : "tt:StreamSetup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StreamSetup ** SOAP_FMAC4 soap_get_PointerTott__StreamSetup(struct soap *soap, struct tt__StreamSetup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StreamSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReceiverConfiguration))
		soap_serialize_tt__ReceiverConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReceiverConfiguration(struct soap *soap, const char *tag, int id, struct tt__ReceiverConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReceiverConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReceiverConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReceiverConfiguration ** SOAP_FMAC4 soap_in_PointerTott__ReceiverConfiguration(struct soap *soap, const char *tag, struct tt__ReceiverConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReceiverConfiguration **)soap_malloc(soap, sizeof(struct tt__ReceiverConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReceiverConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReceiverConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(struct tt__ReceiverConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReceiverConfiguration(soap, tag ? tag : "tt:ReceiverConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverConfiguration ** SOAP_FMAC4 soap_get_PointerTott__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReceiverConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneOptionExtension))
		soap_serialize_tt__PaneOptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneOptionExtension(struct soap *soap, const char *tag, int id, struct tt__PaneOptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneOptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PaneOptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PaneOptionExtension ** SOAP_FMAC4 soap_in_PointerTott__PaneOptionExtension(struct soap *soap, const char *tag, struct tt__PaneOptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PaneOptionExtension **)soap_malloc(soap, sizeof(struct tt__PaneOptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PaneOptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PaneOptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneOptionExtension, sizeof(struct tt__PaneOptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PaneOptionExtension(soap, tag ? tag : "tt:PaneOptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneOptionExtension ** SOAP_FMAC4 soap_get_PointerTott__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneOptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LayoutOptionsExtension))
		soap_serialize_tt__LayoutOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LayoutOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__LayoutOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LayoutOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LayoutOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__LayoutOptionsExtension(struct soap *soap, const char *tag, struct tt__LayoutOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LayoutOptionsExtension **)soap_malloc(soap, sizeof(struct tt__LayoutOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LayoutOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(struct tt__LayoutOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LayoutOptionsExtension(soap, tag ? tag : "tt:LayoutOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LayoutOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneLayoutOptions))
		soap_serialize_tt__PaneLayoutOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneLayoutOptions(struct soap *soap, const char *tag, int id, struct tt__PaneLayoutOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneLayoutOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PaneLayoutOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PaneLayoutOptions ** SOAP_FMAC4 soap_in_PointerTott__PaneLayoutOptions(struct soap *soap, const char *tag, struct tt__PaneLayoutOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PaneLayoutOptions **)soap_malloc(soap, sizeof(struct tt__PaneLayoutOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PaneLayoutOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PaneLayoutOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PaneLayoutOptions(soap, tag ? tag : "tt:PaneLayoutOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneLayoutOptions ** SOAP_FMAC4 soap_get_PointerTott__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneLayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions))
		soap_serialize_tt__VideoDecoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoDecoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoDecoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoDecoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoDecoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, sizeof(struct tt__VideoDecoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoDecoderConfigurationOptions(soap, tag ? tag : "tt:VideoDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions))
		soap_serialize_tt__AudioDecoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioDecoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioDecoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioDecoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioDecoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(struct tt__AudioDecoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioDecoderConfigurationOptions(soap, tag ? tag : "tt:AudioDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions))
		soap_serialize_tt__AudioEncoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioEncoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(struct tt__AudioEncoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioEncoderConfigurationOptions(soap, tag ? tag : "tt:AudioEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LayoutExtension(struct soap *soap, struct tt__LayoutExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LayoutExtension))
		soap_serialize_tt__LayoutExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LayoutExtension(struct soap *soap, const char *tag, int id, struct tt__LayoutExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LayoutExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LayoutExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LayoutExtension ** SOAP_FMAC4 soap_in_PointerTott__LayoutExtension(struct soap *soap, const char *tag, struct tt__LayoutExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LayoutExtension **)soap_malloc(soap, sizeof(struct tt__LayoutExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LayoutExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutExtension, sizeof(struct tt__LayoutExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LayoutExtension(struct soap *soap, struct tt__LayoutExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LayoutExtension(soap, tag ? tag : "tt:LayoutExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutExtension ** SOAP_FMAC4 soap_get_PointerTott__LayoutExtension(struct soap *soap, struct tt__LayoutExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LayoutExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneLayout(struct soap *soap, struct tt__PaneLayout *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneLayout))
		soap_serialize_tt__PaneLayout(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneLayout(struct soap *soap, const char *tag, int id, struct tt__PaneLayout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneLayout, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PaneLayout(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PaneLayout ** SOAP_FMAC4 soap_in_PointerTott__PaneLayout(struct soap *soap, const char *tag, struct tt__PaneLayout **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PaneLayout **)soap_malloc(soap, sizeof(struct tt__PaneLayout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PaneLayout(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PaneLayout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneLayout, sizeof(struct tt__PaneLayout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneLayout(struct soap *soap, struct tt__PaneLayout *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PaneLayout(soap, tag ? tag : "tt:PaneLayout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneLayout ** SOAP_FMAC4 soap_get_PointerTott__PaneLayout(struct soap *soap, struct tt__PaneLayout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Transformation(struct soap *soap, struct tt__Transformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Transformation))
		soap_serialize_tt__Transformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Transformation(struct soap *soap, const char *tag, int id, struct tt__Transformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Transformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Transformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Transformation ** SOAP_FMAC4 soap_in_PointerTott__Transformation(struct soap *soap, const char *tag, struct tt__Transformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Transformation **)soap_malloc(soap, sizeof(struct tt__Transformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Transformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Transformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transformation, sizeof(struct tt__Transformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Transformation(struct soap *soap, struct tt__Transformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Transformation(soap, tag ? tag : "tt:Transformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transformation ** SOAP_FMAC4 soap_get_PointerTott__Transformation(struct soap *soap, struct tt__Transformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MotionExpression(struct soap *soap, struct tt__MotionExpression *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MotionExpression))
		soap_serialize_tt__MotionExpression(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MotionExpression(struct soap *soap, const char *tag, int id, struct tt__MotionExpression *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MotionExpression, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MotionExpression(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MotionExpression ** SOAP_FMAC4 soap_in_PointerTott__MotionExpression(struct soap *soap, const char *tag, struct tt__MotionExpression **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MotionExpression **)soap_malloc(soap, sizeof(struct tt__MotionExpression *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MotionExpression(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MotionExpression **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MotionExpression, sizeof(struct tt__MotionExpression), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MotionExpression(struct soap *soap, struct tt__MotionExpression *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MotionExpression(soap, tag ? tag : "tt:MotionExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MotionExpression ** SOAP_FMAC4 soap_get_PointerTott__MotionExpression(struct soap *soap, struct tt__MotionExpression **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MotionExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PolylineArray(struct soap *soap, struct tt__PolylineArray *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PolylineArray))
		soap_serialize_tt__PolylineArray(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PolylineArray(struct soap *soap, const char *tag, int id, struct tt__PolylineArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PolylineArray, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PolylineArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PolylineArray ** SOAP_FMAC4 soap_in_PointerTott__PolylineArray(struct soap *soap, const char *tag, struct tt__PolylineArray **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PolylineArray **)soap_malloc(soap, sizeof(struct tt__PolylineArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PolylineArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PolylineArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PolylineArray, sizeof(struct tt__PolylineArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PolylineArray(struct soap *soap, struct tt__PolylineArray *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PolylineArray(soap, tag ? tag : "tt:PolylineArray", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolylineArray ** SOAP_FMAC4 soap_get_PointerTott__PolylineArray(struct soap *soap, struct tt__PolylineArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PolylineArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PolylineArrayExtension))
		soap_serialize_tt__PolylineArrayExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PolylineArrayExtension(struct soap *soap, const char *tag, int id, struct tt__PolylineArrayExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PolylineArrayExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PolylineArrayExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PolylineArrayExtension ** SOAP_FMAC4 soap_in_PointerTott__PolylineArrayExtension(struct soap *soap, const char *tag, struct tt__PolylineArrayExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PolylineArrayExtension **)soap_malloc(soap, sizeof(struct tt__PolylineArrayExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PolylineArrayExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PolylineArrayExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(struct tt__PolylineArrayExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PolylineArrayExtension(soap, tag ? tag : "tt:PolylineArrayExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolylineArrayExtension ** SOAP_FMAC4 soap_get_PointerTott__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PolylineArrayExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Polyline(struct soap *soap, struct tt__Polyline *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Polyline))
		soap_serialize_tt__Polyline(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Polyline(struct soap *soap, const char *tag, int id, struct tt__Polyline *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Polyline, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Polyline(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Polyline ** SOAP_FMAC4 soap_in_PointerTott__Polyline(struct soap *soap, const char *tag, struct tt__Polyline **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Polyline **)soap_malloc(soap, sizeof(struct tt__Polyline *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Polyline(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Polyline **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Polyline, sizeof(struct tt__Polyline), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Polyline(struct soap *soap, struct tt__Polyline *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Polyline(soap, tag ? tag : "tt:Polyline", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Polyline ** SOAP_FMAC4 soap_get_PointerTott__Polyline(struct soap *soap, struct tt__Polyline **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Polyline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension))
		soap_serialize_tt__SupportedAnalyticsModulesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, int id, struct tt__SupportedAnalyticsModulesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportedAnalyticsModulesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension ** SOAP_FMAC4 soap_in_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, struct tt__SupportedAnalyticsModulesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportedAnalyticsModulesExtension **)soap_malloc(soap, sizeof(struct tt__SupportedAnalyticsModulesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportedAnalyticsModulesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedAnalyticsModulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(struct tt__SupportedAnalyticsModulesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SupportedAnalyticsModulesExtension(soap, tag ? tag : "tt:SupportedAnalyticsModulesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension ** SOAP_FMAC4 soap_get_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedAnalyticsModulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedRulesExtension))
		soap_serialize_tt__SupportedRulesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedRulesExtension(struct soap *soap, const char *tag, int id, struct tt__SupportedRulesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedRulesExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportedRulesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportedRulesExtension ** SOAP_FMAC4 soap_in_PointerTott__SupportedRulesExtension(struct soap *soap, const char *tag, struct tt__SupportedRulesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportedRulesExtension **)soap_malloc(soap, sizeof(struct tt__SupportedRulesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportedRulesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedRulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(struct tt__SupportedRulesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SupportedRulesExtension(soap, tag ? tag : "tt:SupportedRulesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedRulesExtension ** SOAP_FMAC4 soap_get_PointerTott__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedRulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ConfigDescription(struct soap *soap, struct tt__ConfigDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ConfigDescription))
		soap_serialize_tt__ConfigDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ConfigDescription(struct soap *soap, const char *tag, int id, struct tt__ConfigDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ConfigDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ConfigDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ConfigDescription ** SOAP_FMAC4 soap_in_PointerTott__ConfigDescription(struct soap *soap, const char *tag, struct tt__ConfigDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ConfigDescription **)soap_malloc(soap, sizeof(struct tt__ConfigDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ConfigDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ConfigDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigDescription, sizeof(struct tt__ConfigDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ConfigDescription(struct soap *soap, struct tt__ConfigDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ConfigDescription(soap, tag ? tag : "tt:ConfigDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigDescription ** SOAP_FMAC4 soap_get_PointerTott__ConfigDescription(struct soap *soap, struct tt__ConfigDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ConfigDescriptionExtension))
		soap_serialize_tt__ConfigDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ConfigDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__ConfigDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ConfigDescriptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ConfigDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__ConfigDescriptionExtension(struct soap *soap, const char *tag, struct tt__ConfigDescriptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ConfigDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__ConfigDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ConfigDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ConfigDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(struct tt__ConfigDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ConfigDescriptionExtension(soap, tag ? tag : "tt:ConfigDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ConfigDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ConfigDescription_Messages))
		soap_serialize__tt__ConfigDescription_Messages(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, const char *tag, int id, struct _tt__ConfigDescription_Messages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ConfigDescription_Messages, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ConfigDescription_Messages(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages ** SOAP_FMAC4 soap_in_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, const char *tag, struct _tt__ConfigDescription_Messages **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ConfigDescription_Messages **)soap_malloc(soap, sizeof(struct _tt__ConfigDescription_Messages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ConfigDescription_Messages(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ConfigDescription_Messages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(struct _tt__ConfigDescription_Messages), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ConfigDescription_Messages(soap, tag ? tag : "tt:ConfigDescription-Messages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages ** SOAP_FMAC4 soap_get_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ConfigDescription_Messages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemList(struct soap *soap, struct tt__ItemList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemList))
		soap_serialize_tt__ItemList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemList(struct soap *soap, const char *tag, int id, struct tt__ItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemList ** SOAP_FMAC4 soap_in_PointerTott__ItemList(struct soap *soap, const char *tag, struct tt__ItemList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemList **)soap_malloc(soap, sizeof(struct tt__ItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemList(struct soap *soap, struct tt__ItemList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemList(soap, tag ? tag : "tt:ItemList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemList ** SOAP_FMAC4 soap_get_PointerTott__ItemList(struct soap *soap, struct tt__ItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfigurationExtension))
		soap_serialize_tt__RuleEngineConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__RuleEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RuleEngineConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__RuleEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RuleEngineConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__RuleEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RuleEngineConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RuleEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(struct tt__RuleEngineConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, tag ? tag : "tt:RuleEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension))
		soap_serialize_tt__AnalyticsEngineConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(struct tt__AnalyticsEngineConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Config(struct soap *soap, struct tt__Config *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Config))
		soap_serialize_tt__Config(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Config(struct soap *soap, const char *tag, int id, struct tt__Config *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Config, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Config(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Config ** SOAP_FMAC4 soap_in_PointerTott__Config(struct soap *soap, const char *tag, struct tt__Config **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Config **)soap_malloc(soap, sizeof(struct tt__Config *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Config(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Config **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Config, sizeof(struct tt__Config), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Config(struct soap *soap, struct tt__Config *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Config(soap, tag ? tag : "tt:Config", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Config ** SOAP_FMAC4 soap_get_PointerTott__Config(struct soap *soap, struct tt__Config **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector(struct soap *soap, struct tt__Vector *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector))
		soap_serialize_tt__Vector(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector(struct soap *soap, const char *tag, int id, struct tt__Vector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Vector(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Vector ** SOAP_FMAC4 soap_in_PointerTott__Vector(struct soap *soap, const char *tag, struct tt__Vector **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Vector **)soap_malloc(soap, sizeof(struct tt__Vector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Vector(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Vector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector, sizeof(struct tt__Vector), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector(struct soap *soap, struct tt__Vector *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector(soap, tag ? tag : "tt:Vector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector ** SOAP_FMAC4 soap_get_PointerTott__Vector(struct soap *soap, struct tt__Vector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListDescriptionExtension))
		soap_serialize_tt__ItemListDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__ItemListDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListDescriptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListDescriptionExtension(struct soap *soap, const char *tag, struct tt__ItemListDescriptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__ItemListDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListDescriptionExtension(soap, tag ? tag : "tt:ItemListDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription))
		soap_serialize__tt__ItemListDescription_ElementItemDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, struct _tt__ItemListDescription_ElementItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemListDescription_ElementItemDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_ElementItemDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemListDescription_ElementItemDescription **)soap_malloc(soap, sizeof(struct _tt__ItemListDescription_ElementItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_ElementItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag ? tag : "tt:ItemListDescription-ElementItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription))
		soap_serialize__tt__ItemListDescription_SimpleItemDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, struct _tt__ItemListDescription_SimpleItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemListDescription_SimpleItemDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_SimpleItemDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemListDescription_SimpleItemDescription **)soap_malloc(soap, sizeof(struct _tt__ItemListDescription_SimpleItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_SimpleItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag ? tag : "tt:ItemListDescription-SimpleItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageDescriptionExtension))
		soap_serialize_tt__MessageDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__MessageDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageDescriptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MessageDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageDescriptionExtension(struct soap *soap, const char *tag, struct tt__MessageDescriptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MessageDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__MessageDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MessageDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, tag ? tag : "tt:MessageDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListDescription))
		soap_serialize_tt__ItemListDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListDescription(struct soap *soap, const char *tag, int id, struct tt__ItemListDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListDescription ** SOAP_FMAC4 soap_in_PointerTott__ItemListDescription(struct soap *soap, const char *tag, struct tt__ItemListDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListDescription **)soap_malloc(soap, sizeof(struct tt__ItemListDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListDescription(soap, tag ? tag : "tt:ItemListDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescription ** SOAP_FMAC4 soap_get_PointerTott__ItemListDescription(struct soap *soap, struct tt__ItemListDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListExtension))
		soap_serialize_tt__ItemListExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListExtension(struct soap *soap, const char *tag, int id, struct tt__ItemListExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListExtension(struct soap *soap, const char *tag, struct tt__ItemListExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListExtension **)soap_malloc(soap, sizeof(struct tt__ItemListExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListExtension(soap, tag ? tag : "tt:ItemListExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_ElementItem))
		soap_serialize__tt__ItemList_ElementItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, struct _tt__ItemList_ElementItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_ElementItem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemList_ElementItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, struct _tt__ItemList_ElementItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemList_ElementItem **)soap_malloc(soap, sizeof(struct _tt__ItemList_ElementItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemList_ElementItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_ElementItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemList_ElementItem(soap, tag ? tag : "tt:ItemList-ElementItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_SimpleItem))
		soap_serialize__tt__ItemList_SimpleItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, struct _tt__ItemList_SimpleItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_SimpleItem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemList_SimpleItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _tt__ItemList_SimpleItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemList_SimpleItem **)soap_malloc(soap, sizeof(struct _tt__ItemList_SimpleItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemList_SimpleItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_SimpleItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemList_SimpleItem(soap, tag ? tag : "tt:ItemList-SimpleItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions20Extension))
		soap_serialize_tt__FocusOptions20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, int id, struct tt__FocusOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, struct tt__FocusOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusOptions20Extension **)soap_malloc(soap, sizeof(struct tt__FocusOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(struct tt__FocusOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusOptions20Extension(soap, tag ? tag : "tt:FocusOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension))
		soap_serialize_tt__WhiteBalanceOptions20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, struct tt__WhiteBalanceOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalanceOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalanceOptions20Extension **)soap_malloc(soap, sizeof(struct tt__WhiteBalanceOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(struct tt__WhiteBalanceOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, tag ? tag : "tt:WhiteBalanceOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20Extension))
		soap_serialize_tt__FocusConfiguration20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, struct tt__FocusConfiguration20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusConfiguration20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, struct tt__FocusConfiguration20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusConfiguration20Extension **)soap_malloc(soap, sizeof(struct tt__FocusConfiguration20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusConfiguration20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, tag ? tag : "tt:FocusConfiguration20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20Extension))
		soap_serialize_tt__WhiteBalance20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, struct tt__WhiteBalance20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalance20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalance20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalance20Extension **)soap_malloc(soap, sizeof(struct tt__WhiteBalance20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalance20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, tag ? tag : "tt:WhiteBalance20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocusOptions20))
		soap_serialize_tt__RelativeFocusOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, struct tt__RelativeFocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocusOptions20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelativeFocusOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, struct tt__RelativeFocusOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelativeFocusOptions20 **)soap_malloc(soap, sizeof(struct tt__RelativeFocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelativeFocusOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelativeFocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(struct tt__RelativeFocusOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, tag ? tag : "tt:RelativeFocusOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensationMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationMode(struct soap *soap, const char *tag, int id, enum tt__BacklightCompensationMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensationMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BacklightCompensationMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__BacklightCompensationMode ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationMode(struct soap *soap, const char *tag, enum tt__BacklightCompensationMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__BacklightCompensationMode **)soap_malloc(soap, sizeof(enum tt__BacklightCompensationMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BacklightCompensationMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__BacklightCompensationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BacklightCompensationMode(soap, tag ? tag : "tt:BacklightCompensationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__BacklightCompensationMode ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
