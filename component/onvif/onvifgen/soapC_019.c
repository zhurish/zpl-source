/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:06 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetDigitalInputConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetDigitalInputConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DigitalInputOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetDigitalInputConfigurationOptionsResponse(struct soap *soap, const struct _tmd__GetDigitalInputConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotmd__DigitalInputConfigurationOptions(soap, &a->DigitalInputOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetDigitalInputConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetDigitalInputConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse), type))
		return soap->error;
	if (a->DigitalInputOptions)
		soap_element_result(soap, "tmd:DigitalInputOptions");
	if (!a->DigitalInputOptions)
	{	if (soap_element_empty(soap, "tmd:DigitalInputOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotmd__DigitalInputConfigurationOptions(soap, "tmd:DigitalInputOptions", -1, &a->DigitalInputOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetDigitalInputConfigurationOptionsResponse * SOAP_FMAC4 soap_in__tmd__GetDigitalInputConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetDigitalInputConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_DigitalInputOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetDigitalInputConfigurationOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse, sizeof(struct _tmd__GetDigitalInputConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetDigitalInputConfigurationOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DigitalInputOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotmd__DigitalInputConfigurationOptions(soap, "tmd:DigitalInputOptions", &a->DigitalInputOptions, "tmd:DigitalInputConfigurationOptions"))
				{	soap_flag_DigitalInputOptions--;
					continue;
				}
			}
			soap_check_result(soap, "tmd:DigitalInputOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->DigitalInputOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetDigitalInputConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse, sizeof(struct _tmd__GetDigitalInputConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetDigitalInputConfigurationOptionsResponse * SOAP_FMAC4 soap_new__tmd__GetDigitalInputConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _tmd__GetDigitalInputConfigurationOptionsResponse *p;
	struct _tmd__GetDigitalInputConfigurationOptionsResponse *a = (struct _tmd__GetDigitalInputConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetDigitalInputConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetDigitalInputConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetDigitalInputConfigurationOptionsResponse(struct soap *soap, const struct _tmd__GetDigitalInputConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetDigitalInputConfigurationOptionsResponse(soap, tag ? tag : "tmd:GetDigitalInputConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetDigitalInputConfigurationOptionsResponse * SOAP_FMAC4 soap_get__tmd__GetDigitalInputConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetDigitalInputConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetDigitalInputConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetDigitalInputConfigurationOptions(struct soap *soap, struct _tmd__GetDigitalInputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetDigitalInputConfigurationOptions(struct soap *soap, const struct _tmd__GetDigitalInputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetDigitalInputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _tmd__GetDigitalInputConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tmd:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetDigitalInputConfigurationOptions * SOAP_FMAC4 soap_in__tmd__GetDigitalInputConfigurationOptions(struct soap *soap, const char *tag, struct _tmd__GetDigitalInputConfigurationOptions *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetDigitalInputConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions, sizeof(struct _tmd__GetDigitalInputConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetDigitalInputConfigurationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetDigitalInputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions, SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions, sizeof(struct _tmd__GetDigitalInputConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetDigitalInputConfigurationOptions * SOAP_FMAC4 soap_new__tmd__GetDigitalInputConfigurationOptions(struct soap *soap, int n)
{
	struct _tmd__GetDigitalInputConfigurationOptions *p;
	struct _tmd__GetDigitalInputConfigurationOptions *a = (struct _tmd__GetDigitalInputConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetDigitalInputConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetDigitalInputConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetDigitalInputConfigurationOptions(struct soap *soap, const struct _tmd__GetDigitalInputConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetDigitalInputConfigurationOptions(soap, tag ? tag : "tmd:GetDigitalInputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetDigitalInputConfigurationOptions * SOAP_FMAC4 soap_get__tmd__GetDigitalInputConfigurationOptions(struct soap *soap, struct _tmd__GetDigitalInputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetDigitalInputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DigitalInput(struct soap *soap, struct tt__DigitalInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->__size = 0;
	a->__any = NULL;
	a->IdleState = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DigitalInput(struct soap *soap, const struct tt__DigitalInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DigitalInput(struct soap *soap, const char *tag, int id, const struct tt__DigitalInput *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (a->IdleState)
	{	soap_set_attr(soap, "IdleState", soap_tt__DigitalIdleState2s(soap, *a->IdleState), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DigitalInput), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DigitalInput * SOAP_FMAC4 soap_in_tt__DigitalInput(struct soap *soap, const char *tag, struct tt__DigitalInput *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__DigitalInput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DigitalInput, sizeof(struct tt__DigitalInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DigitalInput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "IdleState", 5, 0);
		if (t)
		{
			if (!(a->IdleState = (enum tt__DigitalIdleState *)soap_malloc(soap, sizeof(enum tt__DigitalIdleState))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__DigitalIdleState(soap, t, a->IdleState))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DigitalInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DigitalInput, SOAP_TYPE_tt__DigitalInput, sizeof(struct tt__DigitalInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DigitalInput * SOAP_FMAC4 soap_new_tt__DigitalInput(struct soap *soap, int n)
{
	struct tt__DigitalInput *p;
	struct tt__DigitalInput *a = (struct tt__DigitalInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DigitalInput));
	for (p = a; p && n--; p++)
		soap_default_tt__DigitalInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DigitalInput(struct soap *soap, const struct tt__DigitalInput *a, const char *tag, const char *type)
{
	if (soap_out_tt__DigitalInput(soap, tag ? tag : "tt:DigitalInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DigitalInput * SOAP_FMAC4 soap_get_tt__DigitalInput(struct soap *soap, struct tt__DigitalInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DigitalInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetDigitalInputsResponse(struct soap *soap, struct _tmd__GetDigitalInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDigitalInputs = 0;
	a->DigitalInputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetDigitalInputsResponse(struct soap *soap, const struct _tmd__GetDigitalInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->DigitalInputs)
	{	int i;
		for (i = 0; i < (int)a->__sizeDigitalInputs; i++)
		{
			soap_embedded(soap, a->DigitalInputs + i, SOAP_TYPE_tt__DigitalInput);
			soap_serialize_tt__DigitalInput(soap, a->DigitalInputs + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetDigitalInputsResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetDigitalInputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetDigitalInputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeDigitalInputs");
	if (a->DigitalInputs)
	{	int i;
		for (i = 0; i < (int)a->__sizeDigitalInputs; i++)
			if (soap_out_tt__DigitalInput(soap, "tmd:DigitalInputs", -1, a->DigitalInputs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetDigitalInputsResponse * SOAP_FMAC4 soap_in__tmd__GetDigitalInputsResponse(struct soap *soap, const char *tag, struct _tmd__GetDigitalInputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_DigitalInputs = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetDigitalInputsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetDigitalInputsResponse, sizeof(struct _tmd__GetDigitalInputsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetDigitalInputsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:DigitalInputs", 1, NULL))
			{	if (a->DigitalInputs == NULL)
				{	if (soap_blist_DigitalInputs == NULL)
						soap_blist_DigitalInputs = soap_alloc_block(soap);
					a->DigitalInputs = (struct tt__DigitalInput *)soap_push_block_max(soap, soap_blist_DigitalInputs, sizeof(struct tt__DigitalInput));
					if (a->DigitalInputs == NULL)
						return NULL;
					soap_default_tt__DigitalInput(soap, a->DigitalInputs);
				}
				soap_revert(soap);
				if (soap_in_tt__DigitalInput(soap, "tmd:DigitalInputs", a->DigitalInputs, "tt:DigitalInput"))
				{	a->__sizeDigitalInputs++;
					a->DigitalInputs = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeDigitalInputs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DigitalInputs)
			soap_pop_block(soap, soap_blist_DigitalInputs);
		if (a->__sizeDigitalInputs)
		{	a->DigitalInputs = (struct tt__DigitalInput *)soap_save_block(soap, soap_blist_DigitalInputs, NULL, 1);
		}
		else
		{	a->DigitalInputs = NULL;
			if (soap_blist_DigitalInputs)
				soap_end_block(soap, soap_blist_DigitalInputs);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetDigitalInputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetDigitalInputsResponse, SOAP_TYPE__tmd__GetDigitalInputsResponse, sizeof(struct _tmd__GetDigitalInputsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetDigitalInputsResponse * SOAP_FMAC4 soap_new__tmd__GetDigitalInputsResponse(struct soap *soap, int n)
{
	struct _tmd__GetDigitalInputsResponse *p;
	struct _tmd__GetDigitalInputsResponse *a = (struct _tmd__GetDigitalInputsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetDigitalInputsResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetDigitalInputsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetDigitalInputsResponse(struct soap *soap, const struct _tmd__GetDigitalInputsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetDigitalInputsResponse(soap, tag ? tag : "tmd:GetDigitalInputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetDigitalInputsResponse * SOAP_FMAC4 soap_get__tmd__GetDigitalInputsResponse(struct soap *soap, struct _tmd__GetDigitalInputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetDigitalInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetDigitalInputs(struct soap *soap, struct _tmd__GetDigitalInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetDigitalInputs(struct soap *soap, const struct _tmd__GetDigitalInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetDigitalInputs(struct soap *soap, const char *tag, int id, const struct _tmd__GetDigitalInputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetDigitalInputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetDigitalInputs * SOAP_FMAC4 soap_in__tmd__GetDigitalInputs(struct soap *soap, const char *tag, struct _tmd__GetDigitalInputs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetDigitalInputs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetDigitalInputs, sizeof(struct _tmd__GetDigitalInputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetDigitalInputs(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetDigitalInputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetDigitalInputs, SOAP_TYPE__tmd__GetDigitalInputs, sizeof(struct _tmd__GetDigitalInputs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetDigitalInputs * SOAP_FMAC4 soap_new__tmd__GetDigitalInputs(struct soap *soap, int n)
{
	struct _tmd__GetDigitalInputs *p;
	struct _tmd__GetDigitalInputs *a = (struct _tmd__GetDigitalInputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetDigitalInputs));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetDigitalInputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetDigitalInputs(struct soap *soap, const struct _tmd__GetDigitalInputs *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetDigitalInputs(soap, tag ? tag : "tmd:GetDigitalInputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetDigitalInputs * SOAP_FMAC4 soap_get__tmd__GetDigitalInputs(struct soap *soap, struct _tmd__GetDigitalInputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetDigitalInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetRelayOutputSettingsResponse(struct soap *soap, struct _tmd__SetRelayOutputSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetRelayOutputSettingsResponse(struct soap *soap, const struct _tmd__SetRelayOutputSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, const struct _tmd__SetRelayOutputSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetRelayOutputSettingsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_in__tmd__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, struct _tmd__SetRelayOutputSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetRelayOutputSettingsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetRelayOutputSettingsResponse, sizeof(struct _tmd__SetRelayOutputSettingsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetRelayOutputSettingsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetRelayOutputSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetRelayOutputSettingsResponse, SOAP_TYPE__tmd__SetRelayOutputSettingsResponse, sizeof(struct _tmd__SetRelayOutputSettingsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_new__tmd__SetRelayOutputSettingsResponse(struct soap *soap, int n)
{
	struct _tmd__SetRelayOutputSettingsResponse *p;
	struct _tmd__SetRelayOutputSettingsResponse *a = (struct _tmd__SetRelayOutputSettingsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetRelayOutputSettingsResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetRelayOutputSettingsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetRelayOutputSettingsResponse(struct soap *soap, const struct _tmd__SetRelayOutputSettingsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetRelayOutputSettingsResponse(soap, tag ? tag : "tmd:SetRelayOutputSettingsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_get__tmd__SetRelayOutputSettingsResponse(struct soap *soap, struct _tmd__SetRelayOutputSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayOutput(struct soap *soap, struct tt__RelayOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->Properties = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelayOutput(struct soap *soap, const struct tt__RelayOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RelayOutputSettings(soap, &a->Properties);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutput(struct soap *soap, const char *tag, int id, const struct tt__RelayOutput *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutput), type))
		return soap->error;
	if (!a->Properties)
	{	if (soap_element_empty(soap, "tt:Properties", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RelayOutputSettings(soap, "tt:Properties", -1, &a->Properties, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_in_tt__RelayOutput(struct soap *soap, const char *tag, struct tt__RelayOutput *a, const char *type)
{
	size_t soap_flag_Properties = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RelayOutput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelayOutput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelayOutputSettings(soap, "tt:Properties", &a->Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Properties))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RelayOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutput, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_new_tt__RelayOutput(struct soap *soap, int n)
{
	struct tt__RelayOutput *p;
	struct tt__RelayOutput *a = (struct tt__RelayOutput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RelayOutput));
	for (p = a; p && n--; p++)
		soap_default_tt__RelayOutput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayOutput(struct soap *soap, const struct tt__RelayOutput *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayOutput(soap, tag ? tag : "tt:RelayOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_get_tt__RelayOutput(struct soap *soap, struct tt__RelayOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetRelayOutputSettings(struct soap *soap, struct _tmd__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RelayOutput = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetRelayOutputSettings(struct soap *soap, const struct _tmd__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RelayOutput(soap, &a->RelayOutput);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const struct _tmd__SetRelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetRelayOutputSettings), type))
		return soap->error;
	if (!a->RelayOutput)
	{	if (soap_element_empty(soap, "tmd:RelayOutput", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RelayOutput(soap, "tmd:RelayOutput", -1, &a->RelayOutput, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetRelayOutputSettings * SOAP_FMAC4 soap_in__tmd__SetRelayOutputSettings(struct soap *soap, const char *tag, struct _tmd__SetRelayOutputSettings *a, const char *type)
{
	size_t soap_flag_RelayOutput = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetRelayOutputSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetRelayOutputSettings, sizeof(struct _tmd__SetRelayOutputSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetRelayOutputSettings(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutput && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelayOutput(soap, "tmd:RelayOutput", &a->RelayOutput, "tt:RelayOutput"))
				{	soap_flag_RelayOutput--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RelayOutput))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__SetRelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetRelayOutputSettings, SOAP_TYPE__tmd__SetRelayOutputSettings, sizeof(struct _tmd__SetRelayOutputSettings), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetRelayOutputSettings * SOAP_FMAC4 soap_new__tmd__SetRelayOutputSettings(struct soap *soap, int n)
{
	struct _tmd__SetRelayOutputSettings *p;
	struct _tmd__SetRelayOutputSettings *a = (struct _tmd__SetRelayOutputSettings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetRelayOutputSettings));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetRelayOutputSettings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetRelayOutputSettings(struct soap *soap, const struct _tmd__SetRelayOutputSettings *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetRelayOutputSettings(soap, tag ? tag : "tmd:SetRelayOutputSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetRelayOutputSettings * SOAP_FMAC4 soap_get__tmd__SetRelayOutputSettings(struct soap *soap, struct _tmd__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOutputTokensAvailable = 0;
	a->OutputTokensAvailable = NULL;
	a->__sizeSendPrimacyOptions = 0;
	a->SendPrimacyOptions = NULL;
	a->OutputLevelRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioOutputConfigurationOptions(struct soap *soap, const struct tt__AudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->OutputTokensAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeOutputTokensAvailable; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->OutputTokensAvailable + i));
		}
	}
	if (a->SendPrimacyOptions)
	{	int i;
		for (i = 0; i < (int)a->__sizeSendPrimacyOptions; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->SendPrimacyOptions + i));
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->OutputLevelRange);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__AudioOutputConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutputConfigurationOptions), type))
		return soap->error;
	if (a->OutputTokensAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeOutputTokensAvailable; i++)
			if (soap_out_string(soap, "tt:OutputTokensAvailable", -1, (char*const*)(a->OutputTokensAvailable + i), ""))
				return soap->error;
	}
	if (a->SendPrimacyOptions)
	{	int i;
		for (i = 0; i < (int)a->__sizeSendPrimacyOptions; i++)
			if (soap_out_string(soap, "tt:SendPrimacyOptions", -1, (char*const*)(a->SendPrimacyOptions + i), ""))
				return soap->error;
	}
	if (!a->OutputLevelRange)
	{	if (soap_element_empty(soap, "tt:OutputLevelRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:OutputLevelRange", -1, &a->OutputLevelRange, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioOutputConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_OutputTokensAvailable = NULL;
	struct soap_blist *soap_blist_SendPrimacyOptions = NULL;
	size_t soap_flag_OutputLevelRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioOutputConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(struct tt__AudioOutputConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioOutputConfigurationOptions(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:OutputTokensAvailable", 1, NULL))
			{	if (a->OutputTokensAvailable == NULL)
				{	if (soap_blist_OutputTokensAvailable == NULL)
						soap_blist_OutputTokensAvailable = soap_alloc_block(soap);
					a->OutputTokensAvailable = (char **)soap_push_block_max(soap, soap_blist_OutputTokensAvailable, sizeof(char *));
					if (a->OutputTokensAvailable == NULL)
						return NULL;
					*a->OutputTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:OutputTokensAvailable", (char**)a->OutputTokensAvailable, "tt:ReferenceToken"))
				{	a->__sizeOutputTokensAvailable++;
					a->OutputTokensAvailable = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SendPrimacyOptions", 1, NULL))
			{	if (a->SendPrimacyOptions == NULL)
				{	if (soap_blist_SendPrimacyOptions == NULL)
						soap_blist_SendPrimacyOptions = soap_alloc_block(soap);
					a->SendPrimacyOptions = (char **)soap_push_block_max(soap, soap_blist_SendPrimacyOptions, sizeof(char *));
					if (a->SendPrimacyOptions == NULL)
						return NULL;
					*a->SendPrimacyOptions = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tt:SendPrimacyOptions", (char**)a->SendPrimacyOptions, "xsd:anyURI"))
				{	a->__sizeSendPrimacyOptions++;
					a->SendPrimacyOptions = NULL;
					continue;
				}
			}
			if (soap_flag_OutputLevelRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:OutputLevelRange", &a->OutputLevelRange, "tt:IntRange"))
				{	soap_flag_OutputLevelRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->OutputTokensAvailable)
			soap_pop_block(soap, soap_blist_OutputTokensAvailable);
		if (a->__sizeOutputTokensAvailable)
		{	a->OutputTokensAvailable = (char **)soap_save_block(soap, soap_blist_OutputTokensAvailable, NULL, 1);
		}
		else
		{	a->OutputTokensAvailable = NULL;
			if (soap_blist_OutputTokensAvailable)
				soap_end_block(soap, soap_blist_OutputTokensAvailable);
		}
		if (a->SendPrimacyOptions)
			soap_pop_block(soap, soap_blist_SendPrimacyOptions);
		if (a->__sizeSendPrimacyOptions)
		{	a->SendPrimacyOptions = (char **)soap_save_block(soap, soap_blist_SendPrimacyOptions, NULL, 1);
		}
		else
		{	a->SendPrimacyOptions = NULL;
			if (soap_blist_SendPrimacyOptions)
				soap_end_block(soap, soap_blist_SendPrimacyOptions);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeOutputTokensAvailable < 1 || !a->OutputLevelRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfigurationOptions, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(struct tt__AudioOutputConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions * SOAP_FMAC4 soap_new_tt__AudioOutputConfigurationOptions(struct soap *soap, int n)
{
	struct tt__AudioOutputConfigurationOptions *p;
	struct tt__AudioOutputConfigurationOptions *a = (struct tt__AudioOutputConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioOutputConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioOutputConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioOutputConfigurationOptions(struct soap *soap, const struct tt__AudioOutputConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioOutputConfigurationOptions(soap, tag ? tag : "tt:AudioOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetAudioOutputConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AudioOutputOptions = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const struct _tmd__GetAudioOutputConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioOutputConfigurationOptions(soap, &a->AudioOutputOptions);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetAudioOutputConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse), type))
		return soap->error;
	if (a->AudioOutputOptions)
		soap_element_result(soap, "tmd:AudioOutputOptions");
	if (!a->AudioOutputOptions)
	{	if (soap_element_empty(soap, "tmd:AudioOutputOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AudioOutputConfigurationOptions(soap, "tmd:AudioOutputOptions", -1, &a->AudioOutputOptions, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_in__tmd__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetAudioOutputConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_AudioOutputOptions = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetAudioOutputConfigurationOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _tmd__GetAudioOutputConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetAudioOutputConfigurationOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioOutputOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioOutputConfigurationOptions(soap, "tmd:AudioOutputOptions", &a->AudioOutputOptions, "tt:AudioOutputConfigurationOptions"))
				{	soap_flag_AudioOutputOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tmd:AudioOutputOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioOutputOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioOutputConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _tmd__GetAudioOutputConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_new__tmd__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _tmd__GetAudioOutputConfigurationOptionsResponse *p;
	struct _tmd__GetAudioOutputConfigurationOptionsResponse *a = (struct _tmd__GetAudioOutputConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetAudioOutputConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetAudioOutputConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const struct _tmd__GetAudioOutputConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetAudioOutputConfigurationOptionsResponse(soap, tag ? tag : "tmd:GetAudioOutputConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_get__tmd__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetAudioOutputConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetAudioOutputConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetAudioOutputConfigurationOptions(struct soap *soap, struct _tmd__GetAudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->AudioOutputToken);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetAudioOutputConfigurationOptions(struct soap *soap, const struct _tmd__GetAudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AudioOutputToken);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _tmd__GetAudioOutputConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions), type))
		return soap->error;
	if (!a->AudioOutputToken)
	{	if (soap_element_empty(soap, "tmd:AudioOutputToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tmd:AudioOutputToken", -1, (char*const*)&a->AudioOutputToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_in__tmd__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct _tmd__GetAudioOutputConfigurationOptions *a, const char *type)
{
	size_t soap_flag_AudioOutputToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetAudioOutputConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions, sizeof(struct _tmd__GetAudioOutputConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetAudioOutputConfigurationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:AudioOutputToken", (char**)&a->AudioOutputToken, "tt:ReferenceToken"))
				{	soap_flag_AudioOutputToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioOutputToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions, sizeof(struct _tmd__GetAudioOutputConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_new__tmd__GetAudioOutputConfigurationOptions(struct soap *soap, int n)
{
	struct _tmd__GetAudioOutputConfigurationOptions *p;
	struct _tmd__GetAudioOutputConfigurationOptions *a = (struct _tmd__GetAudioOutputConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetAudioOutputConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetAudioOutputConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetAudioOutputConfigurationOptions(struct soap *soap, const struct _tmd__GetAudioOutputConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetAudioOutputConfigurationOptions(soap, tag ? tag : "tmd:GetAudioOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_get__tmd__GetAudioOutputConfigurationOptions(struct soap *soap, struct _tmd__GetAudioOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetAudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeInputTokensAvailable = 0;
	a->InputTokensAvailable = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioSourceConfigurationOptions(struct soap *soap, const struct tt__AudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->InputTokensAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeInputTokensAvailable; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->InputTokensAvailable + i));
		}
	}
	soap_serialize_PointerTott__AudioSourceOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__AudioSourceConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions), type))
		return soap->error;
	if (a->InputTokensAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeInputTokensAvailable; i++)
			if (soap_out_string(soap, "tt:InputTokensAvailable", -1, (char*const*)(a->InputTokensAvailable + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioSourceConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_InputTokensAvailable = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioSourceConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(struct tt__AudioSourceConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioSourceConfigurationOptions(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:InputTokensAvailable", 1, NULL))
			{	if (a->InputTokensAvailable == NULL)
				{	if (soap_blist_InputTokensAvailable == NULL)
						soap_blist_InputTokensAvailable = soap_alloc_block(soap);
					a->InputTokensAvailable = (char **)soap_push_block_max(soap, soap_blist_InputTokensAvailable, sizeof(char *));
					if (a->InputTokensAvailable == NULL)
						return NULL;
					*a->InputTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:InputTokensAvailable", (char**)a->InputTokensAvailable, "tt:ReferenceToken"))
				{	a->__sizeInputTokensAvailable++;
					a->InputTokensAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:AudioSourceOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->InputTokensAvailable)
			soap_pop_block(soap, soap_blist_InputTokensAvailable);
		if (a->__sizeInputTokensAvailable)
		{	a->InputTokensAvailable = (char **)soap_save_block(soap, soap_blist_InputTokensAvailable, NULL, 1);
		}
		else
		{	a->InputTokensAvailable = NULL;
			if (soap_blist_InputTokensAvailable)
				soap_end_block(soap, soap_blist_InputTokensAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeInputTokensAvailable < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfigurationOptions, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(struct tt__AudioSourceConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_new_tt__AudioSourceConfigurationOptions(struct soap *soap, int n)
{
	struct tt__AudioSourceConfigurationOptions *p;
	struct tt__AudioSourceConfigurationOptions *a = (struct tt__AudioSourceConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioSourceConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioSourceConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioSourceConfigurationOptions(struct soap *soap, const struct tt__AudioSourceConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioSourceConfigurationOptions(soap, tag ? tag : "tt:AudioSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetAudioSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AudioSourceOptions = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const struct _tmd__GetAudioSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioSourceConfigurationOptions(soap, &a->AudioSourceOptions);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetAudioSourceConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse), type))
		return soap->error;
	if (a->AudioSourceOptions)
		soap_element_result(soap, "tmd:AudioSourceOptions");
	if (!a->AudioSourceOptions)
	{	if (soap_element_empty(soap, "tmd:AudioSourceOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AudioSourceConfigurationOptions(soap, "tmd:AudioSourceOptions", -1, &a->AudioSourceOptions, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_in__tmd__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetAudioSourceConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_AudioSourceOptions = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetAudioSourceConfigurationOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _tmd__GetAudioSourceConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetAudioSourceConfigurationOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioSourceOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioSourceConfigurationOptions(soap, "tmd:AudioSourceOptions", &a->AudioSourceOptions, "tt:AudioSourceConfigurationOptions"))
				{	soap_flag_AudioSourceOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tmd:AudioSourceOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioSourceOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioSourceConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _tmd__GetAudioSourceConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_new__tmd__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _tmd__GetAudioSourceConfigurationOptionsResponse *p;
	struct _tmd__GetAudioSourceConfigurationOptionsResponse *a = (struct _tmd__GetAudioSourceConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetAudioSourceConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetAudioSourceConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const struct _tmd__GetAudioSourceConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetAudioSourceConfigurationOptionsResponse(soap, tag ? tag : "tmd:GetAudioSourceConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_get__tmd__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetAudioSourceConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetAudioSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetAudioSourceConfigurationOptions(struct soap *soap, struct _tmd__GetAudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->AudioSourceToken);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetAudioSourceConfigurationOptions(struct soap *soap, const struct _tmd__GetAudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AudioSourceToken);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _tmd__GetAudioSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions), type))
		return soap->error;
	if (!a->AudioSourceToken)
	{	if (soap_element_empty(soap, "tmd:AudioSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tmd:AudioSourceToken", -1, (char*const*)&a->AudioSourceToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_in__tmd__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct _tmd__GetAudioSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_AudioSourceToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetAudioSourceConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions, sizeof(struct _tmd__GetAudioSourceConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetAudioSourceConfigurationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:AudioSourceToken", (char**)&a->AudioSourceToken, "tt:ReferenceToken"))
				{	soap_flag_AudioSourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioSourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions, sizeof(struct _tmd__GetAudioSourceConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_new__tmd__GetAudioSourceConfigurationOptions(struct soap *soap, int n)
{
	struct _tmd__GetAudioSourceConfigurationOptions *p;
	struct _tmd__GetAudioSourceConfigurationOptions *a = (struct _tmd__GetAudioSourceConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetAudioSourceConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetAudioSourceConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetAudioSourceConfigurationOptions(struct soap *soap, const struct _tmd__GetAudioSourceConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetAudioSourceConfigurationOptions(soap, tag ? tag : "tmd:GetAudioSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_get__tmd__GetAudioSourceConfigurationOptions(struct soap *soap, struct _tmd__GetAudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetAudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoOutputConfigurationOptions(struct soap *soap, struct tt__VideoOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoOutputConfigurationOptions(struct soap *soap, const struct tt__VideoOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoOutputConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutputConfigurationOptions), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoOutputConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoOutputConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoOutputConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoOutputConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputConfigurationOptions, sizeof(struct tt__VideoOutputConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoOutputConfigurationOptions(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputConfigurationOptions, SOAP_TYPE_tt__VideoOutputConfigurationOptions, sizeof(struct tt__VideoOutputConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoOutputConfigurationOptions * SOAP_FMAC4 soap_new_tt__VideoOutputConfigurationOptions(struct soap *soap, int n)
{
	struct tt__VideoOutputConfigurationOptions *p;
	struct tt__VideoOutputConfigurationOptions *a = (struct tt__VideoOutputConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoOutputConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoOutputConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoOutputConfigurationOptions(struct soap *soap, const struct tt__VideoOutputConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoOutputConfigurationOptions(soap, tag ? tag : "tt:VideoOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoOutputConfigurationOptions(struct soap *soap, struct tt__VideoOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetVideoOutputConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetVideoOutputConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->VideoOutputConfigurationOptions = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetVideoOutputConfigurationOptionsResponse(struct soap *soap, const struct _tmd__GetVideoOutputConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoOutputConfigurationOptions(soap, &a->VideoOutputConfigurationOptions);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetVideoOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetVideoOutputConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse), type))
		return soap->error;
	if (a->VideoOutputConfigurationOptions)
		soap_element_result(soap, "tmd:VideoOutputConfigurationOptions");
	if (!a->VideoOutputConfigurationOptions)
	{	if (soap_element_empty(soap, "tmd:VideoOutputConfigurationOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoOutputConfigurationOptions(soap, "tmd:VideoOutputConfigurationOptions", -1, &a->VideoOutputConfigurationOptions, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_in__tmd__GetVideoOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetVideoOutputConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_VideoOutputConfigurationOptions = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetVideoOutputConfigurationOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse, sizeof(struct _tmd__GetVideoOutputConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetVideoOutputConfigurationOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutputConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoOutputConfigurationOptions(soap, "tmd:VideoOutputConfigurationOptions", &a->VideoOutputConfigurationOptions, "tt:VideoOutputConfigurationOptions"))
				{	soap_flag_VideoOutputConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tmd:VideoOutputConfigurationOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutputConfigurationOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoOutputConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse, sizeof(struct _tmd__GetVideoOutputConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_new__tmd__GetVideoOutputConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _tmd__GetVideoOutputConfigurationOptionsResponse *p;
	struct _tmd__GetVideoOutputConfigurationOptionsResponse *a = (struct _tmd__GetVideoOutputConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetVideoOutputConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetVideoOutputConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetVideoOutputConfigurationOptionsResponse(struct soap *soap, const struct _tmd__GetVideoOutputConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetVideoOutputConfigurationOptionsResponse(soap, tag ? tag : "tmd:GetVideoOutputConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_get__tmd__GetVideoOutputConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetVideoOutputConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetVideoOutputConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetVideoOutputConfigurationOptions(struct soap *soap, struct _tmd__GetVideoOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutputToken);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetVideoOutputConfigurationOptions(struct soap *soap, const struct _tmd__GetVideoOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutputToken);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetVideoOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _tmd__GetVideoOutputConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions), type))
		return soap->error;
	if (!a->VideoOutputToken)
	{	if (soap_element_empty(soap, "tmd:VideoOutputToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tmd:VideoOutputToken", -1, (char*const*)&a->VideoOutputToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationOptions * SOAP_FMAC4 soap_in__tmd__GetVideoOutputConfigurationOptions(struct soap *soap, const char *tag, struct _tmd__GetVideoOutputConfigurationOptions *a, const char *type)
{
	size_t soap_flag_VideoOutputToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetVideoOutputConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions, sizeof(struct _tmd__GetVideoOutputConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetVideoOutputConfigurationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:VideoOutputToken", (char**)&a->VideoOutputToken, "tt:ReferenceToken"))
				{	soap_flag_VideoOutputToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutputToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions, sizeof(struct _tmd__GetVideoOutputConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationOptions * SOAP_FMAC4 soap_new__tmd__GetVideoOutputConfigurationOptions(struct soap *soap, int n)
{
	struct _tmd__GetVideoOutputConfigurationOptions *p;
	struct _tmd__GetVideoOutputConfigurationOptions *a = (struct _tmd__GetVideoOutputConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetVideoOutputConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetVideoOutputConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetVideoOutputConfigurationOptions(struct soap *soap, const struct _tmd__GetVideoOutputConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetVideoOutputConfigurationOptions(soap, tag ? tag : "tmd:GetVideoOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationOptions * SOAP_FMAC4 soap_get__tmd__GetVideoOutputConfigurationOptions(struct soap *soap, struct _tmd__GetVideoOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetVideoOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BoundsRange = NULL;
	a->__sizeVideoSourceTokensAvailable = 0;
	a->VideoSourceTokensAvailable = NULL;
	a->Extension = NULL;
	a->MaximumNumberOfProfiles = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceConfigurationOptions(struct soap *soap, const struct tt__VideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRectangleRange(soap, &a->BoundsRange);
	if (a->VideoSourceTokensAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoSourceTokensAvailable; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->VideoSourceTokensAvailable + i));
		}
	}
	soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceConfigurationOptions *a, const char *type)
{
	if (a->MaximumNumberOfProfiles)
	{	soap_set_attr(soap, "MaximumNumberOfProfiles", soap_int2s(soap, *a->MaximumNumberOfProfiles), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions), type))
		return soap->error;
	if (!a->BoundsRange)
	{	if (soap_element_empty(soap, "tt:BoundsRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", -1, &a->BoundsRange, ""))
		return soap->error;
	if (a->VideoSourceTokensAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoSourceTokensAvailable; i++)
			if (soap_out_string(soap, "tt:VideoSourceTokensAvailable", -1, (char*const*)(a->VideoSourceTokensAvailable + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_BoundsRange = 1;
	struct soap_blist *soap_blist_VideoSourceTokensAvailable = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoSourceConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(struct tt__VideoSourceConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceConfigurationOptions(soap, a);
	{
		const char *t = soap_attr_value(soap, "MaximumNumberOfProfiles", 5, 0);
		if (t)
		{
			if (!(a->MaximumNumberOfProfiles = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaximumNumberOfProfiles))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundsRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", &a->BoundsRange, "tt:IntRectangleRange"))
				{	soap_flag_BoundsRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:VideoSourceTokensAvailable", 1, NULL))
			{	if (a->VideoSourceTokensAvailable == NULL)
				{	if (soap_blist_VideoSourceTokensAvailable == NULL)
						soap_blist_VideoSourceTokensAvailable = soap_alloc_block(soap);
					a->VideoSourceTokensAvailable = (char **)soap_push_block_max(soap, soap_blist_VideoSourceTokensAvailable, sizeof(char *));
					if (a->VideoSourceTokensAvailable == NULL)
						return NULL;
					*a->VideoSourceTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:VideoSourceTokensAvailable", (char**)a->VideoSourceTokensAvailable, "tt:ReferenceToken"))
				{	a->__sizeVideoSourceTokensAvailable++;
					a->VideoSourceTokensAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:VideoSourceConfigurationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->VideoSourceTokensAvailable)
			soap_pop_block(soap, soap_blist_VideoSourceTokensAvailable);
		if (a->__sizeVideoSourceTokensAvailable)
		{	a->VideoSourceTokensAvailable = (char **)soap_save_block(soap, soap_blist_VideoSourceTokensAvailable, NULL, 1);
		}
		else
		{	a->VideoSourceTokensAvailable = NULL;
			if (soap_blist_VideoSourceTokensAvailable)
				soap_end_block(soap, soap_blist_VideoSourceTokensAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->BoundsRange || a->__sizeVideoSourceTokensAvailable < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptions, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(struct tt__VideoSourceConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_new_tt__VideoSourceConfigurationOptions(struct soap *soap, int n)
{
	struct tt__VideoSourceConfigurationOptions *p;
	struct tt__VideoSourceConfigurationOptions *a = (struct tt__VideoSourceConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoSourceConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoSourceConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceConfigurationOptions(struct soap *soap, const struct tt__VideoSourceConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoSourceConfigurationOptions(soap, tag ? tag : "tt:VideoSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetVideoSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->VideoSourceConfigurationOptions = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const struct _tmd__GetVideoSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoSourceConfigurationOptions(soap, &a->VideoSourceConfigurationOptions);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetVideoSourceConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse), type))
		return soap->error;
	if (a->VideoSourceConfigurationOptions)
		soap_element_result(soap, "tmd:VideoSourceConfigurationOptions");
	if (!a->VideoSourceConfigurationOptions)
	{	if (soap_element_empty(soap, "tmd:VideoSourceConfigurationOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoSourceConfigurationOptions(soap, "tmd:VideoSourceConfigurationOptions", -1, &a->VideoSourceConfigurationOptions, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_in__tmd__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetVideoSourceConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_VideoSourceConfigurationOptions = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetVideoSourceConfigurationOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _tmd__GetVideoSourceConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetVideoSourceConfigurationOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationOptions(soap, "tmd:VideoSourceConfigurationOptions", &a->VideoSourceConfigurationOptions, "tt:VideoSourceConfigurationOptions"))
				{	soap_flag_VideoSourceConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tmd:VideoSourceConfigurationOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceConfigurationOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoSourceConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _tmd__GetVideoSourceConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_new__tmd__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _tmd__GetVideoSourceConfigurationOptionsResponse *p;
	struct _tmd__GetVideoSourceConfigurationOptionsResponse *a = (struct _tmd__GetVideoSourceConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetVideoSourceConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetVideoSourceConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const struct _tmd__GetVideoSourceConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetVideoSourceConfigurationOptionsResponse(soap, tag ? tag : "tmd:GetVideoSourceConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_get__tmd__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetVideoSourceConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetVideoSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetVideoSourceConfigurationOptions(struct soap *soap, struct _tmd__GetVideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetVideoSourceConfigurationOptions(struct soap *soap, const struct _tmd__GetVideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _tmd__GetVideoSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "tmd:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tmd:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_in__tmd__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct _tmd__GetVideoSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetVideoSourceConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions, sizeof(struct _tmd__GetVideoSourceConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetVideoSourceConfigurationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions, sizeof(struct _tmd__GetVideoSourceConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_new__tmd__GetVideoSourceConfigurationOptions(struct soap *soap, int n)
{
	struct _tmd__GetVideoSourceConfigurationOptions *p;
	struct _tmd__GetVideoSourceConfigurationOptions *a = (struct _tmd__GetVideoSourceConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetVideoSourceConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetVideoSourceConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetVideoSourceConfigurationOptions(struct soap *soap, const struct _tmd__GetVideoSourceConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetVideoSourceConfigurationOptions(soap, tag ? tag : "tmd:GetVideoSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_get__tmd__GetVideoSourceConfigurationOptions(struct soap *soap, struct _tmd__GetVideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetVideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetVideoOutputConfigurationResponse(struct soap *soap, struct _tmd__SetVideoOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetVideoOutputConfigurationResponse(struct soap *soap, const struct _tmd__SetVideoOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetVideoOutputConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tmd__SetVideoOutputConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetVideoOutputConfigurationResponse * SOAP_FMAC4 soap_in__tmd__SetVideoOutputConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__SetVideoOutputConfigurationResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetVideoOutputConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse, sizeof(struct _tmd__SetVideoOutputConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetVideoOutputConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetVideoOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse, SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse, sizeof(struct _tmd__SetVideoOutputConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetVideoOutputConfigurationResponse * SOAP_FMAC4 soap_new__tmd__SetVideoOutputConfigurationResponse(struct soap *soap, int n)
{
	struct _tmd__SetVideoOutputConfigurationResponse *p;
	struct _tmd__SetVideoOutputConfigurationResponse *a = (struct _tmd__SetVideoOutputConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetVideoOutputConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetVideoOutputConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetVideoOutputConfigurationResponse(struct soap *soap, const struct _tmd__SetVideoOutputConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetVideoOutputConfigurationResponse(soap, tag ? tag : "tmd:SetVideoOutputConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetVideoOutputConfigurationResponse * SOAP_FMAC4 soap_get__tmd__SetVideoOutputConfigurationResponse(struct soap *soap, struct _tmd__SetVideoOutputConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetVideoOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetVideoOutputConfiguration(struct soap *soap, struct _tmd__SetVideoOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetVideoOutputConfiguration(struct soap *soap, const struct _tmd__SetVideoOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoOutputConfiguration(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetVideoOutputConfiguration(struct soap *soap, const char *tag, int id, const struct _tmd__SetVideoOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetVideoOutputConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tmd:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoOutputConfiguration(soap, "tmd:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tmd:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetVideoOutputConfiguration * SOAP_FMAC4 soap_in__tmd__SetVideoOutputConfiguration(struct soap *soap, const char *tag, struct _tmd__SetVideoOutputConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetVideoOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetVideoOutputConfiguration, sizeof(struct _tmd__SetVideoOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetVideoOutputConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoOutputConfiguration(soap, "tmd:Configuration", &a->Configuration, "tt:VideoOutputConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tmd:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__SetVideoOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetVideoOutputConfiguration, SOAP_TYPE__tmd__SetVideoOutputConfiguration, sizeof(struct _tmd__SetVideoOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetVideoOutputConfiguration * SOAP_FMAC4 soap_new__tmd__SetVideoOutputConfiguration(struct soap *soap, int n)
{
	struct _tmd__SetVideoOutputConfiguration *p;
	struct _tmd__SetVideoOutputConfiguration *a = (struct _tmd__SetVideoOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetVideoOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetVideoOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetVideoOutputConfiguration(struct soap *soap, const struct _tmd__SetVideoOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetVideoOutputConfiguration(soap, tag ? tag : "tmd:SetVideoOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetVideoOutputConfiguration * SOAP_FMAC4 soap_get__tmd__SetVideoOutputConfiguration(struct soap *soap, struct _tmd__SetVideoOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetVideoOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetVideoSourceConfigurationResponse(struct soap *soap, struct _tmd__SetVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetVideoSourceConfigurationResponse(struct soap *soap, const struct _tmd__SetVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tmd__SetVideoSourceConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetVideoSourceConfigurationResponse * SOAP_FMAC4 soap_in__tmd__SetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__SetVideoSourceConfigurationResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetVideoSourceConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse, sizeof(struct _tmd__SetVideoSourceConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetVideoSourceConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse, SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse, sizeof(struct _tmd__SetVideoSourceConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetVideoSourceConfigurationResponse * SOAP_FMAC4 soap_new__tmd__SetVideoSourceConfigurationResponse(struct soap *soap, int n)
{
	struct _tmd__SetVideoSourceConfigurationResponse *p;
	struct _tmd__SetVideoSourceConfigurationResponse *a = (struct _tmd__SetVideoSourceConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetVideoSourceConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetVideoSourceConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetVideoSourceConfigurationResponse(struct soap *soap, const struct _tmd__SetVideoSourceConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetVideoSourceConfigurationResponse(soap, tag ? tag : "tmd:SetVideoSourceConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetVideoSourceConfigurationResponse * SOAP_FMAC4 soap_get__tmd__SetVideoSourceConfigurationResponse(struct soap *soap, struct _tmd__SetVideoSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetVideoSourceConfiguration(struct soap *soap, struct _tmd__SetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetVideoSourceConfiguration(struct soap *soap, const struct _tmd__SetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoSourceConfiguration(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _tmd__SetVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetVideoSourceConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tmd:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoSourceConfiguration(soap, "tmd:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tmd:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetVideoSourceConfiguration * SOAP_FMAC4 soap_in__tmd__SetVideoSourceConfiguration(struct soap *soap, const char *tag, struct _tmd__SetVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetVideoSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetVideoSourceConfiguration, sizeof(struct _tmd__SetVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetVideoSourceConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfiguration(soap, "tmd:Configuration", &a->Configuration, "tt:VideoSourceConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tmd:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__SetVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetVideoSourceConfiguration, SOAP_TYPE__tmd__SetVideoSourceConfiguration, sizeof(struct _tmd__SetVideoSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetVideoSourceConfiguration * SOAP_FMAC4 soap_new__tmd__SetVideoSourceConfiguration(struct soap *soap, int n)
{
	struct _tmd__SetVideoSourceConfiguration *p;
	struct _tmd__SetVideoSourceConfiguration *a = (struct _tmd__SetVideoSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetVideoSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetVideoSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetVideoSourceConfiguration(struct soap *soap, const struct _tmd__SetVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetVideoSourceConfiguration(soap, tag ? tag : "tmd:SetVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetVideoSourceConfiguration * SOAP_FMAC4 soap_get__tmd__SetVideoSourceConfiguration(struct soap *soap, struct _tmd__SetVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetAudioOutputConfigurationResponse(struct soap *soap, struct _tmd__SetAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetAudioOutputConfigurationResponse(struct soap *soap, const struct _tmd__SetAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tmd__SetAudioOutputConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetAudioOutputConfigurationResponse * SOAP_FMAC4 soap_in__tmd__SetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__SetAudioOutputConfigurationResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetAudioOutputConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse, sizeof(struct _tmd__SetAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetAudioOutputConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse, SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse, sizeof(struct _tmd__SetAudioOutputConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetAudioOutputConfigurationResponse * SOAP_FMAC4 soap_new__tmd__SetAudioOutputConfigurationResponse(struct soap *soap, int n)
{
	struct _tmd__SetAudioOutputConfigurationResponse *p;
	struct _tmd__SetAudioOutputConfigurationResponse *a = (struct _tmd__SetAudioOutputConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetAudioOutputConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetAudioOutputConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetAudioOutputConfigurationResponse(struct soap *soap, const struct _tmd__SetAudioOutputConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetAudioOutputConfigurationResponse(soap, tag ? tag : "tmd:SetAudioOutputConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetAudioOutputConfigurationResponse * SOAP_FMAC4 soap_get__tmd__SetAudioOutputConfigurationResponse(struct soap *soap, struct _tmd__SetAudioOutputConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetAudioOutputConfiguration(struct soap *soap, struct _tmd__SetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetAudioOutputConfiguration(struct soap *soap, const struct _tmd__SetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioOutputConfiguration(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct _tmd__SetAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetAudioOutputConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tmd:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AudioOutputConfiguration(soap, "tmd:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tmd:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetAudioOutputConfiguration * SOAP_FMAC4 soap_in__tmd__SetAudioOutputConfiguration(struct soap *soap, const char *tag, struct _tmd__SetAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetAudioOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetAudioOutputConfiguration, sizeof(struct _tmd__SetAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetAudioOutputConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioOutputConfiguration(soap, "tmd:Configuration", &a->Configuration, "tt:AudioOutputConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tmd:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__SetAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetAudioOutputConfiguration, SOAP_TYPE__tmd__SetAudioOutputConfiguration, sizeof(struct _tmd__SetAudioOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetAudioOutputConfiguration * SOAP_FMAC4 soap_new__tmd__SetAudioOutputConfiguration(struct soap *soap, int n)
{
	struct _tmd__SetAudioOutputConfiguration *p;
	struct _tmd__SetAudioOutputConfiguration *a = (struct _tmd__SetAudioOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetAudioOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetAudioOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetAudioOutputConfiguration(struct soap *soap, const struct _tmd__SetAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetAudioOutputConfiguration(soap, tag ? tag : "tmd:SetAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetAudioOutputConfiguration * SOAP_FMAC4 soap_get__tmd__SetAudioOutputConfiguration(struct soap *soap, struct _tmd__SetAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetAudioSourceConfigurationResponse(struct soap *soap, struct _tmd__SetAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetAudioSourceConfigurationResponse(struct soap *soap, const struct _tmd__SetAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tmd__SetAudioSourceConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetAudioSourceConfigurationResponse * SOAP_FMAC4 soap_in__tmd__SetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__SetAudioSourceConfigurationResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetAudioSourceConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse, sizeof(struct _tmd__SetAudioSourceConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetAudioSourceConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse, SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse, sizeof(struct _tmd__SetAudioSourceConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetAudioSourceConfigurationResponse * SOAP_FMAC4 soap_new__tmd__SetAudioSourceConfigurationResponse(struct soap *soap, int n)
{
	struct _tmd__SetAudioSourceConfigurationResponse *p;
	struct _tmd__SetAudioSourceConfigurationResponse *a = (struct _tmd__SetAudioSourceConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetAudioSourceConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetAudioSourceConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetAudioSourceConfigurationResponse(struct soap *soap, const struct _tmd__SetAudioSourceConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetAudioSourceConfigurationResponse(soap, tag ? tag : "tmd:SetAudioSourceConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetAudioSourceConfigurationResponse * SOAP_FMAC4 soap_get__tmd__SetAudioSourceConfigurationResponse(struct soap *soap, struct _tmd__SetAudioSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetAudioSourceConfiguration(struct soap *soap, struct _tmd__SetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetAudioSourceConfiguration(struct soap *soap, const struct _tmd__SetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioSourceConfiguration(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _tmd__SetAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetAudioSourceConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tmd:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AudioSourceConfiguration(soap, "tmd:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tmd:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetAudioSourceConfiguration * SOAP_FMAC4 soap_in__tmd__SetAudioSourceConfiguration(struct soap *soap, const char *tag, struct _tmd__SetAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetAudioSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetAudioSourceConfiguration, sizeof(struct _tmd__SetAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetAudioSourceConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioSourceConfiguration(soap, "tmd:Configuration", &a->Configuration, "tt:AudioSourceConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tmd:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__SetAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetAudioSourceConfiguration, SOAP_TYPE__tmd__SetAudioSourceConfiguration, sizeof(struct _tmd__SetAudioSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetAudioSourceConfiguration * SOAP_FMAC4 soap_new__tmd__SetAudioSourceConfiguration(struct soap *soap, int n)
{
	struct _tmd__SetAudioSourceConfiguration *p;
	struct _tmd__SetAudioSourceConfiguration *a = (struct _tmd__SetAudioSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetAudioSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetAudioSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetAudioSourceConfiguration(struct soap *soap, const struct _tmd__SetAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetAudioSourceConfiguration(soap, tag ? tag : "tmd:SetAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetAudioSourceConfiguration * SOAP_FMAC4 soap_get__tmd__SetAudioSourceConfiguration(struct soap *soap, struct _tmd__SetAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoOutputConfiguration(struct soap *soap, struct tt__VideoOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->OutputToken);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoOutputConfiguration(struct soap *soap, const struct tt__VideoOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OutputToken);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutputConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoOutputConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutputConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->OutputToken)
	{	if (soap_element_empty(soap, "tt:OutputToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:OutputToken", -1, (char*const*)&a->OutputToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration * SOAP_FMAC4 soap_in_tt__VideoOutputConfiguration(struct soap *soap, const char *tag, struct tt__VideoOutputConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_OutputToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(struct tt__VideoOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoOutputConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_OutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:OutputToken", (char**)&a->OutputToken, "tt:ReferenceToken"))
				{	soap_flag_OutputToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->OutputToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputConfiguration, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(struct tt__VideoOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration * SOAP_FMAC4 soap_new_tt__VideoOutputConfiguration(struct soap *soap, int n)
{
	struct tt__VideoOutputConfiguration *p;
	struct tt__VideoOutputConfiguration *a = (struct tt__VideoOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoOutputConfiguration(struct soap *soap, const struct tt__VideoOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoOutputConfiguration(soap, tag ? tag : "tt:VideoOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration * SOAP_FMAC4 soap_get_tt__VideoOutputConfiguration(struct soap *soap, struct tt__VideoOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetVideoOutputConfigurationResponse(struct soap *soap, struct _tmd__GetVideoOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->VideoOutputConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetVideoOutputConfigurationResponse(struct soap *soap, const struct _tmd__GetVideoOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoOutputConfiguration(soap, &a->VideoOutputConfiguration);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetVideoOutputConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetVideoOutputConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse), type))
		return soap->error;
	if (a->VideoOutputConfiguration)
		soap_element_result(soap, "tmd:VideoOutputConfiguration");
	if (!a->VideoOutputConfiguration)
	{	if (soap_element_empty(soap, "tmd:VideoOutputConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoOutputConfiguration(soap, "tmd:VideoOutputConfiguration", -1, &a->VideoOutputConfiguration, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationResponse * SOAP_FMAC4 soap_in__tmd__GetVideoOutputConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__GetVideoOutputConfigurationResponse *a, const char *type)
{
	size_t soap_flag_VideoOutputConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetVideoOutputConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse, sizeof(struct _tmd__GetVideoOutputConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetVideoOutputConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoOutputConfiguration(soap, "tmd:VideoOutputConfiguration", &a->VideoOutputConfiguration, "tt:VideoOutputConfiguration"))
				{	soap_flag_VideoOutputConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tmd:VideoOutputConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutputConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse, SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse, sizeof(struct _tmd__GetVideoOutputConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationResponse * SOAP_FMAC4 soap_new__tmd__GetVideoOutputConfigurationResponse(struct soap *soap, int n)
{
	struct _tmd__GetVideoOutputConfigurationResponse *p;
	struct _tmd__GetVideoOutputConfigurationResponse *a = (struct _tmd__GetVideoOutputConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetVideoOutputConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetVideoOutputConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetVideoOutputConfigurationResponse(struct soap *soap, const struct _tmd__GetVideoOutputConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetVideoOutputConfigurationResponse(soap, tag ? tag : "tmd:GetVideoOutputConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationResponse * SOAP_FMAC4 soap_get__tmd__GetVideoOutputConfigurationResponse(struct soap *soap, struct _tmd__GetVideoOutputConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetVideoOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetVideoOutputConfiguration(struct soap *soap, struct _tmd__GetVideoOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutputToken);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetVideoOutputConfiguration(struct soap *soap, const struct _tmd__GetVideoOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutputToken);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetVideoOutputConfiguration(struct soap *soap, const char *tag, int id, const struct _tmd__GetVideoOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetVideoOutputConfiguration), type))
		return soap->error;
	if (!a->VideoOutputToken)
	{	if (soap_element_empty(soap, "tmd:VideoOutputToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tmd:VideoOutputToken", -1, (char*const*)&a->VideoOutputToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfiguration * SOAP_FMAC4 soap_in__tmd__GetVideoOutputConfiguration(struct soap *soap, const char *tag, struct _tmd__GetVideoOutputConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutputToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetVideoOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoOutputConfiguration, sizeof(struct _tmd__GetVideoOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetVideoOutputConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:VideoOutputToken", (char**)&a->VideoOutputToken, "tt:ReferenceToken"))
				{	soap_flag_VideoOutputToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutputToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoOutputConfiguration, SOAP_TYPE__tmd__GetVideoOutputConfiguration, sizeof(struct _tmd__GetVideoOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfiguration * SOAP_FMAC4 soap_new__tmd__GetVideoOutputConfiguration(struct soap *soap, int n)
{
	struct _tmd__GetVideoOutputConfiguration *p;
	struct _tmd__GetVideoOutputConfiguration *a = (struct _tmd__GetVideoOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetVideoOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetVideoOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetVideoOutputConfiguration(struct soap *soap, const struct _tmd__GetVideoOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetVideoOutputConfiguration(soap, tag ? tag : "tmd:GetVideoOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfiguration * SOAP_FMAC4 soap_get__tmd__GetVideoOutputConfiguration(struct soap *soap, struct _tmd__GetVideoOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetVideoOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->SourceToken);
	a->Bounds = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->Extension = NULL;
	soap_default_string(soap, &a->ViewMode);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceConfiguration(struct soap *soap, const struct tt__VideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->SourceToken);
	soap_serialize_PointerTott__IntRectangle(soap, &a->Bounds);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_serialize_PointerTott__VideoSourceConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (a->ViewMode)
		soap_set_attr(soap, "ViewMode", soap_string2s(soap, a->ViewMode), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->SourceToken)
	{	if (soap_element_empty(soap, "tt:SourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, (char*const*)&a->SourceToken, ""))
		return soap->error;
	if (!a->Bounds)
	{	if (soap_element_empty(soap, "tt:Bounds", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRectangle(soap, "tt:Bounds", -1, &a->Bounds, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration * SOAP_FMAC4 soap_in_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, struct tt__VideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceToken = 1;
	size_t soap_flag_Bounds = 1;
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ViewMode", 1, 0), &a->ViewMode))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_SourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", (char**)&a->SourceToken, "tt:ReferenceToken"))
				{	soap_flag_SourceToken--;
					continue;
				}
			}
			if (soap_flag_Bounds && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRectangle(soap, "tt:Bounds", &a->Bounds, "tt:IntRectangle"))
				{	soap_flag_Bounds--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:VideoSourceConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->SourceToken || !a->Bounds))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfiguration, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration * SOAP_FMAC4 soap_new_tt__VideoSourceConfiguration(struct soap *soap, int n)
{
	struct tt__VideoSourceConfiguration *p;
	struct tt__VideoSourceConfiguration *a = (struct tt__VideoSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceConfiguration(struct soap *soap, const struct tt__VideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoSourceConfiguration(soap, tag ? tag : "tt:VideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration * SOAP_FMAC4 soap_get_tt__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetVideoSourceConfigurationResponse(struct soap *soap, struct _tmd__GetVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->VideoSourceConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetVideoSourceConfigurationResponse(struct soap *soap, const struct _tmd__GetVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoSourceConfiguration(soap, &a->VideoSourceConfiguration);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetVideoSourceConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse), type))
		return soap->error;
	if (a->VideoSourceConfiguration)
		soap_element_result(soap, "tmd:VideoSourceConfiguration");
	if (!a->VideoSourceConfiguration)
	{	if (soap_element_empty(soap, "tmd:VideoSourceConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoSourceConfiguration(soap, "tmd:VideoSourceConfiguration", -1, &a->VideoSourceConfiguration, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationResponse * SOAP_FMAC4 soap_in__tmd__GetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__GetVideoSourceConfigurationResponse *a, const char *type)
{
	size_t soap_flag_VideoSourceConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetVideoSourceConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse, sizeof(struct _tmd__GetVideoSourceConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetVideoSourceConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfiguration(soap, "tmd:VideoSourceConfiguration", &a->VideoSourceConfiguration, "tt:VideoSourceConfiguration"))
				{	soap_flag_VideoSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tmd:VideoSourceConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse, SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse, sizeof(struct _tmd__GetVideoSourceConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationResponse * SOAP_FMAC4 soap_new__tmd__GetVideoSourceConfigurationResponse(struct soap *soap, int n)
{
	struct _tmd__GetVideoSourceConfigurationResponse *p;
	struct _tmd__GetVideoSourceConfigurationResponse *a = (struct _tmd__GetVideoSourceConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetVideoSourceConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetVideoSourceConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetVideoSourceConfigurationResponse(struct soap *soap, const struct _tmd__GetVideoSourceConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetVideoSourceConfigurationResponse(soap, tag ? tag : "tmd:GetVideoSourceConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationResponse * SOAP_FMAC4 soap_get__tmd__GetVideoSourceConfigurationResponse(struct soap *soap, struct _tmd__GetVideoSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetVideoSourceConfiguration(struct soap *soap, struct _tmd__GetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetVideoSourceConfiguration(struct soap *soap, const struct _tmd__GetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _tmd__GetVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetVideoSourceConfiguration), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "tmd:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tmd:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfiguration * SOAP_FMAC4 soap_in__tmd__GetVideoSourceConfiguration(struct soap *soap, const char *tag, struct _tmd__GetVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetVideoSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoSourceConfiguration, sizeof(struct _tmd__GetVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetVideoSourceConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoSourceConfiguration, SOAP_TYPE__tmd__GetVideoSourceConfiguration, sizeof(struct _tmd__GetVideoSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfiguration * SOAP_FMAC4 soap_new__tmd__GetVideoSourceConfiguration(struct soap *soap, int n)
{
	struct _tmd__GetVideoSourceConfiguration *p;
	struct _tmd__GetVideoSourceConfiguration *a = (struct _tmd__GetVideoSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetVideoSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetVideoSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetVideoSourceConfiguration(struct soap *soap, const struct _tmd__GetVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetVideoSourceConfiguration(soap, tag ? tag : "tmd:GetVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfiguration * SOAP_FMAC4 soap_get__tmd__GetVideoSourceConfiguration(struct soap *soap, struct _tmd__GetVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->OutputToken);
	soap_default_xsd__anyURI(soap, &a->SendPrimacy);
	soap_default_int(soap, &a->OutputLevel);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioOutputConfiguration(struct soap *soap, const struct tt__AudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OutputToken);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->SendPrimacy);
	soap_embedded(soap, &a->OutputLevel, SOAP_TYPE_int);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioOutputConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutputConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->OutputToken)
	{	if (soap_element_empty(soap, "tt:OutputToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:OutputToken", -1, (char*const*)&a->OutputToken, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:SendPrimacy", -1, (char*const*)&a->SendPrimacy, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:OutputLevel", -1, &a->OutputLevel, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration * SOAP_FMAC4 soap_in_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, struct tt__AudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_OutputToken = 1;
	size_t soap_flag_SendPrimacy = 1;
	size_t soap_flag_OutputLevel = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioOutputConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_OutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:OutputToken", (char**)&a->OutputToken, "tt:ReferenceToken"))
				{	soap_flag_OutputToken--;
					continue;
				}
			}
			if (soap_flag_SendPrimacy && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:SendPrimacy", (char**)&a->SendPrimacy, "xsd:anyURI"))
				{	soap_flag_SendPrimacy--;
					continue;
				}
			}
			if (soap_flag_OutputLevel && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:OutputLevel", &a->OutputLevel, "xsd:int"))
				{	soap_flag_OutputLevel--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->OutputToken || soap_flag_OutputLevel > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfiguration, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration * SOAP_FMAC4 soap_new_tt__AudioOutputConfiguration(struct soap *soap, int n)
{
	struct tt__AudioOutputConfiguration *p;
	struct tt__AudioOutputConfiguration *a = (struct tt__AudioOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioOutputConfiguration(struct soap *soap, const struct tt__AudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioOutputConfiguration(soap, tag ? tag : "tt:AudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration * SOAP_FMAC4 soap_get_tt__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetAudioOutputConfigurationResponse(struct soap *soap, struct _tmd__GetAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AudioOutputConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetAudioOutputConfigurationResponse(struct soap *soap, const struct _tmd__GetAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioOutputConfiguration(soap, &a->AudioOutputConfiguration);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetAudioOutputConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse), type))
		return soap->error;
	if (a->AudioOutputConfiguration)
		soap_element_result(soap, "tmd:AudioOutputConfiguration");
	if (!a->AudioOutputConfiguration)
	{	if (soap_element_empty(soap, "tmd:AudioOutputConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AudioOutputConfiguration(soap, "tmd:AudioOutputConfiguration", -1, &a->AudioOutputConfiguration, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationResponse * SOAP_FMAC4 soap_in__tmd__GetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__GetAudioOutputConfigurationResponse *a, const char *type)
{
	size_t soap_flag_AudioOutputConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetAudioOutputConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse, sizeof(struct _tmd__GetAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetAudioOutputConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioOutputConfiguration(soap, "tmd:AudioOutputConfiguration", &a->AudioOutputConfiguration, "tt:AudioOutputConfiguration"))
				{	soap_flag_AudioOutputConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tmd:AudioOutputConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioOutputConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse, SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse, sizeof(struct _tmd__GetAudioOutputConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationResponse * SOAP_FMAC4 soap_new__tmd__GetAudioOutputConfigurationResponse(struct soap *soap, int n)
{
	struct _tmd__GetAudioOutputConfigurationResponse *p;
	struct _tmd__GetAudioOutputConfigurationResponse *a = (struct _tmd__GetAudioOutputConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetAudioOutputConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetAudioOutputConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetAudioOutputConfigurationResponse(struct soap *soap, const struct _tmd__GetAudioOutputConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetAudioOutputConfigurationResponse(soap, tag ? tag : "tmd:GetAudioOutputConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationResponse * SOAP_FMAC4 soap_get__tmd__GetAudioOutputConfigurationResponse(struct soap *soap, struct _tmd__GetAudioOutputConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetAudioOutputConfiguration(struct soap *soap, struct _tmd__GetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->AudioOutputToken);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetAudioOutputConfiguration(struct soap *soap, const struct _tmd__GetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AudioOutputToken);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct _tmd__GetAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetAudioOutputConfiguration), type))
		return soap->error;
	if (!a->AudioOutputToken)
	{	if (soap_element_empty(soap, "tmd:AudioOutputToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tmd:AudioOutputToken", -1, (char*const*)&a->AudioOutputToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfiguration * SOAP_FMAC4 soap_in__tmd__GetAudioOutputConfiguration(struct soap *soap, const char *tag, struct _tmd__GetAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_AudioOutputToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetAudioOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioOutputConfiguration, sizeof(struct _tmd__GetAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetAudioOutputConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:AudioOutputToken", (char**)&a->AudioOutputToken, "tt:ReferenceToken"))
				{	soap_flag_AudioOutputToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioOutputToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioOutputConfiguration, SOAP_TYPE__tmd__GetAudioOutputConfiguration, sizeof(struct _tmd__GetAudioOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfiguration * SOAP_FMAC4 soap_new__tmd__GetAudioOutputConfiguration(struct soap *soap, int n)
{
	struct _tmd__GetAudioOutputConfiguration *p;
	struct _tmd__GetAudioOutputConfiguration *a = (struct _tmd__GetAudioOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetAudioOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetAudioOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetAudioOutputConfiguration(struct soap *soap, const struct _tmd__GetAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetAudioOutputConfiguration(soap, tag ? tag : "tmd:GetAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfiguration * SOAP_FMAC4 soap_get__tmd__GetAudioOutputConfiguration(struct soap *soap, struct _tmd__GetAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->SourceToken);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioSourceConfiguration(struct soap *soap, const struct tt__AudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->SourceToken);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioSourceConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->SourceToken)
	{	if (soap_element_empty(soap, "tt:SourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, (char*const*)&a->SourceToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration * SOAP_FMAC4 soap_in_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, struct tt__AudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioSourceConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_SourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", (char**)&a->SourceToken, "tt:ReferenceToken"))
				{	soap_flag_SourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->SourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfiguration, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration * SOAP_FMAC4 soap_new_tt__AudioSourceConfiguration(struct soap *soap, int n)
{
	struct tt__AudioSourceConfiguration *p;
	struct tt__AudioSourceConfiguration *a = (struct tt__AudioSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioSourceConfiguration(struct soap *soap, const struct tt__AudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioSourceConfiguration(soap, tag ? tag : "tt:AudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration * SOAP_FMAC4 soap_get_tt__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetAudioSourceConfigurationResponse(struct soap *soap, struct _tmd__GetAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AudioSourceConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetAudioSourceConfigurationResponse(struct soap *soap, const struct _tmd__GetAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioSourceConfiguration(soap, &a->AudioSourceConfiguration);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetAudioSourceConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse), type))
		return soap->error;
	if (a->AudioSourceConfiguration)
		soap_element_result(soap, "tmd:AudioSourceConfiguration");
	if (!a->AudioSourceConfiguration)
	{	if (soap_element_empty(soap, "tmd:AudioSourceConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AudioSourceConfiguration(soap, "tmd:AudioSourceConfiguration", -1, &a->AudioSourceConfiguration, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationResponse * SOAP_FMAC4 soap_in__tmd__GetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__GetAudioSourceConfigurationResponse *a, const char *type)
{
	size_t soap_flag_AudioSourceConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetAudioSourceConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse, sizeof(struct _tmd__GetAudioSourceConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetAudioSourceConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioSourceConfiguration(soap, "tmd:AudioSourceConfiguration", &a->AudioSourceConfiguration, "tt:AudioSourceConfiguration"))
				{	soap_flag_AudioSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tmd:AudioSourceConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioSourceConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse, SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse, sizeof(struct _tmd__GetAudioSourceConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationResponse * SOAP_FMAC4 soap_new__tmd__GetAudioSourceConfigurationResponse(struct soap *soap, int n)
{
	struct _tmd__GetAudioSourceConfigurationResponse *p;
	struct _tmd__GetAudioSourceConfigurationResponse *a = (struct _tmd__GetAudioSourceConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetAudioSourceConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetAudioSourceConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetAudioSourceConfigurationResponse(struct soap *soap, const struct _tmd__GetAudioSourceConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetAudioSourceConfigurationResponse(soap, tag ? tag : "tmd:GetAudioSourceConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationResponse * SOAP_FMAC4 soap_get__tmd__GetAudioSourceConfigurationResponse(struct soap *soap, struct _tmd__GetAudioSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetAudioSourceConfiguration(struct soap *soap, struct _tmd__GetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->AudioSourceToken);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetAudioSourceConfiguration(struct soap *soap, const struct _tmd__GetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AudioSourceToken);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _tmd__GetAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetAudioSourceConfiguration), type))
		return soap->error;
	if (!a->AudioSourceToken)
	{	if (soap_element_empty(soap, "tmd:AudioSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tmd:AudioSourceToken", -1, (char*const*)&a->AudioSourceToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfiguration * SOAP_FMAC4 soap_in__tmd__GetAudioSourceConfiguration(struct soap *soap, const char *tag, struct _tmd__GetAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_AudioSourceToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetAudioSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetAudioSourceConfiguration, sizeof(struct _tmd__GetAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetAudioSourceConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:AudioSourceToken", (char**)&a->AudioSourceToken, "tt:ReferenceToken"))
				{	soap_flag_AudioSourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AudioSourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetAudioSourceConfiguration, SOAP_TYPE__tmd__GetAudioSourceConfiguration, sizeof(struct _tmd__GetAudioSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfiguration * SOAP_FMAC4 soap_new__tmd__GetAudioSourceConfiguration(struct soap *soap, int n)
{
	struct _tmd__GetAudioSourceConfiguration *p;
	struct _tmd__GetAudioSourceConfiguration *a = (struct _tmd__GetAudioSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetAudioSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetAudioSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetAudioSourceConfiguration(struct soap *soap, const struct _tmd__GetAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetAudioSourceConfiguration(soap, tag ? tag : "tmd:GetAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfiguration * SOAP_FMAC4 soap_get__tmd__GetAudioSourceConfiguration(struct soap *soap, struct _tmd__GetAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoOutput(struct soap *soap, struct tt__VideoOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->Layout = NULL;
	a->Resolution = NULL;
	a->RefreshRate = NULL;
	a->AspectRatio = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoOutput(struct soap *soap, const struct tt__VideoOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Layout(soap, &a->Layout);
	soap_serialize_PointerTott__VideoResolution(soap, &a->Resolution);
	soap_serialize_PointerTofloat(soap, &a->RefreshRate);
	soap_serialize_PointerTofloat(soap, &a->AspectRatio);
	soap_serialize_PointerTott__VideoOutputExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutput(struct soap *soap, const char *tag, int id, const struct tt__VideoOutput *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutput), type))
		return soap->error;
	if (!a->Layout)
	{	if (soap_element_empty(soap, "tt:Layout", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Layout(soap, "tt:Layout", -1, &a->Layout, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->Resolution, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:RefreshRate", -1, &a->RefreshRate, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:AspectRatio", -1, &a->AspectRatio, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoOutputExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoOutput * SOAP_FMAC4 soap_in_tt__VideoOutput(struct soap *soap, const char *tag, struct tt__VideoOutput *a, const char *type)
{
	size_t soap_flag_Layout = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_RefreshRate = 1;
	size_t soap_flag_AspectRatio = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoOutput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutput, sizeof(struct tt__VideoOutput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoOutput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Layout && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Layout(soap, "tt:Layout", &a->Layout, "tt:Layout"))
				{	soap_flag_Layout--;
					continue;
				}
			}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution--;
					continue;
				}
			}
			if (soap_flag_RefreshRate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:RefreshRate", &a->RefreshRate, "xsd:float"))
				{	soap_flag_RefreshRate--;
					continue;
				}
			}
			if (soap_flag_AspectRatio && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:AspectRatio", &a->AspectRatio, "xsd:float"))
				{	soap_flag_AspectRatio--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoOutputExtension(soap, "tt:Extension", &a->Extension, "tt:VideoOutputExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Layout))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutput, SOAP_TYPE_tt__VideoOutput, sizeof(struct tt__VideoOutput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoOutput * SOAP_FMAC4 soap_new_tt__VideoOutput(struct soap *soap, int n)
{
	struct tt__VideoOutput *p;
	struct tt__VideoOutput *a = (struct tt__VideoOutput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoOutput));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoOutput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoOutput(struct soap *soap, const struct tt__VideoOutput *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoOutput(soap, tag ? tag : "tt:VideoOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutput * SOAP_FMAC4 soap_get_tt__VideoOutput(struct soap *soap, struct tt__VideoOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetVideoOutputsResponse(struct soap *soap, struct _tmd__GetVideoOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeVideoOutputs = 0;
	a->VideoOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetVideoOutputsResponse(struct soap *soap, const struct _tmd__GetVideoOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->VideoOutputs)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoOutputs; i++)
		{
			soap_embedded(soap, a->VideoOutputs + i, SOAP_TYPE_tt__VideoOutput);
			soap_serialize_tt__VideoOutput(soap, a->VideoOutputs + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetVideoOutputsResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetVideoOutputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetVideoOutputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeVideoOutputs");
	if (a->VideoOutputs)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoOutputs; i++)
			if (soap_out_tt__VideoOutput(soap, "tmd:VideoOutputs", -1, a->VideoOutputs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputsResponse * SOAP_FMAC4 soap_in__tmd__GetVideoOutputsResponse(struct soap *soap, const char *tag, struct _tmd__GetVideoOutputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_VideoOutputs = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetVideoOutputsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoOutputsResponse, sizeof(struct _tmd__GetVideoOutputsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetVideoOutputsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:VideoOutputs", 1, NULL))
			{	if (a->VideoOutputs == NULL)
				{	if (soap_blist_VideoOutputs == NULL)
						soap_blist_VideoOutputs = soap_alloc_block(soap);
					a->VideoOutputs = (struct tt__VideoOutput *)soap_push_block_max(soap, soap_blist_VideoOutputs, sizeof(struct tt__VideoOutput));
					if (a->VideoOutputs == NULL)
						return NULL;
					soap_default_tt__VideoOutput(soap, a->VideoOutputs);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoOutput(soap, "tmd:VideoOutputs", a->VideoOutputs, "tt:VideoOutput"))
				{	a->__sizeVideoOutputs++;
					a->VideoOutputs = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeVideoOutputs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->VideoOutputs)
			soap_pop_block(soap, soap_blist_VideoOutputs);
		if (a->__sizeVideoOutputs)
		{	a->VideoOutputs = (struct tt__VideoOutput *)soap_save_block(soap, soap_blist_VideoOutputs, NULL, 1);
		}
		else
		{	a->VideoOutputs = NULL;
			if (soap_blist_VideoOutputs)
				soap_end_block(soap, soap_blist_VideoOutputs);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoOutputsResponse, SOAP_TYPE__tmd__GetVideoOutputsResponse, sizeof(struct _tmd__GetVideoOutputsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetVideoOutputsResponse * SOAP_FMAC4 soap_new__tmd__GetVideoOutputsResponse(struct soap *soap, int n)
{
	struct _tmd__GetVideoOutputsResponse *p;
	struct _tmd__GetVideoOutputsResponse *a = (struct _tmd__GetVideoOutputsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetVideoOutputsResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetVideoOutputsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetVideoOutputsResponse(struct soap *soap, const struct _tmd__GetVideoOutputsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetVideoOutputsResponse(soap, tag ? tag : "tmd:GetVideoOutputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputsResponse * SOAP_FMAC4 soap_get__tmd__GetVideoOutputsResponse(struct soap *soap, struct _tmd__GetVideoOutputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetVideoOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetVideoOutputs(struct soap *soap, struct _tmd__GetVideoOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetVideoOutputs(struct soap *soap, const struct _tmd__GetVideoOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetVideoOutputs(struct soap *soap, const char *tag, int id, const struct _tmd__GetVideoOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetVideoOutputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputs * SOAP_FMAC4 soap_in__tmd__GetVideoOutputs(struct soap *soap, const char *tag, struct _tmd__GetVideoOutputs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetVideoOutputs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetVideoOutputs, sizeof(struct _tmd__GetVideoOutputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetVideoOutputs(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetVideoOutputs, SOAP_TYPE__tmd__GetVideoOutputs, sizeof(struct _tmd__GetVideoOutputs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetVideoOutputs * SOAP_FMAC4 soap_new__tmd__GetVideoOutputs(struct soap *soap, int n)
{
	struct _tmd__GetVideoOutputs *p;
	struct _tmd__GetVideoOutputs *a = (struct _tmd__GetVideoOutputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetVideoOutputs));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetVideoOutputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetVideoOutputs(struct soap *soap, const struct _tmd__GetVideoOutputs *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetVideoOutputs(soap, tag ? tag : "tmd:GetVideoOutputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputs * SOAP_FMAC4 soap_get__tmd__GetVideoOutputs(struct soap *soap, struct _tmd__GetVideoOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetVideoOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetRelayOutputOptionsResponse(struct soap *soap, struct _tmd__GetRelayOutputOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRelayOutputOptions = 0;
	a->RelayOutputOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetRelayOutputOptionsResponse(struct soap *soap, const struct _tmd__GetRelayOutputOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RelayOutputOptions)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelayOutputOptions; i++)
		{
			soap_embedded(soap, a->RelayOutputOptions + i, SOAP_TYPE_tmd__RelayOutputOptions);
			soap_serialize_tmd__RelayOutputOptions(soap, a->RelayOutputOptions + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetRelayOutputOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetRelayOutputOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetRelayOutputOptionsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeRelayOutputOptions");
	if (a->RelayOutputOptions)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelayOutputOptions; i++)
			if (soap_out_tmd__RelayOutputOptions(soap, "tmd:RelayOutputOptions", -1, a->RelayOutputOptions + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetRelayOutputOptionsResponse * SOAP_FMAC4 soap_in__tmd__GetRelayOutputOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetRelayOutputOptionsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_RelayOutputOptions = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetRelayOutputOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetRelayOutputOptionsResponse, sizeof(struct _tmd__GetRelayOutputOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetRelayOutputOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:RelayOutputOptions", 1, NULL))
			{	if (a->RelayOutputOptions == NULL)
				{	if (soap_blist_RelayOutputOptions == NULL)
						soap_blist_RelayOutputOptions = soap_alloc_block(soap);
					a->RelayOutputOptions = (struct tmd__RelayOutputOptions *)soap_push_block_max(soap, soap_blist_RelayOutputOptions, sizeof(struct tmd__RelayOutputOptions));
					if (a->RelayOutputOptions == NULL)
						return NULL;
					soap_default_tmd__RelayOutputOptions(soap, a->RelayOutputOptions);
				}
				soap_revert(soap);
				if (soap_in_tmd__RelayOutputOptions(soap, "tmd:RelayOutputOptions", a->RelayOutputOptions, "tmd:RelayOutputOptions"))
				{	a->__sizeRelayOutputOptions++;
					a->RelayOutputOptions = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRelayOutputOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RelayOutputOptions)
			soap_pop_block(soap, soap_blist_RelayOutputOptions);
		if (a->__sizeRelayOutputOptions)
		{	a->RelayOutputOptions = (struct tmd__RelayOutputOptions *)soap_save_block(soap, soap_blist_RelayOutputOptions, NULL, 1);
		}
		else
		{	a->RelayOutputOptions = NULL;
			if (soap_blist_RelayOutputOptions)
				soap_end_block(soap, soap_blist_RelayOutputOptions);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetRelayOutputOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetRelayOutputOptionsResponse, SOAP_TYPE__tmd__GetRelayOutputOptionsResponse, sizeof(struct _tmd__GetRelayOutputOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetRelayOutputOptionsResponse * SOAP_FMAC4 soap_new__tmd__GetRelayOutputOptionsResponse(struct soap *soap, int n)
{
	struct _tmd__GetRelayOutputOptionsResponse *p;
	struct _tmd__GetRelayOutputOptionsResponse *a = (struct _tmd__GetRelayOutputOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetRelayOutputOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetRelayOutputOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetRelayOutputOptionsResponse(struct soap *soap, const struct _tmd__GetRelayOutputOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetRelayOutputOptionsResponse(soap, tag ? tag : "tmd:GetRelayOutputOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetRelayOutputOptionsResponse * SOAP_FMAC4 soap_get__tmd__GetRelayOutputOptionsResponse(struct soap *soap, struct _tmd__GetRelayOutputOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetRelayOutputOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetRelayOutputOptions(struct soap *soap, struct _tmd__GetRelayOutputOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->RelayOutputToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetRelayOutputOptions(struct soap *soap, const struct _tmd__GetRelayOutputOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->RelayOutputToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetRelayOutputOptions(struct soap *soap, const char *tag, int id, const struct _tmd__GetRelayOutputOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetRelayOutputOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tmd:RelayOutputToken", -1, (char*const*)&a->RelayOutputToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetRelayOutputOptions * SOAP_FMAC4 soap_in__tmd__GetRelayOutputOptions(struct soap *soap, const char *tag, struct _tmd__GetRelayOutputOptions *a, const char *type)
{
	size_t soap_flag_RelayOutputToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetRelayOutputOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetRelayOutputOptions, sizeof(struct _tmd__GetRelayOutputOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetRelayOutputOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:RelayOutputToken", (char**)&a->RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetRelayOutputOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetRelayOutputOptions, SOAP_TYPE__tmd__GetRelayOutputOptions, sizeof(struct _tmd__GetRelayOutputOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetRelayOutputOptions * SOAP_FMAC4 soap_new__tmd__GetRelayOutputOptions(struct soap *soap, int n)
{
	struct _tmd__GetRelayOutputOptions *p;
	struct _tmd__GetRelayOutputOptions *a = (struct _tmd__GetRelayOutputOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetRelayOutputOptions));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetRelayOutputOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetRelayOutputOptions(struct soap *soap, const struct _tmd__GetRelayOutputOptions *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetRelayOutputOptions(soap, tag ? tag : "tmd:GetRelayOutputOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetRelayOutputOptions * SOAP_FMAC4 soap_get__tmd__GetRelayOutputOptions(struct soap *soap, struct _tmd__GetRelayOutputOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetRelayOutputOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetServiceCapabilitiesResponse(struct soap *soap, struct _tmd__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tmd__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotmd__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tmd:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tmd:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotmd__Capabilities(soap, "tmd:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tmd__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tmd__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetServiceCapabilitiesResponse, sizeof(struct _tmd__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotmd__Capabilities(soap, "tmd:Capabilities", &a->Capabilities, "tmd:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tmd:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetServiceCapabilitiesResponse, SOAP_TYPE__tmd__GetServiceCapabilitiesResponse, sizeof(struct _tmd__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tmd__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tmd__GetServiceCapabilitiesResponse *p;
	struct _tmd__GetServiceCapabilitiesResponse *a = (struct _tmd__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tmd__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetServiceCapabilitiesResponse(soap, tag ? tag : "tmd:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tmd__GetServiceCapabilitiesResponse(struct soap *soap, struct _tmd__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetServiceCapabilities(struct soap *soap, struct _tmd__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetServiceCapabilities(struct soap *soap, const struct _tmd__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tmd__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetServiceCapabilities * SOAP_FMAC4 soap_in__tmd__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tmd__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetServiceCapabilities, sizeof(struct _tmd__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetServiceCapabilities, SOAP_TYPE__tmd__GetServiceCapabilities, sizeof(struct _tmd__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetServiceCapabilities * SOAP_FMAC4 soap_new__tmd__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tmd__GetServiceCapabilities *p;
	struct _tmd__GetServiceCapabilities *a = (struct _tmd__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetServiceCapabilities(struct soap *soap, const struct _tmd__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetServiceCapabilities(soap, tag ? tag : "tmd:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetServiceCapabilities * SOAP_FMAC4 soap_get__tmd__GetServiceCapabilities(struct soap *soap, struct _tmd__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FloatItems(struct soap *soap, struct tt__FloatItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeItems = 0;
	a->Items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatItems(struct soap *soap, const struct tt__FloatItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
		{
			soap_embedded(soap, a->Items + i, SOAP_TYPE_float);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatItems(struct soap *soap, const char *tag, int id, const struct tt__FloatItems *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatItems), type))
		return soap->error;
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
			if (soap_out_float(soap, "tt:Items", -1, a->Items + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FloatItems * SOAP_FMAC4 soap_in_tt__FloatItems(struct soap *soap, const char *tag, struct tt__FloatItems *a, const char *type)
{
	struct soap_blist *soap_blist_Items = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FloatItems*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatItems, sizeof(struct tt__FloatItems), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FloatItems(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Items", 1, NULL))
			{	if (a->Items == NULL)
				{	if (soap_blist_Items == NULL)
						soap_blist_Items = soap_alloc_block(soap);
					a->Items = (float *)soap_push_block_max(soap, soap_blist_Items, sizeof(float));
					if (a->Items == NULL)
						return NULL;
					soap_default_float(soap, a->Items);
				}
				soap_revert(soap);
				if (soap_in_float(soap, "tt:Items", a->Items, "xsd:float"))
				{	a->__sizeItems++;
					a->Items = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Items)
			soap_pop_block(soap, soap_blist_Items);
		if (a->__sizeItems)
		{	a->Items = (float *)soap_save_block(soap, soap_blist_Items, NULL, 1);
		}
		else
		{	a->Items = NULL;
			if (soap_blist_Items)
				soap_end_block(soap, soap_blist_Items);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FloatItems *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatItems, SOAP_TYPE_tt__FloatItems, sizeof(struct tt__FloatItems), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FloatItems * SOAP_FMAC4 soap_new_tt__FloatItems(struct soap *soap, int n)
{
	struct tt__FloatItems *p;
	struct tt__FloatItems *a = (struct tt__FloatItems*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FloatItems));
	for (p = a; p && n--; p++)
		soap_default_tt__FloatItems(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatItems(struct soap *soap, const struct tt__FloatItems *a, const char *tag, const char *type)
{
	if (soap_out_tt__FloatItems(soap, tag ? tag : "tt:FloatItems", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatItems * SOAP_FMAC4 soap_get_tt__FloatItems(struct soap *soap, struct tt__FloatItems *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tmd__ParityBitList(struct soap *soap, struct tmd__ParityBitList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeItems = 0;
	a->Items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__ParityBitList(struct soap *soap, const struct tmd__ParityBitList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
		{
			soap_embedded(soap, a->Items + i, SOAP_TYPE_tmd__ParityBit);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__ParityBitList(struct soap *soap, const char *tag, int id, const struct tmd__ParityBitList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__ParityBitList), type))
		return soap->error;
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
			if (soap_out_tmd__ParityBit(soap, "tmd:Items", -1, a->Items + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tmd__ParityBitList * SOAP_FMAC4 soap_in_tmd__ParityBitList(struct soap *soap, const char *tag, struct tmd__ParityBitList *a, const char *type)
{
	struct soap_blist *soap_blist_Items = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tmd__ParityBitList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__ParityBitList, sizeof(struct tmd__ParityBitList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tmd__ParityBitList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:Items", 1, NULL))
			{	if (a->Items == NULL)
				{	if (soap_blist_Items == NULL)
						soap_blist_Items = soap_alloc_block(soap);
					a->Items = (enum tmd__ParityBit *)soap_push_block_max(soap, soap_blist_Items, sizeof(enum tmd__ParityBit));
					if (a->Items == NULL)
						return NULL;
					soap_default_tmd__ParityBit(soap, a->Items);
				}
				soap_revert(soap);
				if (soap_in_tmd__ParityBit(soap, "tmd:Items", a->Items, "tmd:ParityBit"))
				{	a->__sizeItems++;
					a->Items = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Items)
			soap_pop_block(soap, soap_blist_Items);
		if (a->__sizeItems)
		{	a->Items = (enum tmd__ParityBit *)soap_save_block(soap, soap_blist_Items, NULL, 1);
		}
		else
		{	a->Items = NULL;
			if (soap_blist_Items)
				soap_end_block(soap, soap_blist_Items);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tmd__ParityBitList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__ParityBitList, SOAP_TYPE_tmd__ParityBitList, sizeof(struct tmd__ParityBitList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tmd__ParityBitList * SOAP_FMAC4 soap_new_tmd__ParityBitList(struct soap *soap, int n)
{
	struct tmd__ParityBitList *p;
	struct tmd__ParityBitList *a = (struct tmd__ParityBitList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tmd__ParityBitList));
	for (p = a; p && n--; p++)
		soap_default_tmd__ParityBitList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__ParityBitList(struct soap *soap, const struct tmd__ParityBitList *a, const char *tag, const char *type)
{
	if (soap_out_tmd__ParityBitList(soap, tag ? tag : "tmd:ParityBitList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__ParityBitList * SOAP_FMAC4 soap_get_tmd__ParityBitList(struct soap *soap, struct tmd__ParityBitList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__ParityBitList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntItems(struct soap *soap, struct tt__IntItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeItems = 0;
	a->Items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntItems(struct soap *soap, const struct tt__IntItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
		{
			soap_embedded(soap, a->Items + i, SOAP_TYPE_int);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntItems(struct soap *soap, const char *tag, int id, const struct tt__IntItems *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntItems), type))
		return soap->error;
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
			if (soap_out_int(soap, "tt:Items", -1, a->Items + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntItems * SOAP_FMAC4 soap_in_tt__IntItems(struct soap *soap, const char *tag, struct tt__IntItems *a, const char *type)
{
	struct soap_blist *soap_blist_Items = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__IntItems*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntItems, sizeof(struct tt__IntItems), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntItems(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Items", 1, NULL))
			{	if (a->Items == NULL)
				{	if (soap_blist_Items == NULL)
						soap_blist_Items = soap_alloc_block(soap);
					a->Items = (int *)soap_push_block_max(soap, soap_blist_Items, sizeof(int));
					if (a->Items == NULL)
						return NULL;
					soap_default_int(soap, a->Items);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "tt:Items", a->Items, "xsd:int"))
				{	a->__sizeItems++;
					a->Items = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Items)
			soap_pop_block(soap, soap_blist_Items);
		if (a->__sizeItems)
		{	a->Items = (int *)soap_save_block(soap, soap_blist_Items, NULL, 1);
		}
		else
		{	a->Items = NULL;
			if (soap_blist_Items)
				soap_end_block(soap, soap_blist_Items);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IntItems *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntItems, SOAP_TYPE_tt__IntItems, sizeof(struct tt__IntItems), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IntItems * SOAP_FMAC4 soap_new_tt__IntItems(struct soap *soap, int n)
{
	struct tt__IntItems *p;
	struct tt__IntItems *a = (struct tt__IntItems*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IntItems));
	for (p = a; p && n--; p++)
		soap_default_tt__IntItems(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntItems(struct soap *soap, const struct tt__IntItems *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntItems(soap, tag ? tag : "tt:IntItems", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntItems * SOAP_FMAC4 soap_get_tt__IntItems(struct soap *soap, struct tt__IntItems *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tmd__SerialPortConfigurationOptions(struct soap *soap, struct tmd__SerialPortConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BaudRateList = NULL;
	a->ParityBitList = NULL;
	a->CharacterLengthList = NULL;
	a->StopBitList = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__SerialPortConfigurationOptions(struct soap *soap, const struct tmd__SerialPortConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntItems(soap, &a->BaudRateList);
	soap_serialize_PointerTotmd__ParityBitList(soap, &a->ParityBitList);
	soap_serialize_PointerTott__IntItems(soap, &a->CharacterLengthList);
	soap_serialize_PointerTott__FloatItems(soap, &a->StopBitList);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__SerialPortConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tmd__SerialPortConfigurationOptions *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__SerialPortConfigurationOptions), type))
		return soap->error;
	if (!a->BaudRateList)
	{	if (soap_element_empty(soap, "tmd:BaudRateList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntItems(soap, "tmd:BaudRateList", -1, &a->BaudRateList, ""))
		return soap->error;
	if (!a->ParityBitList)
	{	if (soap_element_empty(soap, "tmd:ParityBitList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotmd__ParityBitList(soap, "tmd:ParityBitList", -1, &a->ParityBitList, ""))
		return soap->error;
	if (!a->CharacterLengthList)
	{	if (soap_element_empty(soap, "tmd:CharacterLengthList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntItems(soap, "tmd:CharacterLengthList", -1, &a->CharacterLengthList, ""))
		return soap->error;
	if (!a->StopBitList)
	{	if (soap_element_empty(soap, "tmd:StopBitList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatItems(soap, "tmd:StopBitList", -1, &a->StopBitList, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tmd__SerialPortConfigurationOptions * SOAP_FMAC4 soap_in_tmd__SerialPortConfigurationOptions(struct soap *soap, const char *tag, struct tmd__SerialPortConfigurationOptions *a, const char *type)
{
	size_t soap_flag_BaudRateList = 1;
	size_t soap_flag_ParityBitList = 1;
	size_t soap_flag_CharacterLengthList = 1;
	size_t soap_flag_StopBitList = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tmd__SerialPortConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__SerialPortConfigurationOptions, sizeof(struct tmd__SerialPortConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tmd__SerialPortConfigurationOptions(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BaudRateList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntItems(soap, "tmd:BaudRateList", &a->BaudRateList, "tt:IntItems"))
				{	soap_flag_BaudRateList--;
					continue;
				}
			}
			if (soap_flag_ParityBitList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotmd__ParityBitList(soap, "tmd:ParityBitList", &a->ParityBitList, "tmd:ParityBitList"))
				{	soap_flag_ParityBitList--;
					continue;
				}
			}
			if (soap_flag_CharacterLengthList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntItems(soap, "tmd:CharacterLengthList", &a->CharacterLengthList, "tt:IntItems"))
				{	soap_flag_CharacterLengthList--;
					continue;
				}
			}
			if (soap_flag_StopBitList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatItems(soap, "tmd:StopBitList", &a->StopBitList, "tt:FloatItems"))
				{	soap_flag_StopBitList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->BaudRateList || !a->ParityBitList || !a->CharacterLengthList || !a->StopBitList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tmd__SerialPortConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__SerialPortConfigurationOptions, SOAP_TYPE_tmd__SerialPortConfigurationOptions, sizeof(struct tmd__SerialPortConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tmd__SerialPortConfigurationOptions * SOAP_FMAC4 soap_new_tmd__SerialPortConfigurationOptions(struct soap *soap, int n)
{
	struct tmd__SerialPortConfigurationOptions *p;
	struct tmd__SerialPortConfigurationOptions *a = (struct tmd__SerialPortConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tmd__SerialPortConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tmd__SerialPortConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__SerialPortConfigurationOptions(struct soap *soap, const struct tmd__SerialPortConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tmd__SerialPortConfigurationOptions(soap, tag ? tag : "tmd:SerialPortConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__SerialPortConfigurationOptions * SOAP_FMAC4 soap_get_tmd__SerialPortConfigurationOptions(struct soap *soap, struct tmd__SerialPortConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__SerialPortConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tmd__SerialPortConfiguration(struct soap *soap, struct tmd__SerialPortConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->BaudRate);
	soap_default_tmd__ParityBit(soap, &a->ParityBit);
	soap_default_int(soap, &a->CharacterLength);
	soap_default_float(soap, &a->StopBit);
	a->__size = 0;
	a->__any = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tmd__SerialPortType(soap, &a->type);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__SerialPortConfiguration(struct soap *soap, const struct tmd__SerialPortConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->BaudRate, SOAP_TYPE_int);
	soap_embedded(soap, &a->ParityBit, SOAP_TYPE_tmd__ParityBit);
	soap_embedded(soap, &a->CharacterLength, SOAP_TYPE_int);
	soap_embedded(soap, &a->StopBit, SOAP_TYPE_float);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__SerialPortConfiguration(struct soap *soap, const char *tag, int id, const struct tmd__SerialPortConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	soap_set_attr(soap, "type", soap_tmd__SerialPortType2s(soap, a->type), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__SerialPortConfiguration), type))
		return soap->error;
	if (soap_out_int(soap, "tmd:BaudRate", -1, &a->BaudRate, ""))
		return soap->error;
	if (soap_out_tmd__ParityBit(soap, "tmd:ParityBit", -1, &a->ParityBit, ""))
		return soap->error;
	if (soap_out_int(soap, "tmd:CharacterLength", -1, &a->CharacterLength, ""))
		return soap->error;
	if (soap_out_float(soap, "tmd:StopBit", -1, &a->StopBit, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tmd__SerialPortConfiguration * SOAP_FMAC4 soap_in_tmd__SerialPortConfiguration(struct soap *soap, const char *tag, struct tmd__SerialPortConfiguration *a, const char *type)
{
	size_t soap_flag_BaudRate = 1;
	size_t soap_flag_ParityBit = 1;
	size_t soap_flag_CharacterLength = 1;
	size_t soap_flag_StopBit = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tmd__SerialPortConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__SerialPortConfiguration, sizeof(struct tmd__SerialPortConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tmd__SerialPortConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap_s2tmd__SerialPortType(soap, soap_attr_value(soap, "type", 5, 1), &a->type))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BaudRate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tmd:BaudRate", &a->BaudRate, "xsd:int"))
				{	soap_flag_BaudRate--;
					continue;
				}
			}
			if (soap_flag_ParityBit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tmd__ParityBit(soap, "tmd:ParityBit", &a->ParityBit, "tmd:ParityBit"))
				{	soap_flag_ParityBit--;
					continue;
				}
			}
			if (soap_flag_CharacterLength && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tmd:CharacterLength", &a->CharacterLength, "xsd:int"))
				{	soap_flag_CharacterLength--;
					continue;
				}
			}
			if (soap_flag_StopBit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tmd:StopBit", &a->StopBit, "xsd:float"))
				{	soap_flag_StopBit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BaudRate > 0 || soap_flag_ParityBit > 0 || soap_flag_CharacterLength > 0 || soap_flag_StopBit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tmd__SerialPortConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__SerialPortConfiguration, SOAP_TYPE_tmd__SerialPortConfiguration, sizeof(struct tmd__SerialPortConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tmd__SerialPortConfiguration * SOAP_FMAC4 soap_new_tmd__SerialPortConfiguration(struct soap *soap, int n)
{
	struct tmd__SerialPortConfiguration *p;
	struct tmd__SerialPortConfiguration *a = (struct tmd__SerialPortConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tmd__SerialPortConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tmd__SerialPortConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__SerialPortConfiguration(struct soap *soap, const struct tmd__SerialPortConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tmd__SerialPortConfiguration(soap, tag ? tag : "tmd:SerialPortConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__SerialPortConfiguration * SOAP_FMAC4 soap_get_tmd__SerialPortConfiguration(struct soap *soap, struct tmd__SerialPortConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__SerialPortConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tmd__SerialData(struct soap *soap, struct tmd__SerialData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_SerialData = 0;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__SerialData(struct soap *soap, const struct tmd__SerialData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tmd__union_SerialData(soap, a->__union_SerialData, &a->union_SerialData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__SerialData(struct soap *soap, const char *tag, int id, const struct tmd__SerialData *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__SerialData), type))
		return soap->error;
	if (soap_out__tmd__union_SerialData(soap, a->__union_SerialData, &a->union_SerialData))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tmd__SerialData * SOAP_FMAC4 soap_in_tmd__SerialData(struct soap *soap, const char *tag, struct tmd__SerialData *a, const char *type)
{
	size_t soap_flag_union_SerialData = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tmd__SerialData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__SerialData, sizeof(struct tmd__SerialData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tmd__SerialData(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_SerialData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__tmd__union_SerialData(soap, &a->__union_SerialData, &a->union_SerialData))
				{	soap_flag_union_SerialData = 0;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tmd__SerialData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__SerialData, SOAP_TYPE_tmd__SerialData, sizeof(struct tmd__SerialData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tmd__SerialData * SOAP_FMAC4 soap_new_tmd__SerialData(struct soap *soap, int n)
{
	struct tmd__SerialData *p;
	struct tmd__SerialData *a = (struct tmd__SerialData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tmd__SerialData));
	for (p = a; p && n--; p++)
		soap_default_tmd__SerialData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__SerialData(struct soap *soap, const struct tmd__SerialData *a, const char *tag, const char *type)
{
	if (soap_out_tmd__SerialData(soap, tag ? tag : "tmd:SerialData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__SerialData * SOAP_FMAC4 soap_get_tmd__SerialData(struct soap *soap, struct tmd__SerialData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__SerialData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tmd__DigitalInputConfigurationOptions(struct soap *soap, struct tmd__DigitalInputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIdleState = 0;
	a->IdleState = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__DigitalInputConfigurationOptions(struct soap *soap, const struct tmd__DigitalInputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->IdleState)
	{	int i;
		for (i = 0; i < (int)a->__sizeIdleState; i++)
		{
			soap_embedded(soap, a->IdleState + i, SOAP_TYPE_tt__DigitalIdleState);
		}
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__DigitalInputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tmd__DigitalInputConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__DigitalInputConfigurationOptions), type))
		return soap->error;
	if (a->IdleState)
	{	int i;
		for (i = 0; i < (int)a->__sizeIdleState; i++)
			if (soap_out_tt__DigitalIdleState(soap, "tmd:IdleState", -1, a->IdleState + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tmd__DigitalInputConfigurationOptions * SOAP_FMAC4 soap_in_tmd__DigitalInputConfigurationOptions(struct soap *soap, const char *tag, struct tmd__DigitalInputConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_IdleState = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tmd__DigitalInputConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__DigitalInputConfigurationOptions, sizeof(struct tmd__DigitalInputConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tmd__DigitalInputConfigurationOptions(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:IdleState", 1, NULL))
			{	if (a->IdleState == NULL)
				{	if (soap_blist_IdleState == NULL)
						soap_blist_IdleState = soap_alloc_block(soap);
					a->IdleState = (enum tt__DigitalIdleState *)soap_push_block_max(soap, soap_blist_IdleState, sizeof(enum tt__DigitalIdleState));
					if (a->IdleState == NULL)
						return NULL;
					soap_default_tt__DigitalIdleState(soap, a->IdleState);
				}
				soap_revert(soap);
				if (soap_in_tt__DigitalIdleState(soap, "tmd:IdleState", a->IdleState, "tt:DigitalIdleState"))
				{	a->__sizeIdleState++;
					a->IdleState = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IdleState)
			soap_pop_block(soap, soap_blist_IdleState);
		if (a->__sizeIdleState)
		{	a->IdleState = (enum tt__DigitalIdleState *)soap_save_block(soap, soap_blist_IdleState, NULL, 1);
		}
		else
		{	a->IdleState = NULL;
			if (soap_blist_IdleState)
				soap_end_block(soap, soap_blist_IdleState);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeIdleState < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tmd__DigitalInputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__DigitalInputConfigurationOptions, SOAP_TYPE_tmd__DigitalInputConfigurationOptions, sizeof(struct tmd__DigitalInputConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tmd__DigitalInputConfigurationOptions * SOAP_FMAC4 soap_new_tmd__DigitalInputConfigurationOptions(struct soap *soap, int n)
{
	struct tmd__DigitalInputConfigurationOptions *p;
	struct tmd__DigitalInputConfigurationOptions *a = (struct tmd__DigitalInputConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tmd__DigitalInputConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tmd__DigitalInputConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__DigitalInputConfigurationOptions(struct soap *soap, const struct tmd__DigitalInputConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tmd__DigitalInputConfigurationOptions(soap, tag ? tag : "tmd:DigitalInputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__DigitalInputConfigurationOptions * SOAP_FMAC4 soap_get_tmd__DigitalInputConfigurationOptions(struct soap *soap, struct tmd__DigitalInputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__DigitalInputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tmd__GetResponse(struct soap *soap, struct tmd__GetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeToken = 0;
	a->Token = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__GetResponse(struct soap *soap, const struct tmd__GetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__GetResponse(struct soap *soap, const char *tag, int id, const struct tmd__GetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__GetResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeToken");
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			if (soap_out_string(soap, "tmd:Token", -1, (char*const*)(a->Token + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tmd__GetResponse * SOAP_FMAC4 soap_in_tmd__GetResponse(struct soap *soap, const char *tag, struct tmd__GetResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Token = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tmd__GetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__GetResponse, sizeof(struct tmd__GetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tmd__GetResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tmd:Token", (char**)a->Token, "tt:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tmd__GetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__GetResponse, SOAP_TYPE_tmd__GetResponse, sizeof(struct tmd__GetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tmd__GetResponse * SOAP_FMAC4 soap_new_tmd__GetResponse(struct soap *soap, int n)
{
	struct tmd__GetResponse *p;
	struct tmd__GetResponse *a = (struct tmd__GetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tmd__GetResponse));
	for (p = a; p && n--; p++)
		soap_default_tmd__GetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__GetResponse(struct soap *soap, const struct tmd__GetResponse *a, const char *tag, const char *type)
{
	if (soap_out_tmd__GetResponse(soap, tag ? tag : "tmd:GetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__GetResponse * SOAP_FMAC4 soap_get_tmd__GetResponse(struct soap *soap, struct tmd__GetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__GetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tmd__Get(struct soap *soap, struct tmd__Get *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__Get(struct soap *soap, const struct tmd__Get *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__Get(struct soap *soap, const char *tag, int id, const struct tmd__Get *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__Get), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tmd__Get * SOAP_FMAC4 soap_in_tmd__Get(struct soap *soap, const char *tag, struct tmd__Get *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tmd__Get*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__Get, sizeof(struct tmd__Get), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tmd__Get(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tmd__Get *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__Get, SOAP_TYPE_tmd__Get, sizeof(struct tmd__Get), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tmd__Get * SOAP_FMAC4 soap_new_tmd__Get(struct soap *soap, int n)
{
	struct tmd__Get *p;
	struct tmd__Get *a = (struct tmd__Get*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tmd__Get));
	for (p = a; p && n--; p++)
		soap_default_tmd__Get(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__Get(struct soap *soap, const struct tmd__Get *a, const char *tag, const char *type)
{
	if (soap_out_tmd__Get(soap, tag ? tag : "tmd:Get", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__Get * SOAP_FMAC4 soap_get_tmd__Get(struct soap *soap, struct tmd__Get *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__Get(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tmd__RelayOutputOptionsExtension(struct soap *soap, struct tmd__RelayOutputOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__RelayOutputOptionsExtension(struct soap *soap, const struct tmd__RelayOutputOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__RelayOutputOptionsExtension(struct soap *soap, const char *tag, int id, const struct tmd__RelayOutputOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__RelayOutputOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tmd__RelayOutputOptionsExtension * SOAP_FMAC4 soap_in_tmd__RelayOutputOptionsExtension(struct soap *soap, const char *tag, struct tmd__RelayOutputOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tmd__RelayOutputOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__RelayOutputOptionsExtension, sizeof(struct tmd__RelayOutputOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tmd__RelayOutputOptionsExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tmd__RelayOutputOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__RelayOutputOptionsExtension, SOAP_TYPE_tmd__RelayOutputOptionsExtension, sizeof(struct tmd__RelayOutputOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tmd__RelayOutputOptionsExtension * SOAP_FMAC4 soap_new_tmd__RelayOutputOptionsExtension(struct soap *soap, int n)
{
	struct tmd__RelayOutputOptionsExtension *p;
	struct tmd__RelayOutputOptionsExtension *a = (struct tmd__RelayOutputOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tmd__RelayOutputOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tmd__RelayOutputOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__RelayOutputOptionsExtension(struct soap *soap, const struct tmd__RelayOutputOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tmd__RelayOutputOptionsExtension(soap, tag ? tag : "tmd:RelayOutputOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__RelayOutputOptionsExtension * SOAP_FMAC4 soap_get_tmd__RelayOutputOptionsExtension(struct soap *soap, struct tmd__RelayOutputOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__RelayOutputOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tmd__RelayOutputOptions(struct soap *soap, struct tmd__RelayOutputOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	soap_default_tmd__DelayTimes(soap, &a->DelayTimes);
	a->Discrete = NULL;
	a->Extension = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__RelayOutputOptions(struct soap *soap, const struct tmd__RelayOutputOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__RelayMode);
		}
	}
	soap_serialize_tmd__DelayTimes(soap, (char*const*)&a->DelayTimes);
	soap_serialize_PointerToxsd__boolean(soap, &a->Discrete);
	soap_serialize_PointerTotmd__RelayOutputOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__RelayOutputOptions(struct soap *soap, const char *tag, int id, const struct tmd__RelayOutputOptions *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__RelayOutputOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__RelayMode(soap, "tmd:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_tmd__DelayTimes(soap, "tmd:DelayTimes", -1, (char*const*)&a->DelayTimes, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tmd:Discrete", -1, &a->Discrete, ""))
		return soap->error;
	if (soap_out_PointerTotmd__RelayOutputOptionsExtension(soap, "tmd:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tmd__RelayOutputOptions * SOAP_FMAC4 soap_in_tmd__RelayOutputOptions(struct soap *soap, const char *tag, struct tmd__RelayOutputOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_DelayTimes = 1;
	size_t soap_flag_Discrete = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tmd__RelayOutputOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__RelayOutputOptions, sizeof(struct tmd__RelayOutputOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tmd__RelayOutputOptions(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__RelayMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__RelayMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__RelayMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__RelayMode(soap, "tmd:Mode", a->Mode, "tt:RelayMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_DelayTimes && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tmd__DelayTimes(soap, "tmd:DelayTimes", (char**)&a->DelayTimes, "tmd:DelayTimes"))
				{	soap_flag_DelayTimes--;
					continue;
				}
			}
			if (soap_flag_Discrete && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tmd:Discrete", &a->Discrete, "xsd:boolean"))
				{	soap_flag_Discrete--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotmd__RelayOutputOptionsExtension(soap, "tmd:Extension", &a->Extension, "tmd:RelayOutputOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__RelayMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tmd__RelayOutputOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__RelayOutputOptions, SOAP_TYPE_tmd__RelayOutputOptions, sizeof(struct tmd__RelayOutputOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tmd__RelayOutputOptions * SOAP_FMAC4 soap_new_tmd__RelayOutputOptions(struct soap *soap, int n)
{
	struct tmd__RelayOutputOptions *p;
	struct tmd__RelayOutputOptions *a = (struct tmd__RelayOutputOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tmd__RelayOutputOptions));
	for (p = a; p && n--; p++)
		soap_default_tmd__RelayOutputOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__RelayOutputOptions(struct soap *soap, const struct tmd__RelayOutputOptions *a, const char *tag, const char *type)
{
	if (soap_out_tmd__RelayOutputOptions(soap, tag ? tag : "tmd:RelayOutputOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__RelayOutputOptions * SOAP_FMAC4 soap_get_tmd__RelayOutputOptions(struct soap *soap, struct tmd__RelayOutputOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__RelayOutputOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tmd__Capabilities(struct soap *soap, struct tmd__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->VideoSources = 0;
	a->VideoOutputs = 0;
	a->AudioSources = 0;
	a->AudioOutputs = 0;
	a->RelayOutputs = 0;
	a->SerialPorts = 0;
	a->DigitalInputs = 0;
	a->DigitalInputOptions = (enum xsd__boolean)0;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__Capabilities(struct soap *soap, const struct tmd__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__Capabilities(struct soap *soap, const char *tag, int id, const struct tmd__Capabilities *a, const char *type)
{
	if (a->VideoSources != 0)
	{	soap_set_attr(soap, "VideoSources", soap_int2s(soap, a->VideoSources), 1);
	}
	if (a->VideoOutputs != 0)
	{	soap_set_attr(soap, "VideoOutputs", soap_int2s(soap, a->VideoOutputs), 1);
	}
	if (a->AudioSources != 0)
	{	soap_set_attr(soap, "AudioSources", soap_int2s(soap, a->AudioSources), 1);
	}
	if (a->AudioOutputs != 0)
	{	soap_set_attr(soap, "AudioOutputs", soap_int2s(soap, a->AudioOutputs), 1);
	}
	if (a->RelayOutputs != 0)
	{	soap_set_attr(soap, "RelayOutputs", soap_int2s(soap, a->RelayOutputs), 1);
	}
	if (a->SerialPorts != 0)
	{	soap_set_attr(soap, "SerialPorts", soap_int2s(soap, a->SerialPorts), 1);
	}
	if (a->DigitalInputs != 0)
	{	soap_set_attr(soap, "DigitalInputs", soap_int2s(soap, a->DigitalInputs), 1);
	}
	if (a->DigitalInputOptions != (enum xsd__boolean)0)
	{	soap_set_attr(soap, "DigitalInputOptions", soap_xsd__boolean2s(soap, a->DigitalInputOptions), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tmd__Capabilities * SOAP_FMAC4 soap_in_tmd__Capabilities(struct soap *soap, const char *tag, struct tmd__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tmd__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__Capabilities, sizeof(struct tmd__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tmd__Capabilities(soap, a);
	if (soap_s2int(soap, soap_attr_value(soap, "VideoSources", 5, 0), &a->VideoSources))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "VideoOutputs", 5, 0), &a->VideoOutputs))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "AudioSources", 5, 0), &a->AudioSources))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "AudioOutputs", 5, 0), &a->AudioOutputs))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "RelayOutputs", 5, 0), &a->RelayOutputs))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "SerialPorts", 5, 0), &a->SerialPorts))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "DigitalInputs", 5, 0), &a->DigitalInputs))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "DigitalInputOptions", 5, 0), &a->DigitalInputOptions))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tmd__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__Capabilities, SOAP_TYPE_tmd__Capabilities, sizeof(struct tmd__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tmd__Capabilities * SOAP_FMAC4 soap_new_tmd__Capabilities(struct soap *soap, int n)
{
	struct tmd__Capabilities *p;
	struct tmd__Capabilities *a = (struct tmd__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tmd__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tmd__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__Capabilities(struct soap *soap, const struct tmd__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tmd__Capabilities(soap, tag ? tag : "tmd:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__Capabilities * SOAP_FMAC4 soap_get_tmd__Capabilities(struct soap *soap, struct tmd__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11PSK(struct soap *soap, struct xsd__hexBinary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSK(struct soap *soap, const struct xsd__hexBinary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_tt__Dot11PSK);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11PSK2s(struct soap *soap, struct xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSK(struct soap *soap, const char *tag, int id, const struct xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_tt__Dot11PSK, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11PSK(struct soap *soap, const char *s, struct xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	if (a->__size < 32)
		return soap->error = SOAP_LENGTH;
	if (a->__size > 32)
		return soap->error = SOAP_LENGTH;
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_in_tt__Dot11PSK(struct soap *soap, const char *tag, struct xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__hexBinary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSK, sizeof(struct xsd__hexBinary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11PSK(soap, a);
	if (soap->body && *soap->href != '#')
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
		if (a->__size < 32)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
		if (a->__size > 32)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
	}
	else
	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSK, SOAP_TYPE_tt__Dot11PSK, sizeof(struct xsd__hexBinary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSK(struct soap *soap, const struct xsd__hexBinary *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11PSK(soap, tag ? tag : "tt:Dot11PSK", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_get_tt__Dot11PSK(struct soap *soap, struct xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11SSIDType(struct soap *soap, struct xsd__hexBinary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11SSIDType(struct soap *soap, const struct xsd__hexBinary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_tt__Dot11SSIDType);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11SSIDType2s(struct soap *soap, struct xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SSIDType(struct soap *soap, const char *tag, int id, const struct xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_tt__Dot11SSIDType, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11SSIDType(struct soap *soap, const char *s, struct xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	if (a->__size < 1)
		return soap->error = SOAP_LENGTH;
	if (a->__size > 32)
		return soap->error = SOAP_LENGTH;
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_in_tt__Dot11SSIDType(struct soap *soap, const char *tag, struct xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__hexBinary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SSIDType, sizeof(struct xsd__hexBinary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11SSIDType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
		if (a->__size < 1)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
		if (a->__size > 32)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
	}
	else
	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SSIDType, SOAP_TYPE_tt__Dot11SSIDType, sizeof(struct xsd__hexBinary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SSIDType(struct soap *soap, const struct xsd__hexBinary *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11SSIDType(soap, tag ? tag : "tt:Dot11SSIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_get_tt__Dot11SSIDType(struct soap *soap, struct xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SSIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__hexBinary(struct soap *soap, struct xsd__hexBinary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__hexBinary(struct soap *soap, const struct xsd__hexBinary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_xsd__hexBinary);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__hexBinary2s(struct soap *soap, struct xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const struct xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__hexBinary, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__hexBinary(struct soap *soap, const char *s, struct xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, struct xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__hexBinary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(struct xsd__hexBinary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__hexBinary(soap, a);
	if (soap->body && *soap->href != '#')
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, SOAP_TYPE_xsd__hexBinary, sizeof(struct xsd__hexBinary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_new_xsd__hexBinary(struct soap *soap, int n)
{
	struct xsd__hexBinary *p;
	struct xsd__hexBinary *a = (struct xsd__hexBinary*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xsd__hexBinary));
	for (p = a; p && n--; p++)
		soap_default_xsd__hexBinary(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__hexBinary(struct soap *soap, const struct xsd__hexBinary *a, const char *tag, const char *type)
{
	if (soap_out_xsd__hexBinary(soap, tag ? tag : "xsd:hexBinary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, struct xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_attachment_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_xsd__base64Binary, a->id, a->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, struct xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const struct xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, struct xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__base64Binary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__base64Binary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_new_xsd__base64Binary(struct soap *soap, int n)
{
	struct xsd__base64Binary *p;
	struct xsd__base64Binary *a = (struct xsd__base64Binary*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xsd__base64Binary));
	for (p = a; p && n--; p++)
		soap_default_xsd__base64Binary(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a, const char *tag, const char *type)
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SOAP_ENV__Header = NULL;
	a->SOAP_ENV__Body = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSOAP_ENV__Header(soap, &a->SOAP_ENV__Header);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Envelope(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Envelope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Envelope), type))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", -1, &a->SOAP_ENV__Header, ""))
		return soap->error;
	if (soap_outliteral(soap, "SOAP-ENV:Body", (char*const*)&a->SOAP_ENV__Body, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_in_SOAP_ENV__Envelope(struct soap *soap, const char *tag, struct SOAP_ENV__Envelope *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Header = 1;
	size_t soap_flag_SOAP_ENV__Body = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Envelope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Envelope(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Header && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", &a->SOAP_ENV__Header, ""))
				{	soap_flag_SOAP_ENV__Header--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Body && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "SOAP-ENV:Body", (char**)&a->SOAP_ENV__Body))
				{	soap_flag_SOAP_ENV__Body--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Envelope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Envelope, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_new_SOAP_ENV__Envelope(struct soap *soap, int n)
{
	struct SOAP_ENV__Envelope *p;
	struct SOAP_ENV__Envelope *a = (struct SOAP_ENV__Envelope*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Envelope));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Envelope(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Envelope(soap, tag ? tag : "SOAP-ENV:Envelope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_get_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Envelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault_alex(struct soap *soap, struct SOAP_ENV__Fault_alex *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault_alex(struct soap *soap, const struct SOAP_ENV__Fault_alex *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault_alex(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault_alex *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault_alex), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault_alex * SOAP_FMAC4 soap_in_SOAP_ENV__Fault_alex(struct soap *soap, const char *tag, struct SOAP_ENV__Fault_alex *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault_alex*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault_alex, sizeof(struct SOAP_ENV__Fault_alex), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault_alex(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault_alex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault_alex, SOAP_TYPE_SOAP_ENV__Fault_alex, sizeof(struct SOAP_ENV__Fault_alex), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault_alex * SOAP_FMAC4 soap_new_SOAP_ENV__Fault_alex(struct soap *soap, int n)
{
	struct SOAP_ENV__Fault_alex *p;
	struct SOAP_ENV__Fault_alex *a = (struct SOAP_ENV__Fault_alex*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Fault_alex));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Fault_alex(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault_alex(struct soap *soap, const struct SOAP_ENV__Fault_alex *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault_alex(soap, tag ? tag : "SOAP-ENV:Fault-alex", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault_alex * SOAP_FMAC4 soap_get_SOAP_ENV__Fault_alex(struct soap *soap, struct SOAP_ENV__Fault_alex *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault_alex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
	a->wsa5__IsReferenceParameter = (enum _wsa5__IsReferenceParameter)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__item, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap *soap, const char *tag, int id, const struct chan__ChannelInstanceType *a, const char *type)
{
	if (a->wsa5__IsReferenceParameter != (enum _wsa5__IsReferenceParameter)0)
	{	soap_set_attr(soap, "wsa5:IsReferenceParameter", soap__wsa5__IsReferenceParameter2s(soap, a->wsa5__IsReferenceParameter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct chan__ChannelInstanceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_chan__ChannelInstanceType(soap, a);
	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_attr_value(soap, "wsa5:IsReferenceParameter", 5, 0), &a->wsa5__IsReferenceParameter))
		return NULL;
	if (!soap_in_int(soap, tag, &a->__item, "chan:ChannelInstanceType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_new_chan__ChannelInstanceType(struct soap *soap, int n)
{
	struct chan__ChannelInstanceType *p;
	struct chan__ChannelInstanceType *a = (struct chan__ChannelInstanceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct chan__ChannelInstanceType));
	for (p = a; p && n--; p++)
		soap_default_chan__ChannelInstanceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a, const char *tag, const char *type)
{
	if (soap_out_chan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_chan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemAction(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemAction(soap, tag ? tag : "wsa5:ProblemAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__FaultTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__From(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReplyTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RelatesTo(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Metadata(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Metadata(soap, tag ? tag : "wsa5:Metadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReferenceParameters(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReferenceParameters(soap, tag ? tag : "wsa5:ReferenceParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__EndpointReference(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__EndpointReference(soap, tag ? tag : "wsa5:EndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Action);
	soap_serialize_string(soap, (char*const*)&a->SoapAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, (char*const*)&a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, (char*const*)&a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ProblemActionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Action", (char**)&a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:SoapAction", (char**)&a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_new_wsa5__ProblemActionType(struct soap *soap, int n)
{
	struct wsa5__ProblemActionType *p;
	struct wsa5__ProblemActionType *a = (struct wsa5__ProblemActionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__ProblemActionType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__ProblemActionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ProblemActionType(soap, tag ? tag : "wsa5:ProblemActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_wsa5__RelationshipTypeOpenEnum2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2wsa5__RelationshipTypeOpenEnum(soap, soap_attr_value(soap, "RelationshipType", 1, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_new_wsa5__RelatesToType(struct soap *soap, int n)
{
	struct wsa5__RelatesToType *p;
	struct wsa5__RelatesToType *a = (struct wsa5__RelatesToType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__RelatesToType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__RelatesToType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelatesToType(soap, tag ? tag : "wsa5:RelatesToType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__MetadataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_new_wsa5__MetadataType(struct soap *soap, int n)
{
	struct wsa5__MetadataType *p;
	struct wsa5__MetadataType *a = (struct wsa5__MetadataType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__MetadataType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__MetadataType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->chan__ChannelInstance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "xsd:int"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_new_wsa5__ReferenceParametersType(struct soap *soap, int n)
{
	struct wsa5__ReferenceParametersType *p;
	struct wsa5__ReferenceParametersType *a = (struct wsa5__ReferenceParametersType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__ReferenceParametersType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__ReferenceParametersType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa5:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsa5:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_new_wsa5__EndpointReferenceType(struct soap *soap, int n)
{
	struct wsa5__EndpointReferenceType *p;
	struct wsa5__EndpointReferenceType *a = (struct wsa5__EndpointReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa5__EndpointReferenceType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__EndpointReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap *soap, struct _xop__Include *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap *soap, const struct _xop__Include *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_attachment_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE__xop__Include, a->id, a->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__xop__Include2s(struct soap *soap, struct _xop__Include a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap *soap, const char *tag, int id, const struct _xop__Include *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE__xop__Include);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE__xop__Include, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_xop__Include(struct soap *soap, const char *s, struct _xop__Include *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap *soap, const char *tag, struct _xop__Include *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct _xop__Include*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xop__Include(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xop__Include, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_new__xop__Include(struct soap *soap, int n)
{
	struct _xop__Include *p;
	struct _xop__Include *a = (struct _xop__Include*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _xop__Include));
	for (p = a; p && n--; p++)
		soap_default__xop__Include(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap *soap, const struct _xop__Include *a, const char *tag, const char *type)
{
	if (soap_out__xop__Include(soap, tag ? tag : "xop:Include", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap *soap, struct _xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in__xop__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__ResolveMatches = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__ResolveMatches(struct soap *soap, const struct __wsdd__ResolveMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ResolveMatchesType(soap, &a->wsdd__ResolveMatches);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__ResolveMatches(struct soap *soap, const char *tag, int id, const struct __wsdd__ResolveMatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ResolveMatchesType(soap, "wsdd:ResolveMatches", -1, &a->wsdd__ResolveMatches, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_in___wsdd__ResolveMatches(struct soap *soap, const char *tag, struct __wsdd__ResolveMatches *a, const char *type)
{
	size_t soap_flag_wsdd__ResolveMatches = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__ResolveMatches*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__ResolveMatches, sizeof(struct __wsdd__ResolveMatches), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__ResolveMatches(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__ResolveMatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ResolveMatchesType(soap, "wsdd:ResolveMatches", &a->wsdd__ResolveMatches, "wsdd:ResolveMatchesType"))
				{	soap_flag_wsdd__ResolveMatches--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_new___wsdd__ResolveMatches(struct soap *soap, int n)
{
	struct __wsdd__ResolveMatches *p;
	struct __wsdd__ResolveMatches *a = (struct __wsdd__ResolveMatches*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__ResolveMatches));
	for (p = a; p && n--; p++)
		soap_default___wsdd__ResolveMatches(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__ResolveMatches(struct soap *soap, const struct __wsdd__ResolveMatches *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__ResolveMatches(soap, tag ? tag : "-wsdd:ResolveMatches", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_get___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__ResolveMatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Resolve = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Resolve(struct soap *soap, const struct __wsdd__Resolve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ResolveType(soap, &a->wsdd__Resolve);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Resolve(struct soap *soap, const char *tag, int id, const struct __wsdd__Resolve *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ResolveType(soap, "wsdd:Resolve", -1, &a->wsdd__Resolve, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_in___wsdd__Resolve(struct soap *soap, const char *tag, struct __wsdd__Resolve *a, const char *type)
{
	size_t soap_flag_wsdd__Resolve = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Resolve*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Resolve, sizeof(struct __wsdd__Resolve), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Resolve(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Resolve && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ResolveType(soap, "wsdd:Resolve", &a->wsdd__Resolve, "wsdd:ResolveType"))
				{	soap_flag_wsdd__Resolve--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_new___wsdd__Resolve(struct soap *soap, int n)
{
	struct __wsdd__Resolve *p;
	struct __wsdd__Resolve *a = (struct __wsdd__Resolve*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__Resolve));
	for (p = a; p && n--; p++)
		soap_default___wsdd__Resolve(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Resolve(struct soap *soap, const struct __wsdd__Resolve *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Resolve(soap, tag ? tag : "-wsdd:Resolve", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_get___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Resolve(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__ProbeMatches = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__ProbeMatches(struct soap *soap, const struct __wsdd__ProbeMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ProbeMatchesType(soap, &a->wsdd__ProbeMatches);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__ProbeMatches(struct soap *soap, const char *tag, int id, const struct __wsdd__ProbeMatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ProbeMatchesType(soap, "wsdd:ProbeMatches", -1, &a->wsdd__ProbeMatches, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_in___wsdd__ProbeMatches(struct soap *soap, const char *tag, struct __wsdd__ProbeMatches *a, const char *type)
{
	size_t soap_flag_wsdd__ProbeMatches = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__ProbeMatches*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__ProbeMatches, sizeof(struct __wsdd__ProbeMatches), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__ProbeMatches(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__ProbeMatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ProbeMatchesType(soap, "wsdd:ProbeMatches", &a->wsdd__ProbeMatches, "wsdd:ProbeMatchesType"))
				{	soap_flag_wsdd__ProbeMatches--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_new___wsdd__ProbeMatches(struct soap *soap, int n)
{
	struct __wsdd__ProbeMatches *p;
	struct __wsdd__ProbeMatches *a = (struct __wsdd__ProbeMatches*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__ProbeMatches));
	for (p = a; p && n--; p++)
		soap_default___wsdd__ProbeMatches(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__ProbeMatches(struct soap *soap, const struct __wsdd__ProbeMatches *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__ProbeMatches(soap, tag ? tag : "-wsdd:ProbeMatches", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_get___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__ProbeMatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Probe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Probe(struct soap *soap, const struct __wsdd__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ProbeType(soap, &a->wsdd__Probe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Probe(struct soap *soap, const char *tag, int id, const struct __wsdd__Probe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ProbeType(soap, "wsdd:Probe", -1, &a->wsdd__Probe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_in___wsdd__Probe(struct soap *soap, const char *tag, struct __wsdd__Probe *a, const char *type)
{
	size_t soap_flag_wsdd__Probe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Probe*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Probe, sizeof(struct __wsdd__Probe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Probe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Probe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ProbeType(soap, "wsdd:Probe", &a->wsdd__Probe, "wsdd:ProbeType"))
				{	soap_flag_wsdd__Probe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_new___wsdd__Probe(struct soap *soap, int n)
{
	struct __wsdd__Probe *p;
	struct __wsdd__Probe *a = (struct __wsdd__Probe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__Probe));
	for (p = a; p && n--; p++)
		soap_default___wsdd__Probe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Probe(struct soap *soap, const struct __wsdd__Probe *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Probe(soap, tag ? tag : "-wsdd:Probe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_get___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Probe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Bye = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Bye(struct soap *soap, const struct __wsdd__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ByeType(soap, &a->wsdd__Bye);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Bye(struct soap *soap, const char *tag, int id, const struct __wsdd__Bye *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ByeType(soap, "wsdd:Bye", -1, &a->wsdd__Bye, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_in___wsdd__Bye(struct soap *soap, const char *tag, struct __wsdd__Bye *a, const char *type)
{
	size_t soap_flag_wsdd__Bye = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Bye*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Bye, sizeof(struct __wsdd__Bye), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Bye && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ByeType(soap, "wsdd:Bye", &a->wsdd__Bye, "wsdd:ByeType"))
				{	soap_flag_wsdd__Bye--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_new___wsdd__Bye(struct soap *soap, int n)
{
	struct __wsdd__Bye *p;
	struct __wsdd__Bye *a = (struct __wsdd__Bye*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__Bye));
	for (p = a; p && n--; p++)
		soap_default___wsdd__Bye(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Bye(struct soap *soap, const struct __wsdd__Bye *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Bye(soap, tag ? tag : "-wsdd:Bye", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_get___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Hello = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Hello(struct soap *soap, const struct __wsdd__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__HelloType(soap, &a->wsdd__Hello);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Hello(struct soap *soap, const char *tag, int id, const struct __wsdd__Hello *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__HelloType(soap, "wsdd:Hello", -1, &a->wsdd__Hello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_in___wsdd__Hello(struct soap *soap, const char *tag, struct __wsdd__Hello *a, const char *type)
{
	size_t soap_flag_wsdd__Hello = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Hello*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Hello, sizeof(struct __wsdd__Hello), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Hello(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Hello && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__HelloType(soap, "wsdd:Hello", &a->wsdd__Hello, "wsdd:HelloType"))
				{	soap_flag_wsdd__Hello--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_new___wsdd__Hello(struct soap *soap, int n)
{
	struct __wsdd__Hello *p;
	struct __wsdd__Hello *a = (struct __wsdd__Hello*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsdd__Hello));
	for (p = a; p && n--; p++)
		soap_default___wsdd__Hello(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Hello(struct soap *soap, const struct __wsdd__Hello *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Hello(soap, tag ? tag : "-wsdd:Hello", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_get___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Hello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__AppSequence(struct soap *soap, const struct wsdd__AppSequenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__AppSequence(soap, tag ? tag : "wsdd:AppSequence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Sig(struct soap *soap, const struct wsdd__SigType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Sig(soap, tag ? tag : "wsdd:Sig", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Security(struct soap *soap, const struct wsdd__SecurityType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Security(soap, tag ? tag : "wsdd:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Scopes(struct soap *soap, const struct wsdd__ScopesType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Scopes(soap, tag ? tag : "wsdd:Scopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__ResolveMatches(struct soap *soap, const struct wsdd__ResolveMatchesType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__ResolveMatches(soap, tag ? tag : "wsdd:ResolveMatches", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Resolve(struct soap *soap, const struct wsdd__ResolveType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Resolve(soap, tag ? tag : "wsdd:Resolve", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__ProbeMatches(struct soap *soap, const struct wsdd__ProbeMatchesType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__ProbeMatches(soap, tag ? tag : "wsdd:ProbeMatches", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Probe(struct soap *soap, const struct wsdd__ProbeType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Probe(soap, tag ? tag : "wsdd:Probe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Bye(struct soap *soap, const struct wsdd__ByeType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Bye(soap, tag ? tag : "wsdd:Bye", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Hello(struct soap *soap, const struct wsdd__HelloType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Hello(soap, tag ? tag : "wsdd:Hello", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->InstanceId);
	soap_default_string(soap, &a->SequenceId);
	soap_default_unsignedInt(soap, &a->MessageNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__AppSequenceType(struct soap *soap, const struct wsdd__AppSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__AppSequenceType(struct soap *soap, const char *tag, int id, const struct wsdd__AppSequenceType *a, const char *type)
{
	soap_set_attr(soap, "InstanceId", soap_unsignedInt2s(soap, a->InstanceId), 1);
	if (a->SequenceId)
		soap_set_attr(soap, "SequenceId", soap_string2s(soap, a->SequenceId), 1);
	soap_set_attr(soap, "MessageNumber", soap_unsignedInt2s(soap, a->MessageNumber), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__AppSequenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_in_wsdd__AppSequenceType(struct soap *soap, const char *tag, struct wsdd__AppSequenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__AppSequenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__AppSequenceType(soap, a);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "InstanceId", 5, 1), &a->InstanceId))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SequenceId", 1, 0), &a->SequenceId))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "MessageNumber", 5, 1), &a->MessageNumber))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__AppSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__AppSequenceType, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_new_wsdd__AppSequenceType(struct soap *soap, int n)
{
	struct wsdd__AppSequenceType *p;
	struct wsdd__AppSequenceType *a = (struct wsdd__AppSequenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__AppSequenceType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__AppSequenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__AppSequenceType(struct soap *soap, const struct wsdd__AppSequenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__AppSequenceType(soap, tag ? tag : "wsdd:AppSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_get_wsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__AppSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__SigType(struct soap *soap, struct wsdd__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Scheme);
	soap_default_string(soap, &a->KeyId);
	soap_default_string(soap, &a->Refs);
	soap_default_string(soap, &a->Sig);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__SigType(struct soap *soap, const struct wsdd__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__SigType(struct soap *soap, const char *tag, int id, const struct wsdd__SigType *a, const char *type)
{
	soap_set_attr(soap, "Scheme", a->Scheme ? soap_string2s(soap, a->Scheme) : "", 1);
	if (a->KeyId)
		soap_set_attr(soap, "KeyId", soap_string2s(soap, a->KeyId), 1);
	soap_set_attr(soap, "Refs", a->Refs ? soap_string2s(soap, a->Refs) : "", 1);
	soap_set_attr(soap, "Sig", a->Sig ? soap_string2s(soap, a->Sig) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__SigType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_in_wsdd__SigType(struct soap *soap, const char *tag, struct wsdd__SigType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__SigType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__SigType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Scheme", 1, 1), &a->Scheme))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "KeyId", 1, 0), &a->KeyId))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Refs", 1, 1), &a->Refs))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Sig", 1, 1), &a->Sig))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__SigType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__SigType, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_new_wsdd__SigType(struct soap *soap, int n)
{
	struct wsdd__SigType *p;
	struct wsdd__SigType *a = (struct wsdd__SigType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__SigType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__SigType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__SigType(struct soap *soap, const struct wsdd__SigType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__SigType(soap, tag ? tag : "wsdd:SigType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_get_wsdd__SigType(struct soap *soap, struct wsdd__SigType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__SecurityType(struct soap *soap, struct wsdd__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Sig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__SecurityType(struct soap *soap, const struct wsdd__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__SigType(soap, &a->Sig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__SecurityType(struct soap *soap, const char *tag, int id, const struct wsdd__SecurityType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__SecurityType), type))
		return soap->error;
	if (soap_out_PointerTowsdd__SigType(soap, "wsdd:Sig", -1, &a->Sig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_in_wsdd__SecurityType(struct soap *soap, const char *tag, struct wsdd__SecurityType *a, const char *type)
{
	size_t soap_flag_Sig = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__SecurityType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__SecurityType, sizeof(struct wsdd__SecurityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__SecurityType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sig && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__SigType(soap, "wsdd:Sig", &a->Sig, "wsdd:SigType"))
				{	soap_flag_Sig--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__SecurityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__SecurityType, SOAP_TYPE_wsdd__SecurityType, sizeof(struct wsdd__SecurityType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_new_wsdd__SecurityType(struct soap *soap, int n)
{
	struct wsdd__SecurityType *p;
	struct wsdd__SecurityType *a = (struct wsdd__SecurityType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__SecurityType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__SecurityType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__SecurityType(struct soap *soap, const struct wsdd__SecurityType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__SecurityType(soap, tag ? tag : "wsdd:SecurityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_get_wsdd__SecurityType(struct soap *soap, struct wsdd__SecurityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__SecurityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__UriListType(soap, &a->__item);
	soap_default_string(soap, &a->MatchBy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ScopesType(struct soap *soap, const struct wsdd__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ScopesType(struct soap *soap, const char *tag, int id, const struct wsdd__ScopesType *a, const char *type)
{
	if (a->MatchBy)
		soap_set_attr(soap, "MatchBy", soap_string2s(soap, a->MatchBy), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wsdd__UriListType(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_in_wsdd__ScopesType(struct soap *soap, const char *tag, struct wsdd__ScopesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsdd__ScopesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ScopesType, sizeof(struct wsdd__ScopesType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsdd__ScopesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "MatchBy", 1, 0), &a->MatchBy))
		return NULL;
	if (!soap_in_wsdd__UriListType(soap, tag, (char**)&a->__item, "wsdd:ScopesType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_new_wsdd__ScopesType(struct soap *soap, int n)
{
	struct wsdd__ScopesType *p;
	struct wsdd__ScopesType *a = (struct wsdd__ScopesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ScopesType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ScopesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ScopesType(struct soap *soap, const struct wsdd__ScopesType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ScopesType(soap, tag ? tag : "wsdd:ScopesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_get_wsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
