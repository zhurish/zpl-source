/* onvif_server.c
   Generated by gSOAP 2.8.111 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include "os_include.h"
#include <zpl_include.h>
#include "lib_include.h"
#include "soapH.h"
#include "wsddapi.h"
#include "onvif_server.h"
#include "onvif_util.h"

#include "RemoteDiscoveryBinding.nsmap"


int onvif_soapsrv_client_add(struct onvif_soapsrv *srv, zpl_char *bindaddress, zpl_uint16 bindport)
{
  zpl_uint32 i = 0;
  for(i = 0; i < ONVIF_CLIENT_MAX; i++)
  {
    if(srv->onvif_client[i].flag == 0)
    {
      srv->onvif_client[i].bindport = bindport;
      strcpy(srv->onvif_client[i].bindaddress, bindaddress);
      srv->onvif_client[i].flag = 1;
      return OK;
    }
  }
  return ERROR;
}

int onvif_soapsrv_client_del(struct onvif_soapsrv *srv, zpl_char *bindaddress, zpl_uint16 bindport)
{
  zpl_uint32 i = 0;
  for(i = 0; i < ONVIF_CLIENT_MAX; i++)
  {
    if(srv->onvif_client[i].bindport == bindport && srv->onvif_client[i].flag == 1)
    {
      if(bindaddress && strcmp(srv->onvif_client[i].bindaddress, bindaddress)==0)
      {
        srv->onvif_client[i].bindport = 0;
        memset(srv->onvif_client[i].bindaddress, 0, sizeof(srv->onvif_client[i].bindaddress));
        srv->onvif_client[i].flag = 0; 
        return OK;
      }
      else
      {
        srv->onvif_client[i].bindport = 0;
        memset(srv->onvif_client[i].bindaddress, 0, sizeof(srv->onvif_client[i].bindaddress));
        srv->onvif_client[i].flag = 0;
        return OK;
      }
    }
  }
  return ERROR;
}

struct onvif_soapsrv_node *onvif_soapsrv_client_lookup(struct onvif_soapsrv *srv, zpl_char *bindaddress, zpl_uint16 bindport)
{
  zpl_uint32 i = 0;
  for(i = 0; i < ONVIF_CLIENT_MAX; i++)
  {
    if(srv->onvif_client[i].bindport == bindport)
    {
      if(bindaddress && strcmp(srv->onvif_client[i].bindaddress, bindaddress)==0)
        return &srv->onvif_client[i];
    }
  }
  return NULL;
}

static int onvif_soapsrv_read(struct thread *t)
{
    char logtmp[1024];
	  struct onvif_soapsrv_node *node = THREAD_ARG(t);
    if(node)
    {
      node->t_read = NULL;

      ONVIF_DEBUG_MSG("============dd============\r\n");
      if (!soap_valid_socket(soap_accept(&node->soap))) {
        memset(logtmp, 0, sizeof(logtmp));
        soap_sprint_fault(&node->soap, logtmp, sizeof(logtmp));
        zlog_err(MODULE_ONVIF, "%s", logtmp);
      }
      if (soap_serve(&node->soap))
      {
        ONVIF_DEBUG_MSG("============soap_serve=soap_print_fault===========\r\n");
        memset(logtmp, 0, sizeof(logtmp));
        soap_sprint_fault(&node->soap, logtmp, sizeof(logtmp));
        zlog_err(MODULE_ONVIF, "%s", logtmp);
      }
      ONVIF_DEBUG_MSG("============soap_destroy============\r\n");
      ONVIF_DEBUG_MSG("============Recv connection from IP = %lu.%lu.%lu.%lu socket = %d \r\n", ((node->soap.ip) >> 24) & 0xFF,
                      ((node->soap.ip) >> 16) & 0xFF, ((node->soap.ip) >> 8) & 0xFF, (node->soap.ip) & 0xFF, (node->soap.socket));
      soap_destroy(&node->soap);
      soap_end(&node->soap);

      if(node->soap.master >= 0)
        node->t_read = thread_add_read(t->master, onvif_soapsrv_read, node, node->soap.master);
    }
	  return OK;
}


static int onvif_soapsrv_dis_read(struct thread *t)
{
    char logtmp[1024];
	  struct onvif_soapsrv *srv = THREAD_ARG(t);
    if(srv)
    {
      srv->t_read = NULL;

      ONVIF_DEBUG_MSG("============dd============\r\n");
      if (soap_serve(&srv->dis_soap))
      {
        ONVIF_DEBUG_MSG("============soap_serve=soap_print_fault===========\r\n");
        memset(logtmp, 0, sizeof(logtmp));
        soap_sprint_fault(&srv->dis_soap, logtmp, sizeof(logtmp));
        zlog_err(MODULE_ONVIF, "%s", logtmp);
      }
      ONVIF_DEBUG_MSG("============soap_destroy============\r\n");
      ONVIF_DEBUG_MSG("============Recv connection from IP = %lu.%lu.%lu.%lu socket = %d \r\n", ((srv->dis_soap.ip) >> 24) & 0xFF,
                      ((srv->dis_soap.ip) >> 16) & 0xFF, ((srv->dis_soap.ip) >> 8) & 0xFF, (srv->dis_soap.ip) & 0xFF, (srv->dis_soap.socket));
      soap_destroy(&srv->dis_soap);
      soap_end(&srv->dis_soap);

      if(srv->dis_soap.master >= 0)
        srv->t_read = thread_add_read(t->master, onvif_soapsrv_dis_read, srv, srv->dis_soap.master);
    }
	  return OK;
}



int onvif_soapsrv_cancel(struct onvif_soapsrv_node *node)
{
    if(node && node->t_read)
    {
        thread_cancel(node->t_read);
        node->t_read = NULL;
    }
    return OK; 
}

int onvif_soapsrv_dis_cancel(struct onvif_soapsrv *srv)
{
    if(srv && srv->t_read)
    {
        thread_cancel(srv->t_read);
        srv->t_read = NULL;
    }
    return OK; 
}

static int onvif_soapsrv_main(void *argv)
{
  struct onvif_soapsrv *srv = argv;    
	struct thread_master *master = (struct thread_master *)srv->master;
	master_thread[MODULE_ONVIF] = master;
	host_waitting_loadconfig;
	thread_mainloop(master);
	return OK;
}
/*
static int onvif_soapsrv_main(struct onvif_soapsrv *srv)
{
  int count = 0;
  char logtmp[1024];
  for (;;)
  {
    ONVIF_DEBUG_MSG("Accepting requests\n");
    int fd = soap_accept(&srv->soap);
    if (!soap_valid_socket(fd))
    {
      memset(logtmp, 0, sizeof(logtmp));
      soap_sprint_fault(&srv->soap, logtmp, sizeof(logtmp));
      zlog_err(MODULE_ONVIF, "%s", logtmp);
    }
    ONVIF_DEBUG_MSG("============dd============\r\n");
    if (soap_serve(&srv->soap))
    {
      ONVIF_DEBUG_MSG("============soap_serve=soap_print_fault===========\r\n");
      memset(logtmp, 0, sizeof(logtmp));
      soap_sprint_fault(&srv->soap, logtmp, sizeof(logtmp));
      zlog_err(MODULE_ONVIF, "%s", logtmp);
    }
    ONVIF_DEBUG_MSG("============soap_destroy============\r\n");
    count++;
    ONVIF_DEBUG_MSG("============Recv %d connection from IP = %lu.%lu.%lu.%lu socket = %d \r\n", count, ((srv->soap.ip) >> 24) & 0xFF,
                    ((srv->soap.ip) >> 16) & 0xFF, ((srv->soap.ip) >> 8) & 0xFF, (srv->soap.ip) & 0xFF, (srv->soap.socket));
    soap_destroy(&srv->soap);
    soap_end(&srv->soap);
  }
  soap_done(&srv->soap);
  return 0;
}
*/

int onvif_soapsrv_init(struct onvif_soapsrv *srv)
{
  char logtmp[1024];
  soap_init1(&srv->dis_soap, SOAP_IO_UDP | SOAP_IO_FLUSH);
  soap_set_namespaces(&srv->dis_soap, namespaces);

  if (!soap_valid_socket(soap_bind(&srv->dis_soap, strlen(srv->dis_bindaddress) ? srv->dis_bindaddress : NULL, srv->dis_bindport, 100)))
  {
    memset(logtmp, 0, sizeof(logtmp));
    soap_sprint_fault(&srv->dis_soap, logtmp, sizeof(logtmp));
    zlog_err(MODULE_ONVIF, "%s", logtmp);
    return ERROR;
  }

  if (strlen(srv->dis_multicast))
  {
    struct ip_mreq mreq;
    mreq.imr_multiaddr.s_addr = ipstack_inet_addr(srv->dis_multicast);
    mreq.imr_interface.s_addr = htonl(IPSTACK_INADDR_ANY);
    if (setsockopt(srv->dis_soap.master, IPSTACK_IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0)
    {
      zlog_err(MODULE_ONVIF, "join multicast membership error(%s)", strerror(errno));
      return ERROR;
    }
  }

  soap_init(&srv->onvif_client[0].soap);
  soap_set_namespaces(&srv->onvif_client[0].soap, namespaces);
  srv->onvif_client[0].bindport = 5000;
	srv->onvif_client[0].flag = 1;
  strcpy(srv->onvif_client[0].bindaddress, "192.168.182.129");
  srv->onvif_client[0].soap.bind_flags = IPSTACK_SO_REUSEADDR;
  if (!soap_valid_socket(soap_bind(&srv->onvif_client[0].soap, strlen(srv->onvif_client[0].bindaddress) ? srv->onvif_client[0].bindaddress : NULL, srv->onvif_client[0].bindport, 10)))
  {
    memset(logtmp, 0, sizeof(logtmp));
    soap_sprint_fault(&srv->onvif_client[0].soap, logtmp, sizeof(logtmp));
    zlog_err(MODULE_ONVIF, "%s", logtmp);
    return ERROR;
  }
  srv->master = master_thread[MODULE_ONVIF] = thread_master_module_create(MODULE_ONVIF);
  srv->onvif_client[0].t_read = thread_add_read(srv->master, onvif_soapsrv_read, &srv->onvif_client[0], srv->onvif_client[0].soap.master);
  srv->t_read = thread_add_read(srv->master, onvif_soapsrv_dis_read, srv, srv->dis_soap.master);
  return OK;
}


int onvif_soapsrv_exit(struct onvif_soapsrv *srv)
{
  if(srv)
  {
    soap_destroy(&srv->dis_soap);
    soap_end(&srv->dis_soap);
    soap_done(&srv->dis_soap);
  }
  return OK;
}


int onvif_soapsrv_task_init(struct onvif_soapsrv *srv)
{
  if (srv)
    srv->taskid = os_task_create("onvifTask", OS_TASK_DEFAULT_PRIORITY,
                                 0, onvif_soapsrv_main, srv, OS_TASK_DEFAULT_STACK);
  return 0;
}

int onvif_soapsrv_task_exit(struct onvif_soapsrv *srv)
{
  if(srv && srv->taskid)
  {
    os_task_destroy(srv->taskid);
    srv->taskid = 0;
    soap_destroy(&srv->dis_soap);
    soap_end(&srv->dis_soap);
    soap_done(&srv->dis_soap);
  }
  return OK;
}