/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:05 GMT")


static const struct soap_code_map soap_codes_tt__IPv6DHCPConfiguration[] =
{	{ (LONG64)tt__IPv6DHCPConfiguration__Auto, "Auto" },
	{ (LONG64)tt__IPv6DHCPConfiguration__Stateful, "Stateful" },
	{ (LONG64)tt__IPv6DHCPConfiguration__Stateless, "Stateless" },
	{ (LONG64)tt__IPv6DHCPConfiguration__Off, "Off" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPv6DHCPConfiguration2s(struct soap *soap, enum tt__IPv6DHCPConfiguration n)
{
	const char *s = soap_code_str(soap_codes_tt__IPv6DHCPConfiguration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, const enum tt__IPv6DHCPConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration), type) || soap_send(soap, soap_tt__IPv6DHCPConfiguration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPv6DHCPConfiguration(struct soap *soap, const char *s, enum tt__IPv6DHCPConfiguration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPv6DHCPConfiguration, s);
	if (map)
		*a = (enum tt__IPv6DHCPConfiguration)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPv6DHCPConfiguration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_in_tt__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum tt__IPv6DHCPConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPv6DHCPConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__IPv6DHCPConfiguration(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__IPv6DHCPConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6DHCPConfiguration, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_new_tt__IPv6DHCPConfiguration(struct soap *soap, int n)
{
	enum tt__IPv6DHCPConfiguration *p;
	enum tt__IPv6DHCPConfiguration *a = (enum tt__IPv6DHCPConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IPv6DHCPConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__IPv6DHCPConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6DHCPConfiguration(struct soap *soap, const enum tt__IPv6DHCPConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPv6DHCPConfiguration(soap, tag ? tag : "tt:IPv6DHCPConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_get_tt__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Duplex[] =
{	{ (LONG64)tt__Duplex__Full, "Full" },
	{ (LONG64)tt__Duplex__Half, "Half" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Duplex2s(struct soap *soap, enum tt__Duplex n)
{
	const char *s = soap_code_str(soap_codes_tt__Duplex, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Duplex(struct soap *soap, const char *tag, int id, const enum tt__Duplex *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Duplex), type) || soap_send(soap, soap_tt__Duplex2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Duplex(struct soap *soap, const char *s, enum tt__Duplex *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Duplex, s);
	if (map)
		*a = (enum tt__Duplex)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Duplex)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_in_tt__Duplex(struct soap *soap, const char *tag, enum tt__Duplex *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Duplex*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Duplex, sizeof(enum tt__Duplex), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Duplex(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Duplex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Duplex, SOAP_TYPE_tt__Duplex, sizeof(enum tt__Duplex), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_new_tt__Duplex(struct soap *soap, int n)
{
	enum tt__Duplex *p;
	enum tt__Duplex *a = (enum tt__Duplex*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Duplex));
	for (p = a; p && n--; p++)
		soap_default_tt__Duplex(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Duplex(struct soap *soap, const enum tt__Duplex *a, const char *tag, const char *type)
{
	if (soap_out_tt__Duplex(soap, tag ? tag : "tt:Duplex", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_get_tt__Duplex(struct soap *soap, enum tt__Duplex *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Duplex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__DiscoveryMode[] =
{	{ (LONG64)tt__DiscoveryMode__Discoverable, "Discoverable" },
	{ (LONG64)tt__DiscoveryMode__NonDiscoverable, "NonDiscoverable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DiscoveryMode2s(struct soap *soap, enum tt__DiscoveryMode n)
{
	const char *s = soap_code_str(soap_codes_tt__DiscoveryMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DiscoveryMode(struct soap *soap, const char *tag, int id, const enum tt__DiscoveryMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DiscoveryMode), type) || soap_send(soap, soap_tt__DiscoveryMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DiscoveryMode(struct soap *soap, const char *s, enum tt__DiscoveryMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__DiscoveryMode, s);
	if (map)
		*a = (enum tt__DiscoveryMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DiscoveryMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_in_tt__DiscoveryMode(struct soap *soap, const char *tag, enum tt__DiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__DiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DiscoveryMode, sizeof(enum tt__DiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__DiscoveryMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__DiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DiscoveryMode, SOAP_TYPE_tt__DiscoveryMode, sizeof(enum tt__DiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_new_tt__DiscoveryMode(struct soap *soap, int n)
{
	enum tt__DiscoveryMode *p;
	enum tt__DiscoveryMode *a = (enum tt__DiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__DiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default_tt__DiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DiscoveryMode(struct soap *soap, const enum tt__DiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__DiscoveryMode(soap, tag ? tag : "tt:DiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_get_tt__DiscoveryMode(struct soap *soap, enum tt__DiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ScopeDefinition[] =
{	{ (LONG64)tt__ScopeDefinition__Fixed, "Fixed" },
	{ (LONG64)tt__ScopeDefinition__Configurable, "Configurable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ScopeDefinition2s(struct soap *soap, enum tt__ScopeDefinition n)
{
	const char *s = soap_code_str(soap_codes_tt__ScopeDefinition, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ScopeDefinition(struct soap *soap, const char *tag, int id, const enum tt__ScopeDefinition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ScopeDefinition), type) || soap_send(soap, soap_tt__ScopeDefinition2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ScopeDefinition(struct soap *soap, const char *s, enum tt__ScopeDefinition *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ScopeDefinition, s);
	if (map)
		*a = (enum tt__ScopeDefinition)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ScopeDefinition)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_in_tt__ScopeDefinition(struct soap *soap, const char *tag, enum tt__ScopeDefinition *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ScopeDefinition*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ScopeDefinition, sizeof(enum tt__ScopeDefinition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ScopeDefinition(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ScopeDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ScopeDefinition, SOAP_TYPE_tt__ScopeDefinition, sizeof(enum tt__ScopeDefinition), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_new_tt__ScopeDefinition(struct soap *soap, int n)
{
	enum tt__ScopeDefinition *p;
	enum tt__ScopeDefinition *a = (enum tt__ScopeDefinition*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ScopeDefinition));
	for (p = a; p && n--; p++)
		soap_default_tt__ScopeDefinition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ScopeDefinition(struct soap *soap, const enum tt__ScopeDefinition *a, const char *tag, const char *type)
{
	if (soap_out_tt__ScopeDefinition(soap, tag ? tag : "tt:ScopeDefinition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_get_tt__ScopeDefinition(struct soap *soap, enum tt__ScopeDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ScopeDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__TransportProtocol[] =
{	{ (LONG64)tt__TransportProtocol__UDP, "UDP" },
	{ (LONG64)tt__TransportProtocol__TCP, "TCP" },
	{ (LONG64)tt__TransportProtocol__RTSP, "RTSP" },
	{ (LONG64)tt__TransportProtocol__HTTP, "HTTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__TransportProtocol2s(struct soap *soap, enum tt__TransportProtocol n)
{
	const char *s = soap_code_str(soap_codes_tt__TransportProtocol, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TransportProtocol(struct soap *soap, const char *tag, int id, const enum tt__TransportProtocol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TransportProtocol), type) || soap_send(soap, soap_tt__TransportProtocol2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__TransportProtocol(struct soap *soap, const char *s, enum tt__TransportProtocol *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__TransportProtocol, s);
	if (map)
		*a = (enum tt__TransportProtocol)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__TransportProtocol)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_in_tt__TransportProtocol(struct soap *soap, const char *tag, enum tt__TransportProtocol *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__TransportProtocol*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransportProtocol, sizeof(enum tt__TransportProtocol), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__TransportProtocol(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__TransportProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TransportProtocol, SOAP_TYPE_tt__TransportProtocol, sizeof(enum tt__TransportProtocol), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_new_tt__TransportProtocol(struct soap *soap, int n)
{
	enum tt__TransportProtocol *p;
	enum tt__TransportProtocol *a = (enum tt__TransportProtocol*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__TransportProtocol));
	for (p = a; p && n--; p++)
		soap_default_tt__TransportProtocol(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TransportProtocol(struct soap *soap, const enum tt__TransportProtocol *a, const char *tag, const char *type)
{
	if (soap_out_tt__TransportProtocol(soap, tag ? tag : "tt:TransportProtocol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_get_tt__TransportProtocol(struct soap *soap, enum tt__TransportProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TransportProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__StreamType[] =
{	{ (LONG64)tt__StreamType__RTP_Unicast, "RTP-Unicast" },
	{ (LONG64)tt__StreamType__RTP_Multicast, "RTP-Multicast" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__StreamType2s(struct soap *soap, enum tt__StreamType n)
{
	const char *s = soap_code_str(soap_codes_tt__StreamType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StreamType(struct soap *soap, const char *tag, int id, const enum tt__StreamType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StreamType), type) || soap_send(soap, soap_tt__StreamType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__StreamType(struct soap *soap, const char *s, enum tt__StreamType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__StreamType, s);
	if (map)
		*a = (enum tt__StreamType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__StreamType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_in_tt__StreamType(struct soap *soap, const char *tag, enum tt__StreamType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__StreamType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamType, sizeof(enum tt__StreamType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__StreamType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__StreamType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamType, SOAP_TYPE_tt__StreamType, sizeof(enum tt__StreamType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_new_tt__StreamType(struct soap *soap, int n)
{
	enum tt__StreamType *p;
	enum tt__StreamType *a = (enum tt__StreamType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__StreamType));
	for (p = a; p && n--; p++)
		soap_default_tt__StreamType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StreamType(struct soap *soap, const enum tt__StreamType *a, const char *tag, const char *type)
{
	if (soap_out_tt__StreamType(soap, tag ? tag : "tt:StreamType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_get_tt__StreamType(struct soap *soap, enum tt__StreamType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StreamType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__MetadataCompressionType[] =
{	{ (LONG64)tt__MetadataCompressionType__None, "None" },
	{ (LONG64)tt__MetadataCompressionType__GZIP, "GZIP" },
	{ (LONG64)tt__MetadataCompressionType__EXI, "EXI" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__MetadataCompressionType2s(struct soap *soap, enum tt__MetadataCompressionType n)
{
	const char *s = soap_code_str(soap_codes_tt__MetadataCompressionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataCompressionType(struct soap *soap, const char *tag, int id, const enum tt__MetadataCompressionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataCompressionType), type) || soap_send(soap, soap_tt__MetadataCompressionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__MetadataCompressionType(struct soap *soap, const char *s, enum tt__MetadataCompressionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__MetadataCompressionType, s);
	if (map)
		*a = (enum tt__MetadataCompressionType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__MetadataCompressionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__MetadataCompressionType * SOAP_FMAC4 soap_in_tt__MetadataCompressionType(struct soap *soap, const char *tag, enum tt__MetadataCompressionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__MetadataCompressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataCompressionType, sizeof(enum tt__MetadataCompressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__MetadataCompressionType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__MetadataCompressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataCompressionType, SOAP_TYPE_tt__MetadataCompressionType, sizeof(enum tt__MetadataCompressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__MetadataCompressionType * SOAP_FMAC4 soap_new_tt__MetadataCompressionType(struct soap *soap, int n)
{
	enum tt__MetadataCompressionType *p;
	enum tt__MetadataCompressionType *a = (enum tt__MetadataCompressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__MetadataCompressionType));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataCompressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataCompressionType(struct soap *soap, const enum tt__MetadataCompressionType *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataCompressionType(soap, tag ? tag : "tt:MetadataCompressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MetadataCompressionType * SOAP_FMAC4 soap_get_tt__MetadataCompressionType(struct soap *soap, enum tt__MetadataCompressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataCompressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__AudioEncodingMimeNames[] =
{	{ (LONG64)tt__AudioEncodingMimeNames__PCMU, "PCMU" },
	{ (LONG64)tt__AudioEncodingMimeNames__G726, "G726" },
	{ (LONG64)tt__AudioEncodingMimeNames__MP4A_LATM, "MP4A-LATM" },
	{ (LONG64)tt__AudioEncodingMimeNames__mpeg4_generic, "mpeg4-generic" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AudioEncodingMimeNames2s(struct soap *soap, enum tt__AudioEncodingMimeNames n)
{
	const char *s = soap_code_str(soap_codes_tt__AudioEncodingMimeNames, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncodingMimeNames(struct soap *soap, const char *tag, int id, const enum tt__AudioEncodingMimeNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncodingMimeNames), type) || soap_send(soap, soap_tt__AudioEncodingMimeNames2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AudioEncodingMimeNames(struct soap *soap, const char *s, enum tt__AudioEncodingMimeNames *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AudioEncodingMimeNames, s);
	if (map)
		*a = (enum tt__AudioEncodingMimeNames)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AudioEncodingMimeNames)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AudioEncodingMimeNames * SOAP_FMAC4 soap_in_tt__AudioEncodingMimeNames(struct soap *soap, const char *tag, enum tt__AudioEncodingMimeNames *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AudioEncodingMimeNames*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncodingMimeNames, sizeof(enum tt__AudioEncodingMimeNames), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__AudioEncodingMimeNames(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__AudioEncodingMimeNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncodingMimeNames, SOAP_TYPE_tt__AudioEncodingMimeNames, sizeof(enum tt__AudioEncodingMimeNames), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__AudioEncodingMimeNames * SOAP_FMAC4 soap_new_tt__AudioEncodingMimeNames(struct soap *soap, int n)
{
	enum tt__AudioEncodingMimeNames *p;
	enum tt__AudioEncodingMimeNames *a = (enum tt__AudioEncodingMimeNames*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__AudioEncodingMimeNames));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncodingMimeNames(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncodingMimeNames(struct soap *soap, const enum tt__AudioEncodingMimeNames *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncodingMimeNames(soap, tag ? tag : "tt:AudioEncodingMimeNames", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AudioEncodingMimeNames * SOAP_FMAC4 soap_get_tt__AudioEncodingMimeNames(struct soap *soap, enum tt__AudioEncodingMimeNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncodingMimeNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__AudioEncoding[] =
{	{ (LONG64)tt__AudioEncoding__G711, "G711" },
	{ (LONG64)tt__AudioEncoding__G726, "G726" },
	{ (LONG64)tt__AudioEncoding__AAC, "AAC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AudioEncoding2s(struct soap *soap, enum tt__AudioEncoding n)
{
	const char *s = soap_code_str(soap_codes_tt__AudioEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoding(struct soap *soap, const char *tag, int id, const enum tt__AudioEncoding *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoding), type) || soap_send(soap, soap_tt__AudioEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AudioEncoding(struct soap *soap, const char *s, enum tt__AudioEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AudioEncoding, s);
	if (map)
		*a = (enum tt__AudioEncoding)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AudioEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_in_tt__AudioEncoding(struct soap *soap, const char *tag, enum tt__AudioEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AudioEncoding*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoding, sizeof(enum tt__AudioEncoding), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__AudioEncoding(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__AudioEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoding, SOAP_TYPE_tt__AudioEncoding, sizeof(enum tt__AudioEncoding), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_new_tt__AudioEncoding(struct soap *soap, int n)
{
	enum tt__AudioEncoding *p;
	enum tt__AudioEncoding *a = (enum tt__AudioEncoding*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__AudioEncoding));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncoding(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoding(struct soap *soap, const enum tt__AudioEncoding *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncoding(soap, tag ? tag : "tt:AudioEncoding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_get_tt__AudioEncoding(struct soap *soap, enum tt__AudioEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__VideoEncodingProfiles[] =
{	{ (LONG64)tt__VideoEncodingProfiles__Simple, "Simple" },
	{ (LONG64)tt__VideoEncodingProfiles__AdvancedSimple, "AdvancedSimple" },
	{ (LONG64)tt__VideoEncodingProfiles__Baseline, "Baseline" },
	{ (LONG64)tt__VideoEncodingProfiles__Main, "Main" },
	{ (LONG64)tt__VideoEncodingProfiles__Main10, "Main10" },
	{ (LONG64)tt__VideoEncodingProfiles__Extended, "Extended" },
	{ (LONG64)tt__VideoEncodingProfiles__High, "High" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncodingProfiles2s(struct soap *soap, enum tt__VideoEncodingProfiles n)
{
	const char *s = soap_code_str(soap_codes_tt__VideoEncodingProfiles, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncodingProfiles(struct soap *soap, const char *tag, int id, const enum tt__VideoEncodingProfiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncodingProfiles), type) || soap_send(soap, soap_tt__VideoEncodingProfiles2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncodingProfiles(struct soap *soap, const char *s, enum tt__VideoEncodingProfiles *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__VideoEncodingProfiles, s);
	if (map)
		*a = (enum tt__VideoEncodingProfiles)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__VideoEncodingProfiles)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncodingProfiles * SOAP_FMAC4 soap_in_tt__VideoEncodingProfiles(struct soap *soap, const char *tag, enum tt__VideoEncodingProfiles *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__VideoEncodingProfiles*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncodingProfiles, sizeof(enum tt__VideoEncodingProfiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__VideoEncodingProfiles(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__VideoEncodingProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncodingProfiles, SOAP_TYPE_tt__VideoEncodingProfiles, sizeof(enum tt__VideoEncodingProfiles), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__VideoEncodingProfiles * SOAP_FMAC4 soap_new_tt__VideoEncodingProfiles(struct soap *soap, int n)
{
	enum tt__VideoEncodingProfiles *p;
	enum tt__VideoEncodingProfiles *a = (enum tt__VideoEncodingProfiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__VideoEncodingProfiles));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncodingProfiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncodingProfiles(struct soap *soap, const enum tt__VideoEncodingProfiles *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncodingProfiles(soap, tag ? tag : "tt:VideoEncodingProfiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncodingProfiles * SOAP_FMAC4 soap_get_tt__VideoEncodingProfiles(struct soap *soap, enum tt__VideoEncodingProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncodingProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__VideoEncodingMimeNames[] =
{	{ (LONG64)tt__VideoEncodingMimeNames__JPEG, "JPEG" },
	{ (LONG64)tt__VideoEncodingMimeNames__MPV4_ES, "MPV4-ES" },
	{ (LONG64)tt__VideoEncodingMimeNames__H264, "H264" },
	{ (LONG64)tt__VideoEncodingMimeNames__H265, "H265" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncodingMimeNames2s(struct soap *soap, enum tt__VideoEncodingMimeNames n)
{
	const char *s = soap_code_str(soap_codes_tt__VideoEncodingMimeNames, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncodingMimeNames(struct soap *soap, const char *tag, int id, const enum tt__VideoEncodingMimeNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncodingMimeNames), type) || soap_send(soap, soap_tt__VideoEncodingMimeNames2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncodingMimeNames(struct soap *soap, const char *s, enum tt__VideoEncodingMimeNames *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__VideoEncodingMimeNames, s);
	if (map)
		*a = (enum tt__VideoEncodingMimeNames)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__VideoEncodingMimeNames)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncodingMimeNames * SOAP_FMAC4 soap_in_tt__VideoEncodingMimeNames(struct soap *soap, const char *tag, enum tt__VideoEncodingMimeNames *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__VideoEncodingMimeNames*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncodingMimeNames, sizeof(enum tt__VideoEncodingMimeNames), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__VideoEncodingMimeNames(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__VideoEncodingMimeNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncodingMimeNames, SOAP_TYPE_tt__VideoEncodingMimeNames, sizeof(enum tt__VideoEncodingMimeNames), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__VideoEncodingMimeNames * SOAP_FMAC4 soap_new_tt__VideoEncodingMimeNames(struct soap *soap, int n)
{
	enum tt__VideoEncodingMimeNames *p;
	enum tt__VideoEncodingMimeNames *a = (enum tt__VideoEncodingMimeNames*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__VideoEncodingMimeNames));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncodingMimeNames(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncodingMimeNames(struct soap *soap, const enum tt__VideoEncodingMimeNames *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncodingMimeNames(soap, tag ? tag : "tt:VideoEncodingMimeNames", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncodingMimeNames * SOAP_FMAC4 soap_get_tt__VideoEncodingMimeNames(struct soap *soap, enum tt__VideoEncodingMimeNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncodingMimeNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__H264Profile[] =
{	{ (LONG64)tt__H264Profile__Baseline, "Baseline" },
	{ (LONG64)tt__H264Profile__Main, "Main" },
	{ (LONG64)tt__H264Profile__Extended, "Extended" },
	{ (LONG64)tt__H264Profile__High, "High" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__H264Profile2s(struct soap *soap, enum tt__H264Profile n)
{
	const char *s = soap_code_str(soap_codes_tt__H264Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Profile(struct soap *soap, const char *tag, int id, const enum tt__H264Profile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Profile), type) || soap_send(soap, soap_tt__H264Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__H264Profile(struct soap *soap, const char *s, enum tt__H264Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__H264Profile, s);
	if (map)
		*a = (enum tt__H264Profile)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__H264Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_in_tt__H264Profile(struct soap *soap, const char *tag, enum tt__H264Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__H264Profile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__H264Profile(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__H264Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Profile, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_new_tt__H264Profile(struct soap *soap, int n)
{
	enum tt__H264Profile *p;
	enum tt__H264Profile *a = (enum tt__H264Profile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__H264Profile));
	for (p = a; p && n--; p++)
		soap_default_tt__H264Profile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Profile(struct soap *soap, const enum tt__H264Profile *a, const char *tag, const char *type)
{
	if (soap_out_tt__H264Profile(soap, tag ? tag : "tt:H264Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_get_tt__H264Profile(struct soap *soap, enum tt__H264Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Mpeg4Profile[] =
{	{ (LONG64)tt__Mpeg4Profile__SP, "SP" },
	{ (LONG64)tt__Mpeg4Profile__ASP, "ASP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Mpeg4Profile2s(struct soap *soap, enum tt__Mpeg4Profile n)
{
	const char *s = soap_code_str(soap_codes_tt__Mpeg4Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Profile(struct soap *soap, const char *tag, int id, const enum tt__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Profile), type) || soap_send(soap, soap_tt__Mpeg4Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Mpeg4Profile(struct soap *soap, const char *s, enum tt__Mpeg4Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Mpeg4Profile, s);
	if (map)
		*a = (enum tt__Mpeg4Profile)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Mpeg4Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_in_tt__Mpeg4Profile(struct soap *soap, const char *tag, enum tt__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Mpeg4Profile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Mpeg4Profile(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Mpeg4Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Profile, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_new_tt__Mpeg4Profile(struct soap *soap, int n)
{
	enum tt__Mpeg4Profile *p;
	enum tt__Mpeg4Profile *a = (enum tt__Mpeg4Profile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Mpeg4Profile));
	for (p = a; p && n--; p++)
		soap_default_tt__Mpeg4Profile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Profile(struct soap *soap, const enum tt__Mpeg4Profile *a, const char *tag, const char *type)
{
	if (soap_out_tt__Mpeg4Profile(soap, tag ? tag : "tt:Mpeg4Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_get_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__VideoEncoding[] =
{	{ (LONG64)tt__VideoEncoding__JPEG, "JPEG" },
	{ (LONG64)tt__VideoEncoding__MPEG4, "MPEG4" },
	{ (LONG64)tt__VideoEncoding__H264, "H264" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncoding2s(struct soap *soap, enum tt__VideoEncoding n)
{
	const char *s = soap_code_str(soap_codes_tt__VideoEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoding(struct soap *soap, const char *tag, int id, const enum tt__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoding), type) || soap_send(soap, soap_tt__VideoEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncoding(struct soap *soap, const char *s, enum tt__VideoEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__VideoEncoding, s);
	if (map)
		*a = (enum tt__VideoEncoding)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__VideoEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_in_tt__VideoEncoding(struct soap *soap, const char *tag, enum tt__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__VideoEncoding*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__VideoEncoding(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__VideoEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoding, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_new_tt__VideoEncoding(struct soap *soap, int n)
{
	enum tt__VideoEncoding *p;
	enum tt__VideoEncoding *a = (enum tt__VideoEncoding*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__VideoEncoding));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoding(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoding(struct soap *soap, const enum tt__VideoEncoding *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoding(soap, tag ? tag : "tt:VideoEncoding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_get_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ViewModes[] =
{	{ (LONG64)tt__ViewModes__tt_x003aFisheye, "tt:Fisheye" },
	{ (LONG64)tt__ViewModes__tt_x003a360Panorama, "tt:360Panorama" },
	{ (LONG64)tt__ViewModes__tt_x003a180Panorama, "tt:180Panorama" },
	{ (LONG64)tt__ViewModes__tt_x003aQuad, "tt:Quad" },
	{ (LONG64)tt__ViewModes__tt_x003aOriginal, "tt:Original" },
	{ (LONG64)tt__ViewModes__tt_x003aLeftHalf, "tt:LeftHalf" },
	{ (LONG64)tt__ViewModes__tt_x003aRightHalf, "tt:RightHalf" },
	{ (LONG64)tt__ViewModes__tt_x003aDewarp, "tt:Dewarp" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ViewModes2s(struct soap *soap, enum tt__ViewModes n)
{
	const char *s = soap_code_str(soap_codes_tt__ViewModes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ViewModes(struct soap *soap, const char *tag, int id, const enum tt__ViewModes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ViewModes), type) || soap_send(soap, soap_tt__ViewModes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ViewModes(struct soap *soap, const char *s, enum tt__ViewModes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ViewModes, s);
	if (map)
		*a = (enum tt__ViewModes)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 7)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ViewModes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ViewModes * SOAP_FMAC4 soap_in_tt__ViewModes(struct soap *soap, const char *tag, enum tt__ViewModes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ViewModes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ViewModes, sizeof(enum tt__ViewModes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ViewModes(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ViewModes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ViewModes, SOAP_TYPE_tt__ViewModes, sizeof(enum tt__ViewModes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ViewModes * SOAP_FMAC4 soap_new_tt__ViewModes(struct soap *soap, int n)
{
	enum tt__ViewModes *p;
	enum tt__ViewModes *a = (enum tt__ViewModes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ViewModes));
	for (p = a; p && n--; p++)
		soap_default_tt__ViewModes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ViewModes(struct soap *soap, const enum tt__ViewModes *a, const char *tag, const char *type)
{
	if (soap_out_tt__ViewModes(soap, tag ? tag : "tt:ViewModes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ViewModes * SOAP_FMAC4 soap_get_tt__ViewModes(struct soap *soap, enum tt__ViewModes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ViewModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__SceneOrientationOption[] =
{	{ (LONG64)tt__SceneOrientationOption__Below, "Below" },
	{ (LONG64)tt__SceneOrientationOption__Horizon, "Horizon" },
	{ (LONG64)tt__SceneOrientationOption__Above, "Above" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SceneOrientationOption2s(struct soap *soap, enum tt__SceneOrientationOption n)
{
	const char *s = soap_code_str(soap_codes_tt__SceneOrientationOption, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientationOption(struct soap *soap, const char *tag, int id, const enum tt__SceneOrientationOption *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SceneOrientationOption), type) || soap_send(soap, soap_tt__SceneOrientationOption2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SceneOrientationOption(struct soap *soap, const char *s, enum tt__SceneOrientationOption *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SceneOrientationOption, s);
	if (map)
		*a = (enum tt__SceneOrientationOption)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SceneOrientationOption)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SceneOrientationOption * SOAP_FMAC4 soap_in_tt__SceneOrientationOption(struct soap *soap, const char *tag, enum tt__SceneOrientationOption *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SceneOrientationOption*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientationOption, sizeof(enum tt__SceneOrientationOption), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__SceneOrientationOption(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__SceneOrientationOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SceneOrientationOption, SOAP_TYPE_tt__SceneOrientationOption, sizeof(enum tt__SceneOrientationOption), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__SceneOrientationOption * SOAP_FMAC4 soap_new_tt__SceneOrientationOption(struct soap *soap, int n)
{
	enum tt__SceneOrientationOption *p;
	enum tt__SceneOrientationOption *a = (enum tt__SceneOrientationOption*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__SceneOrientationOption));
	for (p = a; p && n--; p++)
		soap_default_tt__SceneOrientationOption(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SceneOrientationOption(struct soap *soap, const enum tt__SceneOrientationOption *a, const char *tag, const char *type)
{
	if (soap_out_tt__SceneOrientationOption(soap, tag ? tag : "tt:SceneOrientationOption", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SceneOrientationOption * SOAP_FMAC4 soap_get_tt__SceneOrientationOption(struct soap *soap, enum tt__SceneOrientationOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SceneOrientationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__SceneOrientationMode[] =
{	{ (LONG64)tt__SceneOrientationMode__MANUAL, "MANUAL" },
	{ (LONG64)tt__SceneOrientationMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SceneOrientationMode2s(struct soap *soap, enum tt__SceneOrientationMode n)
{
	const char *s = soap_code_str(soap_codes_tt__SceneOrientationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientationMode(struct soap *soap, const char *tag, int id, const enum tt__SceneOrientationMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SceneOrientationMode), type) || soap_send(soap, soap_tt__SceneOrientationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SceneOrientationMode(struct soap *soap, const char *s, enum tt__SceneOrientationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SceneOrientationMode, s);
	if (map)
		*a = (enum tt__SceneOrientationMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SceneOrientationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SceneOrientationMode * SOAP_FMAC4 soap_in_tt__SceneOrientationMode(struct soap *soap, const char *tag, enum tt__SceneOrientationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SceneOrientationMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientationMode, sizeof(enum tt__SceneOrientationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__SceneOrientationMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__SceneOrientationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SceneOrientationMode, SOAP_TYPE_tt__SceneOrientationMode, sizeof(enum tt__SceneOrientationMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__SceneOrientationMode * SOAP_FMAC4 soap_new_tt__SceneOrientationMode(struct soap *soap, int n)
{
	enum tt__SceneOrientationMode *p;
	enum tt__SceneOrientationMode *a = (enum tt__SceneOrientationMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__SceneOrientationMode));
	for (p = a; p && n--; p++)
		soap_default_tt__SceneOrientationMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SceneOrientationMode(struct soap *soap, const enum tt__SceneOrientationMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__SceneOrientationMode(soap, tag ? tag : "tt:SceneOrientationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SceneOrientationMode * SOAP_FMAC4 soap_get_tt__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SceneOrientationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RotateMode[] =
{	{ (LONG64)tt__RotateMode__OFF, "OFF" },
	{ (LONG64)tt__RotateMode__ON, "ON" },
	{ (LONG64)tt__RotateMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RotateMode2s(struct soap *soap, enum tt__RotateMode n)
{
	const char *s = soap_code_str(soap_codes_tt__RotateMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateMode(struct soap *soap, const char *tag, int id, const enum tt__RotateMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateMode), type) || soap_send(soap, soap_tt__RotateMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RotateMode(struct soap *soap, const char *s, enum tt__RotateMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RotateMode, s);
	if (map)
		*a = (enum tt__RotateMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RotateMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_in_tt__RotateMode(struct soap *soap, const char *tag, enum tt__RotateMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RotateMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__RotateMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__RotateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateMode, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_new_tt__RotateMode(struct soap *soap, int n)
{
	enum tt__RotateMode *p;
	enum tt__RotateMode *a = (enum tt__RotateMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RotateMode));
	for (p = a; p && n--; p++)
		soap_default_tt__RotateMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RotateMode(struct soap *soap, const enum tt__RotateMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__RotateMode(soap, tag ? tag : "tt:RotateMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_get_tt__RotateMode(struct soap *soap, enum tt__RotateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tds__StorageType[] =
{	{ (LONG64)tds__StorageType__NFS, "NFS" },
	{ (LONG64)tds__StorageType__CIFS, "CIFS" },
	{ (LONG64)tds__StorageType__CDMI, "CDMI" },
	{ (LONG64)tds__StorageType__FTP, "FTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tds__StorageType2s(struct soap *soap, enum tds__StorageType n)
{
	const char *s = soap_code_str(soap_codes_tds__StorageType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__StorageType(struct soap *soap, const char *tag, int id, const enum tds__StorageType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__StorageType), type) || soap_send(soap, soap_tds__StorageType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tds__StorageType(struct soap *soap, const char *s, enum tds__StorageType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tds__StorageType, s);
	if (map)
		*a = (enum tds__StorageType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tds__StorageType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tds__StorageType * SOAP_FMAC4 soap_in_tds__StorageType(struct soap *soap, const char *tag, enum tds__StorageType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tds__StorageType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageType, sizeof(enum tds__StorageType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tds__StorageType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tds__StorageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageType, SOAP_TYPE_tds__StorageType, sizeof(enum tds__StorageType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tds__StorageType * SOAP_FMAC4 soap_new_tds__StorageType(struct soap *soap, int n)
{
	enum tds__StorageType *p;
	enum tds__StorageType *a = (enum tds__StorageType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tds__StorageType));
	for (p = a; p && n--; p++)
		soap_default_tds__StorageType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__StorageType(struct soap *soap, const enum tds__StorageType *a, const char *tag, const char *type)
{
	if (soap_out_tds__StorageType(soap, tag ? tag : "tds:StorageType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tds__StorageType * SOAP_FMAC4 soap_get_tds__StorageType(struct soap *soap, enum tds__StorageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__StorageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tds__AutoGeoModes[] =
{	{ (LONG64)tds__AutoGeoModes__Location, "Location" },
	{ (LONG64)tds__AutoGeoModes__Heading, "Heading" },
	{ (LONG64)tds__AutoGeoModes__Leveling, "Leveling" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tds__AutoGeoModes2s(struct soap *soap, enum tds__AutoGeoModes n)
{
	const char *s = soap_code_str(soap_codes_tds__AutoGeoModes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__AutoGeoModes(struct soap *soap, const char *tag, int id, const enum tds__AutoGeoModes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__AutoGeoModes), type) || soap_send(soap, soap_tds__AutoGeoModes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tds__AutoGeoModes(struct soap *soap, const char *s, enum tds__AutoGeoModes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tds__AutoGeoModes, s);
	if (map)
		*a = (enum tds__AutoGeoModes)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tds__AutoGeoModes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tds__AutoGeoModes * SOAP_FMAC4 soap_in_tds__AutoGeoModes(struct soap *soap, const char *tag, enum tds__AutoGeoModes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tds__AutoGeoModes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__AutoGeoModes, sizeof(enum tds__AutoGeoModes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tds__AutoGeoModes(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tds__AutoGeoModes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__AutoGeoModes, SOAP_TYPE_tds__AutoGeoModes, sizeof(enum tds__AutoGeoModes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tds__AutoGeoModes * SOAP_FMAC4 soap_new_tds__AutoGeoModes(struct soap *soap, int n)
{
	enum tds__AutoGeoModes *p;
	enum tds__AutoGeoModes *a = (enum tds__AutoGeoModes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tds__AutoGeoModes));
	for (p = a; p && n--; p++)
		soap_default_tds__AutoGeoModes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__AutoGeoModes(struct soap *soap, const enum tds__AutoGeoModes *a, const char *tag, const char *type)
{
	if (soap_out_tds__AutoGeoModes(soap, tag ? tag : "tds:AutoGeoModes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tds__AutoGeoModes * SOAP_FMAC4 soap_get_tds__AutoGeoModes(struct soap *soap, enum tds__AutoGeoModes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__AutoGeoModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tmd__ParityBit[] =
{	{ (LONG64)tmd__ParityBit__None, "None" },
	{ (LONG64)tmd__ParityBit__Even, "Even" },
	{ (LONG64)tmd__ParityBit__Odd, "Odd" },
	{ (LONG64)tmd__ParityBit__Mark, "Mark" },
	{ (LONG64)tmd__ParityBit__Space, "Space" },
	{ (LONG64)tmd__ParityBit__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tmd__ParityBit2s(struct soap *soap, enum tmd__ParityBit n)
{
	const char *s = soap_code_str(soap_codes_tmd__ParityBit, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__ParityBit(struct soap *soap, const char *tag, int id, const enum tmd__ParityBit *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__ParityBit), type) || soap_send(soap, soap_tmd__ParityBit2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tmd__ParityBit(struct soap *soap, const char *s, enum tmd__ParityBit *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tmd__ParityBit, s);
	if (map)
		*a = (enum tmd__ParityBit)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 5)
			return soap->error = SOAP_TYPE;
		*a = (enum tmd__ParityBit)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tmd__ParityBit * SOAP_FMAC4 soap_in_tmd__ParityBit(struct soap *soap, const char *tag, enum tmd__ParityBit *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tmd__ParityBit*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__ParityBit, sizeof(enum tmd__ParityBit), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tmd__ParityBit(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tmd__ParityBit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__ParityBit, SOAP_TYPE_tmd__ParityBit, sizeof(enum tmd__ParityBit), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tmd__ParityBit * SOAP_FMAC4 soap_new_tmd__ParityBit(struct soap *soap, int n)
{
	enum tmd__ParityBit *p;
	enum tmd__ParityBit *a = (enum tmd__ParityBit*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tmd__ParityBit));
	for (p = a; p && n--; p++)
		soap_default_tmd__ParityBit(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__ParityBit(struct soap *soap, const enum tmd__ParityBit *a, const char *tag, const char *type)
{
	if (soap_out_tmd__ParityBit(soap, tag ? tag : "tmd:ParityBit", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tmd__ParityBit * SOAP_FMAC4 soap_get_tmd__ParityBit(struct soap *soap, enum tmd__ParityBit *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__ParityBit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tmd__SerialPortType[] =
{	{ (LONG64)tmd__SerialPortType__RS232, "RS232" },
	{ (LONG64)tmd__SerialPortType__RS422HalfDuplex, "RS422HalfDuplex" },
	{ (LONG64)tmd__SerialPortType__RS422FullDuplex, "RS422FullDuplex" },
	{ (LONG64)tmd__SerialPortType__RS485HalfDuplex, "RS485HalfDuplex" },
	{ (LONG64)tmd__SerialPortType__RS485FullDuplex, "RS485FullDuplex" },
	{ (LONG64)tmd__SerialPortType__Generic, "Generic" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tmd__SerialPortType2s(struct soap *soap, enum tmd__SerialPortType n)
{
	const char *s = soap_code_str(soap_codes_tmd__SerialPortType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__SerialPortType(struct soap *soap, const char *tag, int id, const enum tmd__SerialPortType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__SerialPortType), type) || soap_send(soap, soap_tmd__SerialPortType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tmd__SerialPortType(struct soap *soap, const char *s, enum tmd__SerialPortType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tmd__SerialPortType, s);
	if (map)
		*a = (enum tmd__SerialPortType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 5)
			return soap->error = SOAP_TYPE;
		*a = (enum tmd__SerialPortType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tmd__SerialPortType * SOAP_FMAC4 soap_in_tmd__SerialPortType(struct soap *soap, const char *tag, enum tmd__SerialPortType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tmd__SerialPortType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__SerialPortType, sizeof(enum tmd__SerialPortType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tmd__SerialPortType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tmd__SerialPortType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__SerialPortType, SOAP_TYPE_tmd__SerialPortType, sizeof(enum tmd__SerialPortType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tmd__SerialPortType * SOAP_FMAC4 soap_new_tmd__SerialPortType(struct soap *soap, int n)
{
	enum tmd__SerialPortType *p;
	enum tmd__SerialPortType *a = (enum tmd__SerialPortType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tmd__SerialPortType));
	for (p = a; p && n--; p++)
		soap_default_tmd__SerialPortType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__SerialPortType(struct soap *soap, const enum tmd__SerialPortType *a, const char *tag, const char *type)
{
	if (soap_out_tmd__SerialPortType(soap, tag ? tag : "tmd:SerialPortType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tmd__SerialPortType * SOAP_FMAC4 soap_get_tmd__SerialPortType(struct soap *soap, enum tmd__SerialPortType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__SerialPortType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (LONG64)xsd__boolean__false_, "false" },
	{ (LONG64)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_xsd__boolean, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2xsd__boolean(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_new_xsd__boolean(struct soap *soap, int n)
{
	enum xsd__boolean *p;
	enum xsd__boolean *a = (enum xsd__boolean*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum xsd__boolean));
	for (p = a; p && n--; p++)
		soap_default_xsd__boolean(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	if (soap_out_xsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (LONG64)_wsa5__IsReferenceParameter__false, "false" },
	{ (LONG64)_wsa5__IsReferenceParameter__true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{
	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, s);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_new__wsa5__IsReferenceParameter(struct soap *soap, int n)
{
	enum _wsa5__IsReferenceParameter *p;
	enum _wsa5__IsReferenceParameter *a = (enum _wsa5__IsReferenceParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _wsa5__IsReferenceParameter));
	for (p = a; p && n--; p++)
		soap_default__wsa5__IsReferenceParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__IsReferenceParameter(soap, tag ? tag : "wsa5:IsReferenceParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (LONG64)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (LONG64)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (LONG64)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (LONG64)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (LONG64)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (LONG64)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (LONG64)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (LONG64)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (LONG64)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (LONG64)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (LONG64)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 10)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_new_wsa5__FaultCodesType(struct soap *soap, int n)
{
	enum wsa5__FaultCodesType *p;
	enum wsa5__FaultCodesType *a = (enum wsa5__FaultCodesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__FaultCodesType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__FaultCodesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesType(soap, tag ? tag : "wsa5:FaultCodesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (LONG64)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__RelationshipType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_new_wsa5__RelationshipType(struct soap *soap, int n)
{
	enum wsa5__RelationshipType *p;
	enum wsa5__RelationshipType *a = (enum wsa5__RelationshipType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__RelationshipType));
	for (p = a; p && n--; p++)
		soap_default_wsa5__RelationshipType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipType(soap, tag ? tag : "wsa5:RelationshipType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsdd__FaultCodeType[] =
{	{ (LONG64)wsdd__MatchingRuleNotSupported, "wsdd:MatchingRuleNotSupported" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsdd__FaultCodeType2s(struct soap *soap, enum wsdd__FaultCodeType n)
{
	const char *s = soap_code_str(soap_codes_wsdd__FaultCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__FaultCodeType(struct soap *soap, const char *tag, int id, const enum wsdd__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__FaultCodeType), type) || soap_send(soap, soap_wsdd__FaultCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsdd__FaultCodeType(struct soap *soap, const char *s, enum wsdd__FaultCodeType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsdd__FaultCodeType, t);
	if (map)
		*a = (enum wsdd__FaultCodeType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsdd__FaultCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsdd__FaultCodeType * SOAP_FMAC4 soap_in_wsdd__FaultCodeType(struct soap *soap, const char *tag, enum wsdd__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsdd__FaultCodeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__FaultCodeType, sizeof(enum wsdd__FaultCodeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsdd__FaultCodeType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsdd__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__FaultCodeType, SOAP_TYPE_wsdd__FaultCodeType, sizeof(enum wsdd__FaultCodeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsdd__FaultCodeType * SOAP_FMAC4 soap_new_wsdd__FaultCodeType(struct soap *soap, int n)
{
	enum wsdd__FaultCodeType *p;
	enum wsdd__FaultCodeType *a = (enum wsdd__FaultCodeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsdd__FaultCodeType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__FaultCodeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__FaultCodeType(struct soap *soap, const enum wsdd__FaultCodeType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__FaultCodeType(soap, tag ? tag : "wsdd:FaultCodeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsdd__FaultCodeType * SOAP_FMAC4 soap_get_wsdd__FaultCodeType(struct soap *soap, enum wsdd__FaultCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__FaultCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa__FaultSubcodeValues[] =
{	{ (LONG64)wsa__InvalidMessageInformationHeader, "wsa:InvalidMessageInformationHeader" },
	{ (LONG64)wsa__MessageInformationHeaderRequired, "wsa:MessageInformationHeaderRequired" },
	{ (LONG64)wsa__DestinationUnreachable, "wsa:DestinationUnreachable" },
	{ (LONG64)wsa__ActionNotSupported, "wsa:ActionNotSupported" },
	{ (LONG64)wsa__EndpointUnavailable, "wsa:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__FaultSubcodeValues2s(struct soap *soap, enum wsa__FaultSubcodeValues n)
{
	const char *s = soap_code_str(soap_codes_wsa__FaultSubcodeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, int id, const enum wsa__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__FaultSubcodeValues), type) || soap_send(soap, soap_wsa__FaultSubcodeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__FaultSubcodeValues(struct soap *soap, const char *s, enum wsa__FaultSubcodeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa__FaultSubcodeValues, t);
	if (map)
		*a = (enum wsa__FaultSubcodeValues)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__FaultSubcodeValues)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_in_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, enum wsa__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__FaultSubcodeValues*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa__FaultSubcodeValues(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa__FaultSubcodeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__FaultSubcodeValues, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_new_wsa__FaultSubcodeValues(struct soap *soap, int n)
{
	enum wsa__FaultSubcodeValues *p;
	enum wsa__FaultSubcodeValues *a = (enum wsa__FaultSubcodeValues*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa__FaultSubcodeValues));
	for (p = a; p && n--; p++)
		soap_default_wsa__FaultSubcodeValues(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__FaultSubcodeValues(struct soap *soap, const enum wsa__FaultSubcodeValues *a, const char *tag, const char *type)
{
	if (soap_out_wsa__FaultSubcodeValues(soap, tag ? tag : "wsa:FaultSubcodeValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_get_wsa__FaultSubcodeValues(struct soap *soap, enum wsa__FaultSubcodeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__FaultSubcodeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa__RelationshipTypeValues[] =
{	{ (LONG64)wsa__Reply, "wsa:Reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__RelationshipTypeValues2s(struct soap *soap, enum wsa__RelationshipTypeValues n)
{
	const char *s = soap_code_str(soap_codes_wsa__RelationshipTypeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, int id, const enum wsa__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__RelationshipTypeValues), type) || soap_send(soap, soap_wsa__RelationshipTypeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__RelationshipTypeValues(struct soap *soap, const char *s, enum wsa__RelationshipTypeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa__RelationshipTypeValues, t);
	if (map)
		*a = (enum wsa__RelationshipTypeValues)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__RelationshipTypeValues)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_in_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, enum wsa__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__RelationshipTypeValues*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa__RelationshipTypeValues(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa__RelationshipTypeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__RelationshipTypeValues, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_new_wsa__RelationshipTypeValues(struct soap *soap, int n)
{
	enum wsa__RelationshipTypeValues *p;
	enum wsa__RelationshipTypeValues *a = (enum wsa__RelationshipTypeValues*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsa__RelationshipTypeValues));
	for (p = a; p && n--; p++)
		soap_default_wsa__RelationshipTypeValues(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__RelationshipTypeValues(struct soap *soap, const enum wsa__RelationshipTypeValues *a, const char *tag, const char *type)
{
	if (soap_out_wsa__RelationshipTypeValues(soap, tag ? tag : "wsa:RelationshipTypeValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_get_wsa__RelationshipTypeValues(struct soap *soap, enum wsa__RelationshipTypeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelationshipTypeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__GetMetadataSearchResults(struct soap *soap, struct __tse__GetMetadataSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__GetMetadataSearchResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__GetMetadataSearchResults(struct soap *soap, const struct __tse__GetMetadataSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__GetMetadataSearchResults(soap, &a->tse__GetMetadataSearchResults);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__GetMetadataSearchResults(struct soap *soap, const char *tag, int id, const struct __tse__GetMetadataSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__GetMetadataSearchResults(soap, "tse:GetMetadataSearchResults", -1, &a->tse__GetMetadataSearchResults, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetMetadataSearchResults * SOAP_FMAC4 soap_in___tse__GetMetadataSearchResults(struct soap *soap, const char *tag, struct __tse__GetMetadataSearchResults *a, const char *type)
{
	size_t soap_flag_tse__GetMetadataSearchResults = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__GetMetadataSearchResults*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__GetMetadataSearchResults, sizeof(struct __tse__GetMetadataSearchResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__GetMetadataSearchResults(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__GetMetadataSearchResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__GetMetadataSearchResults(soap, "tse:GetMetadataSearchResults", &a->tse__GetMetadataSearchResults, ""))
				{	soap_flag_tse__GetMetadataSearchResults--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__GetMetadataSearchResults * SOAP_FMAC4 soap_new___tse__GetMetadataSearchResults(struct soap *soap, int n)
{
	struct __tse__GetMetadataSearchResults *p;
	struct __tse__GetMetadataSearchResults *a = (struct __tse__GetMetadataSearchResults*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__GetMetadataSearchResults));
	for (p = a; p && n--; p++)
		soap_default___tse__GetMetadataSearchResults(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__GetMetadataSearchResults(struct soap *soap, const struct __tse__GetMetadataSearchResults *a, const char *tag, const char *type)
{
	if (soap_out___tse__GetMetadataSearchResults(soap, tag ? tag : "-tse:GetMetadataSearchResults", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetMetadataSearchResults * SOAP_FMAC4 soap_get___tse__GetMetadataSearchResults(struct soap *soap, struct __tse__GetMetadataSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__GetMetadataSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__FindMetadata(struct soap *soap, struct __tse__FindMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__FindMetadata = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__FindMetadata(struct soap *soap, const struct __tse__FindMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__FindMetadata(soap, &a->tse__FindMetadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__FindMetadata(struct soap *soap, const char *tag, int id, const struct __tse__FindMetadata *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__FindMetadata(soap, "tse:FindMetadata", -1, &a->tse__FindMetadata, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__FindMetadata * SOAP_FMAC4 soap_in___tse__FindMetadata(struct soap *soap, const char *tag, struct __tse__FindMetadata *a, const char *type)
{
	size_t soap_flag_tse__FindMetadata = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__FindMetadata*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__FindMetadata, sizeof(struct __tse__FindMetadata), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__FindMetadata(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__FindMetadata && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__FindMetadata(soap, "tse:FindMetadata", &a->tse__FindMetadata, ""))
				{	soap_flag_tse__FindMetadata--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__FindMetadata * SOAP_FMAC4 soap_new___tse__FindMetadata(struct soap *soap, int n)
{
	struct __tse__FindMetadata *p;
	struct __tse__FindMetadata *a = (struct __tse__FindMetadata*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__FindMetadata));
	for (p = a; p && n--; p++)
		soap_default___tse__FindMetadata(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__FindMetadata(struct soap *soap, const struct __tse__FindMetadata *a, const char *tag, const char *type)
{
	if (soap_out___tse__FindMetadata(soap, tag ? tag : "-tse:FindMetadata", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__FindMetadata * SOAP_FMAC4 soap_get___tse__FindMetadata(struct soap *soap, struct __tse__FindMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__FindMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__EndSearch(struct soap *soap, struct __tse__EndSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__EndSearch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__EndSearch(struct soap *soap, const struct __tse__EndSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__EndSearch(soap, &a->tse__EndSearch);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__EndSearch(struct soap *soap, const char *tag, int id, const struct __tse__EndSearch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__EndSearch(soap, "tse:EndSearch", -1, &a->tse__EndSearch, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__EndSearch * SOAP_FMAC4 soap_in___tse__EndSearch(struct soap *soap, const char *tag, struct __tse__EndSearch *a, const char *type)
{
	size_t soap_flag_tse__EndSearch = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__EndSearch*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__EndSearch, sizeof(struct __tse__EndSearch), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__EndSearch(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__EndSearch && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__EndSearch(soap, "tse:EndSearch", &a->tse__EndSearch, ""))
				{	soap_flag_tse__EndSearch--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__EndSearch * SOAP_FMAC4 soap_new___tse__EndSearch(struct soap *soap, int n)
{
	struct __tse__EndSearch *p;
	struct __tse__EndSearch *a = (struct __tse__EndSearch*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__EndSearch));
	for (p = a; p && n--; p++)
		soap_default___tse__EndSearch(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__EndSearch(struct soap *soap, const struct __tse__EndSearch *a, const char *tag, const char *type)
{
	if (soap_out___tse__EndSearch(soap, tag ? tag : "-tse:EndSearch", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__EndSearch * SOAP_FMAC4 soap_get___tse__EndSearch(struct soap *soap, struct __tse__EndSearch *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__EndSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__GetSearchState(struct soap *soap, struct __tse__GetSearchState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__GetSearchState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__GetSearchState(struct soap *soap, const struct __tse__GetSearchState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__GetSearchState(soap, &a->tse__GetSearchState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__GetSearchState(struct soap *soap, const char *tag, int id, const struct __tse__GetSearchState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__GetSearchState(soap, "tse:GetSearchState", -1, &a->tse__GetSearchState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetSearchState * SOAP_FMAC4 soap_in___tse__GetSearchState(struct soap *soap, const char *tag, struct __tse__GetSearchState *a, const char *type)
{
	size_t soap_flag_tse__GetSearchState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__GetSearchState*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__GetSearchState, sizeof(struct __tse__GetSearchState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__GetSearchState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__GetSearchState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__GetSearchState(soap, "tse:GetSearchState", &a->tse__GetSearchState, ""))
				{	soap_flag_tse__GetSearchState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__GetSearchState * SOAP_FMAC4 soap_new___tse__GetSearchState(struct soap *soap, int n)
{
	struct __tse__GetSearchState *p;
	struct __tse__GetSearchState *a = (struct __tse__GetSearchState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__GetSearchState));
	for (p = a; p && n--; p++)
		soap_default___tse__GetSearchState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__GetSearchState(struct soap *soap, const struct __tse__GetSearchState *a, const char *tag, const char *type)
{
	if (soap_out___tse__GetSearchState(soap, tag ? tag : "-tse:GetSearchState", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetSearchState * SOAP_FMAC4 soap_get___tse__GetSearchState(struct soap *soap, struct __tse__GetSearchState *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__GetSearchState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__GetPTZPositionSearchResults(struct soap *soap, struct __tse__GetPTZPositionSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__GetPTZPositionSearchResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__GetPTZPositionSearchResults(struct soap *soap, const struct __tse__GetPTZPositionSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__GetPTZPositionSearchResults(soap, &a->tse__GetPTZPositionSearchResults);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, int id, const struct __tse__GetPTZPositionSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__GetPTZPositionSearchResults(soap, "tse:GetPTZPositionSearchResults", -1, &a->tse__GetPTZPositionSearchResults, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetPTZPositionSearchResults * SOAP_FMAC4 soap_in___tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, struct __tse__GetPTZPositionSearchResults *a, const char *type)
{
	size_t soap_flag_tse__GetPTZPositionSearchResults = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__GetPTZPositionSearchResults*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__GetPTZPositionSearchResults, sizeof(struct __tse__GetPTZPositionSearchResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__GetPTZPositionSearchResults(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__GetPTZPositionSearchResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__GetPTZPositionSearchResults(soap, "tse:GetPTZPositionSearchResults", &a->tse__GetPTZPositionSearchResults, ""))
				{	soap_flag_tse__GetPTZPositionSearchResults--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__GetPTZPositionSearchResults * SOAP_FMAC4 soap_new___tse__GetPTZPositionSearchResults(struct soap *soap, int n)
{
	struct __tse__GetPTZPositionSearchResults *p;
	struct __tse__GetPTZPositionSearchResults *a = (struct __tse__GetPTZPositionSearchResults*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__GetPTZPositionSearchResults));
	for (p = a; p && n--; p++)
		soap_default___tse__GetPTZPositionSearchResults(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__GetPTZPositionSearchResults(struct soap *soap, const struct __tse__GetPTZPositionSearchResults *a, const char *tag, const char *type)
{
	if (soap_out___tse__GetPTZPositionSearchResults(soap, tag ? tag : "-tse:GetPTZPositionSearchResults", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetPTZPositionSearchResults * SOAP_FMAC4 soap_get___tse__GetPTZPositionSearchResults(struct soap *soap, struct __tse__GetPTZPositionSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__GetPTZPositionSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__FindPTZPosition(struct soap *soap, struct __tse__FindPTZPosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__FindPTZPosition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__FindPTZPosition(struct soap *soap, const struct __tse__FindPTZPosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__FindPTZPosition(soap, &a->tse__FindPTZPosition);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__FindPTZPosition(struct soap *soap, const char *tag, int id, const struct __tse__FindPTZPosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__FindPTZPosition(soap, "tse:FindPTZPosition", -1, &a->tse__FindPTZPosition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__FindPTZPosition * SOAP_FMAC4 soap_in___tse__FindPTZPosition(struct soap *soap, const char *tag, struct __tse__FindPTZPosition *a, const char *type)
{
	size_t soap_flag_tse__FindPTZPosition = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__FindPTZPosition*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__FindPTZPosition, sizeof(struct __tse__FindPTZPosition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__FindPTZPosition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__FindPTZPosition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__FindPTZPosition(soap, "tse:FindPTZPosition", &a->tse__FindPTZPosition, ""))
				{	soap_flag_tse__FindPTZPosition--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__FindPTZPosition * SOAP_FMAC4 soap_new___tse__FindPTZPosition(struct soap *soap, int n)
{
	struct __tse__FindPTZPosition *p;
	struct __tse__FindPTZPosition *a = (struct __tse__FindPTZPosition*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__FindPTZPosition));
	for (p = a; p && n--; p++)
		soap_default___tse__FindPTZPosition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__FindPTZPosition(struct soap *soap, const struct __tse__FindPTZPosition *a, const char *tag, const char *type)
{
	if (soap_out___tse__FindPTZPosition(soap, tag ? tag : "-tse:FindPTZPosition", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__FindPTZPosition * SOAP_FMAC4 soap_get___tse__FindPTZPosition(struct soap *soap, struct __tse__FindPTZPosition *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__FindPTZPosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__GetEventSearchResults(struct soap *soap, struct __tse__GetEventSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__GetEventSearchResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__GetEventSearchResults(struct soap *soap, const struct __tse__GetEventSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__GetEventSearchResults(soap, &a->tse__GetEventSearchResults);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__GetEventSearchResults(struct soap *soap, const char *tag, int id, const struct __tse__GetEventSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__GetEventSearchResults(soap, "tse:GetEventSearchResults", -1, &a->tse__GetEventSearchResults, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetEventSearchResults * SOAP_FMAC4 soap_in___tse__GetEventSearchResults(struct soap *soap, const char *tag, struct __tse__GetEventSearchResults *a, const char *type)
{
	size_t soap_flag_tse__GetEventSearchResults = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__GetEventSearchResults*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__GetEventSearchResults, sizeof(struct __tse__GetEventSearchResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__GetEventSearchResults(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__GetEventSearchResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__GetEventSearchResults(soap, "tse:GetEventSearchResults", &a->tse__GetEventSearchResults, ""))
				{	soap_flag_tse__GetEventSearchResults--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__GetEventSearchResults * SOAP_FMAC4 soap_new___tse__GetEventSearchResults(struct soap *soap, int n)
{
	struct __tse__GetEventSearchResults *p;
	struct __tse__GetEventSearchResults *a = (struct __tse__GetEventSearchResults*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__GetEventSearchResults));
	for (p = a; p && n--; p++)
		soap_default___tse__GetEventSearchResults(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__GetEventSearchResults(struct soap *soap, const struct __tse__GetEventSearchResults *a, const char *tag, const char *type)
{
	if (soap_out___tse__GetEventSearchResults(soap, tag ? tag : "-tse:GetEventSearchResults", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetEventSearchResults * SOAP_FMAC4 soap_get___tse__GetEventSearchResults(struct soap *soap, struct __tse__GetEventSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__GetEventSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__FindEvents(struct soap *soap, struct __tse__FindEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__FindEvents = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__FindEvents(struct soap *soap, const struct __tse__FindEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__FindEvents(soap, &a->tse__FindEvents);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__FindEvents(struct soap *soap, const char *tag, int id, const struct __tse__FindEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__FindEvents(soap, "tse:FindEvents", -1, &a->tse__FindEvents, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__FindEvents * SOAP_FMAC4 soap_in___tse__FindEvents(struct soap *soap, const char *tag, struct __tse__FindEvents *a, const char *type)
{
	size_t soap_flag_tse__FindEvents = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__FindEvents*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__FindEvents, sizeof(struct __tse__FindEvents), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__FindEvents(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__FindEvents && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__FindEvents(soap, "tse:FindEvents", &a->tse__FindEvents, ""))
				{	soap_flag_tse__FindEvents--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__FindEvents * SOAP_FMAC4 soap_new___tse__FindEvents(struct soap *soap, int n)
{
	struct __tse__FindEvents *p;
	struct __tse__FindEvents *a = (struct __tse__FindEvents*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__FindEvents));
	for (p = a; p && n--; p++)
		soap_default___tse__FindEvents(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__FindEvents(struct soap *soap, const struct __tse__FindEvents *a, const char *tag, const char *type)
{
	if (soap_out___tse__FindEvents(soap, tag ? tag : "-tse:FindEvents", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__FindEvents * SOAP_FMAC4 soap_get___tse__FindEvents(struct soap *soap, struct __tse__FindEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__FindEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__GetRecordingSearchResults(struct soap *soap, struct __tse__GetRecordingSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__GetRecordingSearchResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__GetRecordingSearchResults(struct soap *soap, const struct __tse__GetRecordingSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__GetRecordingSearchResults(soap, &a->tse__GetRecordingSearchResults);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__GetRecordingSearchResults(struct soap *soap, const char *tag, int id, const struct __tse__GetRecordingSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__GetRecordingSearchResults(soap, "tse:GetRecordingSearchResults", -1, &a->tse__GetRecordingSearchResults, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetRecordingSearchResults * SOAP_FMAC4 soap_in___tse__GetRecordingSearchResults(struct soap *soap, const char *tag, struct __tse__GetRecordingSearchResults *a, const char *type)
{
	size_t soap_flag_tse__GetRecordingSearchResults = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__GetRecordingSearchResults*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__GetRecordingSearchResults, sizeof(struct __tse__GetRecordingSearchResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__GetRecordingSearchResults(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__GetRecordingSearchResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__GetRecordingSearchResults(soap, "tse:GetRecordingSearchResults", &a->tse__GetRecordingSearchResults, ""))
				{	soap_flag_tse__GetRecordingSearchResults--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__GetRecordingSearchResults * SOAP_FMAC4 soap_new___tse__GetRecordingSearchResults(struct soap *soap, int n)
{
	struct __tse__GetRecordingSearchResults *p;
	struct __tse__GetRecordingSearchResults *a = (struct __tse__GetRecordingSearchResults*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__GetRecordingSearchResults));
	for (p = a; p && n--; p++)
		soap_default___tse__GetRecordingSearchResults(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__GetRecordingSearchResults(struct soap *soap, const struct __tse__GetRecordingSearchResults *a, const char *tag, const char *type)
{
	if (soap_out___tse__GetRecordingSearchResults(soap, tag ? tag : "-tse:GetRecordingSearchResults", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetRecordingSearchResults * SOAP_FMAC4 soap_get___tse__GetRecordingSearchResults(struct soap *soap, struct __tse__GetRecordingSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__GetRecordingSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__FindRecordings(struct soap *soap, struct __tse__FindRecordings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__FindRecordings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__FindRecordings(struct soap *soap, const struct __tse__FindRecordings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__FindRecordings(soap, &a->tse__FindRecordings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__FindRecordings(struct soap *soap, const char *tag, int id, const struct __tse__FindRecordings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__FindRecordings(soap, "tse:FindRecordings", -1, &a->tse__FindRecordings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__FindRecordings * SOAP_FMAC4 soap_in___tse__FindRecordings(struct soap *soap, const char *tag, struct __tse__FindRecordings *a, const char *type)
{
	size_t soap_flag_tse__FindRecordings = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__FindRecordings*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__FindRecordings, sizeof(struct __tse__FindRecordings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__FindRecordings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__FindRecordings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__FindRecordings(soap, "tse:FindRecordings", &a->tse__FindRecordings, ""))
				{	soap_flag_tse__FindRecordings--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__FindRecordings * SOAP_FMAC4 soap_new___tse__FindRecordings(struct soap *soap, int n)
{
	struct __tse__FindRecordings *p;
	struct __tse__FindRecordings *a = (struct __tse__FindRecordings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__FindRecordings));
	for (p = a; p && n--; p++)
		soap_default___tse__FindRecordings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__FindRecordings(struct soap *soap, const struct __tse__FindRecordings *a, const char *tag, const char *type)
{
	if (soap_out___tse__FindRecordings(soap, tag ? tag : "-tse:FindRecordings", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__FindRecordings * SOAP_FMAC4 soap_get___tse__FindRecordings(struct soap *soap, struct __tse__FindRecordings *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__FindRecordings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__GetMediaAttributes(struct soap *soap, struct __tse__GetMediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__GetMediaAttributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__GetMediaAttributes(struct soap *soap, const struct __tse__GetMediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__GetMediaAttributes(soap, &a->tse__GetMediaAttributes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__GetMediaAttributes(struct soap *soap, const char *tag, int id, const struct __tse__GetMediaAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__GetMediaAttributes(soap, "tse:GetMediaAttributes", -1, &a->tse__GetMediaAttributes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetMediaAttributes * SOAP_FMAC4 soap_in___tse__GetMediaAttributes(struct soap *soap, const char *tag, struct __tse__GetMediaAttributes *a, const char *type)
{
	size_t soap_flag_tse__GetMediaAttributes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__GetMediaAttributes*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__GetMediaAttributes, sizeof(struct __tse__GetMediaAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__GetMediaAttributes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__GetMediaAttributes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__GetMediaAttributes(soap, "tse:GetMediaAttributes", &a->tse__GetMediaAttributes, ""))
				{	soap_flag_tse__GetMediaAttributes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__GetMediaAttributes * SOAP_FMAC4 soap_new___tse__GetMediaAttributes(struct soap *soap, int n)
{
	struct __tse__GetMediaAttributes *p;
	struct __tse__GetMediaAttributes *a = (struct __tse__GetMediaAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__GetMediaAttributes));
	for (p = a; p && n--; p++)
		soap_default___tse__GetMediaAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__GetMediaAttributes(struct soap *soap, const struct __tse__GetMediaAttributes *a, const char *tag, const char *type)
{
	if (soap_out___tse__GetMediaAttributes(soap, tag ? tag : "-tse:GetMediaAttributes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetMediaAttributes * SOAP_FMAC4 soap_get___tse__GetMediaAttributes(struct soap *soap, struct __tse__GetMediaAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__GetMediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__GetRecordingInformation(struct soap *soap, struct __tse__GetRecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__GetRecordingInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__GetRecordingInformation(struct soap *soap, const struct __tse__GetRecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__GetRecordingInformation(soap, &a->tse__GetRecordingInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__GetRecordingInformation(struct soap *soap, const char *tag, int id, const struct __tse__GetRecordingInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__GetRecordingInformation(soap, "tse:GetRecordingInformation", -1, &a->tse__GetRecordingInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetRecordingInformation * SOAP_FMAC4 soap_in___tse__GetRecordingInformation(struct soap *soap, const char *tag, struct __tse__GetRecordingInformation *a, const char *type)
{
	size_t soap_flag_tse__GetRecordingInformation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__GetRecordingInformation*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__GetRecordingInformation, sizeof(struct __tse__GetRecordingInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__GetRecordingInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__GetRecordingInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__GetRecordingInformation(soap, "tse:GetRecordingInformation", &a->tse__GetRecordingInformation, ""))
				{	soap_flag_tse__GetRecordingInformation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__GetRecordingInformation * SOAP_FMAC4 soap_new___tse__GetRecordingInformation(struct soap *soap, int n)
{
	struct __tse__GetRecordingInformation *p;
	struct __tse__GetRecordingInformation *a = (struct __tse__GetRecordingInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__GetRecordingInformation));
	for (p = a; p && n--; p++)
		soap_default___tse__GetRecordingInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__GetRecordingInformation(struct soap *soap, const struct __tse__GetRecordingInformation *a, const char *tag, const char *type)
{
	if (soap_out___tse__GetRecordingInformation(soap, tag ? tag : "-tse:GetRecordingInformation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetRecordingInformation * SOAP_FMAC4 soap_get___tse__GetRecordingInformation(struct soap *soap, struct __tse__GetRecordingInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__GetRecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__GetRecordingSummary(struct soap *soap, struct __tse__GetRecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__GetRecordingSummary = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__GetRecordingSummary(struct soap *soap, const struct __tse__GetRecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__GetRecordingSummary(soap, &a->tse__GetRecordingSummary);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__GetRecordingSummary(struct soap *soap, const char *tag, int id, const struct __tse__GetRecordingSummary *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__GetRecordingSummary(soap, "tse:GetRecordingSummary", -1, &a->tse__GetRecordingSummary, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetRecordingSummary * SOAP_FMAC4 soap_in___tse__GetRecordingSummary(struct soap *soap, const char *tag, struct __tse__GetRecordingSummary *a, const char *type)
{
	size_t soap_flag_tse__GetRecordingSummary = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__GetRecordingSummary*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__GetRecordingSummary, sizeof(struct __tse__GetRecordingSummary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__GetRecordingSummary(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__GetRecordingSummary && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__GetRecordingSummary(soap, "tse:GetRecordingSummary", &a->tse__GetRecordingSummary, ""))
				{	soap_flag_tse__GetRecordingSummary--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__GetRecordingSummary * SOAP_FMAC4 soap_new___tse__GetRecordingSummary(struct soap *soap, int n)
{
	struct __tse__GetRecordingSummary *p;
	struct __tse__GetRecordingSummary *a = (struct __tse__GetRecordingSummary*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__GetRecordingSummary));
	for (p = a; p && n--; p++)
		soap_default___tse__GetRecordingSummary(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__GetRecordingSummary(struct soap *soap, const struct __tse__GetRecordingSummary *a, const char *tag, const char *type)
{
	if (soap_out___tse__GetRecordingSummary(soap, tag ? tag : "-tse:GetRecordingSummary", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetRecordingSummary * SOAP_FMAC4 soap_get___tse__GetRecordingSummary(struct soap *soap, struct __tse__GetRecordingSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__GetRecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tse__GetServiceCapabilities(struct soap *soap, struct __tse__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tse__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tse__GetServiceCapabilities(struct soap *soap, const struct __tse__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tse__GetServiceCapabilities(soap, &a->tse__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tse__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tse__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tse__GetServiceCapabilities(soap, "tse:GetServiceCapabilities", -1, &a->tse__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetServiceCapabilities * SOAP_FMAC4 soap_in___tse__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tse__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tse__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tse__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tse__GetServiceCapabilities, sizeof(struct __tse__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tse__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tse__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tse__GetServiceCapabilities(soap, "tse:GetServiceCapabilities", &a->tse__GetServiceCapabilities, ""))
				{	soap_flag_tse__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tse__GetServiceCapabilities * SOAP_FMAC4 soap_new___tse__GetServiceCapabilities(struct soap *soap, int n)
{
	struct __tse__GetServiceCapabilities *p;
	struct __tse__GetServiceCapabilities *a = (struct __tse__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tse__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default___tse__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tse__GetServiceCapabilities(struct soap *soap, const struct __tse__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tse__GetServiceCapabilities(soap, tag ? tag : "-tse:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tse__GetServiceCapabilities * SOAP_FMAC4 soap_get___tse__GetServiceCapabilities(struct soap *soap, struct __tse__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tse__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trv__GetReceiverState(struct soap *soap, struct __trv__GetReceiverState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trv__GetReceiverState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trv__GetReceiverState(struct soap *soap, const struct __trv__GetReceiverState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trv__GetReceiverState(soap, &a->trv__GetReceiverState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trv__GetReceiverState(struct soap *soap, const char *tag, int id, const struct __trv__GetReceiverState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trv__GetReceiverState(soap, "trv:GetReceiverState", -1, &a->trv__GetReceiverState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__GetReceiverState * SOAP_FMAC4 soap_in___trv__GetReceiverState(struct soap *soap, const char *tag, struct __trv__GetReceiverState *a, const char *type)
{
	size_t soap_flag_trv__GetReceiverState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trv__GetReceiverState*)soap_id_enter(soap, "", a, SOAP_TYPE___trv__GetReceiverState, sizeof(struct __trv__GetReceiverState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trv__GetReceiverState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trv__GetReceiverState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trv__GetReceiverState(soap, "trv:GetReceiverState", &a->trv__GetReceiverState, ""))
				{	soap_flag_trv__GetReceiverState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trv__GetReceiverState * SOAP_FMAC4 soap_new___trv__GetReceiverState(struct soap *soap, int n)
{
	struct __trv__GetReceiverState *p;
	struct __trv__GetReceiverState *a = (struct __trv__GetReceiverState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trv__GetReceiverState));
	for (p = a; p && n--; p++)
		soap_default___trv__GetReceiverState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trv__GetReceiverState(struct soap *soap, const struct __trv__GetReceiverState *a, const char *tag, const char *type)
{
	if (soap_out___trv__GetReceiverState(soap, tag ? tag : "-trv:GetReceiverState", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__GetReceiverState * SOAP_FMAC4 soap_get___trv__GetReceiverState(struct soap *soap, struct __trv__GetReceiverState *p, const char *tag, const char *type)
{
	if ((p = soap_in___trv__GetReceiverState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trv__SetReceiverMode(struct soap *soap, struct __trv__SetReceiverMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trv__SetReceiverMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trv__SetReceiverMode(struct soap *soap, const struct __trv__SetReceiverMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trv__SetReceiverMode(soap, &a->trv__SetReceiverMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trv__SetReceiverMode(struct soap *soap, const char *tag, int id, const struct __trv__SetReceiverMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trv__SetReceiverMode(soap, "trv:SetReceiverMode", -1, &a->trv__SetReceiverMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__SetReceiverMode * SOAP_FMAC4 soap_in___trv__SetReceiverMode(struct soap *soap, const char *tag, struct __trv__SetReceiverMode *a, const char *type)
{
	size_t soap_flag_trv__SetReceiverMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trv__SetReceiverMode*)soap_id_enter(soap, "", a, SOAP_TYPE___trv__SetReceiverMode, sizeof(struct __trv__SetReceiverMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trv__SetReceiverMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trv__SetReceiverMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trv__SetReceiverMode(soap, "trv:SetReceiverMode", &a->trv__SetReceiverMode, ""))
				{	soap_flag_trv__SetReceiverMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trv__SetReceiverMode * SOAP_FMAC4 soap_new___trv__SetReceiverMode(struct soap *soap, int n)
{
	struct __trv__SetReceiverMode *p;
	struct __trv__SetReceiverMode *a = (struct __trv__SetReceiverMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trv__SetReceiverMode));
	for (p = a; p && n--; p++)
		soap_default___trv__SetReceiverMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trv__SetReceiverMode(struct soap *soap, const struct __trv__SetReceiverMode *a, const char *tag, const char *type)
{
	if (soap_out___trv__SetReceiverMode(soap, tag ? tag : "-trv:SetReceiverMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__SetReceiverMode * SOAP_FMAC4 soap_get___trv__SetReceiverMode(struct soap *soap, struct __trv__SetReceiverMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___trv__SetReceiverMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trv__ConfigureReceiver(struct soap *soap, struct __trv__ConfigureReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trv__ConfigureReceiver = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trv__ConfigureReceiver(struct soap *soap, const struct __trv__ConfigureReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trv__ConfigureReceiver(soap, &a->trv__ConfigureReceiver);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trv__ConfigureReceiver(struct soap *soap, const char *tag, int id, const struct __trv__ConfigureReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trv__ConfigureReceiver(soap, "trv:ConfigureReceiver", -1, &a->trv__ConfigureReceiver, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__ConfigureReceiver * SOAP_FMAC4 soap_in___trv__ConfigureReceiver(struct soap *soap, const char *tag, struct __trv__ConfigureReceiver *a, const char *type)
{
	size_t soap_flag_trv__ConfigureReceiver = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trv__ConfigureReceiver*)soap_id_enter(soap, "", a, SOAP_TYPE___trv__ConfigureReceiver, sizeof(struct __trv__ConfigureReceiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trv__ConfigureReceiver(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trv__ConfigureReceiver && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trv__ConfigureReceiver(soap, "trv:ConfigureReceiver", &a->trv__ConfigureReceiver, ""))
				{	soap_flag_trv__ConfigureReceiver--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trv__ConfigureReceiver * SOAP_FMAC4 soap_new___trv__ConfigureReceiver(struct soap *soap, int n)
{
	struct __trv__ConfigureReceiver *p;
	struct __trv__ConfigureReceiver *a = (struct __trv__ConfigureReceiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trv__ConfigureReceiver));
	for (p = a; p && n--; p++)
		soap_default___trv__ConfigureReceiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trv__ConfigureReceiver(struct soap *soap, const struct __trv__ConfigureReceiver *a, const char *tag, const char *type)
{
	if (soap_out___trv__ConfigureReceiver(soap, tag ? tag : "-trv:ConfigureReceiver", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__ConfigureReceiver * SOAP_FMAC4 soap_get___trv__ConfigureReceiver(struct soap *soap, struct __trv__ConfigureReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in___trv__ConfigureReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trv__DeleteReceiver(struct soap *soap, struct __trv__DeleteReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trv__DeleteReceiver = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trv__DeleteReceiver(struct soap *soap, const struct __trv__DeleteReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trv__DeleteReceiver(soap, &a->trv__DeleteReceiver);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trv__DeleteReceiver(struct soap *soap, const char *tag, int id, const struct __trv__DeleteReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trv__DeleteReceiver(soap, "trv:DeleteReceiver", -1, &a->trv__DeleteReceiver, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__DeleteReceiver * SOAP_FMAC4 soap_in___trv__DeleteReceiver(struct soap *soap, const char *tag, struct __trv__DeleteReceiver *a, const char *type)
{
	size_t soap_flag_trv__DeleteReceiver = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trv__DeleteReceiver*)soap_id_enter(soap, "", a, SOAP_TYPE___trv__DeleteReceiver, sizeof(struct __trv__DeleteReceiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trv__DeleteReceiver(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trv__DeleteReceiver && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trv__DeleteReceiver(soap, "trv:DeleteReceiver", &a->trv__DeleteReceiver, ""))
				{	soap_flag_trv__DeleteReceiver--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trv__DeleteReceiver * SOAP_FMAC4 soap_new___trv__DeleteReceiver(struct soap *soap, int n)
{
	struct __trv__DeleteReceiver *p;
	struct __trv__DeleteReceiver *a = (struct __trv__DeleteReceiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trv__DeleteReceiver));
	for (p = a; p && n--; p++)
		soap_default___trv__DeleteReceiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trv__DeleteReceiver(struct soap *soap, const struct __trv__DeleteReceiver *a, const char *tag, const char *type)
{
	if (soap_out___trv__DeleteReceiver(soap, tag ? tag : "-trv:DeleteReceiver", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__DeleteReceiver * SOAP_FMAC4 soap_get___trv__DeleteReceiver(struct soap *soap, struct __trv__DeleteReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in___trv__DeleteReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trv__CreateReceiver(struct soap *soap, struct __trv__CreateReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trv__CreateReceiver = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trv__CreateReceiver(struct soap *soap, const struct __trv__CreateReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trv__CreateReceiver(soap, &a->trv__CreateReceiver);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trv__CreateReceiver(struct soap *soap, const char *tag, int id, const struct __trv__CreateReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trv__CreateReceiver(soap, "trv:CreateReceiver", -1, &a->trv__CreateReceiver, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__CreateReceiver * SOAP_FMAC4 soap_in___trv__CreateReceiver(struct soap *soap, const char *tag, struct __trv__CreateReceiver *a, const char *type)
{
	size_t soap_flag_trv__CreateReceiver = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trv__CreateReceiver*)soap_id_enter(soap, "", a, SOAP_TYPE___trv__CreateReceiver, sizeof(struct __trv__CreateReceiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trv__CreateReceiver(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trv__CreateReceiver && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trv__CreateReceiver(soap, "trv:CreateReceiver", &a->trv__CreateReceiver, ""))
				{	soap_flag_trv__CreateReceiver--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trv__CreateReceiver * SOAP_FMAC4 soap_new___trv__CreateReceiver(struct soap *soap, int n)
{
	struct __trv__CreateReceiver *p;
	struct __trv__CreateReceiver *a = (struct __trv__CreateReceiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trv__CreateReceiver));
	for (p = a; p && n--; p++)
		soap_default___trv__CreateReceiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trv__CreateReceiver(struct soap *soap, const struct __trv__CreateReceiver *a, const char *tag, const char *type)
{
	if (soap_out___trv__CreateReceiver(soap, tag ? tag : "-trv:CreateReceiver", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__CreateReceiver * SOAP_FMAC4 soap_get___trv__CreateReceiver(struct soap *soap, struct __trv__CreateReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in___trv__CreateReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trv__GetReceiver(struct soap *soap, struct __trv__GetReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trv__GetReceiver = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trv__GetReceiver(struct soap *soap, const struct __trv__GetReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trv__GetReceiver(soap, &a->trv__GetReceiver);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trv__GetReceiver(struct soap *soap, const char *tag, int id, const struct __trv__GetReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trv__GetReceiver(soap, "trv:GetReceiver", -1, &a->trv__GetReceiver, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__GetReceiver * SOAP_FMAC4 soap_in___trv__GetReceiver(struct soap *soap, const char *tag, struct __trv__GetReceiver *a, const char *type)
{
	size_t soap_flag_trv__GetReceiver = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trv__GetReceiver*)soap_id_enter(soap, "", a, SOAP_TYPE___trv__GetReceiver, sizeof(struct __trv__GetReceiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trv__GetReceiver(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trv__GetReceiver && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trv__GetReceiver(soap, "trv:GetReceiver", &a->trv__GetReceiver, ""))
				{	soap_flag_trv__GetReceiver--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trv__GetReceiver * SOAP_FMAC4 soap_new___trv__GetReceiver(struct soap *soap, int n)
{
	struct __trv__GetReceiver *p;
	struct __trv__GetReceiver *a = (struct __trv__GetReceiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trv__GetReceiver));
	for (p = a; p && n--; p++)
		soap_default___trv__GetReceiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trv__GetReceiver(struct soap *soap, const struct __trv__GetReceiver *a, const char *tag, const char *type)
{
	if (soap_out___trv__GetReceiver(soap, tag ? tag : "-trv:GetReceiver", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__GetReceiver * SOAP_FMAC4 soap_get___trv__GetReceiver(struct soap *soap, struct __trv__GetReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in___trv__GetReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trv__GetReceivers(struct soap *soap, struct __trv__GetReceivers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trv__GetReceivers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trv__GetReceivers(struct soap *soap, const struct __trv__GetReceivers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trv__GetReceivers(soap, &a->trv__GetReceivers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trv__GetReceivers(struct soap *soap, const char *tag, int id, const struct __trv__GetReceivers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trv__GetReceivers(soap, "trv:GetReceivers", -1, &a->trv__GetReceivers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__GetReceivers * SOAP_FMAC4 soap_in___trv__GetReceivers(struct soap *soap, const char *tag, struct __trv__GetReceivers *a, const char *type)
{
	size_t soap_flag_trv__GetReceivers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trv__GetReceivers*)soap_id_enter(soap, "", a, SOAP_TYPE___trv__GetReceivers, sizeof(struct __trv__GetReceivers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trv__GetReceivers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trv__GetReceivers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trv__GetReceivers(soap, "trv:GetReceivers", &a->trv__GetReceivers, ""))
				{	soap_flag_trv__GetReceivers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trv__GetReceivers * SOAP_FMAC4 soap_new___trv__GetReceivers(struct soap *soap, int n)
{
	struct __trv__GetReceivers *p;
	struct __trv__GetReceivers *a = (struct __trv__GetReceivers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trv__GetReceivers));
	for (p = a; p && n--; p++)
		soap_default___trv__GetReceivers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trv__GetReceivers(struct soap *soap, const struct __trv__GetReceivers *a, const char *tag, const char *type)
{
	if (soap_out___trv__GetReceivers(soap, tag ? tag : "-trv:GetReceivers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__GetReceivers * SOAP_FMAC4 soap_get___trv__GetReceivers(struct soap *soap, struct __trv__GetReceivers *p, const char *tag, const char *type)
{
	if ((p = soap_in___trv__GetReceivers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trv__GetServiceCapabilities(struct soap *soap, struct __trv__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trv__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trv__GetServiceCapabilities(struct soap *soap, const struct __trv__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trv__GetServiceCapabilities(soap, &a->trv__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trv__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __trv__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trv__GetServiceCapabilities(soap, "trv:GetServiceCapabilities", -1, &a->trv__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__GetServiceCapabilities * SOAP_FMAC4 soap_in___trv__GetServiceCapabilities(struct soap *soap, const char *tag, struct __trv__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_trv__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trv__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___trv__GetServiceCapabilities, sizeof(struct __trv__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trv__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trv__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trv__GetServiceCapabilities(soap, "trv:GetServiceCapabilities", &a->trv__GetServiceCapabilities, ""))
				{	soap_flag_trv__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trv__GetServiceCapabilities * SOAP_FMAC4 soap_new___trv__GetServiceCapabilities(struct soap *soap, int n)
{
	struct __trv__GetServiceCapabilities *p;
	struct __trv__GetServiceCapabilities *a = (struct __trv__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trv__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default___trv__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trv__GetServiceCapabilities(struct soap *soap, const struct __trv__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___trv__GetServiceCapabilities(soap, tag ? tag : "-trv:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trv__GetServiceCapabilities * SOAP_FMAC4 soap_get___trv__GetServiceCapabilities(struct soap *soap, struct __trv__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___trv__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__DeleteOSD(struct soap *soap, struct __trt__DeleteOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__DeleteOSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__DeleteOSD(struct soap *soap, const struct __trt__DeleteOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__DeleteOSD(soap, &a->trt__DeleteOSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__DeleteOSD(struct soap *soap, const char *tag, int id, const struct __trt__DeleteOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__DeleteOSD(soap, "trt:DeleteOSD", -1, &a->trt__DeleteOSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__DeleteOSD * SOAP_FMAC4 soap_in___trt__DeleteOSD(struct soap *soap, const char *tag, struct __trt__DeleteOSD *a, const char *type)
{
	size_t soap_flag_trt__DeleteOSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__DeleteOSD*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__DeleteOSD, sizeof(struct __trt__DeleteOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__DeleteOSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__DeleteOSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__DeleteOSD(soap, "trt:DeleteOSD", &a->trt__DeleteOSD, ""))
				{	soap_flag_trt__DeleteOSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__DeleteOSD * SOAP_FMAC4 soap_new___trt__DeleteOSD(struct soap *soap, int n)
{
	struct __trt__DeleteOSD *p;
	struct __trt__DeleteOSD *a = (struct __trt__DeleteOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__DeleteOSD));
	for (p = a; p && n--; p++)
		soap_default___trt__DeleteOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__DeleteOSD(struct soap *soap, const struct __trt__DeleteOSD *a, const char *tag, const char *type)
{
	if (soap_out___trt__DeleteOSD(soap, tag ? tag : "-trt:DeleteOSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__DeleteOSD * SOAP_FMAC4 soap_get___trt__DeleteOSD(struct soap *soap, struct __trt__DeleteOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__DeleteOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__CreateOSD(struct soap *soap, struct __trt__CreateOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__CreateOSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__CreateOSD(struct soap *soap, const struct __trt__CreateOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__CreateOSD(soap, &a->trt__CreateOSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__CreateOSD(struct soap *soap, const char *tag, int id, const struct __trt__CreateOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__CreateOSD(soap, "trt:CreateOSD", -1, &a->trt__CreateOSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__CreateOSD * SOAP_FMAC4 soap_in___trt__CreateOSD(struct soap *soap, const char *tag, struct __trt__CreateOSD *a, const char *type)
{
	size_t soap_flag_trt__CreateOSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__CreateOSD*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__CreateOSD, sizeof(struct __trt__CreateOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__CreateOSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__CreateOSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__CreateOSD(soap, "trt:CreateOSD", &a->trt__CreateOSD, ""))
				{	soap_flag_trt__CreateOSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__CreateOSD * SOAP_FMAC4 soap_new___trt__CreateOSD(struct soap *soap, int n)
{
	struct __trt__CreateOSD *p;
	struct __trt__CreateOSD *a = (struct __trt__CreateOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__CreateOSD));
	for (p = a; p && n--; p++)
		soap_default___trt__CreateOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__CreateOSD(struct soap *soap, const struct __trt__CreateOSD *a, const char *tag, const char *type)
{
	if (soap_out___trt__CreateOSD(soap, tag ? tag : "-trt:CreateOSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__CreateOSD * SOAP_FMAC4 soap_get___trt__CreateOSD(struct soap *soap, struct __trt__CreateOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__CreateOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetOSD(struct soap *soap, struct __trt__SetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetOSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetOSD(struct soap *soap, const struct __trt__SetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetOSD(soap, &a->trt__SetOSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetOSD(struct soap *soap, const char *tag, int id, const struct __trt__SetOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetOSD(soap, "trt:SetOSD", -1, &a->trt__SetOSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetOSD * SOAP_FMAC4 soap_in___trt__SetOSD(struct soap *soap, const char *tag, struct __trt__SetOSD *a, const char *type)
{
	size_t soap_flag_trt__SetOSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetOSD*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetOSD, sizeof(struct __trt__SetOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetOSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetOSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetOSD(soap, "trt:SetOSD", &a->trt__SetOSD, ""))
				{	soap_flag_trt__SetOSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetOSD * SOAP_FMAC4 soap_new___trt__SetOSD(struct soap *soap, int n)
{
	struct __trt__SetOSD *p;
	struct __trt__SetOSD *a = (struct __trt__SetOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetOSD));
	for (p = a; p && n--; p++)
		soap_default___trt__SetOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetOSD(struct soap *soap, const struct __trt__SetOSD *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetOSD(soap, tag ? tag : "-trt:SetOSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetOSD * SOAP_FMAC4 soap_get___trt__SetOSD(struct soap *soap, struct __trt__SetOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetOSDOptions(struct soap *soap, struct __trt__GetOSDOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetOSDOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetOSDOptions(struct soap *soap, const struct __trt__GetOSDOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetOSDOptions(soap, &a->trt__GetOSDOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetOSDOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetOSDOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetOSDOptions(soap, "trt:GetOSDOptions", -1, &a->trt__GetOSDOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSDOptions * SOAP_FMAC4 soap_in___trt__GetOSDOptions(struct soap *soap, const char *tag, struct __trt__GetOSDOptions *a, const char *type)
{
	size_t soap_flag_trt__GetOSDOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetOSDOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetOSDOptions, sizeof(struct __trt__GetOSDOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetOSDOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetOSDOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetOSDOptions(soap, "trt:GetOSDOptions", &a->trt__GetOSDOptions, ""))
				{	soap_flag_trt__GetOSDOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetOSDOptions * SOAP_FMAC4 soap_new___trt__GetOSDOptions(struct soap *soap, int n)
{
	struct __trt__GetOSDOptions *p;
	struct __trt__GetOSDOptions *a = (struct __trt__GetOSDOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetOSDOptions));
	for (p = a; p && n--; p++)
		soap_default___trt__GetOSDOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetOSDOptions(struct soap *soap, const struct __trt__GetOSDOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetOSDOptions(soap, tag ? tag : "-trt:GetOSDOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSDOptions * SOAP_FMAC4 soap_get___trt__GetOSDOptions(struct soap *soap, struct __trt__GetOSDOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetOSDOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetOSD(struct soap *soap, struct __trt__GetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetOSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetOSD(struct soap *soap, const struct __trt__GetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetOSD(soap, &a->trt__GetOSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetOSD(struct soap *soap, const char *tag, int id, const struct __trt__GetOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetOSD(soap, "trt:GetOSD", -1, &a->trt__GetOSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSD * SOAP_FMAC4 soap_in___trt__GetOSD(struct soap *soap, const char *tag, struct __trt__GetOSD *a, const char *type)
{
	size_t soap_flag_trt__GetOSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetOSD*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetOSD, sizeof(struct __trt__GetOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetOSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetOSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetOSD(soap, "trt:GetOSD", &a->trt__GetOSD, ""))
				{	soap_flag_trt__GetOSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetOSD * SOAP_FMAC4 soap_new___trt__GetOSD(struct soap *soap, int n)
{
	struct __trt__GetOSD *p;
	struct __trt__GetOSD *a = (struct __trt__GetOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetOSD));
	for (p = a; p && n--; p++)
		soap_default___trt__GetOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetOSD(struct soap *soap, const struct __trt__GetOSD *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetOSD(soap, tag ? tag : "-trt:GetOSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSD * SOAP_FMAC4 soap_get___trt__GetOSD(struct soap *soap, struct __trt__GetOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetOSDs(struct soap *soap, struct __trt__GetOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetOSDs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetOSDs(struct soap *soap, const struct __trt__GetOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetOSDs(soap, &a->trt__GetOSDs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetOSDs(struct soap *soap, const char *tag, int id, const struct __trt__GetOSDs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetOSDs(soap, "trt:GetOSDs", -1, &a->trt__GetOSDs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSDs * SOAP_FMAC4 soap_in___trt__GetOSDs(struct soap *soap, const char *tag, struct __trt__GetOSDs *a, const char *type)
{
	size_t soap_flag_trt__GetOSDs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetOSDs*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetOSDs, sizeof(struct __trt__GetOSDs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetOSDs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetOSDs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetOSDs(soap, "trt:GetOSDs", &a->trt__GetOSDs, ""))
				{	soap_flag_trt__GetOSDs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetOSDs * SOAP_FMAC4 soap_new___trt__GetOSDs(struct soap *soap, int n)
{
	struct __trt__GetOSDs *p;
	struct __trt__GetOSDs *a = (struct __trt__GetOSDs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetOSDs));
	for (p = a; p && n--; p++)
		soap_default___trt__GetOSDs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetOSDs(struct soap *soap, const struct __trt__GetOSDs *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetOSDs(soap, tag ? tag : "-trt:GetOSDs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSDs * SOAP_FMAC4 soap_get___trt__GetOSDs(struct soap *soap, struct __trt__GetOSDs *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoSourceMode(struct soap *soap, struct __trt__SetVideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoSourceMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoSourceMode(struct soap *soap, const struct __trt__SetVideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetVideoSourceMode(soap, &a->trt__SetVideoSourceMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoSourceMode(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoSourceMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetVideoSourceMode(soap, "trt:SetVideoSourceMode", -1, &a->trt__SetVideoSourceMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoSourceMode * SOAP_FMAC4 soap_in___trt__SetVideoSourceMode(struct soap *soap, const char *tag, struct __trt__SetVideoSourceMode *a, const char *type)
{
	size_t soap_flag_trt__SetVideoSourceMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetVideoSourceMode*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoSourceMode, sizeof(struct __trt__SetVideoSourceMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetVideoSourceMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetVideoSourceMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetVideoSourceMode(soap, "trt:SetVideoSourceMode", &a->trt__SetVideoSourceMode, ""))
				{	soap_flag_trt__SetVideoSourceMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetVideoSourceMode * SOAP_FMAC4 soap_new___trt__SetVideoSourceMode(struct soap *soap, int n)
{
	struct __trt__SetVideoSourceMode *p;
	struct __trt__SetVideoSourceMode *a = (struct __trt__SetVideoSourceMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetVideoSourceMode));
	for (p = a; p && n--; p++)
		soap_default___trt__SetVideoSourceMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoSourceMode(struct soap *soap, const struct __trt__SetVideoSourceMode *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetVideoSourceMode(soap, tag ? tag : "-trt:SetVideoSourceMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoSourceMode * SOAP_FMAC4 soap_get___trt__SetVideoSourceMode(struct soap *soap, struct __trt__SetVideoSourceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSourceModes(struct soap *soap, struct __trt__GetVideoSourceModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSourceModes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSourceModes(struct soap *soap, const struct __trt__GetVideoSourceModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoSourceModes(soap, &a->trt__GetVideoSourceModes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSourceModes(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSourceModes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoSourceModes(soap, "trt:GetVideoSourceModes", -1, &a->trt__GetVideoSourceModes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceModes * SOAP_FMAC4 soap_in___trt__GetVideoSourceModes(struct soap *soap, const char *tag, struct __trt__GetVideoSourceModes *a, const char *type)
{
	size_t soap_flag_trt__GetVideoSourceModes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoSourceModes*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoSourceModes, sizeof(struct __trt__GetVideoSourceModes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoSourceModes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoSourceModes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoSourceModes(soap, "trt:GetVideoSourceModes", &a->trt__GetVideoSourceModes, ""))
				{	soap_flag_trt__GetVideoSourceModes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetVideoSourceModes * SOAP_FMAC4 soap_new___trt__GetVideoSourceModes(struct soap *soap, int n)
{
	struct __trt__GetVideoSourceModes *p;
	struct __trt__GetVideoSourceModes *a = (struct __trt__GetVideoSourceModes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetVideoSourceModes));
	for (p = a; p && n--; p++)
		soap_default___trt__GetVideoSourceModes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoSourceModes(struct soap *soap, const struct __trt__GetVideoSourceModes *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoSourceModes(soap, tag ? tag : "-trt:GetVideoSourceModes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceModes * SOAP_FMAC4 soap_get___trt__GetVideoSourceModes(struct soap *soap, struct __trt__GetVideoSourceModes *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoSourceModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetSnapshotUri(struct soap *soap, struct __trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetSnapshotUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetSnapshotUri(struct soap *soap, const struct __trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetSnapshotUri(soap, &a->trt__GetSnapshotUri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, const struct __trt__GetSnapshotUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetSnapshotUri(soap, "trt:GetSnapshotUri", -1, &a->trt__GetSnapshotUri, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetSnapshotUri * SOAP_FMAC4 soap_in___trt__GetSnapshotUri(struct soap *soap, const char *tag, struct __trt__GetSnapshotUri *a, const char *type)
{
	size_t soap_flag_trt__GetSnapshotUri = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetSnapshotUri*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetSnapshotUri, sizeof(struct __trt__GetSnapshotUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetSnapshotUri(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetSnapshotUri && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetSnapshotUri(soap, "trt:GetSnapshotUri", &a->trt__GetSnapshotUri, ""))
				{	soap_flag_trt__GetSnapshotUri--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetSnapshotUri * SOAP_FMAC4 soap_new___trt__GetSnapshotUri(struct soap *soap, int n)
{
	struct __trt__GetSnapshotUri *p;
	struct __trt__GetSnapshotUri *a = (struct __trt__GetSnapshotUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetSnapshotUri));
	for (p = a; p && n--; p++)
		soap_default___trt__GetSnapshotUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetSnapshotUri(struct soap *soap, const struct __trt__GetSnapshotUri *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetSnapshotUri(soap, tag ? tag : "-trt:GetSnapshotUri", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetSnapshotUri * SOAP_FMAC4 soap_get___trt__GetSnapshotUri(struct soap *soap, struct __trt__GetSnapshotUri *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetSynchronizationPoint(struct soap *soap, struct __trt__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetSynchronizationPoint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetSynchronizationPoint(struct soap *soap, const struct __trt__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetSynchronizationPoint(soap, &a->trt__SetSynchronizationPoint);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const struct __trt__SetSynchronizationPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetSynchronizationPoint(soap, "trt:SetSynchronizationPoint", -1, &a->trt__SetSynchronizationPoint, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetSynchronizationPoint * SOAP_FMAC4 soap_in___trt__SetSynchronizationPoint(struct soap *soap, const char *tag, struct __trt__SetSynchronizationPoint *a, const char *type)
{
	size_t soap_flag_trt__SetSynchronizationPoint = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetSynchronizationPoint*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetSynchronizationPoint, sizeof(struct __trt__SetSynchronizationPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetSynchronizationPoint(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetSynchronizationPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetSynchronizationPoint(soap, "trt:SetSynchronizationPoint", &a->trt__SetSynchronizationPoint, ""))
				{	soap_flag_trt__SetSynchronizationPoint--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetSynchronizationPoint * SOAP_FMAC4 soap_new___trt__SetSynchronizationPoint(struct soap *soap, int n)
{
	struct __trt__SetSynchronizationPoint *p;
	struct __trt__SetSynchronizationPoint *a = (struct __trt__SetSynchronizationPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetSynchronizationPoint));
	for (p = a; p && n--; p++)
		soap_default___trt__SetSynchronizationPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetSynchronizationPoint(struct soap *soap, const struct __trt__SetSynchronizationPoint *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetSynchronizationPoint(soap, tag ? tag : "-trt:SetSynchronizationPoint", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetSynchronizationPoint * SOAP_FMAC4 soap_get___trt__SetSynchronizationPoint(struct soap *soap, struct __trt__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__StopMulticastStreaming(struct soap *soap, struct __trt__StopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__StopMulticastStreaming = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__StopMulticastStreaming(struct soap *soap, const struct __trt__StopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__StopMulticastStreaming(soap, &a->trt__StopMulticastStreaming);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__StopMulticastStreaming(struct soap *soap, const char *tag, int id, const struct __trt__StopMulticastStreaming *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__StopMulticastStreaming(soap, "trt:StopMulticastStreaming", -1, &a->trt__StopMulticastStreaming, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__StopMulticastStreaming * SOAP_FMAC4 soap_in___trt__StopMulticastStreaming(struct soap *soap, const char *tag, struct __trt__StopMulticastStreaming *a, const char *type)
{
	size_t soap_flag_trt__StopMulticastStreaming = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__StopMulticastStreaming*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__StopMulticastStreaming, sizeof(struct __trt__StopMulticastStreaming), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__StopMulticastStreaming(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__StopMulticastStreaming && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__StopMulticastStreaming(soap, "trt:StopMulticastStreaming", &a->trt__StopMulticastStreaming, ""))
				{	soap_flag_trt__StopMulticastStreaming--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__StopMulticastStreaming * SOAP_FMAC4 soap_new___trt__StopMulticastStreaming(struct soap *soap, int n)
{
	struct __trt__StopMulticastStreaming *p;
	struct __trt__StopMulticastStreaming *a = (struct __trt__StopMulticastStreaming*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__StopMulticastStreaming));
	for (p = a; p && n--; p++)
		soap_default___trt__StopMulticastStreaming(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__StopMulticastStreaming(struct soap *soap, const struct __trt__StopMulticastStreaming *a, const char *tag, const char *type)
{
	if (soap_out___trt__StopMulticastStreaming(soap, tag ? tag : "-trt:StopMulticastStreaming", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__StopMulticastStreaming * SOAP_FMAC4 soap_get___trt__StopMulticastStreaming(struct soap *soap, struct __trt__StopMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__StopMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__StartMulticastStreaming(struct soap *soap, struct __trt__StartMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__StartMulticastStreaming = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__StartMulticastStreaming(struct soap *soap, const struct __trt__StartMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__StartMulticastStreaming(soap, &a->trt__StartMulticastStreaming);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__StartMulticastStreaming(struct soap *soap, const char *tag, int id, const struct __trt__StartMulticastStreaming *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__StartMulticastStreaming(soap, "trt:StartMulticastStreaming", -1, &a->trt__StartMulticastStreaming, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__StartMulticastStreaming * SOAP_FMAC4 soap_in___trt__StartMulticastStreaming(struct soap *soap, const char *tag, struct __trt__StartMulticastStreaming *a, const char *type)
{
	size_t soap_flag_trt__StartMulticastStreaming = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__StartMulticastStreaming*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__StartMulticastStreaming, sizeof(struct __trt__StartMulticastStreaming), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__StartMulticastStreaming(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__StartMulticastStreaming && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__StartMulticastStreaming(soap, "trt:StartMulticastStreaming", &a->trt__StartMulticastStreaming, ""))
				{	soap_flag_trt__StartMulticastStreaming--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__StartMulticastStreaming * SOAP_FMAC4 soap_new___trt__StartMulticastStreaming(struct soap *soap, int n)
{
	struct __trt__StartMulticastStreaming *p;
	struct __trt__StartMulticastStreaming *a = (struct __trt__StartMulticastStreaming*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__StartMulticastStreaming));
	for (p = a; p && n--; p++)
		soap_default___trt__StartMulticastStreaming(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__StartMulticastStreaming(struct soap *soap, const struct __trt__StartMulticastStreaming *a, const char *tag, const char *type)
{
	if (soap_out___trt__StartMulticastStreaming(soap, tag ? tag : "-trt:StartMulticastStreaming", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__StartMulticastStreaming * SOAP_FMAC4 soap_get___trt__StartMulticastStreaming(struct soap *soap, struct __trt__StartMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__StartMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetStreamUri(struct soap *soap, struct __trt__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetStreamUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetStreamUri(struct soap *soap, const struct __trt__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetStreamUri(soap, &a->trt__GetStreamUri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetStreamUri(struct soap *soap, const char *tag, int id, const struct __trt__GetStreamUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetStreamUri(soap, "trt:GetStreamUri", -1, &a->trt__GetStreamUri, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetStreamUri * SOAP_FMAC4 soap_in___trt__GetStreamUri(struct soap *soap, const char *tag, struct __trt__GetStreamUri *a, const char *type)
{
	size_t soap_flag_trt__GetStreamUri = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetStreamUri*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetStreamUri, sizeof(struct __trt__GetStreamUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetStreamUri(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetStreamUri && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetStreamUri(soap, "trt:GetStreamUri", &a->trt__GetStreamUri, ""))
				{	soap_flag_trt__GetStreamUri--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetStreamUri * SOAP_FMAC4 soap_new___trt__GetStreamUri(struct soap *soap, int n)
{
	struct __trt__GetStreamUri *p;
	struct __trt__GetStreamUri *a = (struct __trt__GetStreamUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetStreamUri));
	for (p = a; p && n--; p++)
		soap_default___trt__GetStreamUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetStreamUri(struct soap *soap, const struct __trt__GetStreamUri *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetStreamUri(soap, tag ? tag : "-trt:GetStreamUri", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetStreamUri * SOAP_FMAC4 soap_get___trt__GetStreamUri(struct soap *soap, struct __trt__GetStreamUri *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetGuaranteedNumberOfVideoEncoderInstances = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, &a->trt__GetGuaranteedNumberOfVideoEncoderInstances);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, int id, const struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, "trt:GetGuaranteedNumberOfVideoEncoderInstances", -1, &a->trt__GetGuaranteedNumberOfVideoEncoderInstances, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC4 soap_in___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *a, const char *type)
{
	size_t soap_flag_trt__GetGuaranteedNumberOfVideoEncoderInstances = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetGuaranteedNumberOfVideoEncoderInstances*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(struct __trt__GetGuaranteedNumberOfVideoEncoderInstances), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetGuaranteedNumberOfVideoEncoderInstances && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, "trt:GetGuaranteedNumberOfVideoEncoderInstances", &a->trt__GetGuaranteedNumberOfVideoEncoderInstances, ""))
				{	soap_flag_trt__GetGuaranteedNumberOfVideoEncoderInstances--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC4 soap_new___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, int n)
{
	struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *p;
	struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *a = (struct __trt__GetGuaranteedNumberOfVideoEncoderInstances*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetGuaranteedNumberOfVideoEncoderInstances));
	for (p = a; p && n--; p++)
		soap_default___trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag ? tag : "-trt:GetGuaranteedNumberOfVideoEncoderInstances", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC4 soap_get___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct __trt__GetAudioDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioDecoderConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const struct __trt__GetAudioDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, &a->trt__GetAudioDecoderConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioDecoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, "trt:GetAudioDecoderConfigurationOptions", -1, &a->trt__GetAudioDecoderConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetAudioDecoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetAudioDecoderConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioDecoderConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions, sizeof(struct __trt__GetAudioDecoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioDecoderConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioDecoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, "trt:GetAudioDecoderConfigurationOptions", &a->trt__GetAudioDecoderConfigurationOptions, ""))
				{	soap_flag_trt__GetAudioDecoderConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC4 soap_new___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, int n)
{
	struct __trt__GetAudioDecoderConfigurationOptions *p;
	struct __trt__GetAudioDecoderConfigurationOptions *a = (struct __trt__GetAudioDecoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetAudioDecoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default___trt__GetAudioDecoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const struct __trt__GetAudioDecoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioDecoderConfigurationOptions(soap, tag ? tag : "-trt:GetAudioDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct __trt__GetAudioDecoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct __trt__GetAudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioOutputConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioOutputConfigurationOptions(struct soap *soap, const struct __trt__GetAudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, &a->trt__GetAudioOutputConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioOutputConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, "trt:GetAudioOutputConfigurationOptions", -1, &a->trt__GetAudioOutputConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetAudioOutputConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetAudioOutputConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioOutputConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioOutputConfigurationOptions, sizeof(struct __trt__GetAudioOutputConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioOutputConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioOutputConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, "trt:GetAudioOutputConfigurationOptions", &a->trt__GetAudioOutputConfigurationOptions, ""))
				{	soap_flag_trt__GetAudioOutputConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_new___trt__GetAudioOutputConfigurationOptions(struct soap *soap, int n)
{
	struct __trt__GetAudioOutputConfigurationOptions *p;
	struct __trt__GetAudioOutputConfigurationOptions *a = (struct __trt__GetAudioOutputConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetAudioOutputConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default___trt__GetAudioOutputConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioOutputConfigurationOptions(struct soap *soap, const struct __trt__GetAudioOutputConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioOutputConfigurationOptions(soap, tag ? tag : "-trt:GetAudioOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct __trt__GetAudioOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetMetadataConfigurationOptions(struct soap *soap, struct __trt__GetMetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetMetadataConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetMetadataConfigurationOptions(struct soap *soap, const struct __trt__GetMetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetMetadataConfigurationOptions(soap, &a->trt__GetMetadataConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetMetadataConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetMetadataConfigurationOptions(soap, "trt:GetMetadataConfigurationOptions", -1, &a->trt__GetMetadataConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetMetadataConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetMetadataConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetMetadataConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetMetadataConfigurationOptions, sizeof(struct __trt__GetMetadataConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetMetadataConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetMetadataConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetMetadataConfigurationOptions(soap, "trt:GetMetadataConfigurationOptions", &a->trt__GetMetadataConfigurationOptions, ""))
				{	soap_flag_trt__GetMetadataConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetMetadataConfigurationOptions * SOAP_FMAC4 soap_new___trt__GetMetadataConfigurationOptions(struct soap *soap, int n)
{
	struct __trt__GetMetadataConfigurationOptions *p;
	struct __trt__GetMetadataConfigurationOptions *a = (struct __trt__GetMetadataConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetMetadataConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default___trt__GetMetadataConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetMetadataConfigurationOptions(struct soap *soap, const struct __trt__GetMetadataConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetMetadataConfigurationOptions(soap, tag ? tag : "-trt:GetMetadataConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetMetadataConfigurationOptions(struct soap *soap, struct __trt__GetMetadataConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetMetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct __trt__GetAudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioEncoderConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetAudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, &a->trt__GetAudioEncoderConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioEncoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, "trt:GetAudioEncoderConfigurationOptions", -1, &a->trt__GetAudioEncoderConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetAudioEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetAudioEncoderConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioEncoderConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions, sizeof(struct __trt__GetAudioEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioEncoderConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioEncoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, "trt:GetAudioEncoderConfigurationOptions", &a->trt__GetAudioEncoderConfigurationOptions, ""))
				{	soap_flag_trt__GetAudioEncoderConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_new___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, int n)
{
	struct __trt__GetAudioEncoderConfigurationOptions *p;
	struct __trt__GetAudioEncoderConfigurationOptions *a = (struct __trt__GetAudioEncoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetAudioEncoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default___trt__GetAudioEncoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetAudioEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioEncoderConfigurationOptions(soap, tag ? tag : "-trt:GetAudioEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct __trt__GetAudioEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct __trt__GetAudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioSourceConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const struct __trt__GetAudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, &a->trt__GetAudioSourceConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, "trt:GetAudioSourceConfigurationOptions", -1, &a->trt__GetAudioSourceConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetAudioSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetAudioSourceConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioSourceConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioSourceConfigurationOptions, sizeof(struct __trt__GetAudioSourceConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioSourceConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioSourceConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, "trt:GetAudioSourceConfigurationOptions", &a->trt__GetAudioSourceConfigurationOptions, ""))
				{	soap_flag_trt__GetAudioSourceConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_new___trt__GetAudioSourceConfigurationOptions(struct soap *soap, int n)
{
	struct __trt__GetAudioSourceConfigurationOptions *p;
	struct __trt__GetAudioSourceConfigurationOptions *a = (struct __trt__GetAudioSourceConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetAudioSourceConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default___trt__GetAudioSourceConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const struct __trt__GetAudioSourceConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioSourceConfigurationOptions(soap, tag ? tag : "-trt:GetAudioSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct __trt__GetAudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct __trt__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoEncoderConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, &a->trt__GetVideoEncoderConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, "trt:GetVideoEncoderConfigurationOptions", -1, &a->trt__GetVideoEncoderConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetVideoEncoderConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoEncoderConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions, sizeof(struct __trt__GetVideoEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoEncoderConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoEncoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, "trt:GetVideoEncoderConfigurationOptions", &a->trt__GetVideoEncoderConfigurationOptions, ""))
				{	soap_flag_trt__GetVideoEncoderConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_new___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, int n)
{
	struct __trt__GetVideoEncoderConfigurationOptions *p;
	struct __trt__GetVideoEncoderConfigurationOptions *a = (struct __trt__GetVideoEncoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetVideoEncoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default___trt__GetVideoEncoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetVideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoEncoderConfigurationOptions(soap, tag ? tag : "-trt:GetVideoEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct __trt__GetVideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct __trt__GetVideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSourceConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const struct __trt__GetVideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, &a->trt__GetVideoSourceConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, "trt:GetVideoSourceConfigurationOptions", -1, &a->trt__GetVideoSourceConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetVideoSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetVideoSourceConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoSourceConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoSourceConfigurationOptions, sizeof(struct __trt__GetVideoSourceConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoSourceConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoSourceConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, "trt:GetVideoSourceConfigurationOptions", &a->trt__GetVideoSourceConfigurationOptions, ""))
				{	soap_flag_trt__GetVideoSourceConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_new___trt__GetVideoSourceConfigurationOptions(struct soap *soap, int n)
{
	struct __trt__GetVideoSourceConfigurationOptions *p;
	struct __trt__GetVideoSourceConfigurationOptions *a = (struct __trt__GetVideoSourceConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetVideoSourceConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default___trt__GetVideoSourceConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const struct __trt__GetVideoSourceConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoSourceConfigurationOptions(soap, tag ? tag : "-trt:GetVideoSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct __trt__GetVideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetAudioDecoderConfiguration(struct soap *soap, struct __trt__SetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetAudioDecoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetAudioDecoderConfiguration(struct soap *soap, const struct __trt__SetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetAudioDecoderConfiguration(soap, &a->trt__SetAudioDecoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetAudioDecoderConfiguration(soap, "trt:SetAudioDecoderConfiguration", -1, &a->trt__SetAudioDecoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_in___trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct __trt__SetAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetAudioDecoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetAudioDecoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetAudioDecoderConfiguration, sizeof(struct __trt__SetAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetAudioDecoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetAudioDecoderConfiguration(soap, "trt:SetAudioDecoderConfiguration", &a->trt__SetAudioDecoderConfiguration, ""))
				{	soap_flag_trt__SetAudioDecoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_new___trt__SetAudioDecoderConfiguration(struct soap *soap, int n)
{
	struct __trt__SetAudioDecoderConfiguration *p;
	struct __trt__SetAudioDecoderConfiguration *a = (struct __trt__SetAudioDecoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetAudioDecoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__SetAudioDecoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetAudioDecoderConfiguration(struct soap *soap, const struct __trt__SetAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetAudioDecoderConfiguration(soap, tag ? tag : "-trt:SetAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_get___trt__SetAudioDecoderConfiguration(struct soap *soap, struct __trt__SetAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetAudioOutputConfiguration(struct soap *soap, struct __trt__SetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetAudioOutputConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetAudioOutputConfiguration(struct soap *soap, const struct __trt__SetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetAudioOutputConfiguration(soap, &a->trt__SetAudioOutputConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetAudioOutputConfiguration(soap, "trt:SetAudioOutputConfiguration", -1, &a->trt__SetAudioOutputConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioOutputConfiguration * SOAP_FMAC4 soap_in___trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, struct __trt__SetAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetAudioOutputConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetAudioOutputConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetAudioOutputConfiguration, sizeof(struct __trt__SetAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetAudioOutputConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetAudioOutputConfiguration(soap, "trt:SetAudioOutputConfiguration", &a->trt__SetAudioOutputConfiguration, ""))
				{	soap_flag_trt__SetAudioOutputConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetAudioOutputConfiguration * SOAP_FMAC4 soap_new___trt__SetAudioOutputConfiguration(struct soap *soap, int n)
{
	struct __trt__SetAudioOutputConfiguration *p;
	struct __trt__SetAudioOutputConfiguration *a = (struct __trt__SetAudioOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetAudioOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__SetAudioOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetAudioOutputConfiguration(struct soap *soap, const struct __trt__SetAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetAudioOutputConfiguration(soap, tag ? tag : "-trt:SetAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioOutputConfiguration * SOAP_FMAC4 soap_get___trt__SetAudioOutputConfiguration(struct soap *soap, struct __trt__SetAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetMetadataConfiguration(struct soap *soap, struct __trt__SetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetMetadataConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetMetadataConfiguration(struct soap *soap, const struct __trt__SetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetMetadataConfiguration(soap, &a->trt__SetMetadataConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetMetadataConfiguration(soap, "trt:SetMetadataConfiguration", -1, &a->trt__SetMetadataConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetMetadataConfiguration * SOAP_FMAC4 soap_in___trt__SetMetadataConfiguration(struct soap *soap, const char *tag, struct __trt__SetMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetMetadataConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetMetadataConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetMetadataConfiguration, sizeof(struct __trt__SetMetadataConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetMetadataConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetMetadataConfiguration(soap, "trt:SetMetadataConfiguration", &a->trt__SetMetadataConfiguration, ""))
				{	soap_flag_trt__SetMetadataConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetMetadataConfiguration * SOAP_FMAC4 soap_new___trt__SetMetadataConfiguration(struct soap *soap, int n)
{
	struct __trt__SetMetadataConfiguration *p;
	struct __trt__SetMetadataConfiguration *a = (struct __trt__SetMetadataConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetMetadataConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__SetMetadataConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetMetadataConfiguration(struct soap *soap, const struct __trt__SetMetadataConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetMetadataConfiguration(soap, tag ? tag : "-trt:SetMetadataConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetMetadataConfiguration * SOAP_FMAC4 soap_get___trt__SetMetadataConfiguration(struct soap *soap, struct __trt__SetMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__SetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoAnalyticsConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__SetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, &a->trt__SetVideoAnalyticsConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, "trt:SetVideoAnalyticsConfiguration", -1, &a->trt__SetVideoAnalyticsConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct __trt__SetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetVideoAnalyticsConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetVideoAnalyticsConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoAnalyticsConfiguration, sizeof(struct __trt__SetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetVideoAnalyticsConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, "trt:SetVideoAnalyticsConfiguration", &a->trt__SetVideoAnalyticsConfiguration, ""))
				{	soap_flag_trt__SetVideoAnalyticsConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_new___trt__SetVideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct __trt__SetVideoAnalyticsConfiguration *p;
	struct __trt__SetVideoAnalyticsConfiguration *a = (struct __trt__SetVideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetVideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__SetVideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__SetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetVideoAnalyticsConfiguration(soap, tag ? tag : "-trt:SetVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get___trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__SetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetAudioEncoderConfiguration(struct soap *soap, struct __trt__SetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetAudioEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetAudioEncoderConfiguration(struct soap *soap, const struct __trt__SetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetAudioEncoderConfiguration(soap, &a->trt__SetAudioEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetAudioEncoderConfiguration(soap, "trt:SetAudioEncoderConfiguration", -1, &a->trt__SetAudioEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioEncoderConfiguration * SOAP_FMAC4 soap_in___trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__SetAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetAudioEncoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetAudioEncoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetAudioEncoderConfiguration, sizeof(struct __trt__SetAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetAudioEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetAudioEncoderConfiguration(soap, "trt:SetAudioEncoderConfiguration", &a->trt__SetAudioEncoderConfiguration, ""))
				{	soap_flag_trt__SetAudioEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetAudioEncoderConfiguration * SOAP_FMAC4 soap_new___trt__SetAudioEncoderConfiguration(struct soap *soap, int n)
{
	struct __trt__SetAudioEncoderConfiguration *p;
	struct __trt__SetAudioEncoderConfiguration *a = (struct __trt__SetAudioEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetAudioEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__SetAudioEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetAudioEncoderConfiguration(struct soap *soap, const struct __trt__SetAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetAudioEncoderConfiguration(soap, tag ? tag : "-trt:SetAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioEncoderConfiguration * SOAP_FMAC4 soap_get___trt__SetAudioEncoderConfiguration(struct soap *soap, struct __trt__SetAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetAudioSourceConfiguration(struct soap *soap, struct __trt__SetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetAudioSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetAudioSourceConfiguration(struct soap *soap, const struct __trt__SetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetAudioSourceConfiguration(soap, &a->trt__SetAudioSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetAudioSourceConfiguration(soap, "trt:SetAudioSourceConfiguration", -1, &a->trt__SetAudioSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioSourceConfiguration * SOAP_FMAC4 soap_in___trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, struct __trt__SetAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetAudioSourceConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetAudioSourceConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetAudioSourceConfiguration, sizeof(struct __trt__SetAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetAudioSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetAudioSourceConfiguration(soap, "trt:SetAudioSourceConfiguration", &a->trt__SetAudioSourceConfiguration, ""))
				{	soap_flag_trt__SetAudioSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetAudioSourceConfiguration * SOAP_FMAC4 soap_new___trt__SetAudioSourceConfiguration(struct soap *soap, int n)
{
	struct __trt__SetAudioSourceConfiguration *p;
	struct __trt__SetAudioSourceConfiguration *a = (struct __trt__SetAudioSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetAudioSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__SetAudioSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetAudioSourceConfiguration(struct soap *soap, const struct __trt__SetAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetAudioSourceConfiguration(soap, tag ? tag : "-trt:SetAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioSourceConfiguration * SOAP_FMAC4 soap_get___trt__SetAudioSourceConfiguration(struct soap *soap, struct __trt__SetAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoEncoderConfiguration(struct soap *soap, struct __trt__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoEncoderConfiguration(struct soap *soap, const struct __trt__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetVideoEncoderConfiguration(soap, &a->trt__SetVideoEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetVideoEncoderConfiguration(soap, "trt:SetVideoEncoderConfiguration", -1, &a->trt__SetVideoEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_in___trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__SetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetVideoEncoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetVideoEncoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoEncoderConfiguration, sizeof(struct __trt__SetVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetVideoEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetVideoEncoderConfiguration(soap, "trt:SetVideoEncoderConfiguration", &a->trt__SetVideoEncoderConfiguration, ""))
				{	soap_flag_trt__SetVideoEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_new___trt__SetVideoEncoderConfiguration(struct soap *soap, int n)
{
	struct __trt__SetVideoEncoderConfiguration *p;
	struct __trt__SetVideoEncoderConfiguration *a = (struct __trt__SetVideoEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetVideoEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__SetVideoEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoEncoderConfiguration(struct soap *soap, const struct __trt__SetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetVideoEncoderConfiguration(soap, tag ? tag : "-trt:SetVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_get___trt__SetVideoEncoderConfiguration(struct soap *soap, struct __trt__SetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoSourceConfiguration(struct soap *soap, struct __trt__SetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoSourceConfiguration(struct soap *soap, const struct __trt__SetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetVideoSourceConfiguration(soap, &a->trt__SetVideoSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetVideoSourceConfiguration(soap, "trt:SetVideoSourceConfiguration", -1, &a->trt__SetVideoSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoSourceConfiguration * SOAP_FMAC4 soap_in___trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, struct __trt__SetVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetVideoSourceConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetVideoSourceConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoSourceConfiguration, sizeof(struct __trt__SetVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetVideoSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetVideoSourceConfiguration(soap, "trt:SetVideoSourceConfiguration", &a->trt__SetVideoSourceConfiguration, ""))
				{	soap_flag_trt__SetVideoSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__SetVideoSourceConfiguration * SOAP_FMAC4 soap_new___trt__SetVideoSourceConfiguration(struct soap *soap, int n)
{
	struct __trt__SetVideoSourceConfiguration *p;
	struct __trt__SetVideoSourceConfiguration *a = (struct __trt__SetVideoSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__SetVideoSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__SetVideoSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoSourceConfiguration(struct soap *soap, const struct __trt__SetVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetVideoSourceConfiguration(soap, tag ? tag : "-trt:SetVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoSourceConfiguration * SOAP_FMAC4 soap_get___trt__SetVideoSourceConfiguration(struct soap *soap, struct __trt__SetVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleAudioDecoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, &a->trt__GetCompatibleAudioDecoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleAudioDecoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, "trt:GetCompatibleAudioDecoderConfigurations", -1, &a->trt__GetCompatibleAudioDecoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleAudioDecoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleAudioDecoderConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleAudioDecoderConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations, sizeof(struct __trt__GetCompatibleAudioDecoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleAudioDecoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleAudioDecoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, "trt:GetCompatibleAudioDecoderConfigurations", &a->trt__GetCompatibleAudioDecoderConfigurations, ""))
				{	soap_flag_trt__GetCompatibleAudioDecoderConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC4 soap_new___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, int n)
{
	struct __trt__GetCompatibleAudioDecoderConfigurations *p;
	struct __trt__GetCompatibleAudioDecoderConfigurations *a = (struct __trt__GetCompatibleAudioDecoderConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetCompatibleAudioDecoderConfigurations));
	for (p = a; p && n--; p++)
		soap_default___trt__GetCompatibleAudioDecoderConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioDecoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleAudioDecoderConfigurations(soap, tag ? tag : "-trt:GetCompatibleAudioDecoderConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioDecoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleAudioOutputConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, &a->trt__GetCompatibleAudioOutputConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleAudioOutputConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, "trt:GetCompatibleAudioOutputConfigurations", -1, &a->trt__GetCompatibleAudioOutputConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleAudioOutputConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleAudioOutputConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleAudioOutputConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations, sizeof(struct __trt__GetCompatibleAudioOutputConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleAudioOutputConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleAudioOutputConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, "trt:GetCompatibleAudioOutputConfigurations", &a->trt__GetCompatibleAudioOutputConfigurations, ""))
				{	soap_flag_trt__GetCompatibleAudioOutputConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC4 soap_new___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, int n)
{
	struct __trt__GetCompatibleAudioOutputConfigurations *p;
	struct __trt__GetCompatibleAudioOutputConfigurations *a = (struct __trt__GetCompatibleAudioOutputConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetCompatibleAudioOutputConfigurations));
	for (p = a; p && n--; p++)
		soap_default___trt__GetCompatibleAudioOutputConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioOutputConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleAudioOutputConfigurations(soap, tag ? tag : "-trt:GetCompatibleAudioOutputConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioOutputConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct __trt__GetCompatibleMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleMetadataConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const struct __trt__GetCompatibleMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, &a->trt__GetCompatibleMetadataConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleMetadataConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, "trt:GetCompatibleMetadataConfigurations", -1, &a->trt__GetCompatibleMetadataConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleMetadataConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleMetadataConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleMetadataConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleMetadataConfigurations, sizeof(struct __trt__GetCompatibleMetadataConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleMetadataConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleMetadataConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, "trt:GetCompatibleMetadataConfigurations", &a->trt__GetCompatibleMetadataConfigurations, ""))
				{	soap_flag_trt__GetCompatibleMetadataConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC4 soap_new___trt__GetCompatibleMetadataConfigurations(struct soap *soap, int n)
{
	struct __trt__GetCompatibleMetadataConfigurations *p;
	struct __trt__GetCompatibleMetadataConfigurations *a = (struct __trt__GetCompatibleMetadataConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetCompatibleMetadataConfigurations));
	for (p = a; p && n--; p++)
		soap_default___trt__GetCompatibleMetadataConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const struct __trt__GetCompatibleMetadataConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleMetadataConfigurations(soap, tag ? tag : "-trt:GetCompatibleMetadataConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct __trt__GetCompatibleMetadataConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleVideoAnalyticsConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, &a->trt__GetCompatibleVideoAnalyticsConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleVideoAnalyticsConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, "trt:GetCompatibleVideoAnalyticsConfigurations", -1, &a->trt__GetCompatibleVideoAnalyticsConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleVideoAnalyticsConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleVideoAnalyticsConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleVideoAnalyticsConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations, sizeof(struct __trt__GetCompatibleVideoAnalyticsConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleVideoAnalyticsConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleVideoAnalyticsConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, "trt:GetCompatibleVideoAnalyticsConfigurations", &a->trt__GetCompatibleVideoAnalyticsConfigurations, ""))
				{	soap_flag_trt__GetCompatibleVideoAnalyticsConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC4 soap_new___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, int n)
{
	struct __trt__GetCompatibleVideoAnalyticsConfigurations *p;
	struct __trt__GetCompatibleVideoAnalyticsConfigurations *a = (struct __trt__GetCompatibleVideoAnalyticsConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetCompatibleVideoAnalyticsConfigurations));
	for (p = a; p && n--; p++)
		soap_default___trt__GetCompatibleVideoAnalyticsConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoAnalyticsConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag ? tag : "-trt:GetCompatibleVideoAnalyticsConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoAnalyticsConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleAudioSourceConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, &a->trt__GetCompatibleAudioSourceConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleAudioSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, "trt:GetCompatibleAudioSourceConfigurations", -1, &a->trt__GetCompatibleAudioSourceConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleAudioSourceConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleAudioSourceConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleAudioSourceConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations, sizeof(struct __trt__GetCompatibleAudioSourceConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleAudioSourceConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleAudioSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, "trt:GetCompatibleAudioSourceConfigurations", &a->trt__GetCompatibleAudioSourceConfigurations, ""))
				{	soap_flag_trt__GetCompatibleAudioSourceConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC4 soap_new___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, int n)
{
	struct __trt__GetCompatibleAudioSourceConfigurations *p;
	struct __trt__GetCompatibleAudioSourceConfigurations *a = (struct __trt__GetCompatibleAudioSourceConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetCompatibleAudioSourceConfigurations));
	for (p = a; p && n--; p++)
		soap_default___trt__GetCompatibleAudioSourceConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioSourceConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleAudioSourceConfigurations(soap, tag ? tag : "-trt:GetCompatibleAudioSourceConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleAudioEncoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, &a->trt__GetCompatibleAudioEncoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleAudioEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, "trt:GetCompatibleAudioEncoderConfigurations", -1, &a->trt__GetCompatibleAudioEncoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleAudioEncoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleAudioEncoderConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleAudioEncoderConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations, sizeof(struct __trt__GetCompatibleAudioEncoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleAudioEncoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleAudioEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, "trt:GetCompatibleAudioEncoderConfigurations", &a->trt__GetCompatibleAudioEncoderConfigurations, ""))
				{	soap_flag_trt__GetCompatibleAudioEncoderConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC4 soap_new___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, int n)
{
	struct __trt__GetCompatibleAudioEncoderConfigurations *p;
	struct __trt__GetCompatibleAudioEncoderConfigurations *a = (struct __trt__GetCompatibleAudioEncoderConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetCompatibleAudioEncoderConfigurations));
	for (p = a; p && n--; p++)
		soap_default___trt__GetCompatibleAudioEncoderConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioEncoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleAudioEncoderConfigurations(soap, tag ? tag : "-trt:GetCompatibleAudioEncoderConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleVideoSourceConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, &a->trt__GetCompatibleVideoSourceConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleVideoSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, "trt:GetCompatibleVideoSourceConfigurations", -1, &a->trt__GetCompatibleVideoSourceConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleVideoSourceConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleVideoSourceConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleVideoSourceConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations, sizeof(struct __trt__GetCompatibleVideoSourceConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleVideoSourceConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleVideoSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, "trt:GetCompatibleVideoSourceConfigurations", &a->trt__GetCompatibleVideoSourceConfigurations, ""))
				{	soap_flag_trt__GetCompatibleVideoSourceConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC4 soap_new___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, int n)
{
	struct __trt__GetCompatibleVideoSourceConfigurations *p;
	struct __trt__GetCompatibleVideoSourceConfigurations *a = (struct __trt__GetCompatibleVideoSourceConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetCompatibleVideoSourceConfigurations));
	for (p = a; p && n--; p++)
		soap_default___trt__GetCompatibleVideoSourceConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoSourceConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleVideoSourceConfigurations(soap, tag ? tag : "-trt:GetCompatibleVideoSourceConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleVideoEncoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, &a->trt__GetCompatibleVideoEncoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleVideoEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, "trt:GetCompatibleVideoEncoderConfigurations", -1, &a->trt__GetCompatibleVideoEncoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleVideoEncoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleVideoEncoderConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleVideoEncoderConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations, sizeof(struct __trt__GetCompatibleVideoEncoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleVideoEncoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleVideoEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, "trt:GetCompatibleVideoEncoderConfigurations", &a->trt__GetCompatibleVideoEncoderConfigurations, ""))
				{	soap_flag_trt__GetCompatibleVideoEncoderConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC4 soap_new___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, int n)
{
	struct __trt__GetCompatibleVideoEncoderConfigurations *p;
	struct __trt__GetCompatibleVideoEncoderConfigurations *a = (struct __trt__GetCompatibleVideoEncoderConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetCompatibleVideoEncoderConfigurations));
	for (p = a; p && n--; p++)
		soap_default___trt__GetCompatibleVideoEncoderConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoEncoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleVideoEncoderConfigurations(soap, tag ? tag : "-trt:GetCompatibleVideoEncoderConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioDecoderConfiguration(struct soap *soap, struct __trt__GetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioDecoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioDecoderConfiguration(struct soap *soap, const struct __trt__GetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioDecoderConfiguration(soap, &a->trt__GetAudioDecoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioDecoderConfiguration(soap, "trt:GetAudioDecoderConfiguration", -1, &a->trt__GetAudioDecoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfiguration * SOAP_FMAC4 soap_in___trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct __trt__GetAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetAudioDecoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioDecoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioDecoderConfiguration, sizeof(struct __trt__GetAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioDecoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioDecoderConfiguration(soap, "trt:GetAudioDecoderConfiguration", &a->trt__GetAudioDecoderConfiguration, ""))
				{	soap_flag_trt__GetAudioDecoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfiguration * SOAP_FMAC4 soap_new___trt__GetAudioDecoderConfiguration(struct soap *soap, int n)
{
	struct __trt__GetAudioDecoderConfiguration *p;
	struct __trt__GetAudioDecoderConfiguration *a = (struct __trt__GetAudioDecoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetAudioDecoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__GetAudioDecoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioDecoderConfiguration(struct soap *soap, const struct __trt__GetAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioDecoderConfiguration(soap, tag ? tag : "-trt:GetAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfiguration * SOAP_FMAC4 soap_get___trt__GetAudioDecoderConfiguration(struct soap *soap, struct __trt__GetAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioOutputConfiguration(struct soap *soap, struct __trt__GetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioOutputConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioOutputConfiguration(struct soap *soap, const struct __trt__GetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioOutputConfiguration(soap, &a->trt__GetAudioOutputConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioOutputConfiguration(soap, "trt:GetAudioOutputConfiguration", -1, &a->trt__GetAudioOutputConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfiguration * SOAP_FMAC4 soap_in___trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, struct __trt__GetAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetAudioOutputConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioOutputConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioOutputConfiguration, sizeof(struct __trt__GetAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioOutputConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioOutputConfiguration(soap, "trt:GetAudioOutputConfiguration", &a->trt__GetAudioOutputConfiguration, ""))
				{	soap_flag_trt__GetAudioOutputConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfiguration * SOAP_FMAC4 soap_new___trt__GetAudioOutputConfiguration(struct soap *soap, int n)
{
	struct __trt__GetAudioOutputConfiguration *p;
	struct __trt__GetAudioOutputConfiguration *a = (struct __trt__GetAudioOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetAudioOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__GetAudioOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioOutputConfiguration(struct soap *soap, const struct __trt__GetAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioOutputConfiguration(soap, tag ? tag : "-trt:GetAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfiguration * SOAP_FMAC4 soap_get___trt__GetAudioOutputConfiguration(struct soap *soap, struct __trt__GetAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetMetadataConfiguration(struct soap *soap, struct __trt__GetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetMetadataConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetMetadataConfiguration(struct soap *soap, const struct __trt__GetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetMetadataConfiguration(soap, &a->trt__GetMetadataConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetMetadataConfiguration(soap, "trt:GetMetadataConfiguration", -1, &a->trt__GetMetadataConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfiguration * SOAP_FMAC4 soap_in___trt__GetMetadataConfiguration(struct soap *soap, const char *tag, struct __trt__GetMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetMetadataConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetMetadataConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetMetadataConfiguration, sizeof(struct __trt__GetMetadataConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetMetadataConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetMetadataConfiguration(soap, "trt:GetMetadataConfiguration", &a->trt__GetMetadataConfiguration, ""))
				{	soap_flag_trt__GetMetadataConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetMetadataConfiguration * SOAP_FMAC4 soap_new___trt__GetMetadataConfiguration(struct soap *soap, int n)
{
	struct __trt__GetMetadataConfiguration *p;
	struct __trt__GetMetadataConfiguration *a = (struct __trt__GetMetadataConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetMetadataConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__GetMetadataConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetMetadataConfiguration(struct soap *soap, const struct __trt__GetMetadataConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetMetadataConfiguration(soap, tag ? tag : "-trt:GetMetadataConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfiguration * SOAP_FMAC4 soap_get___trt__GetMetadataConfiguration(struct soap *soap, struct __trt__GetMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoAnalyticsConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, &a->trt__GetVideoAnalyticsConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, "trt:GetVideoAnalyticsConfiguration", -1, &a->trt__GetVideoAnalyticsConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct __trt__GetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetVideoAnalyticsConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoAnalyticsConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoAnalyticsConfiguration, sizeof(struct __trt__GetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoAnalyticsConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, "trt:GetVideoAnalyticsConfiguration", &a->trt__GetVideoAnalyticsConfiguration, ""))
				{	soap_flag_trt__GetVideoAnalyticsConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_new___trt__GetVideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct __trt__GetVideoAnalyticsConfiguration *p;
	struct __trt__GetVideoAnalyticsConfiguration *a = (struct __trt__GetVideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetVideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__GetVideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__GetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoAnalyticsConfiguration(soap, tag ? tag : "-trt:GetVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get___trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__GetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioEncoderConfiguration(struct soap *soap, struct __trt__GetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioEncoderConfiguration(struct soap *soap, const struct __trt__GetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioEncoderConfiguration(soap, &a->trt__GetAudioEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioEncoderConfiguration(soap, "trt:GetAudioEncoderConfiguration", -1, &a->trt__GetAudioEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfiguration * SOAP_FMAC4 soap_in___trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__GetAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetAudioEncoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioEncoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioEncoderConfiguration, sizeof(struct __trt__GetAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioEncoderConfiguration(soap, "trt:GetAudioEncoderConfiguration", &a->trt__GetAudioEncoderConfiguration, ""))
				{	soap_flag_trt__GetAudioEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfiguration * SOAP_FMAC4 soap_new___trt__GetAudioEncoderConfiguration(struct soap *soap, int n)
{
	struct __trt__GetAudioEncoderConfiguration *p;
	struct __trt__GetAudioEncoderConfiguration *a = (struct __trt__GetAudioEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetAudioEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__GetAudioEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioEncoderConfiguration(struct soap *soap, const struct __trt__GetAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioEncoderConfiguration(soap, tag ? tag : "-trt:GetAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfiguration * SOAP_FMAC4 soap_get___trt__GetAudioEncoderConfiguration(struct soap *soap, struct __trt__GetAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioSourceConfiguration(struct soap *soap, struct __trt__GetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioSourceConfiguration(struct soap *soap, const struct __trt__GetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioSourceConfiguration(soap, &a->trt__GetAudioSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioSourceConfiguration(soap, "trt:GetAudioSourceConfiguration", -1, &a->trt__GetAudioSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfiguration * SOAP_FMAC4 soap_in___trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, struct __trt__GetAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetAudioSourceConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioSourceConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioSourceConfiguration, sizeof(struct __trt__GetAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioSourceConfiguration(soap, "trt:GetAudioSourceConfiguration", &a->trt__GetAudioSourceConfiguration, ""))
				{	soap_flag_trt__GetAudioSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfiguration * SOAP_FMAC4 soap_new___trt__GetAudioSourceConfiguration(struct soap *soap, int n)
{
	struct __trt__GetAudioSourceConfiguration *p;
	struct __trt__GetAudioSourceConfiguration *a = (struct __trt__GetAudioSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetAudioSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__GetAudioSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioSourceConfiguration(struct soap *soap, const struct __trt__GetAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioSourceConfiguration(soap, tag ? tag : "-trt:GetAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfiguration * SOAP_FMAC4 soap_get___trt__GetAudioSourceConfiguration(struct soap *soap, struct __trt__GetAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoEncoderConfiguration(struct soap *soap, struct __trt__GetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoEncoderConfiguration(struct soap *soap, const struct __trt__GetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoEncoderConfiguration(soap, &a->trt__GetVideoEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoEncoderConfiguration(soap, "trt:GetVideoEncoderConfiguration", -1, &a->trt__GetVideoEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_in___trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__GetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetVideoEncoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoEncoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoEncoderConfiguration, sizeof(struct __trt__GetVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoEncoderConfiguration(soap, "trt:GetVideoEncoderConfiguration", &a->trt__GetVideoEncoderConfiguration, ""))
				{	soap_flag_trt__GetVideoEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_new___trt__GetVideoEncoderConfiguration(struct soap *soap, int n)
{
	struct __trt__GetVideoEncoderConfiguration *p;
	struct __trt__GetVideoEncoderConfiguration *a = (struct __trt__GetVideoEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetVideoEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__GetVideoEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoEncoderConfiguration(struct soap *soap, const struct __trt__GetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoEncoderConfiguration(soap, tag ? tag : "-trt:GetVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_get___trt__GetVideoEncoderConfiguration(struct soap *soap, struct __trt__GetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSourceConfiguration(struct soap *soap, struct __trt__GetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSourceConfiguration(struct soap *soap, const struct __trt__GetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoSourceConfiguration(soap, &a->trt__GetVideoSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoSourceConfiguration(soap, "trt:GetVideoSourceConfiguration", -1, &a->trt__GetVideoSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfiguration * SOAP_FMAC4 soap_in___trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, struct __trt__GetVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetVideoSourceConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoSourceConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoSourceConfiguration, sizeof(struct __trt__GetVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoSourceConfiguration(soap, "trt:GetVideoSourceConfiguration", &a->trt__GetVideoSourceConfiguration, ""))
				{	soap_flag_trt__GetVideoSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfiguration * SOAP_FMAC4 soap_new___trt__GetVideoSourceConfiguration(struct soap *soap, int n)
{
	struct __trt__GetVideoSourceConfiguration *p;
	struct __trt__GetVideoSourceConfiguration *a = (struct __trt__GetVideoSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetVideoSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default___trt__GetVideoSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoSourceConfiguration(struct soap *soap, const struct __trt__GetVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoSourceConfiguration(soap, tag ? tag : "-trt:GetVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfiguration * SOAP_FMAC4 soap_get___trt__GetVideoSourceConfiguration(struct soap *soap, struct __trt__GetVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioDecoderConfigurations(struct soap *soap, struct __trt__GetAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioDecoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioDecoderConfigurations(struct soap *soap, const struct __trt__GetAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioDecoderConfigurations(soap, &a->trt__GetAudioDecoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioDecoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurations(soap, "trt:GetAudioDecoderConfigurations", -1, &a->trt__GetAudioDecoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfigurations * SOAP_FMAC4 soap_in___trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetAudioDecoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetAudioDecoderConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioDecoderConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioDecoderConfigurations, sizeof(struct __trt__GetAudioDecoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioDecoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioDecoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioDecoderConfigurations(soap, "trt:GetAudioDecoderConfigurations", &a->trt__GetAudioDecoderConfigurations, ""))
				{	soap_flag_trt__GetAudioDecoderConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfigurations * SOAP_FMAC4 soap_new___trt__GetAudioDecoderConfigurations(struct soap *soap, int n)
{
	struct __trt__GetAudioDecoderConfigurations *p;
	struct __trt__GetAudioDecoderConfigurations *a = (struct __trt__GetAudioDecoderConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetAudioDecoderConfigurations));
	for (p = a; p && n--; p++)
		soap_default___trt__GetAudioDecoderConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioDecoderConfigurations(struct soap *soap, const struct __trt__GetAudioDecoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioDecoderConfigurations(soap, tag ? tag : "-trt:GetAudioDecoderConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfigurations * SOAP_FMAC4 soap_get___trt__GetAudioDecoderConfigurations(struct soap *soap, struct __trt__GetAudioDecoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioOutputConfigurations(struct soap *soap, struct __trt__GetAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioOutputConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioOutputConfigurations(struct soap *soap, const struct __trt__GetAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioOutputConfigurations(soap, &a->trt__GetAudioOutputConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioOutputConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurations(soap, "trt:GetAudioOutputConfigurations", -1, &a->trt__GetAudioOutputConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfigurations * SOAP_FMAC4 soap_in___trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, struct __trt__GetAudioOutputConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetAudioOutputConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioOutputConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioOutputConfigurations, sizeof(struct __trt__GetAudioOutputConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioOutputConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioOutputConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioOutputConfigurations(soap, "trt:GetAudioOutputConfigurations", &a->trt__GetAudioOutputConfigurations, ""))
				{	soap_flag_trt__GetAudioOutputConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfigurations * SOAP_FMAC4 soap_new___trt__GetAudioOutputConfigurations(struct soap *soap, int n)
{
	struct __trt__GetAudioOutputConfigurations *p;
	struct __trt__GetAudioOutputConfigurations *a = (struct __trt__GetAudioOutputConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetAudioOutputConfigurations));
	for (p = a; p && n--; p++)
		soap_default___trt__GetAudioOutputConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioOutputConfigurations(struct soap *soap, const struct __trt__GetAudioOutputConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioOutputConfigurations(soap, tag ? tag : "-trt:GetAudioOutputConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfigurations * SOAP_FMAC4 soap_get___trt__GetAudioOutputConfigurations(struct soap *soap, struct __trt__GetAudioOutputConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetMetadataConfigurations(struct soap *soap, struct __trt__GetMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetMetadataConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetMetadataConfigurations(struct soap *soap, const struct __trt__GetMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetMetadataConfigurations(soap, &a->trt__GetMetadataConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetMetadataConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetMetadataConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetMetadataConfigurations(soap, "trt:GetMetadataConfigurations", -1, &a->trt__GetMetadataConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfigurations * SOAP_FMAC4 soap_in___trt__GetMetadataConfigurations(struct soap *soap, const char *tag, struct __trt__GetMetadataConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetMetadataConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetMetadataConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetMetadataConfigurations, sizeof(struct __trt__GetMetadataConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetMetadataConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetMetadataConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetMetadataConfigurations(soap, "trt:GetMetadataConfigurations", &a->trt__GetMetadataConfigurations, ""))
				{	soap_flag_trt__GetMetadataConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetMetadataConfigurations * SOAP_FMAC4 soap_new___trt__GetMetadataConfigurations(struct soap *soap, int n)
{
	struct __trt__GetMetadataConfigurations *p;
	struct __trt__GetMetadataConfigurations *a = (struct __trt__GetMetadataConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetMetadataConfigurations));
	for (p = a; p && n--; p++)
		soap_default___trt__GetMetadataConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetMetadataConfigurations(struct soap *soap, const struct __trt__GetMetadataConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetMetadataConfigurations(soap, tag ? tag : "-trt:GetMetadataConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfigurations * SOAP_FMAC4 soap_get___trt__GetMetadataConfigurations(struct soap *soap, struct __trt__GetMetadataConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoAnalyticsConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const struct __trt__GetVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, &a->trt__GetVideoAnalyticsConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoAnalyticsConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, "trt:GetVideoAnalyticsConfigurations", -1, &a->trt__GetVideoAnalyticsConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_in___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct __trt__GetVideoAnalyticsConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetVideoAnalyticsConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoAnalyticsConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoAnalyticsConfigurations, sizeof(struct __trt__GetVideoAnalyticsConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoAnalyticsConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoAnalyticsConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, "trt:GetVideoAnalyticsConfigurations", &a->trt__GetVideoAnalyticsConfigurations, ""))
				{	soap_flag_trt__GetVideoAnalyticsConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_new___trt__GetVideoAnalyticsConfigurations(struct soap *soap, int n)
{
	struct __trt__GetVideoAnalyticsConfigurations *p;
	struct __trt__GetVideoAnalyticsConfigurations *a = (struct __trt__GetVideoAnalyticsConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __trt__GetVideoAnalyticsConfigurations));
	for (p = a; p && n--; p++)
		soap_default___trt__GetVideoAnalyticsConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const struct __trt__GetVideoAnalyticsConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoAnalyticsConfigurations(soap, tag ? tag : "-trt:GetVideoAnalyticsConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_get___trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetVideoAnalyticsConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
