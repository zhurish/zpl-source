/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:05 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__StringItems(struct soap *soap, struct _tt__StringItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeItem = 0;
	a->Item = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__StringItems(struct soap *soap, const struct _tt__StringItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Item)
	{	int i;
		for (i = 0; i < (int)a->__sizeItem; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->Item + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__StringItems(struct soap *soap, const char *tag, int id, const struct _tt__StringItems *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__StringItems), type))
		return soap->error;
	if (a->Item)
	{	int i;
		for (i = 0; i < (int)a->__sizeItem; i++)
			if (soap_out_string(soap, "tt:Item", -1, (char*const*)(a->Item + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__StringItems * SOAP_FMAC4 soap_in__tt__StringItems(struct soap *soap, const char *tag, struct _tt__StringItems *a, const char *type)
{
	struct soap_blist *soap_blist_Item = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__StringItems*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__StringItems, sizeof(struct _tt__StringItems), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__StringItems(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Item", 1, NULL))
			{	if (a->Item == NULL)
				{	if (soap_blist_Item == NULL)
						soap_blist_Item = soap_alloc_block(soap);
					a->Item = (char **)soap_push_block_max(soap, soap_blist_Item, sizeof(char *));
					if (a->Item == NULL)
						return NULL;
					*a->Item = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:Item", (char**)a->Item, "xsd:string"))
				{	a->__sizeItem++;
					a->Item = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Item)
			soap_pop_block(soap, soap_blist_Item);
		if (a->__sizeItem)
		{	a->Item = (char **)soap_save_block(soap, soap_blist_Item, NULL, 1);
		}
		else
		{	a->Item = NULL;
			if (soap_blist_Item)
				soap_end_block(soap, soap_blist_Item);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeItem < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tt__StringItems *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__StringItems, SOAP_TYPE__tt__StringItems, sizeof(struct _tt__StringItems), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__StringItems * SOAP_FMAC4 soap_new__tt__StringItems(struct soap *soap, int n)
{
	struct _tt__StringItems *p;
	struct _tt__StringItems *a = (struct _tt__StringItems*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__StringItems));
	for (p = a; p && n--; p++)
		soap_default__tt__StringItems(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__StringItems(struct soap *soap, const struct _tt__StringItems *a, const char *tag, const char *type)
{
	if (soap_out__tt__StringItems(soap, tag ? tag : "tt:StringItems", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__StringItems * SOAP_FMAC4 soap_get__tt__StringItems(struct soap *soap, struct _tt__StringItems *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__StringItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventStreamExtension(struct soap *soap, struct tt__EventStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventStreamExtension(struct soap *soap, const struct tt__EventStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__EventStreamExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventStreamExtension * SOAP_FMAC4 soap_in_tt__EventStreamExtension(struct soap *soap, const char *tag, struct tt__EventStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__EventStreamExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventStreamExtension, sizeof(struct tt__EventStreamExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventStreamExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventStreamExtension, SOAP_TYPE_tt__EventStreamExtension, sizeof(struct tt__EventStreamExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EventStreamExtension * SOAP_FMAC4 soap_new_tt__EventStreamExtension(struct soap *soap, int n)
{
	struct tt__EventStreamExtension *p;
	struct tt__EventStreamExtension *a = (struct tt__EventStreamExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EventStreamExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__EventStreamExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventStreamExtension(struct soap *soap, const struct tt__EventStreamExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__EventStreamExtension(soap, tag ? tag : "tt:EventStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventStreamExtension * SOAP_FMAC4 soap_get_tt__EventStreamExtension(struct soap *soap, struct tt__EventStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tt__union_EventStream(struct soap *soap, struct __tt__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_EventStream = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tt__union_EventStream(struct soap *soap, const struct __tt__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_EventStream(soap, a->__union_EventStream, &a->union_EventStream);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_EventStream(struct soap *soap, const char *tag, int id, const struct __tt__union_EventStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__tt__union_EventStream(soap, a->__union_EventStream, &a->union_EventStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_EventStream * SOAP_FMAC4 soap_in___tt__union_EventStream(struct soap *soap, const char *tag, struct __tt__union_EventStream *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tt__union_EventStream*)soap_id_enter(soap, "", a, SOAP_TYPE___tt__union_EventStream, sizeof(struct __tt__union_EventStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tt__union_EventStream(soap, a);
		if (!soap_in__tt__union_EventStream(soap, &a->__union_EventStream, &a->union_EventStream))
			return NULL;
	return a;
}

SOAP_FMAC3 struct __tt__union_EventStream * SOAP_FMAC4 soap_new___tt__union_EventStream(struct soap *soap, int n)
{
	struct __tt__union_EventStream *p;
	struct __tt__union_EventStream *a = (struct __tt__union_EventStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tt__union_EventStream));
	for (p = a; p && n--; p++)
		soap_default___tt__union_EventStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tt__union_EventStream(struct soap *soap, const struct __tt__union_EventStream *a, const char *tag, const char *type)
{
	if (soap_out___tt__union_EventStream(soap, tag ? tag : "-tt:union-EventStream", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_EventStream * SOAP_FMAC4 soap_get___tt__union_EventStream(struct soap *soap, struct __tt__union_EventStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStreamExtension(struct soap *soap, struct tt__PTZStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStreamExtension(struct soap *soap, const struct tt__PTZStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZStreamExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStreamExtension * SOAP_FMAC4 soap_in_tt__PTZStreamExtension(struct soap *soap, const char *tag, struct tt__PTZStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZStreamExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStreamExtension, sizeof(struct tt__PTZStreamExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStreamExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStreamExtension, SOAP_TYPE_tt__PTZStreamExtension, sizeof(struct tt__PTZStreamExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZStreamExtension * SOAP_FMAC4 soap_new_tt__PTZStreamExtension(struct soap *soap, int n)
{
	struct tt__PTZStreamExtension *p;
	struct tt__PTZStreamExtension *a = (struct tt__PTZStreamExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZStreamExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZStreamExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStreamExtension(struct soap *soap, const struct tt__PTZStreamExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZStreamExtension(soap, tag ? tag : "tt:PTZStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStreamExtension * SOAP_FMAC4 soap_get_tt__PTZStreamExtension(struct soap *soap, struct tt__PTZStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tt__union_PTZStream(struct soap *soap, struct __tt__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_PTZStream = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tt__union_PTZStream(struct soap *soap, const struct __tt__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_PTZStream(soap, a->__union_PTZStream, &a->union_PTZStream);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_PTZStream(struct soap *soap, const char *tag, int id, const struct __tt__union_PTZStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__tt__union_PTZStream(soap, a->__union_PTZStream, &a->union_PTZStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_PTZStream * SOAP_FMAC4 soap_in___tt__union_PTZStream(struct soap *soap, const char *tag, struct __tt__union_PTZStream *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tt__union_PTZStream*)soap_id_enter(soap, "", a, SOAP_TYPE___tt__union_PTZStream, sizeof(struct __tt__union_PTZStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tt__union_PTZStream(soap, a);
		if (!soap_in__tt__union_PTZStream(soap, &a->__union_PTZStream, &a->union_PTZStream))
			return NULL;
	return a;
}

SOAP_FMAC3 struct __tt__union_PTZStream * SOAP_FMAC4 soap_new___tt__union_PTZStream(struct soap *soap, int n)
{
	struct __tt__union_PTZStream *p;
	struct __tt__union_PTZStream *a = (struct __tt__union_PTZStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tt__union_PTZStream));
	for (p = a; p && n--; p++)
		soap_default___tt__union_PTZStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tt__union_PTZStream(struct soap *soap, const struct __tt__union_PTZStream *a, const char *tag, const char *type)
{
	if (soap_out___tt__union_PTZStream(soap, tag ? tag : "-tt:union-PTZStream", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_PTZStream * SOAP_FMAC4 soap_get___tt__union_PTZStream(struct soap *soap, struct __tt__union_PTZStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoAnalyticsStreamExtension(struct soap *soap, struct tt__VideoAnalyticsStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoAnalyticsStreamExtension(struct soap *soap, const struct tt__VideoAnalyticsStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoAnalyticsStreamExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStreamExtension * SOAP_FMAC4 soap_in_tt__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, struct tt__VideoAnalyticsStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoAnalyticsStreamExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, sizeof(struct tt__VideoAnalyticsStreamExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoAnalyticsStreamExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, sizeof(struct tt__VideoAnalyticsStreamExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoAnalyticsStreamExtension * SOAP_FMAC4 soap_new_tt__VideoAnalyticsStreamExtension(struct soap *soap, int n)
{
	struct tt__VideoAnalyticsStreamExtension *p;
	struct tt__VideoAnalyticsStreamExtension *a = (struct tt__VideoAnalyticsStreamExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoAnalyticsStreamExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoAnalyticsStreamExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoAnalyticsStreamExtension(struct soap *soap, const struct tt__VideoAnalyticsStreamExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoAnalyticsStreamExtension(soap, tag ? tag : "tt:VideoAnalyticsStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStreamExtension * SOAP_FMAC4 soap_get_tt__VideoAnalyticsStreamExtension(struct soap *soap, struct tt__VideoAnalyticsStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tt__union_VideoAnalyticsStream(struct soap *soap, struct __tt__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_VideoAnalyticsStream = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tt__union_VideoAnalyticsStream(struct soap *soap, const struct __tt__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, int id, const struct __tt__union_VideoAnalyticsStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__tt__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_in___tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, struct __tt__union_VideoAnalyticsStream *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tt__union_VideoAnalyticsStream*)soap_id_enter(soap, "", a, SOAP_TYPE___tt__union_VideoAnalyticsStream, sizeof(struct __tt__union_VideoAnalyticsStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tt__union_VideoAnalyticsStream(soap, a);
		if (!soap_in__tt__union_VideoAnalyticsStream(soap, &a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream))
			return NULL;
	return a;
}

SOAP_FMAC3 struct __tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_new___tt__union_VideoAnalyticsStream(struct soap *soap, int n)
{
	struct __tt__union_VideoAnalyticsStream *p;
	struct __tt__union_VideoAnalyticsStream *a = (struct __tt__union_VideoAnalyticsStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tt__union_VideoAnalyticsStream));
	for (p = a; p && n--; p++)
		soap_default___tt__union_VideoAnalyticsStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tt__union_VideoAnalyticsStream(struct soap *soap, const struct __tt__union_VideoAnalyticsStream *a, const char *tag, const char *type)
{
	if (soap_out___tt__union_VideoAnalyticsStream(soap, tag ? tag : "-tt:union-VideoAnalyticsStream", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_get___tt__union_VideoAnalyticsStream(struct soap *soap, struct __tt__union_VideoAnalyticsStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioAnalyticsStreamExtension(struct soap *soap, struct tt__AudioAnalyticsStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioAnalyticsStreamExtension(struct soap *soap, const struct tt__AudioAnalyticsStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioAnalyticsStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__AudioAnalyticsStreamExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioAnalyticsStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioAnalyticsStreamExtension * SOAP_FMAC4 soap_in_tt__AudioAnalyticsStreamExtension(struct soap *soap, const char *tag, struct tt__AudioAnalyticsStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioAnalyticsStreamExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioAnalyticsStreamExtension, sizeof(struct tt__AudioAnalyticsStreamExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioAnalyticsStreamExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioAnalyticsStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioAnalyticsStreamExtension, SOAP_TYPE_tt__AudioAnalyticsStreamExtension, sizeof(struct tt__AudioAnalyticsStreamExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioAnalyticsStreamExtension * SOAP_FMAC4 soap_new_tt__AudioAnalyticsStreamExtension(struct soap *soap, int n)
{
	struct tt__AudioAnalyticsStreamExtension *p;
	struct tt__AudioAnalyticsStreamExtension *a = (struct tt__AudioAnalyticsStreamExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioAnalyticsStreamExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioAnalyticsStreamExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioAnalyticsStreamExtension(struct soap *soap, const struct tt__AudioAnalyticsStreamExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioAnalyticsStreamExtension(soap, tag ? tag : "tt:AudioAnalyticsStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioAnalyticsStreamExtension * SOAP_FMAC4 soap_get_tt__AudioAnalyticsStreamExtension(struct soap *soap, struct tt__AudioAnalyticsStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioAnalyticsStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioDescriptor(struct soap *soap, struct tt__AudioDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->UtcTime);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioDescriptor(struct soap *soap, const struct tt__AudioDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDescriptor(struct soap *soap, const char *tag, int id, const struct tt__AudioDescriptor *a, const char *type)
{
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, a->UtcTime), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDescriptor), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioDescriptor * SOAP_FMAC4 soap_in_tt__AudioDescriptor(struct soap *soap, const char *tag, struct tt__AudioDescriptor *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioDescriptor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDescriptor, sizeof(struct tt__AudioDescriptor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioDescriptor(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 5, 1), &a->UtcTime))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDescriptor, SOAP_TYPE_tt__AudioDescriptor, sizeof(struct tt__AudioDescriptor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioDescriptor * SOAP_FMAC4 soap_new_tt__AudioDescriptor(struct soap *soap, int n)
{
	struct tt__AudioDescriptor *p;
	struct tt__AudioDescriptor *a = (struct tt__AudioDescriptor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioDescriptor));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioDescriptor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioDescriptor(struct soap *soap, const struct tt__AudioDescriptor *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioDescriptor(soap, tag ? tag : "tt:AudioDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDescriptor * SOAP_FMAC4 soap_get_tt__AudioDescriptor(struct soap *soap, struct tt__AudioDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataStreamExtension2(struct soap *soap, struct tt__MetadataStreamExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataStreamExtension2(struct soap *soap, const struct tt__MetadataStreamExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataStreamExtension2(struct soap *soap, const char *tag, int id, const struct tt__MetadataStreamExtension2 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataStreamExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension2 * SOAP_FMAC4 soap_in_tt__MetadataStreamExtension2(struct soap *soap, const char *tag, struct tt__MetadataStreamExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MetadataStreamExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataStreamExtension2, sizeof(struct tt__MetadataStreamExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataStreamExtension2(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataStreamExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataStreamExtension2, SOAP_TYPE_tt__MetadataStreamExtension2, sizeof(struct tt__MetadataStreamExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataStreamExtension2 * SOAP_FMAC4 soap_new_tt__MetadataStreamExtension2(struct soap *soap, int n)
{
	struct tt__MetadataStreamExtension2 *p;
	struct tt__MetadataStreamExtension2 *a = (struct tt__MetadataStreamExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataStreamExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataStreamExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataStreamExtension2(struct soap *soap, const struct tt__MetadataStreamExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataStreamExtension2(soap, tag ? tag : "tt:MetadataStreamExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension2 * SOAP_FMAC4 soap_get_tt__MetadataStreamExtension2(struct soap *soap, struct tt__MetadataStreamExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataStreamExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioAnalyticsStream(struct soap *soap, struct tt__AudioAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudioDescriptor = 0;
	a->AudioDescriptor = NULL;
	a->Extension = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioAnalyticsStream(struct soap *soap, const struct tt__AudioAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AudioDescriptor)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudioDescriptor; i++)
		{
			soap_embedded(soap, a->AudioDescriptor + i, SOAP_TYPE_tt__AudioDescriptor);
			soap_serialize_tt__AudioDescriptor(soap, a->AudioDescriptor + i);
		}
	}
	soap_serialize_PointerTott__AudioAnalyticsStreamExtension(soap, &a->Extension);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioAnalyticsStream(struct soap *soap, const char *tag, int id, const struct tt__AudioAnalyticsStream *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioAnalyticsStream), type))
		return soap->error;
	if (a->AudioDescriptor)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudioDescriptor; i++)
			if (soap_out_tt__AudioDescriptor(soap, "tt:AudioDescriptor", -1, a->AudioDescriptor + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AudioAnalyticsStreamExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioAnalyticsStream * SOAP_FMAC4 soap_in_tt__AudioAnalyticsStream(struct soap *soap, const char *tag, struct tt__AudioAnalyticsStream *a, const char *type)
{
	struct soap_blist *soap_blist_AudioDescriptor = NULL;
	size_t soap_flag_Extension = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioAnalyticsStream*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioAnalyticsStream, sizeof(struct tt__AudioAnalyticsStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioAnalyticsStream(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AudioDescriptor", 1, NULL))
			{	if (a->AudioDescriptor == NULL)
				{	if (soap_blist_AudioDescriptor == NULL)
						soap_blist_AudioDescriptor = soap_alloc_block(soap);
					a->AudioDescriptor = (struct tt__AudioDescriptor *)soap_push_block_max(soap, soap_blist_AudioDescriptor, sizeof(struct tt__AudioDescriptor));
					if (a->AudioDescriptor == NULL)
						return NULL;
					soap_default_tt__AudioDescriptor(soap, a->AudioDescriptor);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioDescriptor(soap, "tt:AudioDescriptor", a->AudioDescriptor, "tt:AudioDescriptor"))
				{	a->__sizeAudioDescriptor++;
					a->AudioDescriptor = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioAnalyticsStreamExtension(soap, "tt:Extension", &a->Extension, "tt:AudioAnalyticsStreamExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AudioDescriptor)
			soap_pop_block(soap, soap_blist_AudioDescriptor);
		if (a->__sizeAudioDescriptor)
		{	a->AudioDescriptor = (struct tt__AudioDescriptor *)soap_save_block(soap, soap_blist_AudioDescriptor, NULL, 1);
		}
		else
		{	a->AudioDescriptor = NULL;
			if (soap_blist_AudioDescriptor)
				soap_end_block(soap, soap_blist_AudioDescriptor);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioAnalyticsStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioAnalyticsStream, SOAP_TYPE_tt__AudioAnalyticsStream, sizeof(struct tt__AudioAnalyticsStream), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioAnalyticsStream * SOAP_FMAC4 soap_new_tt__AudioAnalyticsStream(struct soap *soap, int n)
{
	struct tt__AudioAnalyticsStream *p;
	struct tt__AudioAnalyticsStream *a = (struct tt__AudioAnalyticsStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioAnalyticsStream));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioAnalyticsStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioAnalyticsStream(struct soap *soap, const struct tt__AudioAnalyticsStream *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioAnalyticsStream(soap, tag ? tag : "tt:AudioAnalyticsStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioAnalyticsStream * SOAP_FMAC4 soap_get_tt__AudioAnalyticsStream(struct soap *soap, struct tt__AudioAnalyticsStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataStreamExtension(struct soap *soap, struct tt__MetadataStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->AudioAnalyticsStream = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataStreamExtension(struct soap *soap, const struct tt__MetadataStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_serialize_PointerTott__AudioAnalyticsStream(soap, &a->AudioAnalyticsStream);
	soap_serialize_PointerTott__MetadataStreamExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__MetadataStreamExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AudioAnalyticsStream(soap, "tt:AudioAnalyticsStream", -1, &a->AudioAnalyticsStream, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataStreamExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension * SOAP_FMAC4 soap_in_tt__MetadataStreamExtension(struct soap *soap, const char *tag, struct tt__MetadataStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_AudioAnalyticsStream = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MetadataStreamExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataStreamExtension, sizeof(struct tt__MetadataStreamExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataStreamExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioAnalyticsStream && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioAnalyticsStream(soap, "tt:AudioAnalyticsStream", &a->AudioAnalyticsStream, "tt:AudioAnalyticsStream"))
				{	soap_flag_AudioAnalyticsStream--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataStreamExtension2(soap, "tt:Extension", &a->Extension, "tt:MetadataStreamExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataStreamExtension, SOAP_TYPE_tt__MetadataStreamExtension, sizeof(struct tt__MetadataStreamExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataStreamExtension * SOAP_FMAC4 soap_new_tt__MetadataStreamExtension(struct soap *soap, int n)
{
	struct tt__MetadataStreamExtension *p;
	struct tt__MetadataStreamExtension *a = (struct tt__MetadataStreamExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataStreamExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataStreamExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataStreamExtension(struct soap *soap, const struct tt__MetadataStreamExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataStreamExtension(soap, tag ? tag : "tt:MetadataStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension * SOAP_FMAC4 soap_get_tt__MetadataStreamExtension(struct soap *soap, struct tt__MetadataStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventStream(struct soap *soap, struct tt__EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_EventStream = 0;
	a->__union_EventStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventStream(struct soap *soap, const struct tt__EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_EventStream)
	{	int i;
		for (i = 0; i < (int)a->__size_EventStream; i++)
		{
			soap_serialize___tt__union_EventStream(soap, a->__union_EventStream + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventStream(struct soap *soap, const char *tag, int id, const struct tt__EventStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventStream), type))
		return soap->error;
	if (a->__union_EventStream)
	{	int i;
		for (i = 0; i < (int)a->__size_EventStream; i++)
			if (soap_out___tt__union_EventStream(soap, "-union-EventStream", -1, a->__union_EventStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventStream * SOAP_FMAC4 soap_in_tt__EventStream(struct soap *soap, const char *tag, struct tt__EventStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_EventStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__EventStream*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventStream, sizeof(struct tt__EventStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventStream(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_EventStream == NULL)
				{	if (soap_blist___union_EventStream == NULL)
						soap_blist___union_EventStream = soap_alloc_block(soap);
					a->__union_EventStream = (struct __tt__union_EventStream *)soap_push_block_max(soap, soap_blist___union_EventStream, sizeof(struct __tt__union_EventStream));
					if (a->__union_EventStream == NULL)
						return NULL;
					soap_default___tt__union_EventStream(soap, a->__union_EventStream);
				}
				if (soap_in___tt__union_EventStream(soap, "-union-EventStream", a->__union_EventStream, "-tt:union-EventStream"))
				{	a->__size_EventStream++;
					a->__union_EventStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_EventStream)
			soap_pop_block(soap, soap_blist___union_EventStream);
		if (a->__size_EventStream)
		{	a->__union_EventStream = (struct __tt__union_EventStream *)soap_save_block(soap, soap_blist___union_EventStream, NULL, 1);
		}
		else
		{	a->__union_EventStream = NULL;
			if (soap_blist___union_EventStream)
				soap_end_block(soap, soap_blist___union_EventStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventStream, SOAP_TYPE_tt__EventStream, sizeof(struct tt__EventStream), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EventStream * SOAP_FMAC4 soap_new_tt__EventStream(struct soap *soap, int n)
{
	struct tt__EventStream *p;
	struct tt__EventStream *a = (struct tt__EventStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EventStream));
	for (p = a; p && n--; p++)
		soap_default_tt__EventStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventStream(struct soap *soap, const struct tt__EventStream *a, const char *tag, const char *type)
{
	if (soap_out_tt__EventStream(soap, tag ? tag : "tt:EventStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventStream * SOAP_FMAC4 soap_get_tt__EventStream(struct soap *soap, struct tt__EventStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStream(struct soap *soap, struct tt__PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_PTZStream = 0;
	a->__union_PTZStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStream(struct soap *soap, const struct tt__PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_PTZStream)
	{	int i;
		for (i = 0; i < (int)a->__size_PTZStream; i++)
		{
			soap_serialize___tt__union_PTZStream(soap, a->__union_PTZStream + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStream(struct soap *soap, const char *tag, int id, const struct tt__PTZStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStream), type))
		return soap->error;
	if (a->__union_PTZStream)
	{	int i;
		for (i = 0; i < (int)a->__size_PTZStream; i++)
			if (soap_out___tt__union_PTZStream(soap, "-union-PTZStream", -1, a->__union_PTZStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStream * SOAP_FMAC4 soap_in_tt__PTZStream(struct soap *soap, const char *tag, struct tt__PTZStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_PTZStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZStream*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStream, sizeof(struct tt__PTZStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStream(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_PTZStream == NULL)
				{	if (soap_blist___union_PTZStream == NULL)
						soap_blist___union_PTZStream = soap_alloc_block(soap);
					a->__union_PTZStream = (struct __tt__union_PTZStream *)soap_push_block_max(soap, soap_blist___union_PTZStream, sizeof(struct __tt__union_PTZStream));
					if (a->__union_PTZStream == NULL)
						return NULL;
					soap_default___tt__union_PTZStream(soap, a->__union_PTZStream);
				}
				if (soap_in___tt__union_PTZStream(soap, "-union-PTZStream", a->__union_PTZStream, "-tt:union-PTZStream"))
				{	a->__size_PTZStream++;
					a->__union_PTZStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_PTZStream)
			soap_pop_block(soap, soap_blist___union_PTZStream);
		if (a->__size_PTZStream)
		{	a->__union_PTZStream = (struct __tt__union_PTZStream *)soap_save_block(soap, soap_blist___union_PTZStream, NULL, 1);
		}
		else
		{	a->__union_PTZStream = NULL;
			if (soap_blist___union_PTZStream)
				soap_end_block(soap, soap_blist___union_PTZStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStream, SOAP_TYPE_tt__PTZStream, sizeof(struct tt__PTZStream), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZStream * SOAP_FMAC4 soap_new_tt__PTZStream(struct soap *soap, int n)
{
	struct tt__PTZStream *p;
	struct tt__PTZStream *a = (struct tt__PTZStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZStream));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStream(struct soap *soap, const struct tt__PTZStream *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZStream(soap, tag ? tag : "tt:PTZStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStream * SOAP_FMAC4 soap_get_tt__PTZStream(struct soap *soap, struct tt__PTZStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoAnalyticsStream(struct soap *soap, struct tt__VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_VideoAnalyticsStream = 0;
	a->__union_VideoAnalyticsStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoAnalyticsStream(struct soap *soap, const struct tt__VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_VideoAnalyticsStream)
	{	int i;
		for (i = 0; i < (int)a->__size_VideoAnalyticsStream; i++)
		{
			soap_serialize___tt__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsStream(struct soap *soap, const char *tag, int id, const struct tt__VideoAnalyticsStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsStream), type))
		return soap->error;
	if (a->__union_VideoAnalyticsStream)
	{	int i;
		for (i = 0; i < (int)a->__size_VideoAnalyticsStream; i++)
			if (soap_out___tt__union_VideoAnalyticsStream(soap, "-union-VideoAnalyticsStream", -1, a->__union_VideoAnalyticsStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStream * SOAP_FMAC4 soap_in_tt__VideoAnalyticsStream(struct soap *soap, const char *tag, struct tt__VideoAnalyticsStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_VideoAnalyticsStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoAnalyticsStream*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsStream, sizeof(struct tt__VideoAnalyticsStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoAnalyticsStream(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_VideoAnalyticsStream == NULL)
				{	if (soap_blist___union_VideoAnalyticsStream == NULL)
						soap_blist___union_VideoAnalyticsStream = soap_alloc_block(soap);
					a->__union_VideoAnalyticsStream = (struct __tt__union_VideoAnalyticsStream *)soap_push_block_max(soap, soap_blist___union_VideoAnalyticsStream, sizeof(struct __tt__union_VideoAnalyticsStream));
					if (a->__union_VideoAnalyticsStream == NULL)
						return NULL;
					soap_default___tt__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream);
				}
				if (soap_in___tt__union_VideoAnalyticsStream(soap, "-union-VideoAnalyticsStream", a->__union_VideoAnalyticsStream, "-tt:union-VideoAnalyticsStream"))
				{	a->__size_VideoAnalyticsStream++;
					a->__union_VideoAnalyticsStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_VideoAnalyticsStream)
			soap_pop_block(soap, soap_blist___union_VideoAnalyticsStream);
		if (a->__size_VideoAnalyticsStream)
		{	a->__union_VideoAnalyticsStream = (struct __tt__union_VideoAnalyticsStream *)soap_save_block(soap, soap_blist___union_VideoAnalyticsStream, NULL, 1);
		}
		else
		{	a->__union_VideoAnalyticsStream = NULL;
			if (soap_blist___union_VideoAnalyticsStream)
				soap_end_block(soap, soap_blist___union_VideoAnalyticsStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsStream, SOAP_TYPE_tt__VideoAnalyticsStream, sizeof(struct tt__VideoAnalyticsStream), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoAnalyticsStream * SOAP_FMAC4 soap_new_tt__VideoAnalyticsStream(struct soap *soap, int n)
{
	struct tt__VideoAnalyticsStream *p;
	struct tt__VideoAnalyticsStream *a = (struct tt__VideoAnalyticsStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoAnalyticsStream));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoAnalyticsStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoAnalyticsStream(struct soap *soap, const struct tt__VideoAnalyticsStream *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoAnalyticsStream(soap, tag ? tag : "tt:VideoAnalyticsStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStream * SOAP_FMAC4 soap_get_tt__VideoAnalyticsStream(struct soap *soap, struct tt__VideoAnalyticsStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tt__union_MetadataStream(struct soap *soap, struct __tt__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_MetadataStream = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tt__union_MetadataStream(struct soap *soap, const struct __tt__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_MetadataStream(soap, a->__union_MetadataStream, &a->union_MetadataStream);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_MetadataStream(struct soap *soap, const char *tag, int id, const struct __tt__union_MetadataStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__tt__union_MetadataStream(soap, a->__union_MetadataStream, &a->union_MetadataStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_MetadataStream * SOAP_FMAC4 soap_in___tt__union_MetadataStream(struct soap *soap, const char *tag, struct __tt__union_MetadataStream *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tt__union_MetadataStream*)soap_id_enter(soap, "", a, SOAP_TYPE___tt__union_MetadataStream, sizeof(struct __tt__union_MetadataStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tt__union_MetadataStream(soap, a);
		if (!soap_in__tt__union_MetadataStream(soap, &a->__union_MetadataStream, &a->union_MetadataStream))
			return NULL;
	return a;
}

SOAP_FMAC3 struct __tt__union_MetadataStream * SOAP_FMAC4 soap_new___tt__union_MetadataStream(struct soap *soap, int n)
{
	struct __tt__union_MetadataStream *p;
	struct __tt__union_MetadataStream *a = (struct __tt__union_MetadataStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tt__union_MetadataStream));
	for (p = a; p && n--; p++)
		soap_default___tt__union_MetadataStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tt__union_MetadataStream(struct soap *soap, const struct __tt__union_MetadataStream *a, const char *tag, const char *type)
{
	if (soap_out___tt__union_MetadataStream(soap, tag ? tag : "-tt:union-MetadataStream", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_MetadataStream * SOAP_FMAC4 soap_get___tt__union_MetadataStream(struct soap *soap, struct __tt__union_MetadataStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataStream(struct soap *soap, struct tt__MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_MetadataStream = 0;
	a->__union_MetadataStream = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataStream(struct soap *soap, const struct tt__MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_MetadataStream)
	{	int i;
		for (i = 0; i < (int)a->__size_MetadataStream; i++)
		{
			soap_serialize___tt__union_MetadataStream(soap, a->__union_MetadataStream + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataStream(struct soap *soap, const char *tag, int id, const struct tt__MetadataStream *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataStream), type))
		return soap->error;
	if (a->__union_MetadataStream)
	{	int i;
		for (i = 0; i < (int)a->__size_MetadataStream; i++)
			if (soap_out___tt__union_MetadataStream(soap, "-union-MetadataStream", -1, a->__union_MetadataStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataStream * SOAP_FMAC4 soap_in_tt__MetadataStream(struct soap *soap, const char *tag, struct tt__MetadataStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_MetadataStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MetadataStream*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataStream, sizeof(struct tt__MetadataStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataStream(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_MetadataStream == NULL)
				{	if (soap_blist___union_MetadataStream == NULL)
						soap_blist___union_MetadataStream = soap_alloc_block(soap);
					a->__union_MetadataStream = (struct __tt__union_MetadataStream *)soap_push_block_max(soap, soap_blist___union_MetadataStream, sizeof(struct __tt__union_MetadataStream));
					if (a->__union_MetadataStream == NULL)
						return NULL;
					soap_default___tt__union_MetadataStream(soap, a->__union_MetadataStream);
				}
				if (soap_in___tt__union_MetadataStream(soap, "-union-MetadataStream", a->__union_MetadataStream, "-tt:union-MetadataStream"))
				{	a->__size_MetadataStream++;
					a->__union_MetadataStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_MetadataStream)
			soap_pop_block(soap, soap_blist___union_MetadataStream);
		if (a->__size_MetadataStream)
		{	a->__union_MetadataStream = (struct __tt__union_MetadataStream *)soap_save_block(soap, soap_blist___union_MetadataStream, NULL, 1);
		}
		else
		{	a->__union_MetadataStream = NULL;
			if (soap_blist___union_MetadataStream)
				soap_end_block(soap, soap_blist___union_MetadataStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataStream, SOAP_TYPE_tt__MetadataStream, sizeof(struct tt__MetadataStream), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataStream * SOAP_FMAC4 soap_new_tt__MetadataStream(struct soap *soap, int n)
{
	struct tt__MetadataStream *p;
	struct tt__MetadataStream *a = (struct tt__MetadataStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataStream));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataStream(struct soap *soap, const struct tt__MetadataStream *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataStream(soap, tag ? tag : "tt:MetadataStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataStream * SOAP_FMAC4 soap_get_tt__MetadataStream(struct soap *soap, struct tt__MetadataStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ObjectTreeExtension(struct soap *soap, const struct tt__ObjectTreeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectTreeExtension(struct soap *soap, const char *tag, int id, const struct tt__ObjectTreeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectTreeExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ObjectTreeExtension * SOAP_FMAC4 soap_in_tt__ObjectTreeExtension(struct soap *soap, const char *tag, struct tt__ObjectTreeExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ObjectTreeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectTreeExtension, sizeof(struct tt__ObjectTreeExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ObjectTreeExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectTreeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectTreeExtension, SOAP_TYPE_tt__ObjectTreeExtension, sizeof(struct tt__ObjectTreeExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ObjectTreeExtension * SOAP_FMAC4 soap_new_tt__ObjectTreeExtension(struct soap *soap, int n)
{
	struct tt__ObjectTreeExtension *p;
	struct tt__ObjectTreeExtension *a = (struct tt__ObjectTreeExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ObjectTreeExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ObjectTreeExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ObjectTreeExtension(struct soap *soap, const struct tt__ObjectTreeExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ObjectTreeExtension(soap, tag ? tag : "tt:ObjectTreeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectTreeExtension * SOAP_FMAC4 soap_get_tt__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectTreeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BehaviourExtension(struct soap *soap, const struct tt__BehaviourExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BehaviourExtension(struct soap *soap, const char *tag, int id, const struct tt__BehaviourExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BehaviourExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BehaviourExtension * SOAP_FMAC4 soap_in_tt__BehaviourExtension(struct soap *soap, const char *tag, struct tt__BehaviourExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__BehaviourExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BehaviourExtension, sizeof(struct tt__BehaviourExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BehaviourExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__BehaviourExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BehaviourExtension, SOAP_TYPE_tt__BehaviourExtension, sizeof(struct tt__BehaviourExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__BehaviourExtension * SOAP_FMAC4 soap_new_tt__BehaviourExtension(struct soap *soap, int n)
{
	struct tt__BehaviourExtension *p;
	struct tt__BehaviourExtension *a = (struct tt__BehaviourExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__BehaviourExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__BehaviourExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BehaviourExtension(struct soap *soap, const struct tt__BehaviourExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__BehaviourExtension(soap, tag ? tag : "tt:BehaviourExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BehaviourExtension * SOAP_FMAC4 soap_get_tt__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BehaviourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__Behaviour_Idle(struct soap *soap, const struct _tt__Behaviour_Idle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Behaviour_Idle(struct soap *soap, const char *tag, int id, const struct _tt__Behaviour_Idle *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Behaviour_Idle), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__Behaviour_Idle * SOAP_FMAC4 soap_in__tt__Behaviour_Idle(struct soap *soap, const char *tag, struct _tt__Behaviour_Idle *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__Behaviour_Idle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Behaviour_Idle, sizeof(struct _tt__Behaviour_Idle), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__Behaviour_Idle(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__Behaviour_Idle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Behaviour_Idle, SOAP_TYPE__tt__Behaviour_Idle, sizeof(struct _tt__Behaviour_Idle), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__Behaviour_Idle * SOAP_FMAC4 soap_new__tt__Behaviour_Idle(struct soap *soap, int n)
{
	struct _tt__Behaviour_Idle *p;
	struct _tt__Behaviour_Idle *a = (struct _tt__Behaviour_Idle*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__Behaviour_Idle));
	for (p = a; p && n--; p++)
		soap_default__tt__Behaviour_Idle(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__Behaviour_Idle(struct soap *soap, const struct _tt__Behaviour_Idle *a, const char *tag, const char *type)
{
	if (soap_out__tt__Behaviour_Idle(soap, tag ? tag : "tt:Behaviour-Idle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Behaviour_Idle * SOAP_FMAC4 soap_get__tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Behaviour_Idle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__Behaviour_Removed(struct soap *soap, const struct _tt__Behaviour_Removed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Behaviour_Removed(struct soap *soap, const char *tag, int id, const struct _tt__Behaviour_Removed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Behaviour_Removed), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__Behaviour_Removed * SOAP_FMAC4 soap_in__tt__Behaviour_Removed(struct soap *soap, const char *tag, struct _tt__Behaviour_Removed *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__Behaviour_Removed*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Behaviour_Removed, sizeof(struct _tt__Behaviour_Removed), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__Behaviour_Removed(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__Behaviour_Removed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Behaviour_Removed, SOAP_TYPE__tt__Behaviour_Removed, sizeof(struct _tt__Behaviour_Removed), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__Behaviour_Removed * SOAP_FMAC4 soap_new__tt__Behaviour_Removed(struct soap *soap, int n)
{
	struct _tt__Behaviour_Removed *p;
	struct _tt__Behaviour_Removed *a = (struct _tt__Behaviour_Removed*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__Behaviour_Removed));
	for (p = a; p && n--; p++)
		soap_default__tt__Behaviour_Removed(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__Behaviour_Removed(struct soap *soap, const struct _tt__Behaviour_Removed *a, const char *tag, const char *type)
{
	if (soap_out__tt__Behaviour_Removed(soap, tag ? tag : "tt:Behaviour-Removed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Behaviour_Removed * SOAP_FMAC4 soap_get__tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Behaviour_Removed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Behaviour(struct soap *soap, struct tt__Behaviour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Removed = NULL;
	a->Idle = NULL;
	a->Extension = NULL;
	a->Speed = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Behaviour(struct soap *soap, const struct tt__Behaviour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tt__Behaviour_Removed(soap, &a->Removed);
	soap_serialize_PointerTo_tt__Behaviour_Idle(soap, &a->Idle);
	soap_serialize_PointerTott__BehaviourExtension(soap, &a->Extension);
	soap_serialize_PointerTofloat(soap, &a->Speed);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Behaviour(struct soap *soap, const char *tag, int id, const struct tt__Behaviour *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Behaviour), type))
		return soap->error;
	if (soap_out_PointerTo_tt__Behaviour_Removed(soap, "tt:Removed", -1, &a->Removed, ""))
		return soap->error;
	if (soap_out_PointerTo_tt__Behaviour_Idle(soap, "tt:Idle", -1, &a->Idle, ""))
		return soap->error;
	if (soap_out_PointerTott__BehaviourExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Behaviour * SOAP_FMAC4 soap_in_tt__Behaviour(struct soap *soap, const char *tag, struct tt__Behaviour *a, const char *type)
{
	size_t soap_flag_Removed = 1;
	size_t soap_flag_Idle = 1;
	size_t soap_flag_Extension = 1;
	size_t soap_flag_Speed = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Behaviour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Behaviour, sizeof(struct tt__Behaviour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Behaviour(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Removed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tt__Behaviour_Removed(soap, "tt:Removed", &a->Removed, ""))
				{	soap_flag_Removed--;
					continue;
				}
			}
			if (soap_flag_Idle && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tt__Behaviour_Idle(soap, "tt:Idle", &a->Idle, ""))
				{	soap_flag_Idle--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BehaviourExtension(soap, "tt:Extension", &a->Extension, "tt:BehaviourExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Speed", &a->Speed, "xsd:float"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Behaviour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Behaviour, SOAP_TYPE_tt__Behaviour, sizeof(struct tt__Behaviour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Behaviour * SOAP_FMAC4 soap_new_tt__Behaviour(struct soap *soap, int n)
{
	struct tt__Behaviour *p;
	struct tt__Behaviour *a = (struct tt__Behaviour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Behaviour));
	for (p = a; p && n--; p++)
		soap_default_tt__Behaviour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Behaviour(struct soap *soap, const struct tt__Behaviour *a, const char *tag, const char *type)
{
	if (soap_out_tt__Behaviour(soap, tag ? tag : "tt:Behaviour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Behaviour * SOAP_FMAC4 soap_get_tt__Behaviour(struct soap *soap, struct tt__Behaviour *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Rename(struct soap *soap, struct tt__Rename *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->from = NULL;
	a->to = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Rename(struct soap *soap, const struct tt__Rename *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ObjectId(soap, &a->from);
	soap_serialize_PointerTott__ObjectId(soap, &a->to);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rename(struct soap *soap, const char *tag, int id, const struct tt__Rename *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rename), type))
		return soap->error;
	if (!a->from)
	{	if (soap_element_empty(soap, "tt:from", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ObjectId(soap, "tt:from", -1, &a->from, ""))
		return soap->error;
	if (!a->to)
	{	if (soap_element_empty(soap, "tt:to", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ObjectId(soap, "tt:to", -1, &a->to, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Rename * SOAP_FMAC4 soap_in_tt__Rename(struct soap *soap, const char *tag, struct tt__Rename *a, const char *type)
{
	size_t soap_flag_from = 1;
	size_t soap_flag_to = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Rename*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rename, sizeof(struct tt__Rename), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Rename(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_from && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ObjectId(soap, "tt:from", &a->from, "tt:ObjectId"))
				{	soap_flag_from--;
					continue;
				}
			}
			if (soap_flag_to && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ObjectId(soap, "tt:to", &a->to, "tt:ObjectId"))
				{	soap_flag_to--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->from || !a->to))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Rename *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rename, SOAP_TYPE_tt__Rename, sizeof(struct tt__Rename), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Rename * SOAP_FMAC4 soap_new_tt__Rename(struct soap *soap, int n)
{
	struct tt__Rename *p;
	struct tt__Rename *a = (struct tt__Rename*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Rename));
	for (p = a; p && n--; p++)
		soap_default_tt__Rename(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Rename(struct soap *soap, const struct tt__Rename *a, const char *tag, const char *type)
{
	if (soap_out_tt__Rename(soap, tag ? tag : "tt:Rename", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rename * SOAP_FMAC4 soap_get_tt__Rename(struct soap *soap, struct tt__Rename *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rename(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Split(struct soap *soap, struct tt__Split *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->from = NULL;
	a->__sizeto = 0;
	a->to = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Split(struct soap *soap, const struct tt__Split *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ObjectId(soap, &a->from);
	if (a->to)
	{	int i;
		for (i = 0; i < (int)a->__sizeto; i++)
		{
			soap_embedded(soap, a->to + i, SOAP_TYPE_tt__ObjectId);
			soap_serialize_tt__ObjectId(soap, a->to + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Split(struct soap *soap, const char *tag, int id, const struct tt__Split *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Split), type))
		return soap->error;
	if (!a->from)
	{	if (soap_element_empty(soap, "tt:from", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ObjectId(soap, "tt:from", -1, &a->from, ""))
		return soap->error;
	if (a->to)
	{	int i;
		for (i = 0; i < (int)a->__sizeto; i++)
			if (soap_out_tt__ObjectId(soap, "tt:to", -1, a->to + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Split * SOAP_FMAC4 soap_in_tt__Split(struct soap *soap, const char *tag, struct tt__Split *a, const char *type)
{
	size_t soap_flag_from = 1;
	struct soap_blist *soap_blist_to = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Split*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Split, sizeof(struct tt__Split), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Split(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_from && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ObjectId(soap, "tt:from", &a->from, "tt:ObjectId"))
				{	soap_flag_from--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:to", 1, NULL))
			{	if (a->to == NULL)
				{	if (soap_blist_to == NULL)
						soap_blist_to = soap_alloc_block(soap);
					a->to = (struct tt__ObjectId *)soap_push_block_max(soap, soap_blist_to, sizeof(struct tt__ObjectId));
					if (a->to == NULL)
						return NULL;
					soap_default_tt__ObjectId(soap, a->to);
				}
				soap_revert(soap);
				if (soap_in_tt__ObjectId(soap, "tt:to", a->to, "tt:ObjectId"))
				{	a->__sizeto++;
					a->to = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->to)
			soap_pop_block(soap, soap_blist_to);
		if (a->__sizeto)
		{	a->to = (struct tt__ObjectId *)soap_save_block(soap, soap_blist_to, NULL, 1);
		}
		else
		{	a->to = NULL;
			if (soap_blist_to)
				soap_end_block(soap, soap_blist_to);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->from || a->__sizeto < 2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Split *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Split, SOAP_TYPE_tt__Split, sizeof(struct tt__Split), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Split * SOAP_FMAC4 soap_new_tt__Split(struct soap *soap, int n)
{
	struct tt__Split *p;
	struct tt__Split *a = (struct tt__Split*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Split));
	for (p = a; p && n--; p++)
		soap_default_tt__Split(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Split(struct soap *soap, const struct tt__Split *a, const char *tag, const char *type)
{
	if (soap_out_tt__Split(soap, tag ? tag : "tt:Split", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Split * SOAP_FMAC4 soap_get_tt__Split(struct soap *soap, struct tt__Split *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Split(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ObjectId(struct soap *soap, struct tt__ObjectId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->ObjectId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ObjectId(struct soap *soap, const struct tt__ObjectId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectId(struct soap *soap, const char *tag, int id, const struct tt__ObjectId *a, const char *type)
{
	if (a->ObjectId)
		soap_set_attr(soap, "ObjectId", soap_xsd__integer2s(soap, a->ObjectId), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectId), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ObjectId * SOAP_FMAC4 soap_in_tt__ObjectId(struct soap *soap, const char *tag, struct tt__ObjectId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ObjectId*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectId, sizeof(struct tt__ObjectId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ObjectId(soap, a);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "ObjectId", 5, 0), &a->ObjectId))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectId, SOAP_TYPE_tt__ObjectId, sizeof(struct tt__ObjectId), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ObjectId * SOAP_FMAC4 soap_new_tt__ObjectId(struct soap *soap, int n)
{
	struct tt__ObjectId *p;
	struct tt__ObjectId *a = (struct tt__ObjectId*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ObjectId));
	for (p = a; p && n--; p++)
		soap_default_tt__ObjectId(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ObjectId(struct soap *soap, const struct tt__ObjectId *a, const char *tag, const char *type)
{
	if (soap_out_tt__ObjectId(soap, tag ? tag : "tt:ObjectId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectId * SOAP_FMAC4 soap_get_tt__ObjectId(struct soap *soap, struct tt__ObjectId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Merge(struct soap *soap, struct tt__Merge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizefrom = 0;
	a->from = NULL;
	a->to = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Merge(struct soap *soap, const struct tt__Merge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->from)
	{	int i;
		for (i = 0; i < (int)a->__sizefrom; i++)
		{
			soap_embedded(soap, a->from + i, SOAP_TYPE_tt__ObjectId);
			soap_serialize_tt__ObjectId(soap, a->from + i);
		}
	}
	soap_serialize_PointerTott__ObjectId(soap, &a->to);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Merge(struct soap *soap, const char *tag, int id, const struct tt__Merge *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Merge), type))
		return soap->error;
	if (a->from)
	{	int i;
		for (i = 0; i < (int)a->__sizefrom; i++)
			if (soap_out_tt__ObjectId(soap, "tt:from", -1, a->from + i, ""))
				return soap->error;
	}
	if (!a->to)
	{	if (soap_element_empty(soap, "tt:to", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ObjectId(soap, "tt:to", -1, &a->to, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Merge * SOAP_FMAC4 soap_in_tt__Merge(struct soap *soap, const char *tag, struct tt__Merge *a, const char *type)
{
	struct soap_blist *soap_blist_from = NULL;
	size_t soap_flag_to = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Merge*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Merge, sizeof(struct tt__Merge), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Merge(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:from", 1, NULL))
			{	if (a->from == NULL)
				{	if (soap_blist_from == NULL)
						soap_blist_from = soap_alloc_block(soap);
					a->from = (struct tt__ObjectId *)soap_push_block_max(soap, soap_blist_from, sizeof(struct tt__ObjectId));
					if (a->from == NULL)
						return NULL;
					soap_default_tt__ObjectId(soap, a->from);
				}
				soap_revert(soap);
				if (soap_in_tt__ObjectId(soap, "tt:from", a->from, "tt:ObjectId"))
				{	a->__sizefrom++;
					a->from = NULL;
					continue;
				}
			}
			if (soap_flag_to && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ObjectId(soap, "tt:to", &a->to, "tt:ObjectId"))
				{	soap_flag_to--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->from)
			soap_pop_block(soap, soap_blist_from);
		if (a->__sizefrom)
		{	a->from = (struct tt__ObjectId *)soap_save_block(soap, soap_blist_from, NULL, 1);
		}
		else
		{	a->from = NULL;
			if (soap_blist_from)
				soap_end_block(soap, soap_blist_from);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizefrom < 2 || !a->to))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Merge *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Merge, SOAP_TYPE_tt__Merge, sizeof(struct tt__Merge), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Merge * SOAP_FMAC4 soap_new_tt__Merge(struct soap *soap, int n)
{
	struct tt__Merge *p;
	struct tt__Merge *a = (struct tt__Merge*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Merge));
	for (p = a; p && n--; p++)
		soap_default_tt__Merge(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Merge(struct soap *soap, const struct tt__Merge *a, const char *tag, const char *type)
{
	if (soap_out_tt__Merge(soap, tag ? tag : "tt:Merge", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Merge * SOAP_FMAC4 soap_get_tt__Merge(struct soap *soap, struct tt__Merge *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Merge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FrameExtension2(struct soap *soap, const struct tt__FrameExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FrameExtension2(struct soap *soap, const char *tag, int id, const struct tt__FrameExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FrameExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FrameExtension2 * SOAP_FMAC4 soap_in_tt__FrameExtension2(struct soap *soap, const char *tag, struct tt__FrameExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FrameExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FrameExtension2, sizeof(struct tt__FrameExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FrameExtension2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FrameExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FrameExtension2, SOAP_TYPE_tt__FrameExtension2, sizeof(struct tt__FrameExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FrameExtension2 * SOAP_FMAC4 soap_new_tt__FrameExtension2(struct soap *soap, int n)
{
	struct tt__FrameExtension2 *p;
	struct tt__FrameExtension2 *a = (struct tt__FrameExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FrameExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__FrameExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FrameExtension2(struct soap *soap, const struct tt__FrameExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__FrameExtension2(soap, tag ? tag : "tt:FrameExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FrameExtension2 * SOAP_FMAC4 soap_get_tt__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FrameExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MotionInCells(struct soap *soap, struct tt__MotionInCells *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__integer(soap, &a->Columns);
	soap_default_xsd__integer(soap, &a->Rows);
	soap_default_xsd__base64Binary(soap, &a->Cells);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MotionInCells(struct soap *soap, const struct tt__MotionInCells *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MotionInCells(struct soap *soap, const char *tag, int id, const struct tt__MotionInCells *a, const char *type)
{
	soap_set_attr(soap, "Columns", a->Columns ? soap_xsd__integer2s(soap, a->Columns) : "", 1);
	soap_set_attr(soap, "Rows", a->Rows ? soap_xsd__integer2s(soap, a->Rows) : "", 1);
	soap_set_attr(soap, "Cells", soap_xsd__base64Binary2s(soap, a->Cells), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MotionInCells), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MotionInCells * SOAP_FMAC4 soap_in_tt__MotionInCells(struct soap *soap, const char *tag, struct tt__MotionInCells *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MotionInCells*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MotionInCells, sizeof(struct tt__MotionInCells), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MotionInCells(soap, a);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "Columns", 5, 1), &a->Columns))
		return NULL;
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "Rows", 5, 1), &a->Rows))
		return NULL;
	if (soap_s2xsd__base64Binary(soap, soap_attr_value(soap, "Cells", 1, 1), &a->Cells))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MotionInCells *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MotionInCells, SOAP_TYPE_tt__MotionInCells, sizeof(struct tt__MotionInCells), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MotionInCells * SOAP_FMAC4 soap_new_tt__MotionInCells(struct soap *soap, int n)
{
	struct tt__MotionInCells *p;
	struct tt__MotionInCells *a = (struct tt__MotionInCells*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MotionInCells));
	for (p = a; p && n--; p++)
		soap_default_tt__MotionInCells(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MotionInCells(struct soap *soap, const struct tt__MotionInCells *a, const char *tag, const char *type)
{
	if (soap_out_tt__MotionInCells(soap, tag ? tag : "tt:MotionInCells", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MotionInCells * SOAP_FMAC4 soap_get_tt__MotionInCells(struct soap *soap, struct tt__MotionInCells *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MotionInCells(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FrameExtension(struct soap *soap, struct tt__FrameExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->MotionInCells = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FrameExtension(struct soap *soap, const struct tt__FrameExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_serialize_PointerTott__MotionInCells(soap, &a->MotionInCells);
	soap_serialize_PointerTott__FrameExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FrameExtension(struct soap *soap, const char *tag, int id, const struct tt__FrameExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FrameExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__MotionInCells(soap, "tt:MotionInCells", -1, &a->MotionInCells, ""))
		return soap->error;
	if (soap_out_PointerTott__FrameExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FrameExtension * SOAP_FMAC4 soap_in_tt__FrameExtension(struct soap *soap, const char *tag, struct tt__FrameExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_MotionInCells = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FrameExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FrameExtension, sizeof(struct tt__FrameExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FrameExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MotionInCells && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MotionInCells(soap, "tt:MotionInCells", &a->MotionInCells, "tt:MotionInCells"))
				{	soap_flag_MotionInCells--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FrameExtension2(soap, "tt:Extension", &a->Extension, "tt:FrameExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FrameExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FrameExtension, SOAP_TYPE_tt__FrameExtension, sizeof(struct tt__FrameExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FrameExtension * SOAP_FMAC4 soap_new_tt__FrameExtension(struct soap *soap, int n)
{
	struct tt__FrameExtension *p;
	struct tt__FrameExtension *a = (struct tt__FrameExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FrameExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__FrameExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FrameExtension(struct soap *soap, const struct tt__FrameExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__FrameExtension(soap, tag ? tag : "tt:FrameExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FrameExtension * SOAP_FMAC4 soap_get_tt__FrameExtension(struct soap *soap, struct tt__FrameExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FrameExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ObjectTree(struct soap *soap, struct tt__ObjectTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRename = 0;
	a->Rename = NULL;
	a->__sizeSplit = 0;
	a->Split = NULL;
	a->__sizeMerge = 0;
	a->Merge = NULL;
	a->__sizeDelete = 0;
	a->Delete = NULL;
	a->Extension = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ObjectTree(struct soap *soap, const struct tt__ObjectTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Rename)
	{	int i;
		for (i = 0; i < (int)a->__sizeRename; i++)
		{
			soap_embedded(soap, a->Rename + i, SOAP_TYPE_tt__Rename);
			soap_serialize_tt__Rename(soap, a->Rename + i);
		}
	}
	if (a->Split)
	{	int i;
		for (i = 0; i < (int)a->__sizeSplit; i++)
		{
			soap_embedded(soap, a->Split + i, SOAP_TYPE_tt__Split);
			soap_serialize_tt__Split(soap, a->Split + i);
		}
	}
	if (a->Merge)
	{	int i;
		for (i = 0; i < (int)a->__sizeMerge; i++)
		{
			soap_embedded(soap, a->Merge + i, SOAP_TYPE_tt__Merge);
			soap_serialize_tt__Merge(soap, a->Merge + i);
		}
	}
	if (a->Delete)
	{	int i;
		for (i = 0; i < (int)a->__sizeDelete; i++)
		{
			soap_embedded(soap, a->Delete + i, SOAP_TYPE_tt__ObjectId);
			soap_serialize_tt__ObjectId(soap, a->Delete + i);
		}
	}
	soap_serialize_PointerTott__ObjectTreeExtension(soap, &a->Extension);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectTree(struct soap *soap, const char *tag, int id, const struct tt__ObjectTree *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectTree), type))
		return soap->error;
	if (a->Rename)
	{	int i;
		for (i = 0; i < (int)a->__sizeRename; i++)
			if (soap_out_tt__Rename(soap, "tt:Rename", -1, a->Rename + i, ""))
				return soap->error;
	}
	if (a->Split)
	{	int i;
		for (i = 0; i < (int)a->__sizeSplit; i++)
			if (soap_out_tt__Split(soap, "tt:Split", -1, a->Split + i, ""))
				return soap->error;
	}
	if (a->Merge)
	{	int i;
		for (i = 0; i < (int)a->__sizeMerge; i++)
			if (soap_out_tt__Merge(soap, "tt:Merge", -1, a->Merge + i, ""))
				return soap->error;
	}
	if (a->Delete)
	{	int i;
		for (i = 0; i < (int)a->__sizeDelete; i++)
			if (soap_out_tt__ObjectId(soap, "tt:Delete", -1, a->Delete + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ObjectTreeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ObjectTree * SOAP_FMAC4 soap_in_tt__ObjectTree(struct soap *soap, const char *tag, struct tt__ObjectTree *a, const char *type)
{
	struct soap_blist *soap_blist_Rename = NULL;
	struct soap_blist *soap_blist_Split = NULL;
	struct soap_blist *soap_blist_Merge = NULL;
	struct soap_blist *soap_blist_Delete = NULL;
	size_t soap_flag_Extension = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ObjectTree*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectTree, sizeof(struct tt__ObjectTree), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ObjectTree(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Rename", 1, NULL))
			{	if (a->Rename == NULL)
				{	if (soap_blist_Rename == NULL)
						soap_blist_Rename = soap_alloc_block(soap);
					a->Rename = (struct tt__Rename *)soap_push_block_max(soap, soap_blist_Rename, sizeof(struct tt__Rename));
					if (a->Rename == NULL)
						return NULL;
					soap_default_tt__Rename(soap, a->Rename);
				}
				soap_revert(soap);
				if (soap_in_tt__Rename(soap, "tt:Rename", a->Rename, "tt:Rename"))
				{	a->__sizeRename++;
					a->Rename = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Split", 1, NULL))
			{	if (a->Split == NULL)
				{	if (soap_blist_Split == NULL)
						soap_blist_Split = soap_alloc_block(soap);
					a->Split = (struct tt__Split *)soap_push_block_max(soap, soap_blist_Split, sizeof(struct tt__Split));
					if (a->Split == NULL)
						return NULL;
					soap_default_tt__Split(soap, a->Split);
				}
				soap_revert(soap);
				if (soap_in_tt__Split(soap, "tt:Split", a->Split, "tt:Split"))
				{	a->__sizeSplit++;
					a->Split = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Merge", 1, NULL))
			{	if (a->Merge == NULL)
				{	if (soap_blist_Merge == NULL)
						soap_blist_Merge = soap_alloc_block(soap);
					a->Merge = (struct tt__Merge *)soap_push_block_max(soap, soap_blist_Merge, sizeof(struct tt__Merge));
					if (a->Merge == NULL)
						return NULL;
					soap_default_tt__Merge(soap, a->Merge);
				}
				soap_revert(soap);
				if (soap_in_tt__Merge(soap, "tt:Merge", a->Merge, "tt:Merge"))
				{	a->__sizeMerge++;
					a->Merge = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Delete", 1, NULL))
			{	if (a->Delete == NULL)
				{	if (soap_blist_Delete == NULL)
						soap_blist_Delete = soap_alloc_block(soap);
					a->Delete = (struct tt__ObjectId *)soap_push_block_max(soap, soap_blist_Delete, sizeof(struct tt__ObjectId));
					if (a->Delete == NULL)
						return NULL;
					soap_default_tt__ObjectId(soap, a->Delete);
				}
				soap_revert(soap);
				if (soap_in_tt__ObjectId(soap, "tt:Delete", a->Delete, "tt:ObjectId"))
				{	a->__sizeDelete++;
					a->Delete = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ObjectTreeExtension(soap, "tt:Extension", &a->Extension, "tt:ObjectTreeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Rename)
			soap_pop_block(soap, soap_blist_Rename);
		if (a->__sizeRename)
		{	a->Rename = (struct tt__Rename *)soap_save_block(soap, soap_blist_Rename, NULL, 1);
		}
		else
		{	a->Rename = NULL;
			if (soap_blist_Rename)
				soap_end_block(soap, soap_blist_Rename);
		}
		if (a->Split)
			soap_pop_block(soap, soap_blist_Split);
		if (a->__sizeSplit)
		{	a->Split = (struct tt__Split *)soap_save_block(soap, soap_blist_Split, NULL, 1);
		}
		else
		{	a->Split = NULL;
			if (soap_blist_Split)
				soap_end_block(soap, soap_blist_Split);
		}
		if (a->Merge)
			soap_pop_block(soap, soap_blist_Merge);
		if (a->__sizeMerge)
		{	a->Merge = (struct tt__Merge *)soap_save_block(soap, soap_blist_Merge, NULL, 1);
		}
		else
		{	a->Merge = NULL;
			if (soap_blist_Merge)
				soap_end_block(soap, soap_blist_Merge);
		}
		if (a->Delete)
			soap_pop_block(soap, soap_blist_Delete);
		if (a->__sizeDelete)
		{	a->Delete = (struct tt__ObjectId *)soap_save_block(soap, soap_blist_Delete, NULL, 1);
		}
		else
		{	a->Delete = NULL;
			if (soap_blist_Delete)
				soap_end_block(soap, soap_blist_Delete);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectTree *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectTree, SOAP_TYPE_tt__ObjectTree, sizeof(struct tt__ObjectTree), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ObjectTree * SOAP_FMAC4 soap_new_tt__ObjectTree(struct soap *soap, int n)
{
	struct tt__ObjectTree *p;
	struct tt__ObjectTree *a = (struct tt__ObjectTree*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ObjectTree));
	for (p = a; p && n--; p++)
		soap_default_tt__ObjectTree(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ObjectTree(struct soap *soap, const struct tt__ObjectTree *a, const char *tag, const char *type)
{
	if (soap_out_tt__ObjectTree(soap, tag ? tag : "tt:ObjectTree", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectTree * SOAP_FMAC4 soap_get_tt__ObjectTree(struct soap *soap, struct tt__ObjectTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Object(struct soap *soap, struct tt__Object *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->ObjectId);
	a->Appearance = NULL;
	a->Behaviour = NULL;
	a->Extension = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__integer(soap, &a->Parent);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Object(struct soap *soap, const struct tt__Object *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Appearance(soap, &a->Appearance);
	soap_serialize_PointerTott__Behaviour(soap, &a->Behaviour);
	soap_serialize_PointerTott__ObjectExtension(soap, &a->Extension);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Object(struct soap *soap, const char *tag, int id, const struct tt__Object *a, const char *type)
{
	if (a->ObjectId)
		soap_set_attr(soap, "ObjectId", soap_xsd__integer2s(soap, a->ObjectId), 1);
	if (a->Parent)
		soap_set_attr(soap, "Parent", soap_xsd__integer2s(soap, a->Parent), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Object), type))
		return soap->error;
	if (soap_out_PointerTott__Appearance(soap, "tt:Appearance", -1, &a->Appearance, ""))
		return soap->error;
	if (soap_out_PointerTott__Behaviour(soap, "tt:Behaviour", -1, &a->Behaviour, ""))
		return soap->error;
	if (soap_out_PointerTott__ObjectExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Object * SOAP_FMAC4 soap_in_tt__Object(struct soap *soap, const char *tag, struct tt__Object *a, const char *type)
{
	size_t soap_flag_Appearance = 1;
	size_t soap_flag_Behaviour = 1;
	size_t soap_flag_Extension = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Object*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Object, sizeof(struct tt__Object), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Object(soap, a);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "ObjectId", 5, 0), &a->ObjectId))
		return NULL;
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "Parent", 5, 0), &a->Parent))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Appearance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Appearance(soap, "tt:Appearance", &a->Appearance, "tt:Appearance"))
				{	soap_flag_Appearance--;
					continue;
				}
			}
			if (soap_flag_Behaviour && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Behaviour(soap, "tt:Behaviour", &a->Behaviour, "tt:Behaviour"))
				{	soap_flag_Behaviour--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ObjectExtension(soap, "tt:Extension", &a->Extension, "tt:ObjectExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Object *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Object, SOAP_TYPE_tt__Object, sizeof(struct tt__Object), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Object * SOAP_FMAC4 soap_new_tt__Object(struct soap *soap, int n)
{
	struct tt__Object *p;
	struct tt__Object *a = (struct tt__Object*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Object));
	for (p = a; p && n--; p++)
		soap_default_tt__Object(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Object(struct soap *soap, const struct tt__Object *a, const char *tag, const char *type)
{
	if (soap_out_tt__Object(soap, tag ? tag : "tt:Object", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Object * SOAP_FMAC4 soap_get_tt__Object(struct soap *soap, struct tt__Object *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Frame(struct soap *soap, struct tt__Frame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZStatus = NULL;
	a->Transformation = NULL;
	a->__sizeObject = 0;
	a->Object = NULL;
	a->ObjectTree = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyURI(soap, &a->SceneImageRef);
	soap_default_xsd__base64Binary(soap, &a->SceneImage);
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->UtcTime);
	soap_default_string(soap, &a->Source);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Frame(struct soap *soap, const struct tt__Frame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZStatus(soap, &a->PTZStatus);
	soap_serialize_PointerTott__Transformation(soap, &a->Transformation);
	if (a->Object)
	{	int i;
		for (i = 0; i < (int)a->__sizeObject; i++)
		{
			soap_embedded(soap, a->Object + i, SOAP_TYPE_tt__Object);
			soap_serialize_tt__Object(soap, a->Object + i);
		}
	}
	soap_serialize_PointerTott__ObjectTree(soap, &a->ObjectTree);
	soap_serialize_PointerTott__FrameExtension(soap, &a->Extension);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->SceneImageRef);
	soap_serialize_xsd__base64Binary(soap, &a->SceneImage);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Frame(struct soap *soap, const char *tag, int id, const struct tt__Frame *a, const char *type)
{
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, a->UtcTime), 1);
	if (a->Source)
		soap_set_attr(soap, "Source", soap_string2s(soap, a->Source), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Frame), type))
		return soap->error;
	if (soap_out_PointerTott__PTZStatus(soap, "tt:PTZStatus", -1, &a->PTZStatus, ""))
		return soap->error;
	if (soap_out_PointerTott__Transformation(soap, "tt:Transformation", -1, &a->Transformation, ""))
		return soap->error;
	if (a->Object)
	{	int i;
		for (i = 0; i < (int)a->__sizeObject; i++)
			if (soap_out_tt__Object(soap, "tt:Object", -1, a->Object + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ObjectTree(soap, "tt:ObjectTree", -1, &a->ObjectTree, ""))
		return soap->error;
	if (soap_out_PointerTott__FrameExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:SceneImageRef", -1, (char*const*)&a->SceneImageRef, ""))
		return soap->error;
	if (soap_out_xsd__base64Binary(soap, "tt:SceneImage", -1, &a->SceneImage, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Frame * SOAP_FMAC4 soap_in_tt__Frame(struct soap *soap, const char *tag, struct tt__Frame *a, const char *type)
{
	size_t soap_flag_PTZStatus = 1;
	size_t soap_flag_Transformation = 1;
	struct soap_blist *soap_blist_Object = NULL;
	size_t soap_flag_ObjectTree = 1;
	size_t soap_flag_Extension = 1;
	size_t soap_flag_SceneImageRef = 1;
	size_t soap_flag_SceneImage = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Frame*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Frame, sizeof(struct tt__Frame), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Frame(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 5, 1), &a->UtcTime))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Source", 1, 0), &a->Source))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZStatus(soap, "tt:PTZStatus", &a->PTZStatus, "tt:PTZStatus"))
				{	soap_flag_PTZStatus--;
					continue;
				}
			}
			if (soap_flag_Transformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Transformation(soap, "tt:Transformation", &a->Transformation, "tt:Transformation"))
				{	soap_flag_Transformation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Object", 1, NULL))
			{	if (a->Object == NULL)
				{	if (soap_blist_Object == NULL)
						soap_blist_Object = soap_alloc_block(soap);
					a->Object = (struct tt__Object *)soap_push_block_max(soap, soap_blist_Object, sizeof(struct tt__Object));
					if (a->Object == NULL)
						return NULL;
					soap_default_tt__Object(soap, a->Object);
				}
				soap_revert(soap);
				if (soap_in_tt__Object(soap, "tt:Object", a->Object, "tt:Object"))
				{	a->__sizeObject++;
					a->Object = NULL;
					continue;
				}
			}
			if (soap_flag_ObjectTree && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ObjectTree(soap, "tt:ObjectTree", &a->ObjectTree, "tt:ObjectTree"))
				{	soap_flag_ObjectTree--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FrameExtension(soap, "tt:Extension", &a->Extension, "tt:FrameExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap_flag_SceneImageRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:SceneImageRef", (char**)&a->SceneImageRef, "xsd:anyURI"))
				{	soap_flag_SceneImageRef--;
					continue;
				}
			}
			if (soap_flag_SceneImage && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__base64Binary(soap, "tt:SceneImage", &a->SceneImage, "xsd:base64Binary"))
				{	soap_flag_SceneImage--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Object)
			soap_pop_block(soap, soap_blist_Object);
		if (a->__sizeObject)
		{	a->Object = (struct tt__Object *)soap_save_block(soap, soap_blist_Object, NULL, 1);
		}
		else
		{	a->Object = NULL;
			if (soap_blist_Object)
				soap_end_block(soap, soap_blist_Object);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Frame *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Frame, SOAP_TYPE_tt__Frame, sizeof(struct tt__Frame), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Frame * SOAP_FMAC4 soap_new_tt__Frame(struct soap *soap, int n)
{
	struct tt__Frame *p;
	struct tt__Frame *a = (struct tt__Frame*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Frame));
	for (p = a; p && n--; p++)
		soap_default_tt__Frame(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Frame(struct soap *soap, const struct tt__Frame *a, const char *tag, const char *type)
{
	if (soap_out_tt__Frame(soap, tag ? tag : "tt:Frame", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Frame * SOAP_FMAC4 soap_get_tt__Frame(struct soap *soap, struct tt__Frame *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Frame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ObjectExtension(struct soap *soap, struct tt__ObjectExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ObjectExtension(struct soap *soap, const struct tt__ObjectExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectExtension(struct soap *soap, const char *tag, int id, const struct tt__ObjectExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ObjectExtension * SOAP_FMAC4 soap_in_tt__ObjectExtension(struct soap *soap, const char *tag, struct tt__ObjectExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ObjectExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectExtension, sizeof(struct tt__ObjectExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ObjectExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectExtension, SOAP_TYPE_tt__ObjectExtension, sizeof(struct tt__ObjectExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ObjectExtension * SOAP_FMAC4 soap_new_tt__ObjectExtension(struct soap *soap, int n)
{
	struct tt__ObjectExtension *p;
	struct tt__ObjectExtension *a = (struct tt__ObjectExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ObjectExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ObjectExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ObjectExtension(struct soap *soap, const struct tt__ObjectExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ObjectExtension(soap, tag ? tag : "tt:ObjectExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectExtension * SOAP_FMAC4 soap_get_tt__ObjectExtension(struct soap *soap, struct tt__ObjectExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ClassDescriptorExtension2(struct soap *soap, const struct tt__ClassDescriptorExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ClassDescriptorExtension2(struct soap *soap, const char *tag, int id, const struct tt__ClassDescriptorExtension2 *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ClassDescriptorExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension2 * SOAP_FMAC4 soap_in_tt__ClassDescriptorExtension2(struct soap *soap, const char *tag, struct tt__ClassDescriptorExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ClassDescriptorExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ClassDescriptorExtension2, sizeof(struct tt__ClassDescriptorExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ClassDescriptorExtension2(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptorExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ClassDescriptorExtension2, SOAP_TYPE_tt__ClassDescriptorExtension2, sizeof(struct tt__ClassDescriptorExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension2 * SOAP_FMAC4 soap_new_tt__ClassDescriptorExtension2(struct soap *soap, int n)
{
	struct tt__ClassDescriptorExtension2 *p;
	struct tt__ClassDescriptorExtension2 *a = (struct tt__ClassDescriptorExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ClassDescriptorExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__ClassDescriptorExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ClassDescriptorExtension2(struct soap *soap, const struct tt__ClassDescriptorExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ClassDescriptorExtension2(soap, tag ? tag : "tt:ClassDescriptorExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension2 * SOAP_FMAC4 soap_get_tt__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ClassDescriptorExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OtherType(struct soap *soap, struct tt__OtherType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Type);
	soap_default_float(soap, &a->Likelihood);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OtherType(struct soap *soap, const struct tt__OtherType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Type);
	soap_embedded(soap, &a->Likelihood, SOAP_TYPE_float);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OtherType(struct soap *soap, const char *tag, int id, const struct tt__OtherType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OtherType), type))
		return soap->error;
	if (!a->Type)
	{	if (soap_element_empty(soap, "tt:Type", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Type", -1, (char*const*)&a->Type, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Likelihood", -1, &a->Likelihood, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OtherType * SOAP_FMAC4 soap_in_tt__OtherType(struct soap *soap, const char *tag, struct tt__OtherType *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Likelihood = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OtherType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OtherType, sizeof(struct tt__OtherType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OtherType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Type", (char**)&a->Type, "xsd:string"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_Likelihood && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Likelihood", &a->Likelihood, "xsd:float"))
				{	soap_flag_Likelihood--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Type || soap_flag_Likelihood > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OtherType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OtherType, SOAP_TYPE_tt__OtherType, sizeof(struct tt__OtherType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OtherType * SOAP_FMAC4 soap_new_tt__OtherType(struct soap *soap, int n)
{
	struct tt__OtherType *p;
	struct tt__OtherType *a = (struct tt__OtherType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OtherType));
	for (p = a; p && n--; p++)
		soap_default_tt__OtherType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OtherType(struct soap *soap, const struct tt__OtherType *a, const char *tag, const char *type)
{
	if (soap_out_tt__OtherType(soap, tag ? tag : "tt:OtherType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OtherType * SOAP_FMAC4 soap_get_tt__OtherType(struct soap *soap, struct tt__OtherType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OtherType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__sizeOtherTypes = 0;
	a->OtherTypes = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ClassDescriptorExtension(struct soap *soap, const struct tt__ClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	if (a->OtherTypes)
	{	int i;
		for (i = 0; i < (int)a->__sizeOtherTypes; i++)
		{
			soap_embedded(soap, a->OtherTypes + i, SOAP_TYPE_tt__OtherType);
			soap_serialize_tt__OtherType(soap, a->OtherTypes + i);
		}
	}
	soap_serialize_PointerTott__ClassDescriptorExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ClassDescriptorExtension(struct soap *soap, const char *tag, int id, const struct tt__ClassDescriptorExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ClassDescriptorExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (a->OtherTypes)
	{	int i;
		for (i = 0; i < (int)a->__sizeOtherTypes; i++)
			if (soap_out_tt__OtherType(soap, "tt:OtherTypes", -1, a->OtherTypes + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ClassDescriptorExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension * SOAP_FMAC4 soap_in_tt__ClassDescriptorExtension(struct soap *soap, const char *tag, struct tt__ClassDescriptorExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	struct soap_blist *soap_blist_OtherTypes = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ClassDescriptorExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ClassDescriptorExtension, sizeof(struct tt__ClassDescriptorExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ClassDescriptorExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:OtherTypes", 1, NULL))
			{	if (a->OtherTypes == NULL)
				{	if (soap_blist_OtherTypes == NULL)
						soap_blist_OtherTypes = soap_alloc_block(soap);
					a->OtherTypes = (struct tt__OtherType *)soap_push_block_max(soap, soap_blist_OtherTypes, sizeof(struct tt__OtherType));
					if (a->OtherTypes == NULL)
						return NULL;
					soap_default_tt__OtherType(soap, a->OtherTypes);
				}
				soap_revert(soap);
				if (soap_in_tt__OtherType(soap, "tt:OtherTypes", a->OtherTypes, "tt:OtherType"))
				{	a->__sizeOtherTypes++;
					a->OtherTypes = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ClassDescriptorExtension2(soap, "tt:Extension", &a->Extension, "tt:ClassDescriptorExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->OtherTypes)
			soap_pop_block(soap, soap_blist_OtherTypes);
		if (a->__sizeOtherTypes)
		{	a->OtherTypes = (struct tt__OtherType *)soap_save_block(soap, soap_blist_OtherTypes, NULL, 1);
		}
		else
		{	a->OtherTypes = NULL;
			if (soap_blist_OtherTypes)
				soap_end_block(soap, soap_blist_OtherTypes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeOtherTypes < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ClassDescriptorExtension, SOAP_TYPE_tt__ClassDescriptorExtension, sizeof(struct tt__ClassDescriptorExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension * SOAP_FMAC4 soap_new_tt__ClassDescriptorExtension(struct soap *soap, int n)
{
	struct tt__ClassDescriptorExtension *p;
	struct tt__ClassDescriptorExtension *a = (struct tt__ClassDescriptorExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ClassDescriptorExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ClassDescriptorExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ClassDescriptorExtension(struct soap *soap, const struct tt__ClassDescriptorExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ClassDescriptorExtension(soap, tag ? tag : "tt:ClassDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension * SOAP_FMAC4 soap_get_tt__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ClassType(soap, &a->Type);
	soap_default_float(soap, &a->Likelihood);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const struct _tt__ClassDescriptor_ClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Likelihood, SOAP_TYPE_float);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, int id, const struct _tt__ClassDescriptor_ClassCandidate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate), type))
		return soap->error;
	if (soap_out_tt__ClassType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Likelihood", -1, &a->Likelihood, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate * SOAP_FMAC4 soap_in__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, struct _tt__ClassDescriptor_ClassCandidate *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Likelihood = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__ClassDescriptor_ClassCandidate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, sizeof(struct _tt__ClassDescriptor_ClassCandidate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ClassDescriptor_ClassCandidate(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ClassType(soap, "tt:Type", &a->Type, "tt:ClassType"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_Likelihood && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Likelihood", &a->Likelihood, "xsd:float"))
				{	soap_flag_Likelihood--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || soap_flag_Likelihood > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tt__ClassDescriptor_ClassCandidate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, sizeof(struct _tt__ClassDescriptor_ClassCandidate), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate * SOAP_FMAC4 soap_new__tt__ClassDescriptor_ClassCandidate(struct soap *soap, int n)
{
	struct _tt__ClassDescriptor_ClassCandidate *p;
	struct _tt__ClassDescriptor_ClassCandidate *a = (struct _tt__ClassDescriptor_ClassCandidate*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ClassDescriptor_ClassCandidate));
	for (p = a; p && n--; p++)
		soap_default__tt__ClassDescriptor_ClassCandidate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const struct _tt__ClassDescriptor_ClassCandidate *a, const char *tag, const char *type)
{
	if (soap_out__tt__ClassDescriptor_ClassCandidate(soap, tag ? tag : "tt:ClassDescriptor-ClassCandidate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate * SOAP_FMAC4 soap_get__tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ClassDescriptor_ClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ShapeDescriptorExtension(struct soap *soap, const struct tt__ShapeDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ShapeDescriptorExtension(struct soap *soap, const char *tag, int id, const struct tt__ShapeDescriptorExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ShapeDescriptorExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension * SOAP_FMAC4 soap_in_tt__ShapeDescriptorExtension(struct soap *soap, const char *tag, struct tt__ShapeDescriptorExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ShapeDescriptorExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ShapeDescriptorExtension, sizeof(struct tt__ShapeDescriptorExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ShapeDescriptorExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ShapeDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ShapeDescriptorExtension, SOAP_TYPE_tt__ShapeDescriptorExtension, sizeof(struct tt__ShapeDescriptorExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension * SOAP_FMAC4 soap_new_tt__ShapeDescriptorExtension(struct soap *soap, int n)
{
	struct tt__ShapeDescriptorExtension *p;
	struct tt__ShapeDescriptorExtension *a = (struct tt__ShapeDescriptorExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ShapeDescriptorExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ShapeDescriptorExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ShapeDescriptorExtension(struct soap *soap, const struct tt__ShapeDescriptorExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ShapeDescriptorExtension(soap, tag ? tag : "tt:ShapeDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension * SOAP_FMAC4 soap_get_tt__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ShapeDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__StringLikelihood(struct soap *soap, struct tt__StringLikelihood *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	a->Likelihood = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringLikelihood(struct soap *soap, const struct tt__StringLikelihood *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringLikelihood(struct soap *soap, const char *tag, int id, const struct tt__StringLikelihood *a, const char *type)
{
	if (a->Likelihood)
	{	soap_set_attr(soap, "Likelihood", soap_float2s(soap, *a->Likelihood), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct tt__StringLikelihood * SOAP_FMAC4 soap_in_tt__StringLikelihood(struct soap *soap, const char *tag, struct tt__StringLikelihood *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct tt__StringLikelihood *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StringLikelihood, sizeof(struct tt__StringLikelihood), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_tt__StringLikelihood(soap, a);
	{
		const char *t = soap_attr_value(soap, "Likelihood", 5, 0);
		if (t)
		{
			if (!(a->Likelihood = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->Likelihood))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_string(soap, tag, (char**)&a->__item, "tt:StringLikelihood"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct tt__StringLikelihood * SOAP_FMAC4 soap_new_tt__StringLikelihood(struct soap *soap, int n)
{
	struct tt__StringLikelihood *p;
	struct tt__StringLikelihood *a = (struct tt__StringLikelihood*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__StringLikelihood));
	for (p = a; p && n--; p++)
		soap_default_tt__StringLikelihood(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringLikelihood(struct soap *soap, const struct tt__StringLikelihood *a, const char *tag, const char *type)
{
	if (soap_out_tt__StringLikelihood(soap, tag ? tag : "tt:StringLikelihood", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StringLikelihood * SOAP_FMAC4 soap_get_tt__StringLikelihood(struct soap *soap, struct tt__StringLikelihood *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringLikelihood(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__HumanBody(struct soap *soap, struct ns2__HumanBody *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BodyMetric = NULL;
	a->Clothing = NULL;
	a->Belonging = NULL;
	a->Behaviour = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__HumanBody(struct soap *soap, const struct ns2__HumanBody *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__BodyMetric(soap, &a->BodyMetric);
	soap_serialize_PointerTons2__Clothing(soap, &a->Clothing);
	soap_serialize_PointerTons2__Belonging(soap, &a->Belonging);
	soap_serialize_PointerTons2__Behaviour(soap, &a->Behaviour);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HumanBody(struct soap *soap, const char *tag, int id, const struct ns2__HumanBody *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HumanBody), type))
		return soap->error;
	if (soap_out_PointerTons2__BodyMetric(soap, "ns2:BodyMetric", -1, &a->BodyMetric, ""))
		return soap->error;
	if (soap_out_PointerTons2__Clothing(soap, "ns2:Clothing", -1, &a->Clothing, ""))
		return soap->error;
	if (soap_out_PointerTons2__Belonging(soap, "ns2:Belonging", -1, &a->Belonging, ""))
		return soap->error;
	if (soap_out_PointerTons2__Behaviour(soap, "ns2:Behaviour", -1, &a->Behaviour, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__HumanBody * SOAP_FMAC4 soap_in_ns2__HumanBody(struct soap *soap, const char *tag, struct ns2__HumanBody *a, const char *type)
{
	size_t soap_flag_BodyMetric = 1;
	size_t soap_flag_Clothing = 1;
	size_t soap_flag_Belonging = 1;
	size_t soap_flag_Behaviour = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__HumanBody*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HumanBody, sizeof(struct ns2__HumanBody), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__HumanBody(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BodyMetric && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__BodyMetric(soap, "ns2:BodyMetric", &a->BodyMetric, "ns2:BodyMetric"))
				{	soap_flag_BodyMetric--;
					continue;
				}
			}
			if (soap_flag_Clothing && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Clothing(soap, "ns2:Clothing", &a->Clothing, "ns2:Clothing"))
				{	soap_flag_Clothing--;
					continue;
				}
			}
			if (soap_flag_Belonging && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Belonging(soap, "ns2:Belonging", &a->Belonging, "ns2:Belonging"))
				{	soap_flag_Belonging--;
					continue;
				}
			}
			if (soap_flag_Behaviour && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Behaviour(soap, "ns2:Behaviour", &a->Behaviour, "ns2:Behaviour"))
				{	soap_flag_Behaviour--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__HumanBody *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HumanBody, SOAP_TYPE_ns2__HumanBody, sizeof(struct ns2__HumanBody), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__HumanBody * SOAP_FMAC4 soap_new_ns2__HumanBody(struct soap *soap, int n)
{
	struct ns2__HumanBody *p;
	struct ns2__HumanBody *a = (struct ns2__HumanBody*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__HumanBody));
	for (p = a; p && n--; p++)
		soap_default_ns2__HumanBody(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__HumanBody(struct soap *soap, const struct ns2__HumanBody *a, const char *tag, const char *type)
{
	if (soap_out_ns2__HumanBody(soap, tag ? tag : "ns2:HumanBody", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__HumanBody * SOAP_FMAC4 soap_get_ns2__HumanBody(struct soap *soap, struct ns2__HumanBody *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HumanBody(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__HumanFace(struct soap *soap, struct ns1__HumanFace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Age = NULL;
	soap_default_string(soap, &a->Gender);
	a->Temperature = NULL;
	soap_default_string(soap, &a->Complexion);
	soap_default_string(soap, &a->FacialShape);
	a->Hair = NULL;
	a->Eyebrow = NULL;
	a->Eye = NULL;
	a->Ear = NULL;
	a->Nose = NULL;
	a->FacialHair = NULL;
	soap_default_string(soap, &a->Lip);
	soap_default_string(soap, &a->Chin);
	soap_default_string(soap, &a->Expression);
	a->PoseAngle = NULL;
	a->Accessory = NULL;
	a->AdditionalFeatures = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__HumanFace(struct soap *soap, const struct ns1__HumanFace *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &a->Age);
	soap_serialize_string(soap, (char*const*)&a->Gender);
	soap_serialize_PointerTofloat(soap, &a->Temperature);
	soap_serialize_string(soap, (char*const*)&a->Complexion);
	soap_serialize_string(soap, (char*const*)&a->FacialShape);
	soap_serialize_PointerTons1__Hair(soap, &a->Hair);
	soap_serialize_PointerTons1__Eyebrow(soap, &a->Eyebrow);
	soap_serialize_PointerTons1__Eye(soap, &a->Eye);
	soap_serialize_PointerTons1__Ear(soap, &a->Ear);
	soap_serialize_PointerTons1__Nose(soap, &a->Nose);
	soap_serialize_PointerTons1__FacialHair(soap, &a->FacialHair);
	soap_serialize_string(soap, (char*const*)&a->Lip);
	soap_serialize_string(soap, (char*const*)&a->Chin);
	soap_serialize_string(soap, (char*const*)&a->Expression);
	soap_serialize_PointerTons1__PoseAngle(soap, &a->PoseAngle);
	soap_serialize_PointerTons1__Accessory(soap, &a->Accessory);
	soap_serialize_PointerTons1__AdditionalFeatures(soap, &a->AdditionalFeatures);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HumanFace(struct soap *soap, const char *tag, int id, const struct ns1__HumanFace *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HumanFace), type))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "ns1:Age", -1, &a->Age, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Gender", -1, (char*const*)&a->Gender, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns1:Temperature", -1, &a->Temperature, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Complexion", -1, (char*const*)&a->Complexion, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:FacialShape", -1, (char*const*)&a->FacialShape, ""))
		return soap->error;
	if (soap_out_PointerTons1__Hair(soap, "ns1:Hair", -1, &a->Hair, ""))
		return soap->error;
	if (soap_out_PointerTons1__Eyebrow(soap, "ns1:Eyebrow", -1, &a->Eyebrow, ""))
		return soap->error;
	if (soap_out_PointerTons1__Eye(soap, "ns1:Eye", -1, &a->Eye, ""))
		return soap->error;
	if (soap_out_PointerTons1__Ear(soap, "ns1:Ear", -1, &a->Ear, ""))
		return soap->error;
	if (soap_out_PointerTons1__Nose(soap, "ns1:Nose", -1, &a->Nose, ""))
		return soap->error;
	if (soap_out_PointerTons1__FacialHair(soap, "ns1:FacialHair", -1, &a->FacialHair, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Lip", -1, (char*const*)&a->Lip, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Chin", -1, (char*const*)&a->Chin, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Expression", -1, (char*const*)&a->Expression, ""))
		return soap->error;
	if (soap_out_PointerTons1__PoseAngle(soap, "ns1:PoseAngle", -1, &a->PoseAngle, ""))
		return soap->error;
	if (soap_out_PointerTons1__Accessory(soap, "ns1:Accessory", -1, &a->Accessory, ""))
		return soap->error;
	if (soap_out_PointerTons1__AdditionalFeatures(soap, "ns1:AdditionalFeatures", -1, &a->AdditionalFeatures, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__HumanFace * SOAP_FMAC4 soap_in_ns1__HumanFace(struct soap *soap, const char *tag, struct ns1__HumanFace *a, const char *type)
{
	size_t soap_flag_Age = 1;
	size_t soap_flag_Gender = 1;
	size_t soap_flag_Temperature = 1;
	size_t soap_flag_Complexion = 1;
	size_t soap_flag_FacialShape = 1;
	size_t soap_flag_Hair = 1;
	size_t soap_flag_Eyebrow = 1;
	size_t soap_flag_Eye = 1;
	size_t soap_flag_Ear = 1;
	size_t soap_flag_Nose = 1;
	size_t soap_flag_FacialHair = 1;
	size_t soap_flag_Lip = 1;
	size_t soap_flag_Chin = 1;
	size_t soap_flag_Expression = 1;
	size_t soap_flag_PoseAngle = 1;
	size_t soap_flag_Accessory = 1;
	size_t soap_flag_AdditionalFeatures = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__HumanFace*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HumanFace, sizeof(struct ns1__HumanFace), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__HumanFace(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Age && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "ns1:Age", &a->Age, "tt:IntRange"))
				{	soap_flag_Age--;
					continue;
				}
			}
			if (soap_flag_Gender && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Gender", (char**)&a->Gender, "xsd:string"))
				{	soap_flag_Gender--;
					continue;
				}
			}
			if (soap_flag_Temperature && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "ns1:Temperature", &a->Temperature, "xsd:float"))
				{	soap_flag_Temperature--;
					continue;
				}
			}
			if (soap_flag_Complexion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Complexion", (char**)&a->Complexion, "xsd:string"))
				{	soap_flag_Complexion--;
					continue;
				}
			}
			if (soap_flag_FacialShape && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:FacialShape", (char**)&a->FacialShape, "xsd:string"))
				{	soap_flag_FacialShape--;
					continue;
				}
			}
			if (soap_flag_Hair && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Hair(soap, "ns1:Hair", &a->Hair, "ns1:Hair"))
				{	soap_flag_Hair--;
					continue;
				}
			}
			if (soap_flag_Eyebrow && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Eyebrow(soap, "ns1:Eyebrow", &a->Eyebrow, "ns1:Eyebrow"))
				{	soap_flag_Eyebrow--;
					continue;
				}
			}
			if (soap_flag_Eye && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Eye(soap, "ns1:Eye", &a->Eye, "ns1:Eye"))
				{	soap_flag_Eye--;
					continue;
				}
			}
			if (soap_flag_Ear && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Ear(soap, "ns1:Ear", &a->Ear, "ns1:Ear"))
				{	soap_flag_Ear--;
					continue;
				}
			}
			if (soap_flag_Nose && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Nose(soap, "ns1:Nose", &a->Nose, "ns1:Nose"))
				{	soap_flag_Nose--;
					continue;
				}
			}
			if (soap_flag_FacialHair && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__FacialHair(soap, "ns1:FacialHair", &a->FacialHair, "ns1:FacialHair"))
				{	soap_flag_FacialHair--;
					continue;
				}
			}
			if (soap_flag_Lip && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Lip", (char**)&a->Lip, "xsd:string"))
				{	soap_flag_Lip--;
					continue;
				}
			}
			if (soap_flag_Chin && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Chin", (char**)&a->Chin, "xsd:string"))
				{	soap_flag_Chin--;
					continue;
				}
			}
			if (soap_flag_Expression && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Expression", (char**)&a->Expression, "xsd:string"))
				{	soap_flag_Expression--;
					continue;
				}
			}
			if (soap_flag_PoseAngle && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__PoseAngle(soap, "ns1:PoseAngle", &a->PoseAngle, "ns1:PoseAngle"))
				{	soap_flag_PoseAngle--;
					continue;
				}
			}
			if (soap_flag_Accessory && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Accessory(soap, "ns1:Accessory", &a->Accessory, "ns1:Accessory"))
				{	soap_flag_Accessory--;
					continue;
				}
			}
			if (soap_flag_AdditionalFeatures && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AdditionalFeatures(soap, "ns1:AdditionalFeatures", &a->AdditionalFeatures, "ns1:AdditionalFeatures"))
				{	soap_flag_AdditionalFeatures--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__HumanFace *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HumanFace, SOAP_TYPE_ns1__HumanFace, sizeof(struct ns1__HumanFace), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__HumanFace * SOAP_FMAC4 soap_new_ns1__HumanFace(struct soap *soap, int n)
{
	struct ns1__HumanFace *p;
	struct ns1__HumanFace *a = (struct ns1__HumanFace*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__HumanFace));
	for (p = a; p && n--; p++)
		soap_default_ns1__HumanFace(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__HumanFace(struct soap *soap, const struct ns1__HumanFace *a, const char *tag, const char *type)
{
	if (soap_out_ns1__HumanFace(soap, tag ? tag : "ns1:HumanFace", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__HumanFace * SOAP_FMAC4 soap_get_ns1__HumanFace(struct soap *soap, struct ns1__HumanFace *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HumanFace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LicensePlateInfo(struct soap *soap, struct tt__LicensePlateInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PlateNumber = NULL;
	a->PlateType = NULL;
	a->CountryCode = NULL;
	a->IssuingEntity = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LicensePlateInfo(struct soap *soap, const struct tt__LicensePlateInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__StringLikelihood(soap, &a->PlateNumber);
	soap_serialize_PointerTott__StringLikelihood(soap, &a->PlateType);
	soap_serialize_PointerTott__StringLikelihood(soap, &a->CountryCode);
	soap_serialize_PointerTott__StringLikelihood(soap, &a->IssuingEntity);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LicensePlateInfo(struct soap *soap, const char *tag, int id, const struct tt__LicensePlateInfo *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LicensePlateInfo), type))
		return soap->error;
	if (!a->PlateNumber)
	{	if (soap_element_empty(soap, "tt:PlateNumber", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__StringLikelihood(soap, "tt:PlateNumber", -1, &a->PlateNumber, ""))
		return soap->error;
	if (soap_out_PointerTott__StringLikelihood(soap, "tt:PlateType", -1, &a->PlateType, ""))
		return soap->error;
	if (soap_out_PointerTott__StringLikelihood(soap, "tt:CountryCode", -1, &a->CountryCode, ""))
		return soap->error;
	if (soap_out_PointerTott__StringLikelihood(soap, "tt:IssuingEntity", -1, &a->IssuingEntity, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LicensePlateInfo * SOAP_FMAC4 soap_in_tt__LicensePlateInfo(struct soap *soap, const char *tag, struct tt__LicensePlateInfo *a, const char *type)
{
	size_t soap_flag_PlateNumber = 1;
	size_t soap_flag_PlateType = 1;
	size_t soap_flag_CountryCode = 1;
	size_t soap_flag_IssuingEntity = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__LicensePlateInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LicensePlateInfo, sizeof(struct tt__LicensePlateInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LicensePlateInfo(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PlateNumber && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StringLikelihood(soap, "tt:PlateNumber", &a->PlateNumber, "tt:StringLikelihood"))
				{	soap_flag_PlateNumber--;
					continue;
				}
			}
			if (soap_flag_PlateType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StringLikelihood(soap, "tt:PlateType", &a->PlateType, "tt:StringLikelihood"))
				{	soap_flag_PlateType--;
					continue;
				}
			}
			if (soap_flag_CountryCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StringLikelihood(soap, "tt:CountryCode", &a->CountryCode, "tt:StringLikelihood"))
				{	soap_flag_CountryCode--;
					continue;
				}
			}
			if (soap_flag_IssuingEntity && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StringLikelihood(soap, "tt:IssuingEntity", &a->IssuingEntity, "tt:StringLikelihood"))
				{	soap_flag_IssuingEntity--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PlateNumber))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__LicensePlateInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LicensePlateInfo, SOAP_TYPE_tt__LicensePlateInfo, sizeof(struct tt__LicensePlateInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__LicensePlateInfo * SOAP_FMAC4 soap_new_tt__LicensePlateInfo(struct soap *soap, int n)
{
	struct tt__LicensePlateInfo *p;
	struct tt__LicensePlateInfo *a = (struct tt__LicensePlateInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__LicensePlateInfo));
	for (p = a; p && n--; p++)
		soap_default_tt__LicensePlateInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LicensePlateInfo(struct soap *soap, const struct tt__LicensePlateInfo *a, const char *tag, const char *type)
{
	if (soap_out_tt__LicensePlateInfo(soap, tag ? tag : "tt:LicensePlateInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LicensePlateInfo * SOAP_FMAC4 soap_get_tt__LicensePlateInfo(struct soap *soap, struct tt__LicensePlateInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LicensePlateInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VehicleInfo(struct soap *soap, struct tt__VehicleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Type = NULL;
	a->Brand = NULL;
	a->Model = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VehicleInfo(struct soap *soap, const struct tt__VehicleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__StringLikelihood(soap, &a->Type);
	soap_serialize_PointerTott__StringLikelihood(soap, &a->Brand);
	soap_serialize_PointerTott__StringLikelihood(soap, &a->Model);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VehicleInfo(struct soap *soap, const char *tag, int id, const struct tt__VehicleInfo *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VehicleInfo), type))
		return soap->error;
	if (!a->Type)
	{	if (soap_element_empty(soap, "tt:Type", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__StringLikelihood(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_PointerTott__StringLikelihood(soap, "tt:Brand", -1, &a->Brand, ""))
		return soap->error;
	if (soap_out_PointerTott__StringLikelihood(soap, "tt:Model", -1, &a->Model, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VehicleInfo * SOAP_FMAC4 soap_in_tt__VehicleInfo(struct soap *soap, const char *tag, struct tt__VehicleInfo *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Brand = 1;
	size_t soap_flag_Model = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VehicleInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VehicleInfo, sizeof(struct tt__VehicleInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VehicleInfo(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StringLikelihood(soap, "tt:Type", &a->Type, "tt:StringLikelihood"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_Brand && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StringLikelihood(soap, "tt:Brand", &a->Brand, "tt:StringLikelihood"))
				{	soap_flag_Brand--;
					continue;
				}
			}
			if (soap_flag_Model && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StringLikelihood(soap, "tt:Model", &a->Model, "tt:StringLikelihood"))
				{	soap_flag_Model--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Type))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VehicleInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VehicleInfo, SOAP_TYPE_tt__VehicleInfo, sizeof(struct tt__VehicleInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VehicleInfo * SOAP_FMAC4 soap_new_tt__VehicleInfo(struct soap *soap, int n)
{
	struct tt__VehicleInfo *p;
	struct tt__VehicleInfo *a = (struct tt__VehicleInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VehicleInfo));
	for (p = a; p && n--; p++)
		soap_default_tt__VehicleInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VehicleInfo(struct soap *soap, const struct tt__VehicleInfo *a, const char *tag, const char *type)
{
	if (soap_out_tt__VehicleInfo(soap, tag ? tag : "tt:VehicleInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VehicleInfo * SOAP_FMAC4 soap_get_tt__VehicleInfo(struct soap *soap, struct tt__VehicleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AppearanceExtension(struct soap *soap, const struct tt__AppearanceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AppearanceExtension(struct soap *soap, const char *tag, int id, const struct tt__AppearanceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AppearanceExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AppearanceExtension * SOAP_FMAC4 soap_in_tt__AppearanceExtension(struct soap *soap, const char *tag, struct tt__AppearanceExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AppearanceExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AppearanceExtension, sizeof(struct tt__AppearanceExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AppearanceExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AppearanceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AppearanceExtension, SOAP_TYPE_tt__AppearanceExtension, sizeof(struct tt__AppearanceExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AppearanceExtension * SOAP_FMAC4 soap_new_tt__AppearanceExtension(struct soap *soap, int n)
{
	struct tt__AppearanceExtension *p;
	struct tt__AppearanceExtension *a = (struct tt__AppearanceExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AppearanceExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AppearanceExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AppearanceExtension(struct soap *soap, const struct tt__AppearanceExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AppearanceExtension(soap, tag ? tag : "tt:AppearanceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AppearanceExtension * SOAP_FMAC4 soap_get_tt__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AppearanceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeClassCandidate = 0;
	a->ClassCandidate = NULL;
	a->Extension = NULL;
	a->__sizeType = 0;
	a->Type = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ClassDescriptor(struct soap *soap, const struct tt__ClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < (int)a->__sizeClassCandidate; i++)
		{
			soap_embedded(soap, a->ClassCandidate + i, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate);
			soap_serialize__tt__ClassDescriptor_ClassCandidate(soap, a->ClassCandidate + i);
		}
	}
	soap_serialize_PointerTott__ClassDescriptorExtension(soap, &a->Extension);
	if (a->Type)
	{	int i;
		for (i = 0; i < (int)a->__sizeType; i++)
		{
			soap_embedded(soap, a->Type + i, SOAP_TYPE_tt__StringLikelihood);
			soap_serialize_tt__StringLikelihood(soap, a->Type + i);
		}
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ClassDescriptor(struct soap *soap, const char *tag, int id, const struct tt__ClassDescriptor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ClassDescriptor), type))
		return soap->error;
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < (int)a->__sizeClassCandidate; i++)
			if (soap_out__tt__ClassDescriptor_ClassCandidate(soap, "tt:ClassCandidate", -1, a->ClassCandidate + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ClassDescriptorExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (a->Type)
	{	int i;
		for (i = 0; i < (int)a->__sizeType; i++)
			if (soap_out_tt__StringLikelihood(soap, "tt:Type", -1, a->Type + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ClassDescriptor * SOAP_FMAC4 soap_in_tt__ClassDescriptor(struct soap *soap, const char *tag, struct tt__ClassDescriptor *a, const char *type)
{
	struct soap_blist *soap_blist_ClassCandidate = NULL;
	size_t soap_flag_Extension = 1;
	struct soap_blist *soap_blist_Type = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ClassDescriptor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ClassDescriptor, sizeof(struct tt__ClassDescriptor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ClassDescriptor(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ClassCandidate", 1, NULL))
			{	if (a->ClassCandidate == NULL)
				{	if (soap_blist_ClassCandidate == NULL)
						soap_blist_ClassCandidate = soap_alloc_block(soap);
					a->ClassCandidate = (struct _tt__ClassDescriptor_ClassCandidate *)soap_push_block_max(soap, soap_blist_ClassCandidate, sizeof(struct _tt__ClassDescriptor_ClassCandidate));
					if (a->ClassCandidate == NULL)
						return NULL;
					soap_default__tt__ClassDescriptor_ClassCandidate(soap, a->ClassCandidate);
				}
				soap_revert(soap);
				if (soap_in__tt__ClassDescriptor_ClassCandidate(soap, "tt:ClassCandidate", a->ClassCandidate, ""))
				{	a->__sizeClassCandidate++;
					a->ClassCandidate = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ClassDescriptorExtension(soap, "tt:Extension", &a->Extension, "tt:ClassDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Type", 1, NULL))
			{	if (a->Type == NULL)
				{	if (soap_blist_Type == NULL)
						soap_blist_Type = soap_alloc_block(soap);
					a->Type = (struct tt__StringLikelihood *)soap_push_block_max(soap, soap_blist_Type, sizeof(struct tt__StringLikelihood));
					if (a->Type == NULL)
						return NULL;
					soap_default_tt__StringLikelihood(soap, a->Type);
				}
				soap_revert(soap);
				if (soap_in_tt__StringLikelihood(soap, "tt:Type", a->Type, "tt:StringLikelihood"))
				{	a->__sizeType++;
					a->Type = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ClassCandidate)
			soap_pop_block(soap, soap_blist_ClassCandidate);
		if (a->__sizeClassCandidate)
		{	a->ClassCandidate = (struct _tt__ClassDescriptor_ClassCandidate *)soap_save_block(soap, soap_blist_ClassCandidate, NULL, 1);
		}
		else
		{	a->ClassCandidate = NULL;
			if (soap_blist_ClassCandidate)
				soap_end_block(soap, soap_blist_ClassCandidate);
		}
		if (a->Type)
			soap_pop_block(soap, soap_blist_Type);
		if (a->__sizeType)
		{	a->Type = (struct tt__StringLikelihood *)soap_save_block(soap, soap_blist_Type, NULL, 1);
		}
		else
		{	a->Type = NULL;
			if (soap_blist_Type)
				soap_end_block(soap, soap_blist_Type);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ClassDescriptor, SOAP_TYPE_tt__ClassDescriptor, sizeof(struct tt__ClassDescriptor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ClassDescriptor * SOAP_FMAC4 soap_new_tt__ClassDescriptor(struct soap *soap, int n)
{
	struct tt__ClassDescriptor *p;
	struct tt__ClassDescriptor *a = (struct tt__ClassDescriptor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ClassDescriptor));
	for (p = a; p && n--; p++)
		soap_default_tt__ClassDescriptor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ClassDescriptor(struct soap *soap, const struct tt__ClassDescriptor *a, const char *tag, const char *type)
{
	if (soap_out_tt__ClassDescriptor(soap, tag ? tag : "tt:ClassDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptor * SOAP_FMAC4 soap_get_tt__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BoundingBox = NULL;
	a->CenterOfGravity = NULL;
	a->__sizePolygon = 0;
	a->Polygon = NULL;
	a->Extension = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ShapeDescriptor(struct soap *soap, const struct tt__ShapeDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Rectangle(soap, &a->BoundingBox);
	soap_serialize_PointerTott__Vector(soap, &a->CenterOfGravity);
	if (a->Polygon)
	{	int i;
		for (i = 0; i < (int)a->__sizePolygon; i++)
		{
			soap_embedded(soap, a->Polygon + i, SOAP_TYPE_tt__Polygon);
			soap_serialize_tt__Polygon(soap, a->Polygon + i);
		}
	}
	soap_serialize_PointerTott__ShapeDescriptorExtension(soap, &a->Extension);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ShapeDescriptor(struct soap *soap, const char *tag, int id, const struct tt__ShapeDescriptor *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ShapeDescriptor), type))
		return soap->error;
	if (!a->BoundingBox)
	{	if (soap_element_empty(soap, "tt:BoundingBox", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Rectangle(soap, "tt:BoundingBox", -1, &a->BoundingBox, ""))
		return soap->error;
	if (!a->CenterOfGravity)
	{	if (soap_element_empty(soap, "tt:CenterOfGravity", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Vector(soap, "tt:CenterOfGravity", -1, &a->CenterOfGravity, ""))
		return soap->error;
	if (a->Polygon)
	{	int i;
		for (i = 0; i < (int)a->__sizePolygon; i++)
			if (soap_out_tt__Polygon(soap, "tt:Polygon", -1, a->Polygon + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ShapeDescriptorExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ShapeDescriptor * SOAP_FMAC4 soap_in_tt__ShapeDescriptor(struct soap *soap, const char *tag, struct tt__ShapeDescriptor *a, const char *type)
{
	size_t soap_flag_BoundingBox = 1;
	size_t soap_flag_CenterOfGravity = 1;
	struct soap_blist *soap_blist_Polygon = NULL;
	size_t soap_flag_Extension = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ShapeDescriptor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ShapeDescriptor, sizeof(struct tt__ShapeDescriptor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ShapeDescriptor(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundingBox && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rectangle(soap, "tt:BoundingBox", &a->BoundingBox, "tt:Rectangle"))
				{	soap_flag_BoundingBox--;
					continue;
				}
			}
			if (soap_flag_CenterOfGravity && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector(soap, "tt:CenterOfGravity", &a->CenterOfGravity, "tt:Vector"))
				{	soap_flag_CenterOfGravity--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Polygon", 1, NULL))
			{	if (a->Polygon == NULL)
				{	if (soap_blist_Polygon == NULL)
						soap_blist_Polygon = soap_alloc_block(soap);
					a->Polygon = (struct tt__Polygon *)soap_push_block_max(soap, soap_blist_Polygon, sizeof(struct tt__Polygon));
					if (a->Polygon == NULL)
						return NULL;
					soap_default_tt__Polygon(soap, a->Polygon);
				}
				soap_revert(soap);
				if (soap_in_tt__Polygon(soap, "tt:Polygon", a->Polygon, "tt:Polygon"))
				{	a->__sizePolygon++;
					a->Polygon = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ShapeDescriptorExtension(soap, "tt:Extension", &a->Extension, "tt:ShapeDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Polygon)
			soap_pop_block(soap, soap_blist_Polygon);
		if (a->__sizePolygon)
		{	a->Polygon = (struct tt__Polygon *)soap_save_block(soap, soap_blist_Polygon, NULL, 1);
		}
		else
		{	a->Polygon = NULL;
			if (soap_blist_Polygon)
				soap_end_block(soap, soap_blist_Polygon);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->BoundingBox || !a->CenterOfGravity))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ShapeDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ShapeDescriptor, SOAP_TYPE_tt__ShapeDescriptor, sizeof(struct tt__ShapeDescriptor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ShapeDescriptor * SOAP_FMAC4 soap_new_tt__ShapeDescriptor(struct soap *soap, int n)
{
	struct tt__ShapeDescriptor *p;
	struct tt__ShapeDescriptor *a = (struct tt__ShapeDescriptor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ShapeDescriptor));
	for (p = a; p && n--; p++)
		soap_default_tt__ShapeDescriptor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ShapeDescriptor(struct soap *soap, const struct tt__ShapeDescriptor *a, const char *tag, const char *type)
{
	if (soap_out_tt__ShapeDescriptor(soap, tag ? tag : "tt:ShapeDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ShapeDescriptor * SOAP_FMAC4 soap_get_tt__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ShapeDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Appearance(struct soap *soap, struct tt__Appearance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transformation = NULL;
	a->Shape = NULL;
	a->Color = NULL;
	a->Class = NULL;
	a->Extension = NULL;
	a->GeoLocation = NULL;
	a->__sizeVehicleInfo = 0;
	a->VehicleInfo = NULL;
	a->LicensePlateInfo = NULL;
	a->HumanFace = NULL;
	a->HumanBody = NULL;
	soap_default_xsd__anyURI(soap, &a->ImageRef);
	soap_default_xsd__base64Binary(soap, &a->Image);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Appearance(struct soap *soap, const struct tt__Appearance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Transformation(soap, &a->Transformation);
	soap_serialize_PointerTott__ShapeDescriptor(soap, &a->Shape);
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	soap_serialize_PointerTott__ClassDescriptor(soap, &a->Class);
	soap_serialize_PointerTott__AppearanceExtension(soap, &a->Extension);
	soap_serialize_PointerTott__GeoLocation(soap, &a->GeoLocation);
	if (a->VehicleInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeVehicleInfo; i++)
		{
			soap_embedded(soap, a->VehicleInfo + i, SOAP_TYPE_tt__VehicleInfo);
			soap_serialize_tt__VehicleInfo(soap, a->VehicleInfo + i);
		}
	}
	soap_serialize_PointerTott__LicensePlateInfo(soap, &a->LicensePlateInfo);
	soap_serialize_PointerTons1__HumanFace(soap, &a->HumanFace);
	soap_serialize_PointerTons2__HumanBody(soap, &a->HumanBody);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->ImageRef);
	soap_serialize_xsd__base64Binary(soap, &a->Image);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Appearance(struct soap *soap, const char *tag, int id, const struct tt__Appearance *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Appearance), type))
		return soap->error;
	if (soap_out_PointerTott__Transformation(soap, "tt:Transformation", -1, &a->Transformation, ""))
		return soap->error;
	if (soap_out_PointerTott__ShapeDescriptor(soap, "tt:Shape", -1, &a->Shape, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "tt:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerTott__ClassDescriptor(soap, "tt:Class", -1, &a->Class, ""))
		return soap->error;
	if (soap_out_PointerTott__AppearanceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (soap_out_PointerTott__GeoLocation(soap, "tt:GeoLocation", -1, &a->GeoLocation, ""))
		return soap->error;
	if (a->VehicleInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeVehicleInfo; i++)
			if (soap_out_tt__VehicleInfo(soap, "tt:VehicleInfo", -1, a->VehicleInfo + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__LicensePlateInfo(soap, "tt:LicensePlateInfo", -1, &a->LicensePlateInfo, ""))
		return soap->error;
	if (soap_out_PointerTons1__HumanFace(soap, "tt:HumanFace", -1, &a->HumanFace, ""))
		return soap->error;
	if (soap_out_PointerTons2__HumanBody(soap, "tt:HumanBody", -1, &a->HumanBody, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:ImageRef", -1, (char*const*)&a->ImageRef, ""))
		return soap->error;
	if (soap_out_xsd__base64Binary(soap, "tt:Image", -1, &a->Image, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Appearance * SOAP_FMAC4 soap_in_tt__Appearance(struct soap *soap, const char *tag, struct tt__Appearance *a, const char *type)
{
	size_t soap_flag_Transformation = 1;
	size_t soap_flag_Shape = 1;
	size_t soap_flag_Color = 1;
	size_t soap_flag_Class = 1;
	size_t soap_flag_Extension = 1;
	size_t soap_flag_GeoLocation = 1;
	struct soap_blist *soap_blist_VehicleInfo = NULL;
	size_t soap_flag_LicensePlateInfo = 1;
	size_t soap_flag_HumanFace = 1;
	size_t soap_flag_HumanBody = 1;
	size_t soap_flag_ImageRef = 1;
	size_t soap_flag_Image = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Appearance*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Appearance, sizeof(struct tt__Appearance), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Appearance(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Transformation(soap, "tt:Transformation", &a->Transformation, "tt:Transformation"))
				{	soap_flag_Transformation--;
					continue;
				}
			}
			if (soap_flag_Shape && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ShapeDescriptor(soap, "tt:Shape", &a->Shape, "tt:ShapeDescriptor"))
				{	soap_flag_Shape--;
					continue;
				}
			}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "tt:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap_flag_Class && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ClassDescriptor(soap, "tt:Class", &a->Class, "tt:ClassDescriptor"))
				{	soap_flag_Class--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AppearanceExtension(soap, "tt:Extension", &a->Extension, "tt:AppearanceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap_flag_GeoLocation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoLocation(soap, "tt:GeoLocation", &a->GeoLocation, "tt:GeoLocation"))
				{	soap_flag_GeoLocation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:VehicleInfo", 1, NULL))
			{	if (a->VehicleInfo == NULL)
				{	if (soap_blist_VehicleInfo == NULL)
						soap_blist_VehicleInfo = soap_alloc_block(soap);
					a->VehicleInfo = (struct tt__VehicleInfo *)soap_push_block_max(soap, soap_blist_VehicleInfo, sizeof(struct tt__VehicleInfo));
					if (a->VehicleInfo == NULL)
						return NULL;
					soap_default_tt__VehicleInfo(soap, a->VehicleInfo);
				}
				soap_revert(soap);
				if (soap_in_tt__VehicleInfo(soap, "tt:VehicleInfo", a->VehicleInfo, "tt:VehicleInfo"))
				{	a->__sizeVehicleInfo++;
					a->VehicleInfo = NULL;
					continue;
				}
			}
			if (soap_flag_LicensePlateInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LicensePlateInfo(soap, "tt:LicensePlateInfo", &a->LicensePlateInfo, "tt:LicensePlateInfo"))
				{	soap_flag_LicensePlateInfo--;
					continue;
				}
			}
			if (soap_flag_HumanFace && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__HumanFace(soap, "tt:HumanFace", &a->HumanFace, "ns1:HumanFace"))
				{	soap_flag_HumanFace--;
					continue;
				}
			}
			if (soap_flag_HumanBody && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__HumanBody(soap, "tt:HumanBody", &a->HumanBody, "ns2:HumanBody"))
				{	soap_flag_HumanBody--;
					continue;
				}
			}
			if (soap_flag_ImageRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:ImageRef", (char**)&a->ImageRef, "xsd:anyURI"))
				{	soap_flag_ImageRef--;
					continue;
				}
			}
			if (soap_flag_Image && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__base64Binary(soap, "tt:Image", &a->Image, "xsd:base64Binary"))
				{	soap_flag_Image--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->VehicleInfo)
			soap_pop_block(soap, soap_blist_VehicleInfo);
		if (a->__sizeVehicleInfo)
		{	a->VehicleInfo = (struct tt__VehicleInfo *)soap_save_block(soap, soap_blist_VehicleInfo, NULL, 1);
		}
		else
		{	a->VehicleInfo = NULL;
			if (soap_blist_VehicleInfo)
				soap_end_block(soap, soap_blist_VehicleInfo);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Appearance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Appearance, SOAP_TYPE_tt__Appearance, sizeof(struct tt__Appearance), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Appearance * SOAP_FMAC4 soap_new_tt__Appearance(struct soap *soap, int n)
{
	struct tt__Appearance *p;
	struct tt__Appearance *a = (struct tt__Appearance*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Appearance));
	for (p = a; p && n--; p++)
		soap_default_tt__Appearance(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Appearance(struct soap *soap, const struct tt__Appearance *a, const char *tag, const char *type)
{
	if (soap_out_tt__Appearance(soap, tag ? tag : "tt:Appearance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Appearance * SOAP_FMAC4 soap_get_tt__Appearance(struct soap *soap, struct tt__Appearance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Appearance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LocalOrientation(struct soap *soap, struct tt__LocalOrientation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->pan = NULL;
	a->tilt = NULL;
	a->roll = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LocalOrientation(struct soap *soap, const struct tt__LocalOrientation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LocalOrientation(struct soap *soap, const char *tag, int id, const struct tt__LocalOrientation *a, const char *type)
{
	if (a->pan)
	{	soap_set_attr(soap, "pan", soap_float2s(soap, *a->pan), 1);
	}
	if (a->tilt)
	{	soap_set_attr(soap, "tilt", soap_float2s(soap, *a->tilt), 1);
	}
	if (a->roll)
	{	soap_set_attr(soap, "roll", soap_float2s(soap, *a->roll), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LocalOrientation), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LocalOrientation * SOAP_FMAC4 soap_in_tt__LocalOrientation(struct soap *soap, const char *tag, struct tt__LocalOrientation *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__LocalOrientation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocalOrientation, sizeof(struct tt__LocalOrientation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LocalOrientation(soap, a);
	{
		const char *t = soap_attr_value(soap, "pan", 5, 0);
		if (t)
		{
			if (!(a->pan = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->pan))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "tilt", 5, 0);
		if (t)
		{
			if (!(a->tilt = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->tilt))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "roll", 5, 0);
		if (t)
		{
			if (!(a->roll = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->roll))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__LocalOrientation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LocalOrientation, SOAP_TYPE_tt__LocalOrientation, sizeof(struct tt__LocalOrientation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__LocalOrientation * SOAP_FMAC4 soap_new_tt__LocalOrientation(struct soap *soap, int n)
{
	struct tt__LocalOrientation *p;
	struct tt__LocalOrientation *a = (struct tt__LocalOrientation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__LocalOrientation));
	for (p = a; p && n--; p++)
		soap_default_tt__LocalOrientation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LocalOrientation(struct soap *soap, const struct tt__LocalOrientation *a, const char *tag, const char *type)
{
	if (soap_out_tt__LocalOrientation(soap, tag ? tag : "tt:LocalOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LocalOrientation * SOAP_FMAC4 soap_get_tt__LocalOrientation(struct soap *soap, struct tt__LocalOrientation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LocalOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LocalLocation(struct soap *soap, struct tt__LocalLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->x = NULL;
	a->y = NULL;
	a->z = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LocalLocation(struct soap *soap, const struct tt__LocalLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LocalLocation(struct soap *soap, const char *tag, int id, const struct tt__LocalLocation *a, const char *type)
{
	if (a->x)
	{	soap_set_attr(soap, "x", soap_float2s(soap, *a->x), 1);
	}
	if (a->y)
	{	soap_set_attr(soap, "y", soap_float2s(soap, *a->y), 1);
	}
	if (a->z)
	{	soap_set_attr(soap, "z", soap_float2s(soap, *a->z), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LocalLocation), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LocalLocation * SOAP_FMAC4 soap_in_tt__LocalLocation(struct soap *soap, const char *tag, struct tt__LocalLocation *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__LocalLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocalLocation, sizeof(struct tt__LocalLocation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LocalLocation(soap, a);
	{
		const char *t = soap_attr_value(soap, "x", 5, 0);
		if (t)
		{
			if (!(a->x = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "y", 5, 0);
		if (t)
		{
			if (!(a->y = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "z", 5, 0);
		if (t)
		{
			if (!(a->z = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->z))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__LocalLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LocalLocation, SOAP_TYPE_tt__LocalLocation, sizeof(struct tt__LocalLocation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__LocalLocation * SOAP_FMAC4 soap_new_tt__LocalLocation(struct soap *soap, int n)
{
	struct tt__LocalLocation *p;
	struct tt__LocalLocation *a = (struct tt__LocalLocation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__LocalLocation));
	for (p = a; p && n--; p++)
		soap_default_tt__LocalLocation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LocalLocation(struct soap *soap, const struct tt__LocalLocation *a, const char *tag, const char *type)
{
	if (soap_out_tt__LocalLocation(soap, tag ? tag : "tt:LocalLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LocalLocation * SOAP_FMAC4 soap_get_tt__LocalLocation(struct soap *soap, struct tt__LocalLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LocalLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GeoOrientation(struct soap *soap, struct tt__GeoOrientation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->roll = NULL;
	a->pitch = NULL;
	a->yaw = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GeoOrientation(struct soap *soap, const struct tt__GeoOrientation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GeoOrientation(struct soap *soap, const char *tag, int id, const struct tt__GeoOrientation *a, const char *type)
{
	if (a->roll)
	{	soap_set_attr(soap, "roll", soap_float2s(soap, *a->roll), 1);
	}
	if (a->pitch)
	{	soap_set_attr(soap, "pitch", soap_float2s(soap, *a->pitch), 1);
	}
	if (a->yaw)
	{	soap_set_attr(soap, "yaw", soap_float2s(soap, *a->yaw), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GeoOrientation), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GeoOrientation * SOAP_FMAC4 soap_in_tt__GeoOrientation(struct soap *soap, const char *tag, struct tt__GeoOrientation *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__GeoOrientation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GeoOrientation, sizeof(struct tt__GeoOrientation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GeoOrientation(soap, a);
	{
		const char *t = soap_attr_value(soap, "roll", 5, 0);
		if (t)
		{
			if (!(a->roll = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->roll))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "pitch", 5, 0);
		if (t)
		{
			if (!(a->pitch = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->pitch))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "yaw", 5, 0);
		if (t)
		{
			if (!(a->yaw = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->yaw))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__GeoOrientation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GeoOrientation, SOAP_TYPE_tt__GeoOrientation, sizeof(struct tt__GeoOrientation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__GeoOrientation * SOAP_FMAC4 soap_new_tt__GeoOrientation(struct soap *soap, int n)
{
	struct tt__GeoOrientation *p;
	struct tt__GeoOrientation *a = (struct tt__GeoOrientation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__GeoOrientation));
	for (p = a; p && n--; p++)
		soap_default_tt__GeoOrientation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GeoOrientation(struct soap *soap, const struct tt__GeoOrientation *a, const char *tag, const char *type)
{
	if (soap_out_tt__GeoOrientation(soap, tag ? tag : "tt:GeoOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GeoOrientation * SOAP_FMAC4 soap_get_tt__GeoOrientation(struct soap *soap, struct tt__GeoOrientation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GeoOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GeoLocation(struct soap *soap, struct tt__GeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->lon = NULL;
	a->lat = NULL;
	a->elevation = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GeoLocation(struct soap *soap, const struct tt__GeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GeoLocation(struct soap *soap, const char *tag, int id, const struct tt__GeoLocation *a, const char *type)
{
	if (a->lon)
	{	soap_set_attr(soap, "lon", soap_double2s(soap, *a->lon), 1);
	}
	if (a->lat)
	{	soap_set_attr(soap, "lat", soap_double2s(soap, *a->lat), 1);
	}
	if (a->elevation)
	{	soap_set_attr(soap, "elevation", soap_float2s(soap, *a->elevation), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GeoLocation), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GeoLocation * SOAP_FMAC4 soap_in_tt__GeoLocation(struct soap *soap, const char *tag, struct tt__GeoLocation *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__GeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GeoLocation, sizeof(struct tt__GeoLocation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GeoLocation(soap, a);
	{
		const char *t = soap_attr_value(soap, "lon", 5, 0);
		if (t)
		{
			if (!(a->lon = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, a->lon))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "lat", 5, 0);
		if (t)
		{
			if (!(a->lat = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, a->lat))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "elevation", 5, 0);
		if (t)
		{
			if (!(a->elevation = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->elevation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__GeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GeoLocation, SOAP_TYPE_tt__GeoLocation, sizeof(struct tt__GeoLocation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__GeoLocation * SOAP_FMAC4 soap_new_tt__GeoLocation(struct soap *soap, int n)
{
	struct tt__GeoLocation *p;
	struct tt__GeoLocation *a = (struct tt__GeoLocation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__GeoLocation));
	for (p = a; p && n--; p++)
		soap_default_tt__GeoLocation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GeoLocation(struct soap *soap, const struct tt__GeoLocation *a, const char *tag, const char *type)
{
	if (soap_out_tt__GeoLocation(soap, tag ? tag : "tt:GeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GeoLocation * SOAP_FMAC4 soap_get_tt__GeoLocation(struct soap *soap, struct tt__GeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TransformationExtension(struct soap *soap, const struct tt__TransformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TransformationExtension(struct soap *soap, const char *tag, int id, const struct tt__TransformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TransformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TransformationExtension * SOAP_FMAC4 soap_in_tt__TransformationExtension(struct soap *soap, const char *tag, struct tt__TransformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__TransformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransformationExtension, sizeof(struct tt__TransformationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TransformationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__TransformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TransformationExtension, SOAP_TYPE_tt__TransformationExtension, sizeof(struct tt__TransformationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TransformationExtension * SOAP_FMAC4 soap_new_tt__TransformationExtension(struct soap *soap, int n)
{
	struct tt__TransformationExtension *p;
	struct tt__TransformationExtension *a = (struct tt__TransformationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TransformationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__TransformationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TransformationExtension(struct soap *soap, const struct tt__TransformationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__TransformationExtension(soap, tag ? tag : "tt:TransformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TransformationExtension * SOAP_FMAC4 soap_get_tt__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Weight = NULL;
	a->Covariance = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ColorDescriptor_ColorCluster(struct soap *soap, const struct _tt__ColorDescriptor_ColorCluster *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Color(soap, &a->Color);
	soap_serialize_PointerTofloat(soap, &a->Weight);
	soap_serialize_PointerTott__ColorCovariance(soap, &a->Covariance);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, int id, const struct _tt__ColorDescriptor_ColorCluster *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster), type))
		return soap->error;
	if (!a->Color)
	{	if (soap_element_empty(soap, "tt:Color", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Color(soap, "tt:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Weight", -1, &a->Weight, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorCovariance(soap, "tt:Covariance", -1, &a->Covariance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster * SOAP_FMAC4 soap_in__tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, struct _tt__ColorDescriptor_ColorCluster *a, const char *type)
{
	size_t soap_flag_Color = 1;
	size_t soap_flag_Weight = 1;
	size_t soap_flag_Covariance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__ColorDescriptor_ColorCluster*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, sizeof(struct _tt__ColorDescriptor_ColorCluster), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ColorDescriptor_ColorCluster(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Color(soap, "tt:Color", &a->Color, "tt:Color"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap_flag_Weight && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Weight", &a->Weight, "xsd:float"))
				{	soap_flag_Weight--;
					continue;
				}
			}
			if (soap_flag_Covariance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorCovariance(soap, "tt:Covariance", &a->Covariance, "tt:ColorCovariance"))
				{	soap_flag_Covariance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Color))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tt__ColorDescriptor_ColorCluster *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, sizeof(struct _tt__ColorDescriptor_ColorCluster), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster * SOAP_FMAC4 soap_new__tt__ColorDescriptor_ColorCluster(struct soap *soap, int n)
{
	struct _tt__ColorDescriptor_ColorCluster *p;
	struct _tt__ColorDescriptor_ColorCluster *a = (struct _tt__ColorDescriptor_ColorCluster*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ColorDescriptor_ColorCluster));
	for (p = a; p && n--; p++)
		soap_default__tt__ColorDescriptor_ColorCluster(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ColorDescriptor_ColorCluster(struct soap *soap, const struct _tt__ColorDescriptor_ColorCluster *a, const char *tag, const char *type)
{
	if (soap_out__tt__ColorDescriptor_ColorCluster(soap, tag ? tag : "tt:ColorDescriptor-ColorCluster", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster * SOAP_FMAC4 soap_get__tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ColorDescriptor_ColorCluster(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeColorCluster = 0;
	a->ColorCluster = NULL;
	a->Extension = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorDescriptor(struct soap *soap, const struct tt__ColorDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ColorCluster)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorCluster; i++)
		{
			soap_embedded(soap, a->ColorCluster + i, SOAP_TYPE__tt__ColorDescriptor_ColorCluster);
			soap_serialize__tt__ColorDescriptor_ColorCluster(soap, a->ColorCluster + i);
		}
	}
	soap_serialize_PointerToxsd__anyType(soap, &a->Extension);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorDescriptor(struct soap *soap, const char *tag, int id, const struct tt__ColorDescriptor *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorDescriptor), type))
		return soap->error;
	if (a->ColorCluster)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorCluster; i++)
			if (soap_out__tt__ColorDescriptor_ColorCluster(soap, "tt:ColorCluster", -1, a->ColorCluster + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__anyType(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorDescriptor * SOAP_FMAC4 soap_in_tt__ColorDescriptor(struct soap *soap, const char *tag, struct tt__ColorDescriptor *a, const char *type)
{
	struct soap_blist *soap_blist_ColorCluster = NULL;
	size_t soap_flag_Extension = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ColorDescriptor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorDescriptor, sizeof(struct tt__ColorDescriptor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorDescriptor(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ColorCluster", 1, NULL))
			{	if (a->ColorCluster == NULL)
				{	if (soap_blist_ColorCluster == NULL)
						soap_blist_ColorCluster = soap_alloc_block(soap);
					a->ColorCluster = (struct _tt__ColorDescriptor_ColorCluster *)soap_push_block_max(soap, soap_blist_ColorCluster, sizeof(struct _tt__ColorDescriptor_ColorCluster));
					if (a->ColorCluster == NULL)
						return NULL;
					soap_default__tt__ColorDescriptor_ColorCluster(soap, a->ColorCluster);
				}
				soap_revert(soap);
				if (soap_in__tt__ColorDescriptor_ColorCluster(soap, "tt:ColorCluster", a->ColorCluster, ""))
				{	a->__sizeColorCluster++;
					a->ColorCluster = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__anyType(soap, "tt:Extension", &a->Extension, "xsd:anyType"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ColorCluster)
			soap_pop_block(soap, soap_blist_ColorCluster);
		if (a->__sizeColorCluster)
		{	a->ColorCluster = (struct _tt__ColorDescriptor_ColorCluster *)soap_save_block(soap, soap_blist_ColorCluster, NULL, 1);
		}
		else
		{	a->ColorCluster = NULL;
			if (soap_blist_ColorCluster)
				soap_end_block(soap, soap_blist_ColorCluster);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ColorDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorDescriptor, SOAP_TYPE_tt__ColorDescriptor, sizeof(struct tt__ColorDescriptor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ColorDescriptor * SOAP_FMAC4 soap_new_tt__ColorDescriptor(struct soap *soap, int n)
{
	struct tt__ColorDescriptor *p;
	struct tt__ColorDescriptor *a = (struct tt__ColorDescriptor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ColorDescriptor));
	for (p = a; p && n--; p++)
		soap_default_tt__ColorDescriptor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorDescriptor(struct soap *soap, const struct tt__ColorDescriptor *a, const char *tag, const char *type)
{
	if (soap_out_tt__ColorDescriptor(soap, tag ? tag : "tt:ColorDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorDescriptor * SOAP_FMAC4 soap_get_tt__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->XX);
	soap_default_float(soap, &a->YY);
	soap_default_float(soap, &a->ZZ);
	a->XY = NULL;
	a->XZ = NULL;
	a->YZ = NULL;
	soap_default_xsd__anyURI(soap, &a->Colorspace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorCovariance(struct soap *soap, const struct tt__ColorCovariance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorCovariance(struct soap *soap, const char *tag, int id, const struct tt__ColorCovariance *a, const char *type)
{
	soap_set_attr(soap, "XX", soap_float2s(soap, a->XX), 1);
	soap_set_attr(soap, "YY", soap_float2s(soap, a->YY), 1);
	soap_set_attr(soap, "ZZ", soap_float2s(soap, a->ZZ), 1);
	if (a->XY)
	{	soap_set_attr(soap, "XY", soap_float2s(soap, *a->XY), 1);
	}
	if (a->XZ)
	{	soap_set_attr(soap, "XZ", soap_float2s(soap, *a->XZ), 1);
	}
	if (a->YZ)
	{	soap_set_attr(soap, "YZ", soap_float2s(soap, *a->YZ), 1);
	}
	if (a->Colorspace)
		soap_set_attr(soap, "Colorspace", soap_xsd__anyURI2s(soap, a->Colorspace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorCovariance), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorCovariance * SOAP_FMAC4 soap_in_tt__ColorCovariance(struct soap *soap, const char *tag, struct tt__ColorCovariance *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ColorCovariance*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorCovariance, sizeof(struct tt__ColorCovariance), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorCovariance(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "XX", 5, 1), &a->XX))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "YY", 5, 1), &a->YY))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "ZZ", 5, 1), &a->ZZ))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "XY", 5, 0);
		if (t)
		{
			if (!(a->XY = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->XY))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "XZ", 5, 0);
		if (t)
		{
			if (!(a->XZ = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->XZ))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "YZ", 5, 0);
		if (t)
		{
			if (!(a->YZ = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->YZ))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Colorspace", 4, 0), &a->Colorspace))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ColorCovariance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorCovariance, SOAP_TYPE_tt__ColorCovariance, sizeof(struct tt__ColorCovariance), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ColorCovariance * SOAP_FMAC4 soap_new_tt__ColorCovariance(struct soap *soap, int n)
{
	struct tt__ColorCovariance *p;
	struct tt__ColorCovariance *a = (struct tt__ColorCovariance*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ColorCovariance));
	for (p = a; p && n--; p++)
		soap_default_tt__ColorCovariance(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorCovariance(struct soap *soap, const struct tt__ColorCovariance *a, const char *tag, const char *type)
{
	if (soap_out_tt__ColorCovariance(soap, tag ? tag : "tt:ColorCovariance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorCovariance * SOAP_FMAC4 soap_get_tt__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorCovariance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Polygon(struct soap *soap, struct tt__Polygon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePoint = 0;
	a->Point = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Polygon(struct soap *soap, const struct tt__Polygon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Point)
	{	int i;
		for (i = 0; i < (int)a->__sizePoint; i++)
		{
			soap_embedded(soap, a->Point + i, SOAP_TYPE_tt__Vector);
			soap_serialize_tt__Vector(soap, a->Point + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polygon(struct soap *soap, const char *tag, int id, const struct tt__Polygon *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polygon), type))
		return soap->error;
	if (a->Point)
	{	int i;
		for (i = 0; i < (int)a->__sizePoint; i++)
			if (soap_out_tt__Vector(soap, "tt:Point", -1, a->Point + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Polygon * SOAP_FMAC4 soap_in_tt__Polygon(struct soap *soap, const char *tag, struct tt__Polygon *a, const char *type)
{
	struct soap_blist *soap_blist_Point = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Polygon*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polygon, sizeof(struct tt__Polygon), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Polygon(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Point", 1, NULL))
			{	if (a->Point == NULL)
				{	if (soap_blist_Point == NULL)
						soap_blist_Point = soap_alloc_block(soap);
					a->Point = (struct tt__Vector *)soap_push_block_max(soap, soap_blist_Point, sizeof(struct tt__Vector));
					if (a->Point == NULL)
						return NULL;
					soap_default_tt__Vector(soap, a->Point);
				}
				soap_revert(soap);
				if (soap_in_tt__Vector(soap, "tt:Point", a->Point, "tt:Vector"))
				{	a->__sizePoint++;
					a->Point = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Point)
			soap_pop_block(soap, soap_blist_Point);
		if (a->__sizePoint)
		{	a->Point = (struct tt__Vector *)soap_save_block(soap, soap_blist_Point, NULL, 1);
		}
		else
		{	a->Point = NULL;
			if (soap_blist_Point)
				soap_end_block(soap, soap_blist_Point);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePoint < 3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Polygon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polygon, SOAP_TYPE_tt__Polygon, sizeof(struct tt__Polygon), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Polygon * SOAP_FMAC4 soap_new_tt__Polygon(struct soap *soap, int n)
{
	struct tt__Polygon *p;
	struct tt__Polygon *a = (struct tt__Polygon*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Polygon));
	for (p = a; p && n--; p++)
		soap_default_tt__Polygon(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Polygon(struct soap *soap, const struct tt__Polygon *a, const char *tag, const char *type)
{
	if (soap_out_tt__Polygon(soap, tag ? tag : "tt:Polygon", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Polygon * SOAP_FMAC4 soap_get_tt__Polygon(struct soap *soap, struct tt__Polygon *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZMoveStatus(struct soap *soap, const struct tt__PTZMoveStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MoveStatus(soap, &a->PanTilt);
	soap_serialize_PointerTott__MoveStatus(soap, &a->Zoom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZMoveStatus(struct soap *soap, const char *tag, int id, const struct tt__PTZMoveStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZMoveStatus), type))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZMoveStatus * SOAP_FMAC4 soap_in_tt__PTZMoveStatus(struct soap *soap, const char *tag, struct tt__PTZMoveStatus *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZMoveStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZMoveStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MoveStatus(soap, "tt:PanTilt", &a->PanTilt, "tt:MoveStatus"))
				{	soap_flag_PanTilt--;
					continue;
				}
			}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MoveStatus(soap, "tt:Zoom", &a->Zoom, "tt:MoveStatus"))
				{	soap_flag_Zoom--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZMoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZMoveStatus, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZMoveStatus * SOAP_FMAC4 soap_new_tt__PTZMoveStatus(struct soap *soap, int n)
{
	struct tt__PTZMoveStatus *p;
	struct tt__PTZMoveStatus *a = (struct tt__PTZMoveStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZMoveStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZMoveStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZMoveStatus(struct soap *soap, const struct tt__PTZMoveStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZMoveStatus(soap, tag ? tag : "tt:PTZMoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZMoveStatus * SOAP_FMAC4 soap_get_tt__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStatus(struct soap *soap, struct tt__PTZStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Position = NULL;
	a->MoveStatus = NULL;
	soap_default_string(soap, &a->Error);
	soap_default_dateTime(soap, &a->UtcTime);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStatus(struct soap *soap, const struct tt__PTZStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZVector(soap, &a->Position);
	soap_serialize_PointerTott__PTZMoveStatus(soap, &a->MoveStatus);
	soap_serialize_string(soap, (char*const*)&a->Error);
	soap_embedded(soap, &a->UtcTime, SOAP_TYPE_dateTime);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatus(struct soap *soap, const char *tag, int id, const struct tt__PTZStatus *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatus), type))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZMoveStatus(soap, "tt:MoveStatus", -1, &a->MoveStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Error", -1, (char*const*)&a->Error, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:UtcTime", -1, &a->UtcTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStatus * SOAP_FMAC4 soap_in_tt__PTZStatus(struct soap *soap, const char *tag, struct tt__PTZStatus *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_MoveStatus = 1;
	size_t soap_flag_Error = 1;
	size_t soap_flag_UtcTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatus, sizeof(struct tt__PTZStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStatus(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:Position", &a->Position, "tt:PTZVector"))
				{	soap_flag_Position--;
					continue;
				}
			}
			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZMoveStatus(soap, "tt:MoveStatus", &a->MoveStatus, "tt:PTZMoveStatus"))
				{	soap_flag_MoveStatus--;
					continue;
				}
			}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Error", (char**)&a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			}
			if (soap_flag_UtcTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:UtcTime", &a->UtcTime, "xsd:dateTime"))
				{	soap_flag_UtcTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatus, SOAP_TYPE_tt__PTZStatus, sizeof(struct tt__PTZStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZStatus * SOAP_FMAC4 soap_new_tt__PTZStatus(struct soap *soap, int n)
{
	struct tt__PTZStatus *p;
	struct tt__PTZStatus *a = (struct tt__PTZStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStatus(struct soap *soap, const struct tt__PTZStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZStatus(soap, tag ? tag : "tt:PTZStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatus * SOAP_FMAC4 soap_get_tt__PTZStatus(struct soap *soap, struct tt__PTZStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PolygonOptions(struct soap *soap, struct tt__PolygonOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RectangleOnly = NULL;
	a->VertexLimits = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PolygonOptions(struct soap *soap, const struct tt__PolygonOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->RectangleOnly);
	soap_serialize_PointerTott__IntRange(soap, &a->VertexLimits);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolygonOptions(struct soap *soap, const char *tag, int id, const struct tt__PolygonOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolygonOptions), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:RectangleOnly", -1, &a->RectangleOnly, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:VertexLimits", -1, &a->VertexLimits, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PolygonOptions * SOAP_FMAC4 soap_in_tt__PolygonOptions(struct soap *soap, const char *tag, struct tt__PolygonOptions *a, const char *type)
{
	size_t soap_flag_RectangleOnly = 1;
	size_t soap_flag_VertexLimits = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PolygonOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolygonOptions, sizeof(struct tt__PolygonOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PolygonOptions(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RectangleOnly && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tt:RectangleOnly", &a->RectangleOnly, "xsd:boolean"))
				{	soap_flag_RectangleOnly--;
					continue;
				}
			}
			if (soap_flag_VertexLimits && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:VertexLimits", &a->VertexLimits, "tt:IntRange"))
				{	soap_flag_VertexLimits--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PolygonOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolygonOptions, SOAP_TYPE_tt__PolygonOptions, sizeof(struct tt__PolygonOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PolygonOptions * SOAP_FMAC4 soap_new_tt__PolygonOptions(struct soap *soap, int n)
{
	struct tt__PolygonOptions *p;
	struct tt__PolygonOptions *a = (struct tt__PolygonOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PolygonOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__PolygonOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PolygonOptions(struct soap *soap, const struct tt__PolygonOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__PolygonOptions(soap, tag ? tag : "tt:PolygonOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolygonOptions * SOAP_FMAC4 soap_get_tt__PolygonOptions(struct soap *soap, struct tt__PolygonOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolygonOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__StorageReferencePathExtension(struct soap *soap, struct tt__StorageReferencePathExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StorageReferencePathExtension(struct soap *soap, const struct tt__StorageReferencePathExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StorageReferencePathExtension(struct soap *soap, const char *tag, int id, const struct tt__StorageReferencePathExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StorageReferencePathExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__StorageReferencePathExtension * SOAP_FMAC4 soap_in_tt__StorageReferencePathExtension(struct soap *soap, const char *tag, struct tt__StorageReferencePathExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__StorageReferencePathExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StorageReferencePathExtension, sizeof(struct tt__StorageReferencePathExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__StorageReferencePathExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__StorageReferencePathExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StorageReferencePathExtension, SOAP_TYPE_tt__StorageReferencePathExtension, sizeof(struct tt__StorageReferencePathExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__StorageReferencePathExtension * SOAP_FMAC4 soap_new_tt__StorageReferencePathExtension(struct soap *soap, int n)
{
	struct tt__StorageReferencePathExtension *p;
	struct tt__StorageReferencePathExtension *a = (struct tt__StorageReferencePathExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__StorageReferencePathExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__StorageReferencePathExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StorageReferencePathExtension(struct soap *soap, const struct tt__StorageReferencePathExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__StorageReferencePathExtension(soap, tag ? tag : "tt:StorageReferencePathExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StorageReferencePathExtension * SOAP_FMAC4 soap_get_tt__StorageReferencePathExtension(struct soap *soap, struct tt__StorageReferencePathExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StorageReferencePathExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__StorageReferencePath(struct soap *soap, struct tt__StorageReferencePath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->StorageToken);
	soap_default_string(soap, &a->RelativePath);
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StorageReferencePath(struct soap *soap, const struct tt__StorageReferencePath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->StorageToken);
	soap_serialize_string(soap, (char*const*)&a->RelativePath);
	soap_serialize_PointerTott__StorageReferencePathExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StorageReferencePath(struct soap *soap, const char *tag, int id, const struct tt__StorageReferencePath *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StorageReferencePath), type))
		return soap->error;
	if (!a->StorageToken)
	{	if (soap_element_empty(soap, "tt:StorageToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:StorageToken", -1, (char*const*)&a->StorageToken, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:RelativePath", -1, (char*const*)&a->RelativePath, ""))
		return soap->error;
	if (soap_out_PointerTott__StorageReferencePathExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__StorageReferencePath * SOAP_FMAC4 soap_in_tt__StorageReferencePath(struct soap *soap, const char *tag, struct tt__StorageReferencePath *a, const char *type)
{
	size_t soap_flag_StorageToken = 1;
	size_t soap_flag_RelativePath = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__StorageReferencePath*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StorageReferencePath, sizeof(struct tt__StorageReferencePath), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__StorageReferencePath(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:StorageToken", (char**)&a->StorageToken, "tt:ReferenceToken"))
				{	soap_flag_StorageToken--;
					continue;
				}
			}
			if (soap_flag_RelativePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:RelativePath", (char**)&a->RelativePath, "xsd:string"))
				{	soap_flag_RelativePath--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StorageReferencePathExtension(soap, "tt:Extension", &a->Extension, "tt:StorageReferencePathExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->StorageToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__StorageReferencePath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StorageReferencePath, SOAP_TYPE_tt__StorageReferencePath, sizeof(struct tt__StorageReferencePath), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__StorageReferencePath * SOAP_FMAC4 soap_new_tt__StorageReferencePath(struct soap *soap, int n)
{
	struct tt__StorageReferencePath *p;
	struct tt__StorageReferencePath *a = (struct tt__StorageReferencePath*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__StorageReferencePath));
	for (p = a; p && n--; p++)
		soap_default_tt__StorageReferencePath(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StorageReferencePath(struct soap *soap, const struct tt__StorageReferencePath *a, const char *tag, const char *type)
{
	if (soap_out_tt__StorageReferencePath(soap, tag ? tag : "tt:StorageReferencePath", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StorageReferencePath * SOAP_FMAC4 soap_get_tt__StorageReferencePath(struct soap *soap, struct tt__StorageReferencePath *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StorageReferencePath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ArrayOfFileProgressExtension(struct soap *soap, struct tt__ArrayOfFileProgressExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ArrayOfFileProgressExtension(struct soap *soap, const struct tt__ArrayOfFileProgressExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ArrayOfFileProgressExtension(struct soap *soap, const char *tag, int id, const struct tt__ArrayOfFileProgressExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ArrayOfFileProgressExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgressExtension * SOAP_FMAC4 soap_in_tt__ArrayOfFileProgressExtension(struct soap *soap, const char *tag, struct tt__ArrayOfFileProgressExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ArrayOfFileProgressExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ArrayOfFileProgressExtension, sizeof(struct tt__ArrayOfFileProgressExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ArrayOfFileProgressExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ArrayOfFileProgressExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ArrayOfFileProgressExtension, SOAP_TYPE_tt__ArrayOfFileProgressExtension, sizeof(struct tt__ArrayOfFileProgressExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ArrayOfFileProgressExtension * SOAP_FMAC4 soap_new_tt__ArrayOfFileProgressExtension(struct soap *soap, int n)
{
	struct tt__ArrayOfFileProgressExtension *p;
	struct tt__ArrayOfFileProgressExtension *a = (struct tt__ArrayOfFileProgressExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ArrayOfFileProgressExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ArrayOfFileProgressExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ArrayOfFileProgressExtension(struct soap *soap, const struct tt__ArrayOfFileProgressExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ArrayOfFileProgressExtension(soap, tag ? tag : "tt:ArrayOfFileProgressExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgressExtension * SOAP_FMAC4 soap_get_tt__ArrayOfFileProgressExtension(struct soap *soap, struct tt__ArrayOfFileProgressExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ArrayOfFileProgressExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ArrayOfFileProgress(struct soap *soap, struct tt__ArrayOfFileProgress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeFileProgress = 0;
	a->FileProgress = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ArrayOfFileProgress(struct soap *soap, const struct tt__ArrayOfFileProgress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->FileProgress)
	{	int i;
		for (i = 0; i < (int)a->__sizeFileProgress; i++)
		{
			soap_embedded(soap, a->FileProgress + i, SOAP_TYPE_tt__FileProgress);
			soap_serialize_tt__FileProgress(soap, a->FileProgress + i);
		}
	}
	soap_serialize_PointerTott__ArrayOfFileProgressExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ArrayOfFileProgress(struct soap *soap, const char *tag, int id, const struct tt__ArrayOfFileProgress *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ArrayOfFileProgress), type))
		return soap->error;
	if (a->FileProgress)
	{	int i;
		for (i = 0; i < (int)a->__sizeFileProgress; i++)
			if (soap_out_tt__FileProgress(soap, "tt:FileProgress", -1, a->FileProgress + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ArrayOfFileProgressExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgress * SOAP_FMAC4 soap_in_tt__ArrayOfFileProgress(struct soap *soap, const char *tag, struct tt__ArrayOfFileProgress *a, const char *type)
{
	struct soap_blist *soap_blist_FileProgress = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ArrayOfFileProgress*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ArrayOfFileProgress, sizeof(struct tt__ArrayOfFileProgress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ArrayOfFileProgress(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:FileProgress", 1, NULL))
			{	if (a->FileProgress == NULL)
				{	if (soap_blist_FileProgress == NULL)
						soap_blist_FileProgress = soap_alloc_block(soap);
					a->FileProgress = (struct tt__FileProgress *)soap_push_block_max(soap, soap_blist_FileProgress, sizeof(struct tt__FileProgress));
					if (a->FileProgress == NULL)
						return NULL;
					soap_default_tt__FileProgress(soap, a->FileProgress);
				}
				soap_revert(soap);
				if (soap_in_tt__FileProgress(soap, "tt:FileProgress", a->FileProgress, "tt:FileProgress"))
				{	a->__sizeFileProgress++;
					a->FileProgress = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ArrayOfFileProgressExtension(soap, "tt:Extension", &a->Extension, "tt:ArrayOfFileProgressExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->FileProgress)
			soap_pop_block(soap, soap_blist_FileProgress);
		if (a->__sizeFileProgress)
		{	a->FileProgress = (struct tt__FileProgress *)soap_save_block(soap, soap_blist_FileProgress, NULL, 1);
		}
		else
		{	a->FileProgress = NULL;
			if (soap_blist_FileProgress)
				soap_end_block(soap, soap_blist_FileProgress);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ArrayOfFileProgress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ArrayOfFileProgress, SOAP_TYPE_tt__ArrayOfFileProgress, sizeof(struct tt__ArrayOfFileProgress), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ArrayOfFileProgress * SOAP_FMAC4 soap_new_tt__ArrayOfFileProgress(struct soap *soap, int n)
{
	struct tt__ArrayOfFileProgress *p;
	struct tt__ArrayOfFileProgress *a = (struct tt__ArrayOfFileProgress*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ArrayOfFileProgress));
	for (p = a; p && n--; p++)
		soap_default_tt__ArrayOfFileProgress(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ArrayOfFileProgress(struct soap *soap, const struct tt__ArrayOfFileProgress *a, const char *tag, const char *type)
{
	if (soap_out_tt__ArrayOfFileProgress(soap, tag ? tag : "tt:ArrayOfFileProgress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgress * SOAP_FMAC4 soap_get_tt__ArrayOfFileProgress(struct soap *soap, struct tt__ArrayOfFileProgress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ArrayOfFileProgress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FileProgress(struct soap *soap, struct tt__FileProgress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->FileName);
	soap_default_float(soap, &a->Progress);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FileProgress(struct soap *soap, const struct tt__FileProgress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->FileName);
	soap_embedded(soap, &a->Progress, SOAP_TYPE_float);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FileProgress(struct soap *soap, const char *tag, int id, const struct tt__FileProgress *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FileProgress), type))
		return soap->error;
	if (!a->FileName)
	{	if (soap_element_empty(soap, "tt:FileName", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:FileName", -1, (char*const*)&a->FileName, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Progress", -1, &a->Progress, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FileProgress * SOAP_FMAC4 soap_in_tt__FileProgress(struct soap *soap, const char *tag, struct tt__FileProgress *a, const char *type)
{
	size_t soap_flag_FileName = 1;
	size_t soap_flag_Progress = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__FileProgress*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FileProgress, sizeof(struct tt__FileProgress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FileProgress(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:FileName", (char**)&a->FileName, "xsd:string"))
				{	soap_flag_FileName--;
					continue;
				}
			}
			if (soap_flag_Progress && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Progress", &a->Progress, "xsd:float"))
				{	soap_flag_Progress--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->FileName || soap_flag_Progress > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FileProgress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FileProgress, SOAP_TYPE_tt__FileProgress, sizeof(struct tt__FileProgress), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FileProgress * SOAP_FMAC4 soap_new_tt__FileProgress(struct soap *soap, int n)
{
	struct tt__FileProgress *p;
	struct tt__FileProgress *a = (struct tt__FileProgress*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FileProgress));
	for (p = a; p && n--; p++)
		soap_default_tt__FileProgress(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FileProgress(struct soap *soap, const struct tt__FileProgress *a, const char *tag, const char *type)
{
	if (soap_out_tt__FileProgress(soap, tag ? tag : "tt:FileProgress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FileProgress * SOAP_FMAC4 soap_get_tt__FileProgress(struct soap *soap, struct tt__FileProgress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FileProgress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDConfigurationOptionsExtension(struct soap *soap, struct tt__OSDConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDConfigurationOptionsExtension(struct soap *soap, const struct tt__OSDConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDConfigurationOptionsExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDConfigurationOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDConfigurationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(struct tt__OSDConfigurationOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDConfigurationOptionsExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(struct tt__OSDConfigurationOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDConfigurationOptionsExtension * SOAP_FMAC4 soap_new_tt__OSDConfigurationOptionsExtension(struct soap *soap, int n)
{
	struct tt__OSDConfigurationOptionsExtension *p;
	struct tt__OSDConfigurationOptionsExtension *a = (struct tt__OSDConfigurationOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDConfigurationOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDConfigurationOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDConfigurationOptionsExtension(struct soap *soap, const struct tt__OSDConfigurationOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDConfigurationOptionsExtension(soap, tag ? tag : "tt:OSDConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDConfigurationOptionsExtension(struct soap *soap, struct tt__OSDConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDConfigurationOptions(struct soap *soap, struct tt__OSDConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MaximumNumberOfOSDs = NULL;
	a->__sizeType = 0;
	a->Type = NULL;
	a->__sizePositionOption = 0;
	a->PositionOption = NULL;
	a->TextOption = NULL;
	a->ImageOption = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDConfigurationOptions(struct soap *soap, const struct tt__OSDConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MaximumNumberOfOSDs(soap, &a->MaximumNumberOfOSDs);
	if (a->Type)
	{	int i;
		for (i = 0; i < (int)a->__sizeType; i++)
		{
			soap_embedded(soap, a->Type + i, SOAP_TYPE_tt__OSDType);
		}
	}
	if (a->PositionOption)
	{	int i;
		for (i = 0; i < (int)a->__sizePositionOption; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->PositionOption + i));
		}
	}
	soap_serialize_PointerTott__OSDTextOptions(soap, &a->TextOption);
	soap_serialize_PointerTott__OSDImgOptions(soap, &a->ImageOption);
	soap_serialize_PointerTott__OSDConfigurationOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__OSDConfigurationOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfigurationOptions), type))
		return soap->error;
	if (!a->MaximumNumberOfOSDs)
	{	if (soap_element_empty(soap, "tt:MaximumNumberOfOSDs", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MaximumNumberOfOSDs(soap, "tt:MaximumNumberOfOSDs", -1, &a->MaximumNumberOfOSDs, ""))
		return soap->error;
	if (a->Type)
	{	int i;
		for (i = 0; i < (int)a->__sizeType; i++)
			if (soap_out_tt__OSDType(soap, "tt:Type", -1, a->Type + i, ""))
				return soap->error;
	}
	if (a->PositionOption)
	{	int i;
		for (i = 0; i < (int)a->__sizePositionOption; i++)
			if (soap_out_string(soap, "tt:PositionOption", -1, (char*const*)(a->PositionOption + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__OSDTextOptions(soap, "tt:TextOption", -1, &a->TextOption, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgOptions(soap, "tt:ImageOption", -1, &a->ImageOption, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptions * SOAP_FMAC4 soap_in_tt__OSDConfigurationOptions(struct soap *soap, const char *tag, struct tt__OSDConfigurationOptions *a, const char *type)
{
	size_t soap_flag_MaximumNumberOfOSDs = 1;
	struct soap_blist *soap_blist_Type = NULL;
	struct soap_blist *soap_blist_PositionOption = NULL;
	size_t soap_flag_TextOption = 1;
	size_t soap_flag_ImageOption = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(struct tt__OSDConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDConfigurationOptions(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfOSDs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MaximumNumberOfOSDs(soap, "tt:MaximumNumberOfOSDs", &a->MaximumNumberOfOSDs, "tt:MaximumNumberOfOSDs"))
				{	soap_flag_MaximumNumberOfOSDs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Type", 1, NULL))
			{	if (a->Type == NULL)
				{	if (soap_blist_Type == NULL)
						soap_blist_Type = soap_alloc_block(soap);
					a->Type = (enum tt__OSDType *)soap_push_block_max(soap, soap_blist_Type, sizeof(enum tt__OSDType));
					if (a->Type == NULL)
						return NULL;
					soap_default_tt__OSDType(soap, a->Type);
				}
				soap_revert(soap);
				if (soap_in_tt__OSDType(soap, "tt:Type", a->Type, "tt:OSDType"))
				{	a->__sizeType++;
					a->Type = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PositionOption", 1, NULL))
			{	if (a->PositionOption == NULL)
				{	if (soap_blist_PositionOption == NULL)
						soap_blist_PositionOption = soap_alloc_block(soap);
					a->PositionOption = (char **)soap_push_block_max(soap, soap_blist_PositionOption, sizeof(char *));
					if (a->PositionOption == NULL)
						return NULL;
					*a->PositionOption = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:PositionOption", (char**)a->PositionOption, "xsd:string"))
				{	a->__sizePositionOption++;
					a->PositionOption = NULL;
					continue;
				}
			}
			if (soap_flag_TextOption && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextOptions(soap, "tt:TextOption", &a->TextOption, "tt:OSDTextOptions"))
				{	soap_flag_TextOption--;
					continue;
				}
			}
			if (soap_flag_ImageOption && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgOptions(soap, "tt:ImageOption", &a->ImageOption, "tt:OSDImgOptions"))
				{	soap_flag_ImageOption--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDConfigurationOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:OSDConfigurationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Type)
			soap_pop_block(soap, soap_blist_Type);
		if (a->__sizeType)
		{	a->Type = (enum tt__OSDType *)soap_save_block(soap, soap_blist_Type, NULL, 1);
		}
		else
		{	a->Type = NULL;
			if (soap_blist_Type)
				soap_end_block(soap, soap_blist_Type);
		}
		if (a->PositionOption)
			soap_pop_block(soap, soap_blist_PositionOption);
		if (a->__sizePositionOption)
		{	a->PositionOption = (char **)soap_save_block(soap, soap_blist_PositionOption, NULL, 1);
		}
		else
		{	a->PositionOption = NULL;
			if (soap_blist_PositionOption)
				soap_end_block(soap, soap_blist_PositionOption);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->MaximumNumberOfOSDs || a->__sizeType < 1 || a->__sizePositionOption < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationOptions, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(struct tt__OSDConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDConfigurationOptions * SOAP_FMAC4 soap_new_tt__OSDConfigurationOptions(struct soap *soap, int n)
{
	struct tt__OSDConfigurationOptions *p;
	struct tt__OSDConfigurationOptions *a = (struct tt__OSDConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDConfigurationOptions(struct soap *soap, const struct tt__OSDConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDConfigurationOptions(soap, tag ? tag : "tt:OSDConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptions * SOAP_FMAC4 soap_get_tt__OSDConfigurationOptions(struct soap *soap, struct tt__OSDConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MaximumNumberOfOSDs(struct soap *soap, struct tt__MaximumNumberOfOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Total);
	a->Image = NULL;
	a->PlainText = NULL;
	a->Date = NULL;
	a->Time = NULL;
	a->DateAndTime = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MaximumNumberOfOSDs(struct soap *soap, const struct tt__MaximumNumberOfOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MaximumNumberOfOSDs(struct soap *soap, const char *tag, int id, const struct tt__MaximumNumberOfOSDs *a, const char *type)
{
	soap_set_attr(soap, "Total", soap_int2s(soap, a->Total), 1);
	if (a->Image)
	{	soap_set_attr(soap, "Image", soap_int2s(soap, *a->Image), 1);
	}
	if (a->PlainText)
	{	soap_set_attr(soap, "PlainText", soap_int2s(soap, *a->PlainText), 1);
	}
	if (a->Date)
	{	soap_set_attr(soap, "Date", soap_int2s(soap, *a->Date), 1);
	}
	if (a->Time)
	{	soap_set_attr(soap, "Time", soap_int2s(soap, *a->Time), 1);
	}
	if (a->DateAndTime)
	{	soap_set_attr(soap, "DateAndTime", soap_int2s(soap, *a->DateAndTime), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MaximumNumberOfOSDs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MaximumNumberOfOSDs * SOAP_FMAC4 soap_in_tt__MaximumNumberOfOSDs(struct soap *soap, const char *tag, struct tt__MaximumNumberOfOSDs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MaximumNumberOfOSDs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(struct tt__MaximumNumberOfOSDs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MaximumNumberOfOSDs(soap, a);
	if (soap_s2int(soap, soap_attr_value(soap, "Total", 5, 1), &a->Total))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "Image", 5, 0);
		if (t)
		{
			if (!(a->Image = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Image))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PlainText", 5, 0);
		if (t)
		{
			if (!(a->PlainText = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->PlainText))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Date", 5, 0);
		if (t)
		{
			if (!(a->Date = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Date))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Time", 5, 0);
		if (t)
		{
			if (!(a->Time = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Time))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DateAndTime", 5, 0);
		if (t)
		{
			if (!(a->DateAndTime = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->DateAndTime))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MaximumNumberOfOSDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MaximumNumberOfOSDs, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(struct tt__MaximumNumberOfOSDs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MaximumNumberOfOSDs * SOAP_FMAC4 soap_new_tt__MaximumNumberOfOSDs(struct soap *soap, int n)
{
	struct tt__MaximumNumberOfOSDs *p;
	struct tt__MaximumNumberOfOSDs *a = (struct tt__MaximumNumberOfOSDs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MaximumNumberOfOSDs));
	for (p = a; p && n--; p++)
		soap_default_tt__MaximumNumberOfOSDs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MaximumNumberOfOSDs(struct soap *soap, const struct tt__MaximumNumberOfOSDs *a, const char *tag, const char *type)
{
	if (soap_out_tt__MaximumNumberOfOSDs(soap, tag ? tag : "tt:MaximumNumberOfOSDs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MaximumNumberOfOSDs * SOAP_FMAC4 soap_get_tt__MaximumNumberOfOSDs(struct soap *soap, struct tt__MaximumNumberOfOSDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MaximumNumberOfOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDConfigurationExtension(struct soap *soap, struct tt__OSDConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDConfigurationExtension(struct soap *soap, const struct tt__OSDConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDConfigurationExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(struct tt__OSDConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDConfigurationExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationExtension, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(struct tt__OSDConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDConfigurationExtension * SOAP_FMAC4 soap_new_tt__OSDConfigurationExtension(struct soap *soap, int n)
{
	struct tt__OSDConfigurationExtension *p;
	struct tt__OSDConfigurationExtension *a = (struct tt__OSDConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDConfigurationExtension(struct soap *soap, const struct tt__OSDConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDConfigurationExtension(soap, tag ? tag : "tt:OSDConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDConfigurationExtension(struct soap *soap, struct tt__OSDConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDImgOptionsExtension(struct soap *soap, struct tt__OSDImgOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDImgOptionsExtension(struct soap *soap, const struct tt__OSDImgOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDImgOptionsExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDImgOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDImgOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDImgOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDImgOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(struct tt__OSDImgOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDImgOptionsExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgOptionsExtension, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(struct tt__OSDImgOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDImgOptionsExtension * SOAP_FMAC4 soap_new_tt__OSDImgOptionsExtension(struct soap *soap, int n)
{
	struct tt__OSDImgOptionsExtension *p;
	struct tt__OSDImgOptionsExtension *a = (struct tt__OSDImgOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDImgOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDImgOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDImgOptionsExtension(struct soap *soap, const struct tt__OSDImgOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDImgOptionsExtension(soap, tag ? tag : "tt:OSDImgOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDImgOptionsExtension(struct soap *soap, struct tt__OSDImgOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDImgOptions(struct soap *soap, struct tt__OSDImgOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeImagePath = 0;
	a->ImagePath = NULL;
	a->Extension = NULL;
	soap_default_tt__StringAttrList(soap, &a->FormatsSupported);
	a->MaxSize = NULL;
	a->MaxWidth = NULL;
	a->MaxHeight = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDImgOptions(struct soap *soap, const struct tt__OSDImgOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ImagePath)
	{	int i;
		for (i = 0; i < (int)a->__sizeImagePath; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ImagePath + i));
		}
	}
	soap_serialize_PointerTott__OSDImgOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgOptions(struct soap *soap, const char *tag, int id, const struct tt__OSDImgOptions *a, const char *type)
{
	if (a->FormatsSupported)
		soap_set_attr(soap, "FormatsSupported", soap_tt__StringAttrList2s(soap, a->FormatsSupported), 1);
	if (a->MaxSize)
	{	soap_set_attr(soap, "MaxSize", soap_int2s(soap, *a->MaxSize), 1);
	}
	if (a->MaxWidth)
	{	soap_set_attr(soap, "MaxWidth", soap_int2s(soap, *a->MaxWidth), 1);
	}
	if (a->MaxHeight)
	{	soap_set_attr(soap, "MaxHeight", soap_int2s(soap, *a->MaxHeight), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgOptions), type))
		return soap->error;
	if (a->ImagePath)
	{	int i;
		for (i = 0; i < (int)a->__sizeImagePath; i++)
			if (soap_out_string(soap, "tt:ImagePath", -1, (char*const*)(a->ImagePath + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__OSDImgOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDImgOptions * SOAP_FMAC4 soap_in_tt__OSDImgOptions(struct soap *soap, const char *tag, struct tt__OSDImgOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ImagePath = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDImgOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgOptions, sizeof(struct tt__OSDImgOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDImgOptions(soap, a);
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "FormatsSupported", 1, 0), &a->FormatsSupported))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "MaxSize", 5, 0);
		if (t)
		{
			if (!(a->MaxSize = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxSize))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxWidth", 5, 0);
		if (t)
		{
			if (!(a->MaxWidth = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxWidth))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxHeight", 5, 0);
		if (t)
		{
			if (!(a->MaxHeight = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxHeight))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ImagePath", 1, NULL))
			{	if (a->ImagePath == NULL)
				{	if (soap_blist_ImagePath == NULL)
						soap_blist_ImagePath = soap_alloc_block(soap);
					a->ImagePath = (char **)soap_push_block_max(soap, soap_blist_ImagePath, sizeof(char *));
					if (a->ImagePath == NULL)
						return NULL;
					*a->ImagePath = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tt:ImagePath", (char**)a->ImagePath, "xsd:anyURI"))
				{	a->__sizeImagePath++;
					a->ImagePath = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:OSDImgOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ImagePath)
			soap_pop_block(soap, soap_blist_ImagePath);
		if (a->__sizeImagePath)
		{	a->ImagePath = (char **)soap_save_block(soap, soap_blist_ImagePath, NULL, 1);
		}
		else
		{	a->ImagePath = NULL;
			if (soap_blist_ImagePath)
				soap_end_block(soap, soap_blist_ImagePath);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeImagePath < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDImgOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgOptions, SOAP_TYPE_tt__OSDImgOptions, sizeof(struct tt__OSDImgOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDImgOptions * SOAP_FMAC4 soap_new_tt__OSDImgOptions(struct soap *soap, int n)
{
	struct tt__OSDImgOptions *p;
	struct tt__OSDImgOptions *a = (struct tt__OSDImgOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDImgOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDImgOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDImgOptions(struct soap *soap, const struct tt__OSDImgOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDImgOptions(soap, tag ? tag : "tt:OSDImgOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgOptions * SOAP_FMAC4 soap_get_tt__OSDImgOptions(struct soap *soap, struct tt__OSDImgOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDTextOptionsExtension(struct soap *soap, struct tt__OSDTextOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDTextOptionsExtension(struct soap *soap, const struct tt__OSDTextOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDTextOptionsExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDTextOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDTextOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDTextOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDTextOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(struct tt__OSDTextOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDTextOptionsExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextOptionsExtension, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(struct tt__OSDTextOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDTextOptionsExtension * SOAP_FMAC4 soap_new_tt__OSDTextOptionsExtension(struct soap *soap, int n)
{
	struct tt__OSDTextOptionsExtension *p;
	struct tt__OSDTextOptionsExtension *a = (struct tt__OSDTextOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDTextOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDTextOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDTextOptionsExtension(struct soap *soap, const struct tt__OSDTextOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDTextOptionsExtension(soap, tag ? tag : "tt:OSDTextOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDTextOptionsExtension(struct soap *soap, struct tt__OSDTextOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDTextOptions(struct soap *soap, struct tt__OSDTextOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeType = 0;
	a->Type = NULL;
	a->FontSizeRange = NULL;
	a->__sizeDateFormat = 0;
	a->DateFormat = NULL;
	a->__sizeTimeFormat = 0;
	a->TimeFormat = NULL;
	a->FontColor = NULL;
	a->BackgroundColor = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDTextOptions(struct soap *soap, const struct tt__OSDTextOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Type)
	{	int i;
		for (i = 0; i < (int)a->__sizeType; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->Type + i));
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->FontSizeRange);
	if (a->DateFormat)
	{	int i;
		for (i = 0; i < (int)a->__sizeDateFormat; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->DateFormat + i));
		}
	}
	if (a->TimeFormat)
	{	int i;
		for (i = 0; i < (int)a->__sizeTimeFormat; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->TimeFormat + i));
		}
	}
	soap_serialize_PointerTott__OSDColorOptions(soap, &a->FontColor);
	soap_serialize_PointerTott__OSDColorOptions(soap, &a->BackgroundColor);
	soap_serialize_PointerTott__OSDTextOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextOptions(struct soap *soap, const char *tag, int id, const struct tt__OSDTextOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextOptions), type))
		return soap->error;
	if (a->Type)
	{	int i;
		for (i = 0; i < (int)a->__sizeType; i++)
			if (soap_out_string(soap, "tt:Type", -1, (char*const*)(a->Type + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IntRange(soap, "tt:FontSizeRange", -1, &a->FontSizeRange, ""))
		return soap->error;
	if (a->DateFormat)
	{	int i;
		for (i = 0; i < (int)a->__sizeDateFormat; i++)
			if (soap_out_string(soap, "tt:DateFormat", -1, (char*const*)(a->DateFormat + i), ""))
				return soap->error;
	}
	if (a->TimeFormat)
	{	int i;
		for (i = 0; i < (int)a->__sizeTimeFormat; i++)
			if (soap_out_string(soap, "tt:TimeFormat", -1, (char*const*)(a->TimeFormat + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__OSDColorOptions(soap, "tt:FontColor", -1, &a->FontColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColorOptions(soap, "tt:BackgroundColor", -1, &a->BackgroundColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDTextOptions * SOAP_FMAC4 soap_in_tt__OSDTextOptions(struct soap *soap, const char *tag, struct tt__OSDTextOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Type = NULL;
	size_t soap_flag_FontSizeRange = 1;
	struct soap_blist *soap_blist_DateFormat = NULL;
	struct soap_blist *soap_blist_TimeFormat = NULL;
	size_t soap_flag_FontColor = 1;
	size_t soap_flag_BackgroundColor = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDTextOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextOptions, sizeof(struct tt__OSDTextOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDTextOptions(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Type", 1, NULL))
			{	if (a->Type == NULL)
				{	if (soap_blist_Type == NULL)
						soap_blist_Type = soap_alloc_block(soap);
					a->Type = (char **)soap_push_block_max(soap, soap_blist_Type, sizeof(char *));
					if (a->Type == NULL)
						return NULL;
					*a->Type = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:Type", (char**)a->Type, "xsd:string"))
				{	a->__sizeType++;
					a->Type = NULL;
					continue;
				}
			}
			if (soap_flag_FontSizeRange && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FontSizeRange", &a->FontSizeRange, "tt:IntRange"))
				{	soap_flag_FontSizeRange--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DateFormat", 1, NULL))
			{	if (a->DateFormat == NULL)
				{	if (soap_blist_DateFormat == NULL)
						soap_blist_DateFormat = soap_alloc_block(soap);
					a->DateFormat = (char **)soap_push_block_max(soap, soap_blist_DateFormat, sizeof(char *));
					if (a->DateFormat == NULL)
						return NULL;
					*a->DateFormat = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:DateFormat", (char**)a->DateFormat, "xsd:string"))
				{	a->__sizeDateFormat++;
					a->DateFormat = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:TimeFormat", 1, NULL))
			{	if (a->TimeFormat == NULL)
				{	if (soap_blist_TimeFormat == NULL)
						soap_blist_TimeFormat = soap_alloc_block(soap);
					a->TimeFormat = (char **)soap_push_block_max(soap, soap_blist_TimeFormat, sizeof(char *));
					if (a->TimeFormat == NULL)
						return NULL;
					*a->TimeFormat = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:TimeFormat", (char**)a->TimeFormat, "xsd:string"))
				{	a->__sizeTimeFormat++;
					a->TimeFormat = NULL;
					continue;
				}
			}
			if (soap_flag_FontColor && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColorOptions(soap, "tt:FontColor", &a->FontColor, "tt:OSDColorOptions"))
				{	soap_flag_FontColor--;
					continue;
				}
			}
			if (soap_flag_BackgroundColor && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColorOptions(soap, "tt:BackgroundColor", &a->BackgroundColor, "tt:OSDColorOptions"))
				{	soap_flag_BackgroundColor--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:OSDTextOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Type)
			soap_pop_block(soap, soap_blist_Type);
		if (a->__sizeType)
		{	a->Type = (char **)soap_save_block(soap, soap_blist_Type, NULL, 1);
		}
		else
		{	a->Type = NULL;
			if (soap_blist_Type)
				soap_end_block(soap, soap_blist_Type);
		}
		if (a->DateFormat)
			soap_pop_block(soap, soap_blist_DateFormat);
		if (a->__sizeDateFormat)
		{	a->DateFormat = (char **)soap_save_block(soap, soap_blist_DateFormat, NULL, 1);
		}
		else
		{	a->DateFormat = NULL;
			if (soap_blist_DateFormat)
				soap_end_block(soap, soap_blist_DateFormat);
		}
		if (a->TimeFormat)
			soap_pop_block(soap, soap_blist_TimeFormat);
		if (a->__sizeTimeFormat)
		{	a->TimeFormat = (char **)soap_save_block(soap, soap_blist_TimeFormat, NULL, 1);
		}
		else
		{	a->TimeFormat = NULL;
			if (soap_blist_TimeFormat)
				soap_end_block(soap, soap_blist_TimeFormat);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeType < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDTextOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextOptions, SOAP_TYPE_tt__OSDTextOptions, sizeof(struct tt__OSDTextOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDTextOptions * SOAP_FMAC4 soap_new_tt__OSDTextOptions(struct soap *soap, int n)
{
	struct tt__OSDTextOptions *p;
	struct tt__OSDTextOptions *a = (struct tt__OSDTextOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDTextOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDTextOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDTextOptions(struct soap *soap, const struct tt__OSDTextOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDTextOptions(soap, tag ? tag : "tt:OSDTextOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextOptions * SOAP_FMAC4 soap_get_tt__OSDTextOptions(struct soap *soap, struct tt__OSDTextOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDColorOptionsExtension(struct soap *soap, struct tt__OSDColorOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDColorOptionsExtension(struct soap *soap, const struct tt__OSDColorOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColorOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDColorOptionsExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColorOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDColorOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDColorOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDColorOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(struct tt__OSDColorOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDColorOptionsExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDColorOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColorOptionsExtension, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(struct tt__OSDColorOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_new_tt__OSDColorOptionsExtension(struct soap *soap, int n)
{
	struct tt__OSDColorOptionsExtension *p;
	struct tt__OSDColorOptionsExtension *a = (struct tt__OSDColorOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDColorOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDColorOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDColorOptionsExtension(struct soap *soap, const struct tt__OSDColorOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDColorOptionsExtension(soap, tag ? tag : "tt:OSDColorOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDColorOptionsExtension(struct soap *soap, struct tt__OSDColorOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColorOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDColorOptions(struct soap *soap, struct tt__OSDColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Transparent = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDColorOptions(struct soap *soap, const struct tt__OSDColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ColorOptions(soap, &a->Color);
	soap_serialize_PointerTott__IntRange(soap, &a->Transparent);
	soap_serialize_PointerTott__OSDColorOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColorOptions(struct soap *soap, const char *tag, int id, const struct tt__OSDColorOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColorOptions), type))
		return soap->error;
	if (soap_out_PointerTott__ColorOptions(soap, "tt:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:Transparent", -1, &a->Transparent, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColorOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDColorOptions * SOAP_FMAC4 soap_in_tt__OSDColorOptions(struct soap *soap, const char *tag, struct tt__OSDColorOptions *a, const char *type)
{
	size_t soap_flag_Color = 1;
	size_t soap_flag_Transparent = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDColorOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColorOptions, sizeof(struct tt__OSDColorOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDColorOptions(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorOptions(soap, "tt:Color", &a->Color, "tt:ColorOptions"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap_flag_Transparent && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:Transparent", &a->Transparent, "tt:IntRange"))
				{	soap_flag_Transparent--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColorOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:OSDColorOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDColorOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColorOptions, SOAP_TYPE_tt__OSDColorOptions, sizeof(struct tt__OSDColorOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDColorOptions * SOAP_FMAC4 soap_new_tt__OSDColorOptions(struct soap *soap, int n)
{
	struct tt__OSDColorOptions *p;
	struct tt__OSDColorOptions *a = (struct tt__OSDColorOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDColorOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDColorOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDColorOptions(struct soap *soap, const struct tt__OSDColorOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDColorOptions(soap, tag ? tag : "tt:OSDColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColorOptions * SOAP_FMAC4 soap_get_tt__OSDColorOptions(struct soap *soap, struct tt__OSDColorOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorOptions(struct soap *soap, struct tt__ColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeColorList = 0;
	a->ColorList = NULL;
	a->__sizeColorspaceRange = 0;
	a->ColorspaceRange = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorOptions(struct soap *soap, const struct tt__ColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ColorList)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorList; i++)
		{
			soap_embedded(soap, a->ColorList + i, SOAP_TYPE_tt__Color);
			soap_serialize_tt__Color(soap, a->ColorList + i);
		}
	}
	if (a->ColorspaceRange)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorspaceRange; i++)
		{
			soap_embedded(soap, a->ColorspaceRange + i, SOAP_TYPE_tt__ColorspaceRange);
			soap_serialize_tt__ColorspaceRange(soap, a->ColorspaceRange + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorOptions(struct soap *soap, const char *tag, int id, const struct tt__ColorOptions *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorOptions), type))
		return soap->error;
	if (a->ColorList)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorList; i++)
			if (soap_out_tt__Color(soap, "tt:ColorList", -1, a->ColorList + i, ""))
				return soap->error;
	}
	if (a->ColorspaceRange)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorspaceRange; i++)
			if (soap_out_tt__ColorspaceRange(soap, "tt:ColorspaceRange", -1, a->ColorspaceRange + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorOptions * SOAP_FMAC4 soap_in_tt__ColorOptions(struct soap *soap, const char *tag, struct tt__ColorOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ColorList = NULL;
	struct soap_blist *soap_blist_ColorspaceRange = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ColorOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorOptions, sizeof(struct tt__ColorOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorOptions(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ColorList", 1, NULL))
			{	if (a->ColorList == NULL)
				{	if (soap_blist_ColorList == NULL)
						soap_blist_ColorList = soap_alloc_block(soap);
					a->ColorList = (struct tt__Color *)soap_push_block_max(soap, soap_blist_ColorList, sizeof(struct tt__Color));
					if (a->ColorList == NULL)
						return NULL;
					soap_default_tt__Color(soap, a->ColorList);
				}
				soap_revert(soap);
				if (soap_in_tt__Color(soap, "tt:ColorList", a->ColorList, "tt:Color"))
				{	a->__sizeColorList++;
					a->ColorList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ColorspaceRange", 1, NULL))
			{	if (a->ColorspaceRange == NULL)
				{	if (soap_blist_ColorspaceRange == NULL)
						soap_blist_ColorspaceRange = soap_alloc_block(soap);
					a->ColorspaceRange = (struct tt__ColorspaceRange *)soap_push_block_max(soap, soap_blist_ColorspaceRange, sizeof(struct tt__ColorspaceRange));
					if (a->ColorspaceRange == NULL)
						return NULL;
					soap_default_tt__ColorspaceRange(soap, a->ColorspaceRange);
				}
				soap_revert(soap);
				if (soap_in_tt__ColorspaceRange(soap, "tt:ColorspaceRange", a->ColorspaceRange, "tt:ColorspaceRange"))
				{	a->__sizeColorspaceRange++;
					a->ColorspaceRange = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ColorList)
			soap_pop_block(soap, soap_blist_ColorList);
		if (a->__sizeColorList)
		{	a->ColorList = (struct tt__Color *)soap_save_block(soap, soap_blist_ColorList, NULL, 1);
		}
		else
		{	a->ColorList = NULL;
			if (soap_blist_ColorList)
				soap_end_block(soap, soap_blist_ColorList);
		}
		if (a->ColorspaceRange)
			soap_pop_block(soap, soap_blist_ColorspaceRange);
		if (a->__sizeColorspaceRange)
		{	a->ColorspaceRange = (struct tt__ColorspaceRange *)soap_save_block(soap, soap_blist_ColorspaceRange, NULL, 1);
		}
		else
		{	a->ColorspaceRange = NULL;
			if (soap_blist_ColorspaceRange)
				soap_end_block(soap, soap_blist_ColorspaceRange);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ColorOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorOptions, SOAP_TYPE_tt__ColorOptions, sizeof(struct tt__ColorOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ColorOptions * SOAP_FMAC4 soap_new_tt__ColorOptions(struct soap *soap, int n)
{
	struct tt__ColorOptions *p;
	struct tt__ColorOptions *a = (struct tt__ColorOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ColorOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__ColorOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorOptions(struct soap *soap, const struct tt__ColorOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__ColorOptions(soap, tag ? tag : "tt:ColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorOptions * SOAP_FMAC4 soap_get_tt__ColorOptions(struct soap *soap, struct tt__ColorOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorspaceRange(struct soap *soap, struct tt__ColorspaceRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X = NULL;
	a->Y = NULL;
	a->Z = NULL;
	soap_default_xsd__anyURI(soap, &a->Colorspace);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorspaceRange(struct soap *soap, const struct tt__ColorspaceRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &a->X);
	soap_serialize_PointerTott__FloatRange(soap, &a->Y);
	soap_serialize_PointerTott__FloatRange(soap, &a->Z);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Colorspace);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorspaceRange(struct soap *soap, const char *tag, int id, const struct tt__ColorspaceRange *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorspaceRange), type))
		return soap->error;
	if (!a->X)
	{	if (soap_element_empty(soap, "tt:X", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:X", -1, &a->X, ""))
		return soap->error;
	if (!a->Y)
	{	if (soap_element_empty(soap, "tt:Y", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Y", -1, &a->Y, ""))
		return soap->error;
	if (!a->Z)
	{	if (soap_element_empty(soap, "tt:Z", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Z", -1, &a->Z, ""))
		return soap->error;
	if (!a->Colorspace)
	{	if (soap_element_empty(soap, "tt:Colorspace", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:Colorspace", -1, (char*const*)&a->Colorspace, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorspaceRange * SOAP_FMAC4 soap_in_tt__ColorspaceRange(struct soap *soap, const char *tag, struct tt__ColorspaceRange *a, const char *type)
{
	size_t soap_flag_X = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_Z = 1;
	size_t soap_flag_Colorspace = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ColorspaceRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorspaceRange, sizeof(struct tt__ColorspaceRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorspaceRange(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:X", &a->X, "tt:FloatRange"))
				{	soap_flag_X--;
					continue;
				}
			}
			if (soap_flag_Y && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Y", &a->Y, "tt:FloatRange"))
				{	soap_flag_Y--;
					continue;
				}
			}
			if (soap_flag_Z && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Z", &a->Z, "tt:FloatRange"))
				{	soap_flag_Z--;
					continue;
				}
			}
			if (soap_flag_Colorspace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Colorspace", (char**)&a->Colorspace, "xsd:anyURI"))
				{	soap_flag_Colorspace--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->X || !a->Y || !a->Z || !a->Colorspace))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ColorspaceRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorspaceRange, SOAP_TYPE_tt__ColorspaceRange, sizeof(struct tt__ColorspaceRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ColorspaceRange * SOAP_FMAC4 soap_new_tt__ColorspaceRange(struct soap *soap, int n)
{
	struct tt__ColorspaceRange *p;
	struct tt__ColorspaceRange *a = (struct tt__ColorspaceRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ColorspaceRange));
	for (p = a; p && n--; p++)
		soap_default_tt__ColorspaceRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorspaceRange(struct soap *soap, const struct tt__ColorspaceRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__ColorspaceRange(soap, tag ? tag : "tt:ColorspaceRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorspaceRange * SOAP_FMAC4 soap_get_tt__ColorspaceRange(struct soap *soap, struct tt__ColorspaceRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorspaceRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDImgConfigurationExtension(struct soap *soap, struct tt__OSDImgConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDImgConfigurationExtension(struct soap *soap, const struct tt__OSDImgConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDImgConfigurationExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDImgConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDImgConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDImgConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(struct tt__OSDImgConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDImgConfigurationExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgConfigurationExtension, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(struct tt__OSDImgConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_new_tt__OSDImgConfigurationExtension(struct soap *soap, int n)
{
	struct tt__OSDImgConfigurationExtension *p;
	struct tt__OSDImgConfigurationExtension *a = (struct tt__OSDImgConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDImgConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDImgConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDImgConfigurationExtension(struct soap *soap, const struct tt__OSDImgConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDImgConfigurationExtension(soap, tag ? tag : "tt:OSDImgConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDImgConfigurationExtension(struct soap *soap, struct tt__OSDImgConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDImgConfiguration(struct soap *soap, struct tt__OSDImgConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->ImgPath);
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDImgConfiguration(struct soap *soap, const struct tt__OSDImgConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->ImgPath);
	soap_serialize_PointerTott__OSDImgConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgConfiguration(struct soap *soap, const char *tag, int id, const struct tt__OSDImgConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgConfiguration), type))
		return soap->error;
	if (!a->ImgPath)
	{	if (soap_element_empty(soap, "tt:ImgPath", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:ImgPath", -1, (char*const*)&a->ImgPath, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDImgConfiguration * SOAP_FMAC4 soap_in_tt__OSDImgConfiguration(struct soap *soap, const char *tag, struct tt__OSDImgConfiguration *a, const char *type)
{
	size_t soap_flag_ImgPath = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDImgConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(struct tt__OSDImgConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDImgConfiguration(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImgPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:ImgPath", (char**)&a->ImgPath, "xsd:anyURI"))
				{	soap_flag_ImgPath--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:OSDImgConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ImgPath))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDImgConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgConfiguration, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(struct tt__OSDImgConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDImgConfiguration * SOAP_FMAC4 soap_new_tt__OSDImgConfiguration(struct soap *soap, int n)
{
	struct tt__OSDImgConfiguration *p;
	struct tt__OSDImgConfiguration *a = (struct tt__OSDImgConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDImgConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDImgConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDImgConfiguration(struct soap *soap, const struct tt__OSDImgConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDImgConfiguration(soap, tag ? tag : "tt:OSDImgConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgConfiguration * SOAP_FMAC4 soap_get_tt__OSDImgConfiguration(struct soap *soap, struct tt__OSDImgConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDTextConfigurationExtension(struct soap *soap, struct tt__OSDTextConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDTextConfigurationExtension(struct soap *soap, const struct tt__OSDTextConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDTextConfigurationExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDTextConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDTextConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDTextConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(struct tt__OSDTextConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDTextConfigurationExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextConfigurationExtension, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(struct tt__OSDTextConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_new_tt__OSDTextConfigurationExtension(struct soap *soap, int n)
{
	struct tt__OSDTextConfigurationExtension *p;
	struct tt__OSDTextConfigurationExtension *a = (struct tt__OSDTextConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDTextConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDTextConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDTextConfigurationExtension(struct soap *soap, const struct tt__OSDTextConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDTextConfigurationExtension(soap, tag ? tag : "tt:OSDTextConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDTextConfigurationExtension(struct soap *soap, struct tt__OSDTextConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDTextConfiguration(struct soap *soap, struct tt__OSDTextConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->DateFormat);
	soap_default_string(soap, &a->TimeFormat);
	a->FontSize = NULL;
	a->FontColor = NULL;
	a->BackgroundColor = NULL;
	soap_default_string(soap, &a->PlainText);
	a->Extension = NULL;
	a->IsPersistentText = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDTextConfiguration(struct soap *soap, const struct tt__OSDTextConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Type);
	soap_serialize_string(soap, (char*const*)&a->DateFormat);
	soap_serialize_string(soap, (char*const*)&a->TimeFormat);
	soap_serialize_PointerToint(soap, &a->FontSize);
	soap_serialize_PointerTott__OSDColor(soap, &a->FontColor);
	soap_serialize_PointerTott__OSDColor(soap, &a->BackgroundColor);
	soap_serialize_string(soap, (char*const*)&a->PlainText);
	soap_serialize_PointerTott__OSDTextConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextConfiguration(struct soap *soap, const char *tag, int id, const struct tt__OSDTextConfiguration *a, const char *type)
{
	if (a->IsPersistentText)
	{	soap_set_attr(soap, "IsPersistentText", soap_xsd__boolean2s(soap, *a->IsPersistentText), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextConfiguration), type))
		return soap->error;
	if (!a->Type)
	{	if (soap_element_empty(soap, "tt:Type", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Type", -1, (char*const*)&a->Type, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:DateFormat", -1, (char*const*)&a->DateFormat, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:TimeFormat", -1, (char*const*)&a->TimeFormat, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:FontSize", -1, &a->FontSize, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColor(soap, "tt:FontColor", -1, &a->FontColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColor(soap, "tt:BackgroundColor", -1, &a->BackgroundColor, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:PlainText", -1, (char*const*)&a->PlainText, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDTextConfiguration * SOAP_FMAC4 soap_in_tt__OSDTextConfiguration(struct soap *soap, const char *tag, struct tt__OSDTextConfiguration *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_DateFormat = 1;
	size_t soap_flag_TimeFormat = 1;
	size_t soap_flag_FontSize = 1;
	size_t soap_flag_FontColor = 1;
	size_t soap_flag_BackgroundColor = 1;
	size_t soap_flag_PlainText = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDTextConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(struct tt__OSDTextConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDTextConfiguration(soap, a);
	{
		const char *t = soap_attr_value(soap, "IsPersistentText", 5, 0);
		if (t)
		{
			if (!(a->IsPersistentText = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->IsPersistentText))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Type", (char**)&a->Type, "xsd:string"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_DateFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:DateFormat", (char**)&a->DateFormat, "xsd:string"))
				{	soap_flag_DateFormat--;
					continue;
				}
			}
			if (soap_flag_TimeFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:TimeFormat", (char**)&a->TimeFormat, "xsd:string"))
				{	soap_flag_TimeFormat--;
					continue;
				}
			}
			if (soap_flag_FontSize && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:FontSize", &a->FontSize, "xsd:int"))
				{	soap_flag_FontSize--;
					continue;
				}
			}
			if (soap_flag_FontColor && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColor(soap, "tt:FontColor", &a->FontColor, "tt:OSDColor"))
				{	soap_flag_FontColor--;
					continue;
				}
			}
			if (soap_flag_BackgroundColor && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColor(soap, "tt:BackgroundColor", &a->BackgroundColor, "tt:OSDColor"))
				{	soap_flag_BackgroundColor--;
					continue;
				}
			}
			if (soap_flag_PlainText && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:PlainText", (char**)&a->PlainText, "xsd:string"))
				{	soap_flag_PlainText--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:OSDTextConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Type))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDTextConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextConfiguration, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(struct tt__OSDTextConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDTextConfiguration * SOAP_FMAC4 soap_new_tt__OSDTextConfiguration(struct soap *soap, int n)
{
	struct tt__OSDTextConfiguration *p;
	struct tt__OSDTextConfiguration *a = (struct tt__OSDTextConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDTextConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDTextConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDTextConfiguration(struct soap *soap, const struct tt__OSDTextConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDTextConfiguration(soap, tag ? tag : "tt:OSDTextConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextConfiguration * SOAP_FMAC4 soap_get_tt__OSDTextConfiguration(struct soap *soap, struct tt__OSDTextConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Color(struct soap *soap, struct tt__Color *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->X);
	soap_default_float(soap, &a->Y);
	soap_default_float(soap, &a->Z);
	soap_default_xsd__anyURI(soap, &a->Colorspace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Color(struct soap *soap, const struct tt__Color *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Color(struct soap *soap, const char *tag, int id, const struct tt__Color *a, const char *type)
{
	soap_set_attr(soap, "X", soap_float2s(soap, a->X), 1);
	soap_set_attr(soap, "Y", soap_float2s(soap, a->Y), 1);
	soap_set_attr(soap, "Z", soap_float2s(soap, a->Z), 1);
	if (a->Colorspace)
		soap_set_attr(soap, "Colorspace", soap_xsd__anyURI2s(soap, a->Colorspace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Color), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Color * SOAP_FMAC4 soap_in_tt__Color(struct soap *soap, const char *tag, struct tt__Color *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Color*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Color(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "X", 5, 1), &a->X))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Y", 5, 1), &a->Y))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Z", 5, 1), &a->Z))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Colorspace", 4, 0), &a->Colorspace))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Color *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Color, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Color * SOAP_FMAC4 soap_new_tt__Color(struct soap *soap, int n)
{
	struct tt__Color *p;
	struct tt__Color *a = (struct tt__Color*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Color));
	for (p = a; p && n--; p++)
		soap_default_tt__Color(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Color(struct soap *soap, const struct tt__Color *a, const char *tag, const char *type)
{
	if (soap_out_tt__Color(soap, tag ? tag : "tt:Color", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Color * SOAP_FMAC4 soap_get_tt__Color(struct soap *soap, struct tt__Color *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDColor(struct soap *soap, struct tt__OSDColor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Transparent = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDColor(struct soap *soap, const struct tt__OSDColor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Color(soap, &a->Color);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColor(struct soap *soap, const char *tag, int id, const struct tt__OSDColor *a, const char *type)
{
	if (a->Transparent)
	{	soap_set_attr(soap, "Transparent", soap_int2s(soap, *a->Transparent), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColor), type))
		return soap->error;
	if (!a->Color)
	{	if (soap_element_empty(soap, "tt:Color", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Color(soap, "tt:Color", -1, &a->Color, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDColor * SOAP_FMAC4 soap_in_tt__OSDColor(struct soap *soap, const char *tag, struct tt__OSDColor *a, const char *type)
{
	size_t soap_flag_Color = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDColor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColor, sizeof(struct tt__OSDColor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDColor(soap, a);
	{
		const char *t = soap_attr_value(soap, "Transparent", 5, 0);
		if (t)
		{
			if (!(a->Transparent = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Transparent))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Color(soap, "tt:Color", &a->Color, "tt:Color"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Color))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDColor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColor, SOAP_TYPE_tt__OSDColor, sizeof(struct tt__OSDColor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDColor * SOAP_FMAC4 soap_new_tt__OSDColor(struct soap *soap, int n)
{
	struct tt__OSDColor *p;
	struct tt__OSDColor *a = (struct tt__OSDColor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDColor));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDColor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDColor(struct soap *soap, const struct tt__OSDColor *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDColor(soap, tag ? tag : "tt:OSDColor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColor * SOAP_FMAC4 soap_get_tt__OSDColor(struct soap *soap, struct tt__OSDColor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDPosConfigurationExtension(struct soap *soap, struct tt__OSDPosConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDPosConfigurationExtension(struct soap *soap, const struct tt__OSDPosConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDPosConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDPosConfigurationExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDPosConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDPosConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDPosConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDPosConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(struct tt__OSDPosConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDPosConfigurationExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDPosConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDPosConfigurationExtension, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(struct tt__OSDPosConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_new_tt__OSDPosConfigurationExtension(struct soap *soap, int n)
{
	struct tt__OSDPosConfigurationExtension *p;
	struct tt__OSDPosConfigurationExtension *a = (struct tt__OSDPosConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDPosConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDPosConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDPosConfigurationExtension(struct soap *soap, const struct tt__OSDPosConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDPosConfigurationExtension(soap, tag ? tag : "tt:OSDPosConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDPosConfigurationExtension(struct soap *soap, struct tt__OSDPosConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDPosConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDPosConfiguration(struct soap *soap, struct tt__OSDPosConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Type);
	a->Pos = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDPosConfiguration(struct soap *soap, const struct tt__OSDPosConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Type);
	soap_serialize_PointerTott__Vector(soap, &a->Pos);
	soap_serialize_PointerTott__OSDPosConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDPosConfiguration(struct soap *soap, const char *tag, int id, const struct tt__OSDPosConfiguration *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDPosConfiguration), type))
		return soap->error;
	if (!a->Type)
	{	if (soap_element_empty(soap, "tt:Type", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Type", -1, (char*const*)&a->Type, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Pos", -1, &a->Pos, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDPosConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDPosConfiguration * SOAP_FMAC4 soap_in_tt__OSDPosConfiguration(struct soap *soap, const char *tag, struct tt__OSDPosConfiguration *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Pos = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OSDPosConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(struct tt__OSDPosConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDPosConfiguration(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Type", (char**)&a->Type, "xsd:string"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_Pos && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector(soap, "tt:Pos", &a->Pos, "tt:Vector"))
				{	soap_flag_Pos--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDPosConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:OSDPosConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Type))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDPosConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDPosConfiguration, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(struct tt__OSDPosConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDPosConfiguration * SOAP_FMAC4 soap_new_tt__OSDPosConfiguration(struct soap *soap, int n)
{
	struct tt__OSDPosConfiguration *p;
	struct tt__OSDPosConfiguration *a = (struct tt__OSDPosConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDPosConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDPosConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDPosConfiguration(struct soap *soap, const struct tt__OSDPosConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDPosConfiguration(soap, tag ? tag : "tt:OSDPosConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDPosConfiguration * SOAP_FMAC4 soap_get_tt__OSDPosConfiguration(struct soap *soap, struct tt__OSDPosConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDPosConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileStatusExtension(struct soap *soap, struct tt__ProfileStatusExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileStatusExtension(struct soap *soap, const struct tt__ProfileStatusExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileStatusExtension(struct soap *soap, const char *tag, int id, const struct tt__ProfileStatusExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileStatusExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileStatusExtension * SOAP_FMAC4 soap_in_tt__ProfileStatusExtension(struct soap *soap, const char *tag, struct tt__ProfileStatusExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ProfileStatusExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(struct tt__ProfileStatusExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileStatusExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileStatusExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileStatusExtension, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(struct tt__ProfileStatusExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ProfileStatusExtension * SOAP_FMAC4 soap_new_tt__ProfileStatusExtension(struct soap *soap, int n)
{
	struct tt__ProfileStatusExtension *p;
	struct tt__ProfileStatusExtension *a = (struct tt__ProfileStatusExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ProfileStatusExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ProfileStatusExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileStatusExtension(struct soap *soap, const struct tt__ProfileStatusExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ProfileStatusExtension(soap, tag ? tag : "tt:ProfileStatusExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileStatusExtension * SOAP_FMAC4 soap_get_tt__ProfileStatusExtension(struct soap *soap, struct tt__ProfileStatusExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileStatus(struct soap *soap, struct tt__ProfileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeActiveConnections = 0;
	a->ActiveConnections = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileStatus(struct soap *soap, const struct tt__ProfileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ActiveConnections)
	{	int i;
		for (i = 0; i < (int)a->__sizeActiveConnections; i++)
		{
			soap_embedded(soap, a->ActiveConnections + i, SOAP_TYPE_tt__ActiveConnection);
			soap_serialize_tt__ActiveConnection(soap, a->ActiveConnections + i);
		}
	}
	soap_serialize_PointerTott__ProfileStatusExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileStatus(struct soap *soap, const char *tag, int id, const struct tt__ProfileStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileStatus), type))
		return soap->error;
	if (a->ActiveConnections)
	{	int i;
		for (i = 0; i < (int)a->__sizeActiveConnections; i++)
			if (soap_out_tt__ActiveConnection(soap, "tt:ActiveConnections", -1, a->ActiveConnections + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ProfileStatusExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileStatus * SOAP_FMAC4 soap_in_tt__ProfileStatus(struct soap *soap, const char *tag, struct tt__ProfileStatus *a, const char *type)
{
	struct soap_blist *soap_blist_ActiveConnections = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ProfileStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileStatus, sizeof(struct tt__ProfileStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ActiveConnections", 1, NULL))
			{	if (a->ActiveConnections == NULL)
				{	if (soap_blist_ActiveConnections == NULL)
						soap_blist_ActiveConnections = soap_alloc_block(soap);
					a->ActiveConnections = (struct tt__ActiveConnection *)soap_push_block_max(soap, soap_blist_ActiveConnections, sizeof(struct tt__ActiveConnection));
					if (a->ActiveConnections == NULL)
						return NULL;
					soap_default_tt__ActiveConnection(soap, a->ActiveConnections);
				}
				soap_revert(soap);
				if (soap_in_tt__ActiveConnection(soap, "tt:ActiveConnections", a->ActiveConnections, "tt:ActiveConnection"))
				{	a->__sizeActiveConnections++;
					a->ActiveConnections = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ProfileStatusExtension(soap, "tt:Extension", &a->Extension, "tt:ProfileStatusExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ActiveConnections)
			soap_pop_block(soap, soap_blist_ActiveConnections);
		if (a->__sizeActiveConnections)
		{	a->ActiveConnections = (struct tt__ActiveConnection *)soap_save_block(soap, soap_blist_ActiveConnections, NULL, 1);
		}
		else
		{	a->ActiveConnections = NULL;
			if (soap_blist_ActiveConnections)
				soap_end_block(soap, soap_blist_ActiveConnections);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileStatus, SOAP_TYPE_tt__ProfileStatus, sizeof(struct tt__ProfileStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ProfileStatus * SOAP_FMAC4 soap_new_tt__ProfileStatus(struct soap *soap, int n)
{
	struct tt__ProfileStatus *p;
	struct tt__ProfileStatus *a = (struct tt__ProfileStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ProfileStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__ProfileStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileStatus(struct soap *soap, const struct tt__ProfileStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__ProfileStatus(soap, tag ? tag : "tt:ProfileStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileStatus * SOAP_FMAC4 soap_get_tt__ProfileStatus(struct soap *soap, struct tt__ProfileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ActiveConnection(struct soap *soap, struct tt__ActiveConnection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->CurrentBitrate);
	soap_default_float(soap, &a->CurrentFps);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ActiveConnection(struct soap *soap, const struct tt__ActiveConnection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->CurrentBitrate, SOAP_TYPE_float);
	soap_embedded(soap, &a->CurrentFps, SOAP_TYPE_float);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ActiveConnection(struct soap *soap, const char *tag, int id, const struct tt__ActiveConnection *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ActiveConnection), type))
		return soap->error;
	if (soap_out_float(soap, "tt:CurrentBitrate", -1, &a->CurrentBitrate, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CurrentFps", -1, &a->CurrentFps, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ActiveConnection * SOAP_FMAC4 soap_in_tt__ActiveConnection(struct soap *soap, const char *tag, struct tt__ActiveConnection *a, const char *type)
{
	size_t soap_flag_CurrentBitrate = 1;
	size_t soap_flag_CurrentFps = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ActiveConnection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActiveConnection, sizeof(struct tt__ActiveConnection), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ActiveConnection(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CurrentBitrate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:CurrentBitrate", &a->CurrentBitrate, "xsd:float"))
				{	soap_flag_CurrentBitrate--;
					continue;
				}
			}
			if (soap_flag_CurrentFps && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:CurrentFps", &a->CurrentFps, "xsd:float"))
				{	soap_flag_CurrentFps--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentBitrate > 0 || soap_flag_CurrentFps > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ActiveConnection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActiveConnection, SOAP_TYPE_tt__ActiveConnection, sizeof(struct tt__ActiveConnection), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ActiveConnection * SOAP_FMAC4 soap_new_tt__ActiveConnection(struct soap *soap, int n)
{
	struct tt__ActiveConnection *p;
	struct tt__ActiveConnection *a = (struct tt__ActiveConnection*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ActiveConnection));
	for (p = a; p && n--; p++)
		soap_default_tt__ActiveConnection(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ActiveConnection(struct soap *soap, const struct tt__ActiveConnection *a, const char *tag, const char *type)
{
	if (soap_out_tt__ActiveConnection(soap, tag ? tag : "tt:ActiveConnection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActiveConnection * SOAP_FMAC4 soap_get_tt__ActiveConnection(struct soap *soap, struct tt__ActiveConnection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ActiveConnection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioClassDescriptorExtension(struct soap *soap, struct tt__AudioClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioClassDescriptorExtension(struct soap *soap, const struct tt__AudioClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassDescriptorExtension(struct soap *soap, const char *tag, int id, const struct tt__AudioClassDescriptorExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassDescriptorExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension * SOAP_FMAC4 soap_in_tt__AudioClassDescriptorExtension(struct soap *soap, const char *tag, struct tt__AudioClassDescriptorExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioClassDescriptorExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(struct tt__AudioClassDescriptorExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioClassDescriptorExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioClassDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassDescriptorExtension, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(struct tt__AudioClassDescriptorExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension * SOAP_FMAC4 soap_new_tt__AudioClassDescriptorExtension(struct soap *soap, int n)
{
	struct tt__AudioClassDescriptorExtension *p;
	struct tt__AudioClassDescriptorExtension *a = (struct tt__AudioClassDescriptorExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioClassDescriptorExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioClassDescriptorExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassDescriptorExtension(struct soap *soap, const struct tt__AudioClassDescriptorExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassDescriptorExtension(soap, tag ? tag : "tt:AudioClassDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension * SOAP_FMAC4 soap_get_tt__AudioClassDescriptorExtension(struct soap *soap, struct tt__AudioClassDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioClassDescriptor(struct soap *soap, struct tt__AudioClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeClassCandidate = 0;
	a->ClassCandidate = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioClassDescriptor(struct soap *soap, const struct tt__AudioClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < (int)a->__sizeClassCandidate; i++)
		{
			soap_embedded(soap, a->ClassCandidate + i, SOAP_TYPE_tt__AudioClassCandidate);
			soap_serialize_tt__AudioClassCandidate(soap, a->ClassCandidate + i);
		}
	}
	soap_serialize_PointerTott__AudioClassDescriptorExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassDescriptor(struct soap *soap, const char *tag, int id, const struct tt__AudioClassDescriptor *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassDescriptor), type))
		return soap->error;
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < (int)a->__sizeClassCandidate; i++)
			if (soap_out_tt__AudioClassCandidate(soap, "tt:ClassCandidate", -1, a->ClassCandidate + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AudioClassDescriptorExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioClassDescriptor * SOAP_FMAC4 soap_in_tt__AudioClassDescriptor(struct soap *soap, const char *tag, struct tt__AudioClassDescriptor *a, const char *type)
{
	struct soap_blist *soap_blist_ClassCandidate = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioClassDescriptor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassDescriptor, sizeof(struct tt__AudioClassDescriptor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioClassDescriptor(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ClassCandidate", 1, NULL))
			{	if (a->ClassCandidate == NULL)
				{	if (soap_blist_ClassCandidate == NULL)
						soap_blist_ClassCandidate = soap_alloc_block(soap);
					a->ClassCandidate = (struct tt__AudioClassCandidate *)soap_push_block_max(soap, soap_blist_ClassCandidate, sizeof(struct tt__AudioClassCandidate));
					if (a->ClassCandidate == NULL)
						return NULL;
					soap_default_tt__AudioClassCandidate(soap, a->ClassCandidate);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioClassCandidate(soap, "tt:ClassCandidate", a->ClassCandidate, "tt:AudioClassCandidate"))
				{	a->__sizeClassCandidate++;
					a->ClassCandidate = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioClassDescriptorExtension(soap, "tt:Extension", &a->Extension, "tt:AudioClassDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ClassCandidate)
			soap_pop_block(soap, soap_blist_ClassCandidate);
		if (a->__sizeClassCandidate)
		{	a->ClassCandidate = (struct tt__AudioClassCandidate *)soap_save_block(soap, soap_blist_ClassCandidate, NULL, 1);
		}
		else
		{	a->ClassCandidate = NULL;
			if (soap_blist_ClassCandidate)
				soap_end_block(soap, soap_blist_ClassCandidate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioClassDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassDescriptor, SOAP_TYPE_tt__AudioClassDescriptor, sizeof(struct tt__AudioClassDescriptor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioClassDescriptor * SOAP_FMAC4 soap_new_tt__AudioClassDescriptor(struct soap *soap, int n)
{
	struct tt__AudioClassDescriptor *p;
	struct tt__AudioClassDescriptor *a = (struct tt__AudioClassDescriptor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioClassDescriptor));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioClassDescriptor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassDescriptor(struct soap *soap, const struct tt__AudioClassDescriptor *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassDescriptor(soap, tag ? tag : "tt:AudioClassDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassDescriptor * SOAP_FMAC4 soap_get_tt__AudioClassDescriptor(struct soap *soap, struct tt__AudioClassDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioClassCandidate(struct soap *soap, struct tt__AudioClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AudioClassType(soap, &a->Type);
	soap_default_float(soap, &a->Likelihood);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioClassCandidate(struct soap *soap, const struct tt__AudioClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__AudioClassType(soap, (char*const*)&a->Type);
	soap_embedded(soap, &a->Likelihood, SOAP_TYPE_float);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassCandidate(struct soap *soap, const char *tag, int id, const struct tt__AudioClassCandidate *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassCandidate), type))
		return soap->error;
	if (!a->Type)
	{	if (soap_element_empty(soap, "tt:Type", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__AudioClassType(soap, "tt:Type", -1, (char*const*)&a->Type, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Likelihood", -1, &a->Likelihood, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioClassCandidate * SOAP_FMAC4 soap_in_tt__AudioClassCandidate(struct soap *soap, const char *tag, struct tt__AudioClassCandidate *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Likelihood = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioClassCandidate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassCandidate, sizeof(struct tt__AudioClassCandidate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioClassCandidate(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__AudioClassType(soap, "tt:Type", (char**)&a->Type, "tt:AudioClassType"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_Likelihood && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Likelihood", &a->Likelihood, "xsd:float"))
				{	soap_flag_Likelihood--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Type || soap_flag_Likelihood > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioClassCandidate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassCandidate, SOAP_TYPE_tt__AudioClassCandidate, sizeof(struct tt__AudioClassCandidate), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioClassCandidate * SOAP_FMAC4 soap_new_tt__AudioClassCandidate(struct soap *soap, int n)
{
	struct tt__AudioClassCandidate *p;
	struct tt__AudioClassCandidate *a = (struct tt__AudioClassCandidate*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioClassCandidate));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioClassCandidate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassCandidate(struct soap *soap, const struct tt__AudioClassCandidate *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassCandidate(soap, tag ? tag : "tt:AudioClassCandidate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassCandidate * SOAP_FMAC4 soap_get_tt__AudioClassCandidate(struct soap *soap, struct tt__AudioClassCandidate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ActionEngineEventPayloadExtension(struct soap *soap, const struct tt__ActionEngineEventPayloadExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, int id, const struct tt__ActionEngineEventPayloadExtension *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension * SOAP_FMAC4 soap_in_tt__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, struct tt__ActionEngineEventPayloadExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ActionEngineEventPayloadExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(struct tt__ActionEngineEventPayloadExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ActionEngineEventPayloadExtension(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ActionEngineEventPayloadExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(struct tt__ActionEngineEventPayloadExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension * SOAP_FMAC4 soap_new_tt__ActionEngineEventPayloadExtension(struct soap *soap, int n)
{
	struct tt__ActionEngineEventPayloadExtension *p;
	struct tt__ActionEngineEventPayloadExtension *a = (struct tt__ActionEngineEventPayloadExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ActionEngineEventPayloadExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ActionEngineEventPayloadExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ActionEngineEventPayloadExtension(struct soap *soap, const struct tt__ActionEngineEventPayloadExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ActionEngineEventPayloadExtension(soap, tag ? tag : "tt:ActionEngineEventPayloadExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension * SOAP_FMAC4 soap_get_tt__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ActionEngineEventPayloadExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ActionEngineEventPayload(struct soap *soap, struct tt__ActionEngineEventPayload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RequestInfo = NULL;
	a->ResponseInfo = NULL;
	a->Fault = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ActionEngineEventPayload(struct soap *soap, const struct tt__ActionEngineEventPayload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSOAP_ENV__Envelope(soap, &a->RequestInfo);
	soap_serialize_PointerToSOAP_ENV__Envelope(soap, &a->ResponseInfo);
	soap_serialize_PointerToSOAP_ENV__Fault(soap, &a->Fault);
	soap_serialize_PointerTott__ActionEngineEventPayloadExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ActionEngineEventPayload(struct soap *soap, const char *tag, int id, const struct tt__ActionEngineEventPayload *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ActionEngineEventPayload), type))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, "tt:RequestInfo", -1, &a->RequestInfo, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, "tt:ResponseInfo", -1, &a->ResponseInfo, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Fault(soap, "tt:Fault", -1, &a->Fault, ""))
		return soap->error;
	if (soap_out_PointerTott__ActionEngineEventPayloadExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayload * SOAP_FMAC4 soap_in_tt__ActionEngineEventPayload(struct soap *soap, const char *tag, struct tt__ActionEngineEventPayload *a, const char *type)
{
	size_t soap_flag_RequestInfo = 1;
	size_t soap_flag_ResponseInfo = 1;
	size_t soap_flag_Fault = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__ActionEngineEventPayload*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActionEngineEventPayload, sizeof(struct tt__ActionEngineEventPayload), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ActionEngineEventPayload(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RequestInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Envelope(soap, "tt:RequestInfo", &a->RequestInfo, ""))
				{	soap_flag_RequestInfo--;
					continue;
				}
			}
			if (soap_flag_ResponseInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Envelope(soap, "tt:ResponseInfo", &a->ResponseInfo, ""))
				{	soap_flag_ResponseInfo--;
					continue;
				}
			}
			if (soap_flag_Fault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Fault(soap, "tt:Fault", &a->Fault, ""))
				{	soap_flag_Fault--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ActionEngineEventPayloadExtension(soap, "tt:Extension", &a->Extension, "tt:ActionEngineEventPayloadExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ActionEngineEventPayload *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActionEngineEventPayload, SOAP_TYPE_tt__ActionEngineEventPayload, sizeof(struct tt__ActionEngineEventPayload), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ActionEngineEventPayload * SOAP_FMAC4 soap_new_tt__ActionEngineEventPayload(struct soap *soap, int n)
{
	struct tt__ActionEngineEventPayload *p;
	struct tt__ActionEngineEventPayload *a = (struct tt__ActionEngineEventPayload*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ActionEngineEventPayload));
	for (p = a; p && n--; p++)
		soap_default_tt__ActionEngineEventPayload(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ActionEngineEventPayload(struct soap *soap, const struct tt__ActionEngineEventPayload *a, const char *tag, const char *type)
{
	if (soap_out_tt__ActionEngineEventPayload(soap, tag ? tag : "tt:ActionEngineEventPayload", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayload * SOAP_FMAC4 soap_get_tt__ActionEngineEventPayload(struct soap *soap, struct tt__ActionEngineEventPayload *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ActionEngineEventPayload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Error);
	soap_default_string(soap, &a->State);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsState(struct soap *soap, const struct tt__AnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Error);
	soap_serialize_string(soap, (char*const*)&a->State);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsState(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsState *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsState), type))
		return soap->error;
	if (soap_out_string(soap, "tt:Error", -1, (char*const*)&a->Error, ""))
		return soap->error;
	if (!a->State)
	{	if (soap_element_empty(soap, "tt:State", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:State", -1, (char*const*)&a->State, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsState * SOAP_FMAC4 soap_in_tt__AnalyticsState(struct soap *soap, const char *tag, struct tt__AnalyticsState *a, const char *type)
{
	size_t soap_flag_Error = 1;
	size_t soap_flag_State = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsState(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Error", (char**)&a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:State", (char**)&a->State, "xsd:string"))
				{	soap_flag_State--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->State))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsState, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsState * SOAP_FMAC4 soap_new_tt__AnalyticsState(struct soap *soap, int n)
{
	struct tt__AnalyticsState *p;
	struct tt__AnalyticsState *a = (struct tt__AnalyticsState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsState));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsState(struct soap *soap, const struct tt__AnalyticsState *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsState(soap, tag ? tag : "tt:AnalyticsState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsState * SOAP_FMAC4 soap_get_tt__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsStateInformation(struct soap *soap, struct tt__AnalyticsStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->AnalyticsEngineControlToken);
	a->State = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsStateInformation(struct soap *soap, const struct tt__AnalyticsStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AnalyticsEngineControlToken);
	soap_serialize_PointerTott__AnalyticsState(soap, &a->State);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsStateInformation(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsStateInformation *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsStateInformation), type))
		return soap->error;
	if (!a->AnalyticsEngineControlToken)
	{	if (soap_element_empty(soap, "tt:AnalyticsEngineControlToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:AnalyticsEngineControlToken", -1, (char*const*)&a->AnalyticsEngineControlToken, ""))
		return soap->error;
	if (!a->State)
	{	if (soap_element_empty(soap, "tt:State", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsState(soap, "tt:State", -1, &a->State, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation * SOAP_FMAC4 soap_in_tt__AnalyticsStateInformation(struct soap *soap, const char *tag, struct tt__AnalyticsStateInformation *a, const char *type)
{
	size_t soap_flag_AnalyticsEngineControlToken = 1;
	size_t soap_flag_State = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsStateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(struct tt__AnalyticsStateInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsStateInformation(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnalyticsEngineControlToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:AnalyticsEngineControlToken", (char**)&a->AnalyticsEngineControlToken, "tt:ReferenceToken"))
				{	soap_flag_AnalyticsEngineControlToken--;
					continue;
				}
			}
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsState(soap, "tt:State", &a->State, "tt:AnalyticsState"))
				{	soap_flag_State--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AnalyticsEngineControlToken || !a->State))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsStateInformation, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(struct tt__AnalyticsStateInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation * SOAP_FMAC4 soap_new_tt__AnalyticsStateInformation(struct soap *soap, int n)
{
	struct tt__AnalyticsStateInformation *p;
	struct tt__AnalyticsStateInformation *a = (struct tt__AnalyticsStateInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsStateInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsStateInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsStateInformation(struct soap *soap, const struct tt__AnalyticsStateInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsStateInformation(soap, tag ? tag : "tt:AnalyticsStateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation * SOAP_FMAC4 soap_get_tt__AnalyticsStateInformation(struct soap *soap, struct tt__AnalyticsStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataInputExtension(struct soap *soap, const struct tt__MetadataInputExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataInputExtension(struct soap *soap, const char *tag, int id, const struct tt__MetadataInputExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataInputExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataInputExtension * SOAP_FMAC4 soap_in_tt__MetadataInputExtension(struct soap *soap, const char *tag, struct tt__MetadataInputExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MetadataInputExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataInputExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInputExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataInputExtension, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataInputExtension * SOAP_FMAC4 soap_new_tt__MetadataInputExtension(struct soap *soap, int n)
{
	struct tt__MetadataInputExtension *p;
	struct tt__MetadataInputExtension *a = (struct tt__MetadataInputExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataInputExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataInputExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataInputExtension(struct soap *soap, const struct tt__MetadataInputExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataInputExtension(soap, tag ? tag : "tt:MetadataInputExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInputExtension * SOAP_FMAC4 soap_get_tt__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataInputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataInput(struct soap *soap, struct tt__MetadataInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMetadataConfig = 0;
	a->MetadataConfig = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataInput(struct soap *soap, const struct tt__MetadataInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->MetadataConfig)
	{	int i;
		for (i = 0; i < (int)a->__sizeMetadataConfig; i++)
		{
			soap_embedded(soap, a->MetadataConfig + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->MetadataConfig + i);
		}
	}
	soap_serialize_PointerTott__MetadataInputExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataInput(struct soap *soap, const char *tag, int id, const struct tt__MetadataInput *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataInput), type))
		return soap->error;
	if (a->MetadataConfig)
	{	int i;
		for (i = 0; i < (int)a->__sizeMetadataConfig; i++)
			if (soap_out_tt__Config(soap, "tt:MetadataConfig", -1, a->MetadataConfig + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__MetadataInputExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataInput * SOAP_FMAC4 soap_in_tt__MetadataInput(struct soap *soap, const char *tag, struct tt__MetadataInput *a, const char *type)
{
	struct soap_blist *soap_blist_MetadataConfig = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__MetadataInput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataInput(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:MetadataConfig", 1, NULL))
			{	if (a->MetadataConfig == NULL)
				{	if (soap_blist_MetadataConfig == NULL)
						soap_blist_MetadataConfig = soap_alloc_block(soap);
					a->MetadataConfig = (struct tt__Config *)soap_push_block_max(soap, soap_blist_MetadataConfig, sizeof(struct tt__Config));
					if (a->MetadataConfig == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->MetadataConfig);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tt:MetadataConfig", a->MetadataConfig, "tt:Config"))
				{	a->__sizeMetadataConfig++;
					a->MetadataConfig = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataInputExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataInputExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->MetadataConfig)
			soap_pop_block(soap, soap_blist_MetadataConfig);
		if (a->__sizeMetadataConfig)
		{	a->MetadataConfig = (struct tt__Config *)soap_save_block(soap, soap_blist_MetadataConfig, NULL, 1);
		}
		else
		{	a->MetadataConfig = NULL;
			if (soap_blist_MetadataConfig)
				soap_end_block(soap, soap_blist_MetadataConfig);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataInput, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataInput * SOAP_FMAC4 soap_new_tt__MetadataInput(struct soap *soap, int n)
{
	struct tt__MetadataInput *p;
	struct tt__MetadataInput *a = (struct tt__MetadataInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataInput));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataInput(struct soap *soap, const struct tt__MetadataInput *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataInput(soap, tag ? tag : "tt:MetadataInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInput * SOAP_FMAC4 soap_get_tt__MetadataInput(struct soap *soap, struct tt__MetadataInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SourceIdentificationExtension(struct soap *soap, const struct tt__SourceIdentificationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceIdentificationExtension(struct soap *soap, const char *tag, int id, const struct tt__SourceIdentificationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceIdentificationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension * SOAP_FMAC4 soap_in_tt__SourceIdentificationExtension(struct soap *soap, const char *tag, struct tt__SourceIdentificationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SourceIdentificationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SourceIdentificationExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SourceIdentificationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceIdentificationExtension, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension * SOAP_FMAC4 soap_new_tt__SourceIdentificationExtension(struct soap *soap, int n)
{
	struct tt__SourceIdentificationExtension *p;
	struct tt__SourceIdentificationExtension *a = (struct tt__SourceIdentificationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SourceIdentificationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SourceIdentificationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SourceIdentificationExtension(struct soap *soap, const struct tt__SourceIdentificationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SourceIdentificationExtension(soap, tag ? tag : "tt:SourceIdentificationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension * SOAP_FMAC4 soap_get_tt__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceIdentificationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	a->__sizeToken = 0;
	a->Token = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SourceIdentification(struct soap *soap, const struct tt__SourceIdentification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Name);
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
	soap_serialize_PointerTott__SourceIdentificationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceIdentification(struct soap *soap, const char *tag, int id, const struct tt__SourceIdentification *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceIdentification), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			if (soap_out_string(soap, "tt:Token", -1, (char*const*)(a->Token + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__SourceIdentificationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SourceIdentification * SOAP_FMAC4 soap_in_tt__SourceIdentification(struct soap *soap, const char *tag, struct tt__SourceIdentification *a, const char *type)
{
	size_t soap_flag_Name = 1;
	struct soap_blist *soap_blist_Token = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SourceIdentification*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SourceIdentification(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Name", (char**)&a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:Token", (char**)a->Token, "tt:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SourceIdentificationExtension(soap, "tt:Extension", &a->Extension, "tt:SourceIdentificationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SourceIdentification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceIdentification, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SourceIdentification * SOAP_FMAC4 soap_new_tt__SourceIdentification(struct soap *soap, int n)
{
	struct tt__SourceIdentification *p;
	struct tt__SourceIdentification *a = (struct tt__SourceIdentification*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SourceIdentification));
	for (p = a; p && n--; p++)
		soap_default_tt__SourceIdentification(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SourceIdentification(struct soap *soap, const struct tt__SourceIdentification *a, const char *tag, const char *type)
{
	if (soap_out_tt__SourceIdentification(soap, tag ? tag : "tt:SourceIdentification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentification * SOAP_FMAC4 soap_get_tt__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const struct tt__AnalyticsEngineInputInfoExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineInputInfoExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfoExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsEngineInputInfoExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineInputInfoExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfoExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_new_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineInputInfoExtension *p;
	struct tt__AnalyticsEngineInputInfoExtension *a = (struct tt__AnalyticsEngineInputInfoExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineInputInfoExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineInputInfoExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const struct tt__AnalyticsEngineInputInfoExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineInputInfoExtension(soap, tag ? tag : "tt:AnalyticsEngineInputInfoExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInputInfoExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->InputInfo = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineInputInfo(struct soap *soap, const struct tt__AnalyticsEngineInputInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Config(soap, &a->InputInfo);
	soap_serialize_PointerTott__AnalyticsEngineInputInfoExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineInputInfo *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfo), type))
		return soap->error;
	if (soap_out_PointerTott__Config(soap, "tt:InputInfo", -1, &a->InputInfo, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineInputInfoExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfo *a, const char *type)
{
	size_t soap_flag_InputInfo = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsEngineInputInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineInputInfo(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Config(soap, "tt:InputInfo", &a->InputInfo, "tt:Config"))
				{	soap_flag_InputInfo--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineInputInfoExtension(soap, "tt:Extension", &a->Extension, "tt:AnalyticsEngineInputInfoExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInputInfo, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_new_tt__AnalyticsEngineInputInfo(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineInputInfo *p;
	struct tt__AnalyticsEngineInputInfo *a = (struct tt__AnalyticsEngineInputInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineInputInfo));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineInputInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineInputInfo(struct soap *soap, const struct tt__AnalyticsEngineInputInfo *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineInputInfo(soap, tag ? tag : "tt:AnalyticsEngineInputInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
