/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:05 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Translation = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RelativeMove(struct soap *soap, const struct _tptz__RelativeMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerTott__PTZVector(soap, &a->Translation);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RelativeMove(struct soap *soap, const char *tag, int id, const struct _tptz__RelativeMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RelativeMove), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->Translation)
	{	if (soap_element_empty(soap, "tptz:Translation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZVector(soap, "tptz:Translation", -1, &a->Translation, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RelativeMove * SOAP_FMAC4 soap_in__tptz__RelativeMove(struct soap *soap, const char *tag, struct _tptz__RelativeMove *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Translation = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__RelativeMove*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RelativeMove, sizeof(struct _tptz__RelativeMove), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RelativeMove(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_Translation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tptz:Translation", &a->Translation, "tt:PTZVector"))
				{	soap_flag_Translation--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->Translation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__RelativeMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RelativeMove, SOAP_TYPE__tptz__RelativeMove, sizeof(struct _tptz__RelativeMove), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__RelativeMove * SOAP_FMAC4 soap_new__tptz__RelativeMove(struct soap *soap, int n)
{
	struct _tptz__RelativeMove *p;
	struct _tptz__RelativeMove *a = (struct _tptz__RelativeMove*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__RelativeMove));
	for (p = a; p && n--; p++)
		soap_default__tptz__RelativeMove(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RelativeMove(struct soap *soap, const struct _tptz__RelativeMove *a, const char *tag, const char *type)
{
	if (soap_out__tptz__RelativeMove(soap, tag ? tag : "tptz:RelativeMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RelativeMove * SOAP_FMAC4 soap_get__tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RelativeMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__ContinuousMoveResponse(struct soap *soap, const struct _tptz__ContinuousMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, int id, const struct _tptz__ContinuousMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ContinuousMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse * SOAP_FMAC4 soap_in__tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, struct _tptz__ContinuousMoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__ContinuousMoveResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(struct _tptz__ContinuousMoveResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__ContinuousMoveResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__ContinuousMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ContinuousMoveResponse, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(struct _tptz__ContinuousMoveResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse * SOAP_FMAC4 soap_new__tptz__ContinuousMoveResponse(struct soap *soap, int n)
{
	struct _tptz__ContinuousMoveResponse *p;
	struct _tptz__ContinuousMoveResponse *a = (struct _tptz__ContinuousMoveResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__ContinuousMoveResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__ContinuousMoveResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__ContinuousMoveResponse(struct soap *soap, const struct _tptz__ContinuousMoveResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__ContinuousMoveResponse(soap, tag ? tag : "tptz:ContinuousMoveResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse * SOAP_FMAC4 soap_get__tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ContinuousMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Velocity = NULL;
	soap_default_xsd__duration(soap, &a->Timeout);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__ContinuousMove(struct soap *soap, const struct _tptz__ContinuousMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Velocity);
	soap_serialize_xsd__duration(soap, (char*const*)&a->Timeout);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ContinuousMove(struct soap *soap, const char *tag, int id, const struct _tptz__ContinuousMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ContinuousMove), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->Velocity)
	{	if (soap_element_empty(soap, "tptz:Velocity", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Velocity", -1, &a->Velocity, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tptz:Timeout", -1, (char*const*)&a->Timeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__ContinuousMove * SOAP_FMAC4 soap_in__tptz__ContinuousMove(struct soap *soap, const char *tag, struct _tptz__ContinuousMove *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Velocity = 1;
	size_t soap_flag_Timeout = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__ContinuousMove*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ContinuousMove, sizeof(struct _tptz__ContinuousMove), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__ContinuousMove(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_Velocity && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Velocity", &a->Velocity, "tt:PTZSpeed"))
				{	soap_flag_Velocity--;
					continue;
				}
			}
			if (soap_flag_Timeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tptz:Timeout", (char**)&a->Timeout, "xsd:duration"))
				{	soap_flag_Timeout--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->Velocity))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__ContinuousMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ContinuousMove, SOAP_TYPE__tptz__ContinuousMove, sizeof(struct _tptz__ContinuousMove), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__ContinuousMove * SOAP_FMAC4 soap_new__tptz__ContinuousMove(struct soap *soap, int n)
{
	struct _tptz__ContinuousMove *p;
	struct _tptz__ContinuousMove *a = (struct _tptz__ContinuousMove*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__ContinuousMove));
	for (p = a; p && n--; p++)
		soap_default__tptz__ContinuousMove(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__ContinuousMove(struct soap *soap, const struct _tptz__ContinuousMove *a, const char *tag, const char *type)
{
	if (soap_out__tptz__ContinuousMove(soap, tag ? tag : "tptz:ContinuousMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ContinuousMove * SOAP_FMAC4 soap_get__tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ContinuousMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetHomePositionResponse(struct soap *soap, const struct _tptz__SetHomePositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetHomePositionResponse(struct soap *soap, const char *tag, int id, const struct _tptz__SetHomePositionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetHomePositionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse * SOAP_FMAC4 soap_in__tptz__SetHomePositionResponse(struct soap *soap, const char *tag, struct _tptz__SetHomePositionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__SetHomePositionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(struct _tptz__SetHomePositionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetHomePositionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetHomePositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetHomePositionResponse, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(struct _tptz__SetHomePositionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse * SOAP_FMAC4 soap_new__tptz__SetHomePositionResponse(struct soap *soap, int n)
{
	struct _tptz__SetHomePositionResponse *p;
	struct _tptz__SetHomePositionResponse *a = (struct _tptz__SetHomePositionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SetHomePositionResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__SetHomePositionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetHomePositionResponse(struct soap *soap, const struct _tptz__SetHomePositionResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SetHomePositionResponse(soap, tag ? tag : "tptz:SetHomePositionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse * SOAP_FMAC4 soap_get__tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetHomePosition(struct soap *soap, const struct _tptz__SetHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetHomePosition(struct soap *soap, const char *tag, int id, const struct _tptz__SetHomePosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetHomePosition), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetHomePosition * SOAP_FMAC4 soap_in__tptz__SetHomePosition(struct soap *soap, const char *tag, struct _tptz__SetHomePosition *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__SetHomePosition*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetHomePosition, sizeof(struct _tptz__SetHomePosition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetHomePosition(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__SetHomePosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetHomePosition, SOAP_TYPE__tptz__SetHomePosition, sizeof(struct _tptz__SetHomePosition), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SetHomePosition * SOAP_FMAC4 soap_new__tptz__SetHomePosition(struct soap *soap, int n)
{
	struct _tptz__SetHomePosition *p;
	struct _tptz__SetHomePosition *a = (struct _tptz__SetHomePosition*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SetHomePosition));
	for (p = a; p && n--; p++)
		soap_default__tptz__SetHomePosition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetHomePosition(struct soap *soap, const struct _tptz__SetHomePosition *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SetHomePosition(soap, tag ? tag : "tptz:SetHomePosition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetHomePosition * SOAP_FMAC4 soap_get__tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GotoHomePositionResponse(struct soap *soap, const struct _tptz__GotoHomePositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GotoHomePositionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoHomePositionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse * SOAP_FMAC4 soap_in__tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, struct _tptz__GotoHomePositionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GotoHomePositionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(struct _tptz__GotoHomePositionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GotoHomePositionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoHomePositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoHomePositionResponse, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(struct _tptz__GotoHomePositionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse * SOAP_FMAC4 soap_new__tptz__GotoHomePositionResponse(struct soap *soap, int n)
{
	struct _tptz__GotoHomePositionResponse *p;
	struct _tptz__GotoHomePositionResponse *a = (struct _tptz__GotoHomePositionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GotoHomePositionResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GotoHomePositionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GotoHomePositionResponse(struct soap *soap, const struct _tptz__GotoHomePositionResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GotoHomePositionResponse(soap, tag ? tag : "tptz:GotoHomePositionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse * SOAP_FMAC4 soap_get__tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GotoHomePosition(struct soap *soap, const struct _tptz__GotoHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoHomePosition(struct soap *soap, const char *tag, int id, const struct _tptz__GotoHomePosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoHomePosition), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GotoHomePosition * SOAP_FMAC4 soap_in__tptz__GotoHomePosition(struct soap *soap, const char *tag, struct _tptz__GotoHomePosition *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GotoHomePosition*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoHomePosition, sizeof(struct _tptz__GotoHomePosition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GotoHomePosition(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GotoHomePosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoHomePosition, SOAP_TYPE__tptz__GotoHomePosition, sizeof(struct _tptz__GotoHomePosition), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GotoHomePosition * SOAP_FMAC4 soap_new__tptz__GotoHomePosition(struct soap *soap, int n)
{
	struct _tptz__GotoHomePosition *p;
	struct _tptz__GotoHomePosition *a = (struct _tptz__GotoHomePosition*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GotoHomePosition));
	for (p = a; p && n--; p++)
		soap_default__tptz__GotoHomePosition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GotoHomePosition(struct soap *soap, const struct _tptz__GotoHomePosition *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GotoHomePosition(soap, tag ? tag : "tptz:GotoHomePosition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoHomePosition * SOAP_FMAC4 soap_get__tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetStatusResponse(struct soap *soap, struct _tptz__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetStatusResponse(struct soap *soap, const struct _tptz__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZStatus(soap, &a->PTZStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetStatusResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetStatusResponse), type))
		return soap->error;
	if (a->PTZStatus)
		soap_element_result(soap, "tptz:PTZStatus");
	if (!a->PTZStatus)
	{	if (soap_element_empty(soap, "tptz:PTZStatus", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZStatus(soap, "tptz:PTZStatus", -1, &a->PTZStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetStatusResponse * SOAP_FMAC4 soap_in__tptz__GetStatusResponse(struct soap *soap, const char *tag, struct _tptz__GetStatusResponse *a, const char *type)
{
	size_t soap_flag_PTZStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetStatusResponse, sizeof(struct _tptz__GetStatusResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetStatusResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZStatus(soap, "tptz:PTZStatus", &a->PTZStatus, "tt:PTZStatus"))
				{	soap_flag_PTZStatus--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PTZStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZStatus))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetStatusResponse, SOAP_TYPE__tptz__GetStatusResponse, sizeof(struct _tptz__GetStatusResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetStatusResponse * SOAP_FMAC4 soap_new__tptz__GetStatusResponse(struct soap *soap, int n)
{
	struct _tptz__GetStatusResponse *p;
	struct _tptz__GetStatusResponse *a = (struct _tptz__GetStatusResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetStatusResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetStatusResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetStatusResponse(struct soap *soap, const struct _tptz__GetStatusResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetStatusResponse(soap, tag ? tag : "tptz:GetStatusResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetStatusResponse * SOAP_FMAC4 soap_get__tptz__GetStatusResponse(struct soap *soap, struct _tptz__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetStatus(struct soap *soap, struct _tptz__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetStatus(struct soap *soap, const struct _tptz__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetStatus(struct soap *soap, const char *tag, int id, const struct _tptz__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetStatus), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetStatus * SOAP_FMAC4 soap_in__tptz__GetStatus(struct soap *soap, const char *tag, struct _tptz__GetStatus *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetStatus, sizeof(struct _tptz__GetStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetStatus, SOAP_TYPE__tptz__GetStatus, sizeof(struct _tptz__GetStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetStatus * SOAP_FMAC4 soap_new__tptz__GetStatus(struct soap *soap, int n)
{
	struct _tptz__GetStatus *p;
	struct _tptz__GetStatus *a = (struct _tptz__GetStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetStatus));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetStatus(struct soap *soap, const struct _tptz__GetStatus *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetStatus(soap, tag ? tag : "tptz:GetStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetStatus * SOAP_FMAC4 soap_get__tptz__GetStatus(struct soap *soap, struct _tptz__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GotoPresetResponse(struct soap *soap, struct _tptz__GotoPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GotoPresetResponse(struct soap *soap, const struct _tptz__GotoPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoPresetResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GotoPresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoPresetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GotoPresetResponse * SOAP_FMAC4 soap_in__tptz__GotoPresetResponse(struct soap *soap, const char *tag, struct _tptz__GotoPresetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GotoPresetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(struct _tptz__GotoPresetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GotoPresetResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoPresetResponse, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(struct _tptz__GotoPresetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GotoPresetResponse * SOAP_FMAC4 soap_new__tptz__GotoPresetResponse(struct soap *soap, int n)
{
	struct _tptz__GotoPresetResponse *p;
	struct _tptz__GotoPresetResponse *a = (struct _tptz__GotoPresetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GotoPresetResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GotoPresetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GotoPresetResponse(struct soap *soap, const struct _tptz__GotoPresetResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GotoPresetResponse(soap, tag ? tag : "tptz:GotoPresetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoPresetResponse * SOAP_FMAC4 soap_get__tptz__GotoPresetResponse(struct soap *soap, struct _tptz__GotoPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GotoPreset(struct soap *soap, struct _tptz__GotoPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GotoPreset(struct soap *soap, const struct _tptz__GotoPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetToken);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoPreset(struct soap *soap, const char *tag, int id, const struct _tptz__GotoPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoPreset), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->PresetToken)
	{	if (soap_element_empty(soap, "tptz:PresetToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, (char*const*)&a->PresetToken, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GotoPreset * SOAP_FMAC4 soap_in__tptz__GotoPreset(struct soap *soap, const char *tag, struct _tptz__GotoPreset *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetToken = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GotoPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoPreset, sizeof(struct _tptz__GotoPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GotoPreset(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", (char**)&a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->PresetToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GotoPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoPreset, SOAP_TYPE__tptz__GotoPreset, sizeof(struct _tptz__GotoPreset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GotoPreset * SOAP_FMAC4 soap_new__tptz__GotoPreset(struct soap *soap, int n)
{
	struct _tptz__GotoPreset *p;
	struct _tptz__GotoPreset *a = (struct _tptz__GotoPreset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GotoPreset));
	for (p = a; p && n--; p++)
		soap_default__tptz__GotoPreset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GotoPreset(struct soap *soap, const struct _tptz__GotoPreset *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GotoPreset(soap, tag ? tag : "tptz:GotoPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoPreset * SOAP_FMAC4 soap_get__tptz__GotoPreset(struct soap *soap, struct _tptz__GotoPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RemovePresetResponse(struct soap *soap, struct _tptz__RemovePresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RemovePresetResponse(struct soap *soap, const struct _tptz__RemovePresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePresetResponse(struct soap *soap, const char *tag, int id, const struct _tptz__RemovePresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePresetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RemovePresetResponse * SOAP_FMAC4 soap_in__tptz__RemovePresetResponse(struct soap *soap, const char *tag, struct _tptz__RemovePresetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__RemovePresetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(struct _tptz__RemovePresetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RemovePresetResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetResponse, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(struct _tptz__RemovePresetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__RemovePresetResponse * SOAP_FMAC4 soap_new__tptz__RemovePresetResponse(struct soap *soap, int n)
{
	struct _tptz__RemovePresetResponse *p;
	struct _tptz__RemovePresetResponse *a = (struct _tptz__RemovePresetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__RemovePresetResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__RemovePresetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RemovePresetResponse(struct soap *soap, const struct _tptz__RemovePresetResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__RemovePresetResponse(soap, tag ? tag : "tptz:RemovePresetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetResponse * SOAP_FMAC4 soap_get__tptz__RemovePresetResponse(struct soap *soap, struct _tptz__RemovePresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RemovePreset(struct soap *soap, struct _tptz__RemovePreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RemovePreset(struct soap *soap, const struct _tptz__RemovePreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePreset(struct soap *soap, const char *tag, int id, const struct _tptz__RemovePreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePreset), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->PresetToken)
	{	if (soap_element_empty(soap, "tptz:PresetToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, (char*const*)&a->PresetToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RemovePreset * SOAP_FMAC4 soap_in__tptz__RemovePreset(struct soap *soap, const char *tag, struct _tptz__RemovePreset *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__RemovePreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePreset, sizeof(struct _tptz__RemovePreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RemovePreset(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", (char**)&a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->PresetToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__RemovePreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePreset, SOAP_TYPE__tptz__RemovePreset, sizeof(struct _tptz__RemovePreset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__RemovePreset * SOAP_FMAC4 soap_new__tptz__RemovePreset(struct soap *soap, int n)
{
	struct _tptz__RemovePreset *p;
	struct _tptz__RemovePreset *a = (struct _tptz__RemovePreset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__RemovePreset));
	for (p = a; p && n--; p++)
		soap_default__tptz__RemovePreset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RemovePreset(struct soap *soap, const struct _tptz__RemovePreset *a, const char *tag, const char *type)
{
	if (soap_out__tptz__RemovePreset(soap, tag ? tag : "tptz:RemovePreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePreset * SOAP_FMAC4 soap_get__tptz__RemovePreset(struct soap *soap, struct _tptz__RemovePreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetPresetResponse(struct soap *soap, struct _tptz__SetPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetPresetResponse(struct soap *soap, const struct _tptz__SetPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetPresetResponse(struct soap *soap, const char *tag, int id, const struct _tptz__SetPresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetPresetResponse), type))
		return soap->error;
	if (a->PresetToken)
		soap_element_result(soap, "tptz:PresetToken");
	if (!a->PresetToken)
	{	if (soap_element_empty(soap, "tptz:PresetToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, (char*const*)&a->PresetToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetPresetResponse * SOAP_FMAC4 soap_in__tptz__SetPresetResponse(struct soap *soap, const char *tag, struct _tptz__SetPresetResponse *a, const char *type)
{
	size_t soap_flag_PresetToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__SetPresetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetPresetResponse, sizeof(struct _tptz__SetPresetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetPresetResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", (char**)&a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PresetToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PresetToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__SetPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetPresetResponse, SOAP_TYPE__tptz__SetPresetResponse, sizeof(struct _tptz__SetPresetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SetPresetResponse * SOAP_FMAC4 soap_new__tptz__SetPresetResponse(struct soap *soap, int n)
{
	struct _tptz__SetPresetResponse *p;
	struct _tptz__SetPresetResponse *a = (struct _tptz__SetPresetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SetPresetResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__SetPresetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetPresetResponse(struct soap *soap, const struct _tptz__SetPresetResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SetPresetResponse(soap, tag ? tag : "tptz:SetPresetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetPresetResponse * SOAP_FMAC4 soap_get__tptz__SetPresetResponse(struct soap *soap, struct _tptz__SetPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetPreset(struct soap *soap, struct _tptz__SetPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_string(soap, &a->PresetName);
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetPreset(struct soap *soap, const struct _tptz__SetPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_string(soap, (char*const*)&a->PresetName);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetPreset(struct soap *soap, const char *tag, int id, const struct _tptz__SetPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetPreset), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (soap_out_string(soap, "tptz:PresetName", -1, (char*const*)&a->PresetName, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, (char*const*)&a->PresetToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetPreset * SOAP_FMAC4 soap_in__tptz__SetPreset(struct soap *soap, const char *tag, struct _tptz__SetPreset *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetName = 1;
	size_t soap_flag_PresetToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__SetPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetPreset, sizeof(struct _tptz__SetPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetPreset(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_PresetName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tptz:PresetName", (char**)&a->PresetName, "xsd:string"))
				{	soap_flag_PresetName--;
					continue;
				}
			}
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", (char**)&a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__SetPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetPreset, SOAP_TYPE__tptz__SetPreset, sizeof(struct _tptz__SetPreset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SetPreset * SOAP_FMAC4 soap_new__tptz__SetPreset(struct soap *soap, int n)
{
	struct _tptz__SetPreset *p;
	struct _tptz__SetPreset *a = (struct _tptz__SetPreset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SetPreset));
	for (p = a; p && n--; p++)
		soap_default__tptz__SetPreset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetPreset(struct soap *soap, const struct _tptz__SetPreset *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SetPreset(soap, tag ? tag : "tptz:SetPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetPreset * SOAP_FMAC4 soap_get__tptz__SetPreset(struct soap *soap, struct _tptz__SetPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetsResponse(struct soap *soap, struct _tptz__GetPresetsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePreset = 0;
	a->Preset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetsResponse(struct soap *soap, const struct _tptz__GetPresetsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Preset)
	{	int i;
		for (i = 0; i < (int)a->__sizePreset; i++)
		{
			soap_embedded(soap, a->Preset + i, SOAP_TYPE_tt__PTZPreset);
			soap_serialize_tt__PTZPreset(soap, a->Preset + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePreset");
	if (a->Preset)
	{	int i;
		for (i = 0; i < (int)a->__sizePreset; i++)
			if (soap_out_tt__PTZPreset(soap, "tptz:Preset", -1, a->Preset + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetsResponse * SOAP_FMAC4 soap_in__tptz__GetPresetsResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Preset = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetPresetsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(struct _tptz__GetPresetsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:Preset", 1, NULL))
			{	if (a->Preset == NULL)
				{	if (soap_blist_Preset == NULL)
						soap_blist_Preset = soap_alloc_block(soap);
					a->Preset = (struct tt__PTZPreset *)soap_push_block_max(soap, soap_blist_Preset, sizeof(struct tt__PTZPreset));
					if (a->Preset == NULL)
						return NULL;
					soap_default_tt__PTZPreset(soap, a->Preset);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZPreset(soap, "tptz:Preset", a->Preset, "tt:PTZPreset"))
				{	a->__sizePreset++;
					a->Preset = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePreset");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Preset)
			soap_pop_block(soap, soap_blist_Preset);
		if (a->__sizePreset)
		{	a->Preset = (struct tt__PTZPreset *)soap_save_block(soap, soap_blist_Preset, NULL, 1);
		}
		else
		{	a->Preset = NULL;
			if (soap_blist_Preset)
				soap_end_block(soap, soap_blist_Preset);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetsResponse, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(struct _tptz__GetPresetsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetsResponse * SOAP_FMAC4 soap_new__tptz__GetPresetsResponse(struct soap *soap, int n)
{
	struct _tptz__GetPresetsResponse *p;
	struct _tptz__GetPresetsResponse *a = (struct _tptz__GetPresetsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetsResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetsResponse(struct soap *soap, const struct _tptz__GetPresetsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetsResponse(soap, tag ? tag : "tptz:GetPresetsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetsResponse * SOAP_FMAC4 soap_get__tptz__GetPresetsResponse(struct soap *soap, struct _tptz__GetPresetsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresets(struct soap *soap, struct _tptz__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresets(struct soap *soap, const struct _tptz__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresets(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresets), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresets * SOAP_FMAC4 soap_in__tptz__GetPresets(struct soap *soap, const char *tag, struct _tptz__GetPresets *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetPresets*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresets, sizeof(struct _tptz__GetPresets), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresets(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetPresets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresets, SOAP_TYPE__tptz__GetPresets, sizeof(struct _tptz__GetPresets), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresets * SOAP_FMAC4 soap_new__tptz__GetPresets(struct soap *soap, int n)
{
	struct _tptz__GetPresets *p;
	struct _tptz__GetPresets *a = (struct _tptz__GetPresets*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresets));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresets(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresets(struct soap *soap, const struct _tptz__GetPresets *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresets(soap, tag ? tag : "tptz:GetPresets", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresets * SOAP_FMAC4 soap_get__tptz__GetPresets(struct soap *soap, struct _tptz__GetPresets *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tptz__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__AuxiliaryData(soap, (char*const*)&a->AuxiliaryResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const struct _tptz__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse), type))
		return soap->error;
	if (a->AuxiliaryResponse)
		soap_element_result(soap, "tptz:AuxiliaryResponse");
	if (!a->AuxiliaryResponse)
	{	if (soap_element_empty(soap, "tptz:AuxiliaryResponse", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__AuxiliaryData(soap, "tptz:AuxiliaryResponse", -1, (char*const*)&a->AuxiliaryResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tptz__SendAuxiliaryCommandResponse *a, const char *type)
{
	size_t soap_flag_AuxiliaryResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__SendAuxiliaryCommandResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(struct _tptz__SendAuxiliaryCommandResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SendAuxiliaryCommandResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryResponse && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__AuxiliaryData(soap, "tptz:AuxiliaryResponse", (char**)&a->AuxiliaryResponse, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryResponse--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:AuxiliaryResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AuxiliaryResponse))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(struct _tptz__SendAuxiliaryCommandResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_new__tptz__SendAuxiliaryCommandResponse(struct soap *soap, int n)
{
	struct _tptz__SendAuxiliaryCommandResponse *p;
	struct _tptz__SendAuxiliaryCommandResponse *a = (struct _tptz__SendAuxiliaryCommandResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SendAuxiliaryCommandResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__SendAuxiliaryCommandResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tptz__SendAuxiliaryCommandResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SendAuxiliaryCommandResponse(soap, tag ? tag : "tptz:SendAuxiliaryCommandResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SendAuxiliaryCommand(struct soap *soap, const struct _tptz__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__AuxiliaryData(soap, (char*const*)&a->AuxiliaryData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct _tptz__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SendAuxiliaryCommand), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->AuxiliaryData)
	{	if (soap_element_empty(soap, "tptz:AuxiliaryData", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__AuxiliaryData(soap, "tptz:AuxiliaryData", -1, (char*const*)&a->AuxiliaryData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tptz__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_AuxiliaryData = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__SendAuxiliaryCommand*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(struct _tptz__SendAuxiliaryCommand), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SendAuxiliaryCommand(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_AuxiliaryData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__AuxiliaryData(soap, "tptz:AuxiliaryData", (char**)&a->AuxiliaryData, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryData--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->AuxiliaryData))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SendAuxiliaryCommand, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(struct _tptz__SendAuxiliaryCommand), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_new__tptz__SendAuxiliaryCommand(struct soap *soap, int n)
{
	struct _tptz__SendAuxiliaryCommand *p;
	struct _tptz__SendAuxiliaryCommand *a = (struct _tptz__SendAuxiliaryCommand*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SendAuxiliaryCommand));
	for (p = a; p && n--; p++)
		soap_default__tptz__SendAuxiliaryCommand(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SendAuxiliaryCommand(struct soap *soap, const struct _tptz__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SendAuxiliaryCommand(soap, tag ? tag : "tptz:SendAuxiliaryCommand", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurationOptionsResponse(struct soap *soap, struct _tptz__GetConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurationOptionsResponse(struct soap *soap, const struct _tptz__GetConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZConfigurationOptions(soap, &a->PTZConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse), type))
		return soap->error;
	if (a->PTZConfigurationOptions)
		soap_element_result(soap, "tptz:PTZConfigurationOptions");
	if (!a->PTZConfigurationOptions)
	{	if (soap_element_empty(soap, "tptz:PTZConfigurationOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZConfigurationOptions(soap, "tptz:PTZConfigurationOptions", -1, &a->PTZConfigurationOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_in__tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_PTZConfigurationOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetConfigurationOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(struct _tptz__GetConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurationOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationOptions(soap, "tptz:PTZConfigurationOptions", &a->PTZConfigurationOptions, "tt:PTZConfigurationOptions"))
				{	soap_flag_PTZConfigurationOptions--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PTZConfigurationOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZConfigurationOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(struct _tptz__GetConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_new__tptz__GetConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _tptz__GetConfigurationOptionsResponse *p;
	struct _tptz__GetConfigurationOptionsResponse *a = (struct _tptz__GetConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurationOptionsResponse(struct soap *soap, const struct _tptz__GetConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetConfigurationOptionsResponse(soap, tag ? tag : "tptz:GetConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_get__tptz__GetConfigurationOptionsResponse(struct soap *soap, struct _tptz__GetConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurationOptions(struct soap *soap, struct _tptz__GetConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurationOptions(struct soap *soap, const struct _tptz__GetConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationOptions), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tptz:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptions * SOAP_FMAC4 soap_in__tptz__GetConfigurationOptions(struct soap *soap, const char *tag, struct _tptz__GetConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(struct _tptz__GetConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationOptions, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(struct _tptz__GetConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptions * SOAP_FMAC4 soap_new__tptz__GetConfigurationOptions(struct soap *soap, int n)
{
	struct _tptz__GetConfigurationOptions *p;
	struct _tptz__GetConfigurationOptions *a = (struct _tptz__GetConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurationOptions(struct soap *soap, const struct _tptz__GetConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetConfigurationOptions(soap, tag ? tag : "tptz:GetConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptions * SOAP_FMAC4 soap_get__tptz__GetConfigurationOptions(struct soap *soap, struct _tptz__GetConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__SetConfigurationResponse_sequence(struct soap *soap, const struct __tptz__SetConfigurationResponse_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, int id, const struct __tptz__SetConfigurationResponse_sequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence * SOAP_FMAC4 soap_in___tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, struct __tptz__SetConfigurationResponse_sequence *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__SetConfigurationResponse_sequence*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence, sizeof(struct __tptz__SetConfigurationResponse_sequence), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__SetConfigurationResponse_sequence(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence * SOAP_FMAC4 soap_new___tptz__SetConfigurationResponse_sequence(struct soap *soap, int n)
{
	struct __tptz__SetConfigurationResponse_sequence *p;
	struct __tptz__SetConfigurationResponse_sequence *a = (struct __tptz__SetConfigurationResponse_sequence*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tptz__SetConfigurationResponse_sequence));
	for (p = a; p && n--; p++)
		soap_default___tptz__SetConfigurationResponse_sequence(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__SetConfigurationResponse_sequence(struct soap *soap, const struct __tptz__SetConfigurationResponse_sequence *a, const char *tag, const char *type)
{
	if (soap_out___tptz__SetConfigurationResponse_sequence(soap, tag ? tag : "-tptz:SetConfigurationResponse-sequence", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence * SOAP_FMAC4 soap_get___tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__SetConfigurationResponse_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetConfigurationResponse(struct soap *soap, struct _tptz__SetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__SetConfigurationResponse_sequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetConfigurationResponse(struct soap *soap, const struct _tptz__SetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo__tptz__SetConfigurationResponse_sequence(soap, &a->__SetConfigurationResponse_sequence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tptz__SetConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetConfigurationResponse), type))
		return soap->error;
	if (a->__SetConfigurationResponse_sequence)
		soap_element_result(soap, "-SetConfigurationResponse-sequence");
	if (soap_out_PointerTo__tptz__SetConfigurationResponse_sequence(soap, "-SetConfigurationResponse-sequence", -1, &a->__SetConfigurationResponse_sequence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetConfigurationResponse * SOAP_FMAC4 soap_in__tptz__SetConfigurationResponse(struct soap *soap, const char *tag, struct _tptz__SetConfigurationResponse *a, const char *type)
{
	size_t soap_flag___SetConfigurationResponse_sequence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__SetConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(struct _tptz__SetConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___SetConfigurationResponse_sequence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo__tptz__SetConfigurationResponse_sequence(soap, "-SetConfigurationResponse-sequence", &a->__SetConfigurationResponse_sequence, "-tptz:SetConfigurationResponse-sequence"))
				{	soap_flag___SetConfigurationResponse_sequence--;
					continue;
				}
			}
			soap_check_result(soap, "-SetConfigurationResponse-sequence");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetConfigurationResponse, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(struct _tptz__SetConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SetConfigurationResponse * SOAP_FMAC4 soap_new__tptz__SetConfigurationResponse(struct soap *soap, int n)
{
	struct _tptz__SetConfigurationResponse *p;
	struct _tptz__SetConfigurationResponse *a = (struct _tptz__SetConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SetConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__SetConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetConfigurationResponse(struct soap *soap, const struct _tptz__SetConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SetConfigurationResponse(soap, tag ? tag : "tptz:SetConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetConfigurationResponse * SOAP_FMAC4 soap_get__tptz__SetConfigurationResponse(struct soap *soap, struct _tptz__SetConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetConfiguration(struct soap *soap, struct _tptz__SetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZConfiguration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetConfiguration(struct soap *soap, const struct _tptz__SetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZConfiguration(soap, &a->PTZConfiguration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetConfiguration(struct soap *soap, const char *tag, int id, const struct _tptz__SetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetConfiguration), type))
		return soap->error;
	if (!a->PTZConfiguration)
	{	if (soap_element_empty(soap, "tptz:PTZConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, &a->PTZConfiguration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tptz:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetConfiguration * SOAP_FMAC4 soap_in__tptz__SetConfiguration(struct soap *soap, const char *tag, struct _tptz__SetConfiguration *a, const char *type)
{
	size_t soap_flag_PTZConfiguration = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__SetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetConfiguration, sizeof(struct _tptz__SetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", &a->PTZConfiguration, "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration--;
					continue;
				}
			}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tptz:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZConfiguration || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__SetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetConfiguration, SOAP_TYPE__tptz__SetConfiguration, sizeof(struct _tptz__SetConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SetConfiguration * SOAP_FMAC4 soap_new__tptz__SetConfiguration(struct soap *soap, int n)
{
	struct _tptz__SetConfiguration *p;
	struct _tptz__SetConfiguration *a = (struct _tptz__SetConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SetConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tptz__SetConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetConfiguration(struct soap *soap, const struct _tptz__SetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SetConfiguration(soap, tag ? tag : "tptz:SetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetConfiguration * SOAP_FMAC4 soap_get__tptz__SetConfiguration(struct soap *soap, struct _tptz__SetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurationResponse(struct soap *soap, struct _tptz__GetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurationResponse(struct soap *soap, const struct _tptz__GetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZConfiguration(soap, &a->PTZConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationResponse), type))
		return soap->error;
	if (a->PTZConfiguration)
		soap_element_result(soap, "tptz:PTZConfiguration");
	if (!a->PTZConfiguration)
	{	if (soap_element_empty(soap, "tptz:PTZConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, &a->PTZConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurationResponse * SOAP_FMAC4 soap_in__tptz__GetConfigurationResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationResponse *a, const char *type)
{
	size_t soap_flag_PTZConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(struct _tptz__GetConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", &a->PTZConfiguration, "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PTZConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationResponse, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(struct _tptz__GetConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetConfigurationResponse * SOAP_FMAC4 soap_new__tptz__GetConfigurationResponse(struct soap *soap, int n)
{
	struct _tptz__GetConfigurationResponse *p;
	struct _tptz__GetConfigurationResponse *a = (struct _tptz__GetConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurationResponse(struct soap *soap, const struct _tptz__GetConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetConfigurationResponse(soap, tag ? tag : "tptz:GetConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationResponse * SOAP_FMAC4 soap_get__tptz__GetConfigurationResponse(struct soap *soap, struct _tptz__GetConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfiguration(struct soap *soap, struct _tptz__GetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->PTZConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfiguration(struct soap *soap, const struct _tptz__GetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PTZConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfiguration(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfiguration), type))
		return soap->error;
	if (!a->PTZConfigurationToken)
	{	if (soap_element_empty(soap, "tptz:PTZConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:PTZConfigurationToken", -1, (char*const*)&a->PTZConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfiguration * SOAP_FMAC4 soap_in__tptz__GetConfiguration(struct soap *soap, const char *tag, struct _tptz__GetConfiguration *a, const char *type)
{
	size_t soap_flag_PTZConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfiguration, sizeof(struct _tptz__GetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PTZConfigurationToken", (char**)&a->PTZConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_PTZConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfiguration, SOAP_TYPE__tptz__GetConfiguration, sizeof(struct _tptz__GetConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetConfiguration * SOAP_FMAC4 soap_new__tptz__GetConfiguration(struct soap *soap, int n)
{
	struct _tptz__GetConfiguration *p;
	struct _tptz__GetConfiguration *a = (struct _tptz__GetConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfiguration(struct soap *soap, const struct _tptz__GetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetConfiguration(soap, tag ? tag : "tptz:GetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfiguration * SOAP_FMAC4 soap_get__tptz__GetConfiguration(struct soap *soap, struct _tptz__GetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurationsResponse(struct soap *soap, struct _tptz__GetConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePTZConfiguration = 0;
	a->PTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurationsResponse(struct soap *soap, const struct _tptz__GetConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PTZConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZConfiguration; i++)
		{
			soap_embedded(soap, a->PTZConfiguration + i, SOAP_TYPE_tt__PTZConfiguration);
			soap_serialize_tt__PTZConfiguration(soap, a->PTZConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePTZConfiguration");
	if (a->PTZConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZConfiguration; i++)
			if (soap_out_tt__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, a->PTZConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurationsResponse * SOAP_FMAC4 soap_in__tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PTZConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(struct _tptz__GetConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PTZConfiguration", 1, NULL))
			{	if (a->PTZConfiguration == NULL)
				{	if (soap_blist_PTZConfiguration == NULL)
						soap_blist_PTZConfiguration = soap_alloc_block(soap);
					a->PTZConfiguration = (struct tt__PTZConfiguration *)soap_push_block_max(soap, soap_blist_PTZConfiguration, sizeof(struct tt__PTZConfiguration));
					if (a->PTZConfiguration == NULL)
						return NULL;
					soap_default_tt__PTZConfiguration(soap, a->PTZConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZConfiguration(soap, "tptz:PTZConfiguration", a->PTZConfiguration, "tt:PTZConfiguration"))
				{	a->__sizePTZConfiguration++;
					a->PTZConfiguration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePTZConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PTZConfiguration)
			soap_pop_block(soap, soap_blist_PTZConfiguration);
		if (a->__sizePTZConfiguration)
		{	a->PTZConfiguration = (struct tt__PTZConfiguration *)soap_save_block(soap, soap_blist_PTZConfiguration, NULL, 1);
		}
		else
		{	a->PTZConfiguration = NULL;
			if (soap_blist_PTZConfiguration)
				soap_end_block(soap, soap_blist_PTZConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationsResponse, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(struct _tptz__GetConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetConfigurationsResponse * SOAP_FMAC4 soap_new__tptz__GetConfigurationsResponse(struct soap *soap, int n)
{
	struct _tptz__GetConfigurationsResponse *p;
	struct _tptz__GetConfigurationsResponse *a = (struct _tptz__GetConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurationsResponse(struct soap *soap, const struct _tptz__GetConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetConfigurationsResponse(soap, tag ? tag : "tptz:GetConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationsResponse * SOAP_FMAC4 soap_get__tptz__GetConfigurationsResponse(struct soap *soap, struct _tptz__GetConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurations(struct soap *soap, struct _tptz__GetConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurations(struct soap *soap, const struct _tptz__GetConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurations(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurations * SOAP_FMAC4 soap_in__tptz__GetConfigurations(struct soap *soap, const char *tag, struct _tptz__GetConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurations, sizeof(struct _tptz__GetConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurations, SOAP_TYPE__tptz__GetConfigurations, sizeof(struct _tptz__GetConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetConfigurations * SOAP_FMAC4 soap_new__tptz__GetConfigurations(struct soap *soap, int n)
{
	struct _tptz__GetConfigurations *p;
	struct _tptz__GetConfigurations *a = (struct _tptz__GetConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetConfigurations));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurations(struct soap *soap, const struct _tptz__GetConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetConfigurations(soap, tag ? tag : "tptz:GetConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurations * SOAP_FMAC4 soap_get__tptz__GetConfigurations(struct soap *soap, struct _tptz__GetConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetNodeResponse(struct soap *soap, struct _tptz__GetNodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZNode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetNodeResponse(struct soap *soap, const struct _tptz__GetNodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZNode(soap, &a->PTZNode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNodeResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetNodeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNodeResponse), type))
		return soap->error;
	if (a->PTZNode)
		soap_element_result(soap, "tptz:PTZNode");
	if (!a->PTZNode)
	{	if (soap_element_empty(soap, "tptz:PTZNode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZNode(soap, "tptz:PTZNode", -1, &a->PTZNode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetNodeResponse * SOAP_FMAC4 soap_in__tptz__GetNodeResponse(struct soap *soap, const char *tag, struct _tptz__GetNodeResponse *a, const char *type)
{
	size_t soap_flag_PTZNode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetNodeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodeResponse, sizeof(struct _tptz__GetNodeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetNodeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZNode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZNode(soap, "tptz:PTZNode", &a->PTZNode, "tt:PTZNode"))
				{	soap_flag_PTZNode--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PTZNode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PTZNode))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetNodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodeResponse, SOAP_TYPE__tptz__GetNodeResponse, sizeof(struct _tptz__GetNodeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetNodeResponse * SOAP_FMAC4 soap_new__tptz__GetNodeResponse(struct soap *soap, int n)
{
	struct _tptz__GetNodeResponse *p;
	struct _tptz__GetNodeResponse *a = (struct _tptz__GetNodeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetNodeResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetNodeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetNodeResponse(struct soap *soap, const struct _tptz__GetNodeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetNodeResponse(soap, tag ? tag : "tptz:GetNodeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodeResponse * SOAP_FMAC4 soap_get__tptz__GetNodeResponse(struct soap *soap, struct _tptz__GetNodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetNode(struct soap *soap, struct _tptz__GetNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->NodeToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetNode(struct soap *soap, const struct _tptz__GetNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->NodeToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNode(struct soap *soap, const char *tag, int id, const struct _tptz__GetNode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNode), type))
		return soap->error;
	if (!a->NodeToken)
	{	if (soap_element_empty(soap, "tptz:NodeToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:NodeToken", -1, (char*const*)&a->NodeToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetNode * SOAP_FMAC4 soap_in__tptz__GetNode(struct soap *soap, const char *tag, struct _tptz__GetNode *a, const char *type)
{
	size_t soap_flag_NodeToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetNode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNode, sizeof(struct _tptz__GetNode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetNode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NodeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:NodeToken", (char**)&a->NodeToken, "tt:ReferenceToken"))
				{	soap_flag_NodeToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->NodeToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNode, SOAP_TYPE__tptz__GetNode, sizeof(struct _tptz__GetNode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetNode * SOAP_FMAC4 soap_new__tptz__GetNode(struct soap *soap, int n)
{
	struct _tptz__GetNode *p;
	struct _tptz__GetNode *a = (struct _tptz__GetNode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetNode));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetNode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetNode(struct soap *soap, const struct _tptz__GetNode *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetNode(soap, tag ? tag : "tptz:GetNode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNode * SOAP_FMAC4 soap_get__tptz__GetNode(struct soap *soap, struct _tptz__GetNode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZNode(struct soap *soap, struct tt__PTZNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__Name(soap, &a->Name);
	a->SupportedPTZSpaces = NULL;
	soap_default_int(soap, &a->MaximumNumberOfPresets);
	soap_default_xsd__boolean(soap, &a->HomeSupported);
	a->__sizeAuxiliaryCommands = 0;
	a->AuxiliaryCommands = NULL;
	a->Extension = NULL;
	a->FixedHomePosition = NULL;
	a->GeoMove = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZNode(struct soap *soap, const struct tt__PTZNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__PTZSpaces(soap, &a->SupportedPTZSpaces);
	soap_embedded(soap, &a->MaximumNumberOfPresets, SOAP_TYPE_int);
	soap_embedded(soap, &a->HomeSupported, SOAP_TYPE_xsd__boolean);
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuxiliaryCommands; i++)
		{
			soap_serialize_tt__AuxiliaryData(soap, (char*const*)(a->AuxiliaryCommands + i));
		}
	}
	soap_serialize_PointerTott__PTZNodeExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNode(struct soap *soap, const char *tag, int id, const struct tt__PTZNode *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (a->FixedHomePosition)
	{	soap_set_attr(soap, "FixedHomePosition", soap_xsd__boolean2s(soap, *a->FixedHomePosition), 1);
	}
	if (a->GeoMove)
	{	soap_set_attr(soap, "GeoMove", soap_xsd__boolean2s(soap, *a->GeoMove), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNode), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (!a->SupportedPTZSpaces)
	{	if (soap_element_empty(soap, "tt:SupportedPTZSpaces", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", -1, &a->SupportedPTZSpaces, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfPresets", -1, &a->MaximumNumberOfPresets, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:HomeSupported", -1, &a->HomeSupported, ""))
		return soap->error;
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuxiliaryCommands; i++)
			if (soap_out_string(soap, "tt:AuxiliaryCommands", -1, (char*const*)(a->AuxiliaryCommands + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PTZNodeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZNode * SOAP_FMAC4 soap_in_tt__PTZNode(struct soap *soap, const char *tag, struct tt__PTZNode *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_SupportedPTZSpaces = 1;
	size_t soap_flag_MaximumNumberOfPresets = 1;
	size_t soap_flag_HomeSupported = 1;
	struct soap_blist *soap_blist_AuxiliaryCommands = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__PTZNode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNode, sizeof(struct tt__PTZNode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZNode(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "FixedHomePosition", 5, 0);
		if (t)
		{
			if (!(a->FixedHomePosition = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->FixedHomePosition))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoMove", 5, 0);
		if (t)
		{
			if (!(a->GeoMove = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->GeoMove))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_SupportedPTZSpaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", &a->SupportedPTZSpaces, "tt:PTZSpaces"))
				{	soap_flag_SupportedPTZSpaces--;
					continue;
				}
			}
			if (soap_flag_MaximumNumberOfPresets && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumNumberOfPresets", &a->MaximumNumberOfPresets, "xsd:int"))
				{	soap_flag_MaximumNumberOfPresets--;
					continue;
				}
			}
			if (soap_flag_HomeSupported && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:HomeSupported", &a->HomeSupported, "xsd:boolean"))
				{	soap_flag_HomeSupported--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuxiliaryCommands", 1, NULL))
			{	if (a->AuxiliaryCommands == NULL)
				{	if (soap_blist_AuxiliaryCommands == NULL)
						soap_blist_AuxiliaryCommands = soap_alloc_block(soap);
					a->AuxiliaryCommands = (char **)soap_push_block_max(soap, soap_blist_AuxiliaryCommands, sizeof(char *));
					if (a->AuxiliaryCommands == NULL)
						return NULL;
					*a->AuxiliaryCommands = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__AuxiliaryData(soap, "tt:AuxiliaryCommands", (char**)a->AuxiliaryCommands, "tt:AuxiliaryData"))
				{	a->__sizeAuxiliaryCommands++;
					a->AuxiliaryCommands = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZNodeExtension(soap, "tt:Extension", &a->Extension, "tt:PTZNodeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AuxiliaryCommands)
			soap_pop_block(soap, soap_blist_AuxiliaryCommands);
		if (a->__sizeAuxiliaryCommands)
		{	a->AuxiliaryCommands = (char **)soap_save_block(soap, soap_blist_AuxiliaryCommands, NULL, 1);
		}
		else
		{	a->AuxiliaryCommands = NULL;
			if (soap_blist_AuxiliaryCommands)
				soap_end_block(soap, soap_blist_AuxiliaryCommands);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SupportedPTZSpaces || soap_flag_MaximumNumberOfPresets > 0 || soap_flag_HomeSupported > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNode, SOAP_TYPE_tt__PTZNode, sizeof(struct tt__PTZNode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZNode * SOAP_FMAC4 soap_new_tt__PTZNode(struct soap *soap, int n)
{
	struct tt__PTZNode *p;
	struct tt__PTZNode *a = (struct tt__PTZNode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZNode));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZNode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZNode(struct soap *soap, const struct tt__PTZNode *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZNode(soap, tag ? tag : "tt:PTZNode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNode * SOAP_FMAC4 soap_get_tt__PTZNode(struct soap *soap, struct tt__PTZNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetNodesResponse(struct soap *soap, struct _tptz__GetNodesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePTZNode = 0;
	a->PTZNode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetNodesResponse(struct soap *soap, const struct _tptz__GetNodesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PTZNode)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZNode; i++)
		{
			soap_embedded(soap, a->PTZNode + i, SOAP_TYPE_tt__PTZNode);
			soap_serialize_tt__PTZNode(soap, a->PTZNode + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNodesResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetNodesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNodesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePTZNode");
	if (a->PTZNode)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZNode; i++)
			if (soap_out_tt__PTZNode(soap, "tptz:PTZNode", -1, a->PTZNode + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetNodesResponse * SOAP_FMAC4 soap_in__tptz__GetNodesResponse(struct soap *soap, const char *tag, struct _tptz__GetNodesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PTZNode = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetNodesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodesResponse, sizeof(struct _tptz__GetNodesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetNodesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PTZNode", 1, NULL))
			{	if (a->PTZNode == NULL)
				{	if (soap_blist_PTZNode == NULL)
						soap_blist_PTZNode = soap_alloc_block(soap);
					a->PTZNode = (struct tt__PTZNode *)soap_push_block_max(soap, soap_blist_PTZNode, sizeof(struct tt__PTZNode));
					if (a->PTZNode == NULL)
						return NULL;
					soap_default_tt__PTZNode(soap, a->PTZNode);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZNode(soap, "tptz:PTZNode", a->PTZNode, "tt:PTZNode"))
				{	a->__sizePTZNode++;
					a->PTZNode = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePTZNode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PTZNode)
			soap_pop_block(soap, soap_blist_PTZNode);
		if (a->__sizePTZNode)
		{	a->PTZNode = (struct tt__PTZNode *)soap_save_block(soap, soap_blist_PTZNode, NULL, 1);
		}
		else
		{	a->PTZNode = NULL;
			if (soap_blist_PTZNode)
				soap_end_block(soap, soap_blist_PTZNode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodesResponse, SOAP_TYPE__tptz__GetNodesResponse, sizeof(struct _tptz__GetNodesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetNodesResponse * SOAP_FMAC4 soap_new__tptz__GetNodesResponse(struct soap *soap, int n)
{
	struct _tptz__GetNodesResponse *p;
	struct _tptz__GetNodesResponse *a = (struct _tptz__GetNodesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetNodesResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetNodesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetNodesResponse(struct soap *soap, const struct _tptz__GetNodesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetNodesResponse(soap, tag ? tag : "tptz:GetNodesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodesResponse * SOAP_FMAC4 soap_get__tptz__GetNodesResponse(struct soap *soap, struct _tptz__GetNodesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNodesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetNodes(struct soap *soap, struct _tptz__GetNodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetNodes(struct soap *soap, const struct _tptz__GetNodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNodes(struct soap *soap, const char *tag, int id, const struct _tptz__GetNodes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNodes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetNodes * SOAP_FMAC4 soap_in__tptz__GetNodes(struct soap *soap, const char *tag, struct _tptz__GetNodes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetNodes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodes, sizeof(struct _tptz__GetNodes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetNodes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodes, SOAP_TYPE__tptz__GetNodes, sizeof(struct _tptz__GetNodes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetNodes * SOAP_FMAC4 soap_new__tptz__GetNodes(struct soap *soap, int n)
{
	struct _tptz__GetNodes *p;
	struct _tptz__GetNodes *a = (struct _tptz__GetNodes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetNodes));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetNodes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetNodes(struct soap *soap, const struct _tptz__GetNodes *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetNodes(soap, tag ? tag : "tptz:GetNodes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodes * SOAP_FMAC4 soap_get__tptz__GetNodes(struct soap *soap, struct _tptz__GetNodes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetServiceCapabilitiesResponse(struct soap *soap, struct _tptz__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tptz__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotptz__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tptz:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tptz:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotptz__Capabilities(soap, "tptz:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tptz__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(struct _tptz__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotptz__Capabilities(soap, "tptz:Capabilities", &a->Capabilities, "tptz:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(struct _tptz__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tptz__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tptz__GetServiceCapabilitiesResponse *p;
	struct _tptz__GetServiceCapabilitiesResponse *a = (struct _tptz__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tptz__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetServiceCapabilitiesResponse(soap, tag ? tag : "tptz:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tptz__GetServiceCapabilitiesResponse(struct soap *soap, struct _tptz__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetServiceCapabilities(struct soap *soap, struct _tptz__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetServiceCapabilities(struct soap *soap, const struct _tptz__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tptz__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilities * SOAP_FMAC4 soap_in__tptz__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tptz__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(struct _tptz__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetServiceCapabilities, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(struct _tptz__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilities * SOAP_FMAC4 soap_new__tptz__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tptz__GetServiceCapabilities *p;
	struct _tptz__GetServiceCapabilities *a = (struct _tptz__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetServiceCapabilities(struct soap *soap, const struct _tptz__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetServiceCapabilities(soap, tag ? tag : "tptz:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilities * SOAP_FMAC4 soap_get__tptz__GetServiceCapabilities(struct soap *soap, struct _tptz__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tptz__Capabilities(struct soap *soap, struct tptz__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->EFlip = NULL;
	a->Reverse = NULL;
	a->GetCompatibleConfigurations = NULL;
	a->MoveStatus = NULL;
	a->StatusPosition = NULL;
	soap_default_tt__StringList(soap, &a->MoveAndTrack);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tptz__Capabilities(struct soap *soap, const struct tptz__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tptz__Capabilities(struct soap *soap, const char *tag, int id, const struct tptz__Capabilities *a, const char *type)
{
	if (a->EFlip)
	{	soap_set_attr(soap, "EFlip", soap_xsd__boolean2s(soap, *a->EFlip), 1);
	}
	if (a->Reverse)
	{	soap_set_attr(soap, "Reverse", soap_xsd__boolean2s(soap, *a->Reverse), 1);
	}
	if (a->GetCompatibleConfigurations)
	{	soap_set_attr(soap, "GetCompatibleConfigurations", soap_xsd__boolean2s(soap, *a->GetCompatibleConfigurations), 1);
	}
	if (a->MoveStatus)
	{	soap_set_attr(soap, "MoveStatus", soap_xsd__boolean2s(soap, *a->MoveStatus), 1);
	}
	if (a->StatusPosition)
	{	soap_set_attr(soap, "StatusPosition", soap_xsd__boolean2s(soap, *a->StatusPosition), 1);
	}
	if (a->MoveAndTrack)
		soap_set_attr(soap, "MoveAndTrack", soap_tt__StringList2s(soap, a->MoveAndTrack), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tptz__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tptz__Capabilities * SOAP_FMAC4 soap_in_tptz__Capabilities(struct soap *soap, const char *tag, struct tptz__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tptz__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tptz__Capabilities, sizeof(struct tptz__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tptz__Capabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "EFlip", 5, 0);
		if (t)
		{
			if (!(a->EFlip = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->EFlip))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Reverse", 5, 0);
		if (t)
		{
			if (!(a->Reverse = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Reverse))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GetCompatibleConfigurations", 5, 0);
		if (t)
		{
			if (!(a->GetCompatibleConfigurations = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->GetCompatibleConfigurations))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MoveStatus", 5, 0);
		if (t)
		{
			if (!(a->MoveStatus = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->MoveStatus))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "StatusPosition", 5, 0);
		if (t)
		{
			if (!(a->StatusPosition = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->StatusPosition))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__StringList(soap, soap_attr_value(soap, "MoveAndTrack", 1, 0), &a->MoveAndTrack))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tptz__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tptz__Capabilities, SOAP_TYPE_tptz__Capabilities, sizeof(struct tptz__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tptz__Capabilities * SOAP_FMAC4 soap_new_tptz__Capabilities(struct soap *soap, int n)
{
	struct tptz__Capabilities *p;
	struct tptz__Capabilities *a = (struct tptz__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tptz__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tptz__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tptz__Capabilities(struct soap *soap, const struct tptz__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tptz__Capabilities(soap, tag ? tag : "tptz:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tptz__Capabilities * SOAP_FMAC4 soap_get_tptz__Capabilities(struct soap *soap, struct tptz__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tptz__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ReceiverState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiverStateResponse(struct soap *soap, const struct _trv__GetReceiverStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ReceiverStateInformation(soap, &a->ReceiverState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiverStateResponse(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiverStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiverStateResponse), type))
		return soap->error;
	if (a->ReceiverState)
		soap_element_result(soap, "trv:ReceiverState");
	if (!a->ReceiverState)
	{	if (soap_element_empty(soap, "trv:ReceiverState", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ReceiverStateInformation(soap, "trv:ReceiverState", -1, &a->ReceiverState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse * SOAP_FMAC4 soap_in__trv__GetReceiverStateResponse(struct soap *soap, const char *tag, struct _trv__GetReceiverStateResponse *a, const char *type)
{
	size_t soap_flag_ReceiverState = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__GetReceiverStateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiverStateResponse, sizeof(struct _trv__GetReceiverStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiverStateResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReceiverStateInformation(soap, "trv:ReceiverState", &a->ReceiverState, "tt:ReceiverStateInformation"))
				{	soap_flag_ReceiverState--;
					continue;
				}
			}
			soap_check_result(soap, "trv:ReceiverState");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ReceiverState))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiverStateResponse, SOAP_TYPE__trv__GetReceiverStateResponse, sizeof(struct _trv__GetReceiverStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse * SOAP_FMAC4 soap_new__trv__GetReceiverStateResponse(struct soap *soap, int n)
{
	struct _trv__GetReceiverStateResponse *p;
	struct _trv__GetReceiverStateResponse *a = (struct _trv__GetReceiverStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetReceiverStateResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__GetReceiverStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiverStateResponse(struct soap *soap, const struct _trv__GetReceiverStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetReceiverStateResponse(soap, tag ? tag : "trv:GetReceiverStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse * SOAP_FMAC4 soap_get__trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiverStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiverState(struct soap *soap, const struct _trv__GetReceiverState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ReceiverToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiverState(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiverState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiverState), type))
		return soap->error;
	if (!a->ReceiverToken)
	{	if (soap_element_empty(soap, "trv:ReceiverToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, (char*const*)&a->ReceiverToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiverState * SOAP_FMAC4 soap_in__trv__GetReceiverState(struct soap *soap, const char *tag, struct _trv__GetReceiverState *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__GetReceiverState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiverState, sizeof(struct _trv__GetReceiverState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiverState(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", (char**)&a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ReceiverToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiverState, SOAP_TYPE__trv__GetReceiverState, sizeof(struct _trv__GetReceiverState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetReceiverState * SOAP_FMAC4 soap_new__trv__GetReceiverState(struct soap *soap, int n)
{
	struct _trv__GetReceiverState *p;
	struct _trv__GetReceiverState *a = (struct _trv__GetReceiverState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetReceiverState));
	for (p = a; p && n--; p++)
		soap_default__trv__GetReceiverState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiverState(struct soap *soap, const struct _trv__GetReceiverState *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetReceiverState(soap, tag ? tag : "trv:GetReceiverState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverState * SOAP_FMAC4 soap_get__trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiverState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__SetReceiverModeResponse(struct soap *soap, const struct _trv__SetReceiverModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__SetReceiverModeResponse(struct soap *soap, const char *tag, int id, const struct _trv__SetReceiverModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__SetReceiverModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse * SOAP_FMAC4 soap_in__trv__SetReceiverModeResponse(struct soap *soap, const char *tag, struct _trv__SetReceiverModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__SetReceiverModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__SetReceiverModeResponse, sizeof(struct _trv__SetReceiverModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__SetReceiverModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__SetReceiverModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__SetReceiverModeResponse, SOAP_TYPE__trv__SetReceiverModeResponse, sizeof(struct _trv__SetReceiverModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse * SOAP_FMAC4 soap_new__trv__SetReceiverModeResponse(struct soap *soap, int n)
{
	struct _trv__SetReceiverModeResponse *p;
	struct _trv__SetReceiverModeResponse *a = (struct _trv__SetReceiverModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__SetReceiverModeResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__SetReceiverModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__SetReceiverModeResponse(struct soap *soap, const struct _trv__SetReceiverModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__SetReceiverModeResponse(soap, tag ? tag : "trv:SetReceiverModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse * SOAP_FMAC4 soap_get__trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__SetReceiverModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
	soap_default_tt__ReceiverMode(soap, &a->Mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__SetReceiverMode(struct soap *soap, const struct _trv__SetReceiverMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ReceiverToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__SetReceiverMode(struct soap *soap, const char *tag, int id, const struct _trv__SetReceiverMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__SetReceiverMode), type))
		return soap->error;
	if (!a->ReceiverToken)
	{	if (soap_element_empty(soap, "trv:ReceiverToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, (char*const*)&a->ReceiverToken, ""))
		return soap->error;
	if (soap_out_tt__ReceiverMode(soap, "trv:Mode", -1, &a->Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__SetReceiverMode * SOAP_FMAC4 soap_in__trv__SetReceiverMode(struct soap *soap, const char *tag, struct _trv__SetReceiverMode *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	size_t soap_flag_Mode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__SetReceiverMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__SetReceiverMode, sizeof(struct _trv__SetReceiverMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__SetReceiverMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", (char**)&a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			}
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ReceiverMode(soap, "trv:Mode", &a->Mode, "tt:ReceiverMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ReceiverToken || soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__SetReceiverMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__SetReceiverMode, SOAP_TYPE__trv__SetReceiverMode, sizeof(struct _trv__SetReceiverMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__SetReceiverMode * SOAP_FMAC4 soap_new__trv__SetReceiverMode(struct soap *soap, int n)
{
	struct _trv__SetReceiverMode *p;
	struct _trv__SetReceiverMode *a = (struct _trv__SetReceiverMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__SetReceiverMode));
	for (p = a; p && n--; p++)
		soap_default__trv__SetReceiverMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__SetReceiverMode(struct soap *soap, const struct _trv__SetReceiverMode *a, const char *tag, const char *type)
{
	if (soap_out__trv__SetReceiverMode(soap, tag ? tag : "trv:SetReceiverMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__SetReceiverMode * SOAP_FMAC4 soap_get__trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__SetReceiverMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__ConfigureReceiverResponse(struct soap *soap, struct _trv__ConfigureReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__ConfigureReceiverResponse(struct soap *soap, const struct _trv__ConfigureReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__ConfigureReceiverResponse(struct soap *soap, const char *tag, int id, const struct _trv__ConfigureReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__ConfigureReceiverResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__ConfigureReceiverResponse * SOAP_FMAC4 soap_in__trv__ConfigureReceiverResponse(struct soap *soap, const char *tag, struct _trv__ConfigureReceiverResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__ConfigureReceiverResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__ConfigureReceiverResponse, sizeof(struct _trv__ConfigureReceiverResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__ConfigureReceiverResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__ConfigureReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__ConfigureReceiverResponse, SOAP_TYPE__trv__ConfigureReceiverResponse, sizeof(struct _trv__ConfigureReceiverResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__ConfigureReceiverResponse * SOAP_FMAC4 soap_new__trv__ConfigureReceiverResponse(struct soap *soap, int n)
{
	struct _trv__ConfigureReceiverResponse *p;
	struct _trv__ConfigureReceiverResponse *a = (struct _trv__ConfigureReceiverResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__ConfigureReceiverResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__ConfigureReceiverResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__ConfigureReceiverResponse(struct soap *soap, const struct _trv__ConfigureReceiverResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__ConfigureReceiverResponse(soap, tag ? tag : "trv:ConfigureReceiverResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__ConfigureReceiverResponse * SOAP_FMAC4 soap_get__trv__ConfigureReceiverResponse(struct soap *soap, struct _trv__ConfigureReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__ConfigureReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__ConfigureReceiver(struct soap *soap, struct _trv__ConfigureReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__ConfigureReceiver(struct soap *soap, const struct _trv__ConfigureReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ReceiverToken);
	soap_serialize_PointerTott__ReceiverConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__ConfigureReceiver(struct soap *soap, const char *tag, int id, const struct _trv__ConfigureReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__ConfigureReceiver), type))
		return soap->error;
	if (!a->ReceiverToken)
	{	if (soap_element_empty(soap, "trv:ReceiverToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, (char*const*)&a->ReceiverToken, ""))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "trv:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ReceiverConfiguration(soap, "trv:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__ConfigureReceiver * SOAP_FMAC4 soap_in__trv__ConfigureReceiver(struct soap *soap, const char *tag, struct _trv__ConfigureReceiver *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__ConfigureReceiver*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__ConfigureReceiver, sizeof(struct _trv__ConfigureReceiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__ConfigureReceiver(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", (char**)&a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReceiverConfiguration(soap, "trv:Configuration", &a->Configuration, "tt:ReceiverConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ReceiverToken || !a->Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__ConfigureReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__ConfigureReceiver, SOAP_TYPE__trv__ConfigureReceiver, sizeof(struct _trv__ConfigureReceiver), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__ConfigureReceiver * SOAP_FMAC4 soap_new__trv__ConfigureReceiver(struct soap *soap, int n)
{
	struct _trv__ConfigureReceiver *p;
	struct _trv__ConfigureReceiver *a = (struct _trv__ConfigureReceiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__ConfigureReceiver));
	for (p = a; p && n--; p++)
		soap_default__trv__ConfigureReceiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__ConfigureReceiver(struct soap *soap, const struct _trv__ConfigureReceiver *a, const char *tag, const char *type)
{
	if (soap_out__trv__ConfigureReceiver(soap, tag ? tag : "trv:ConfigureReceiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__ConfigureReceiver * SOAP_FMAC4 soap_get__trv__ConfigureReceiver(struct soap *soap, struct _trv__ConfigureReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__ConfigureReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__DeleteReceiverResponse(struct soap *soap, struct _trv__DeleteReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__DeleteReceiverResponse(struct soap *soap, const struct _trv__DeleteReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__DeleteReceiverResponse(struct soap *soap, const char *tag, int id, const struct _trv__DeleteReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__DeleteReceiverResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__DeleteReceiverResponse * SOAP_FMAC4 soap_in__trv__DeleteReceiverResponse(struct soap *soap, const char *tag, struct _trv__DeleteReceiverResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__DeleteReceiverResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__DeleteReceiverResponse, sizeof(struct _trv__DeleteReceiverResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__DeleteReceiverResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__DeleteReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__DeleteReceiverResponse, SOAP_TYPE__trv__DeleteReceiverResponse, sizeof(struct _trv__DeleteReceiverResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__DeleteReceiverResponse * SOAP_FMAC4 soap_new__trv__DeleteReceiverResponse(struct soap *soap, int n)
{
	struct _trv__DeleteReceiverResponse *p;
	struct _trv__DeleteReceiverResponse *a = (struct _trv__DeleteReceiverResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__DeleteReceiverResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__DeleteReceiverResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__DeleteReceiverResponse(struct soap *soap, const struct _trv__DeleteReceiverResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__DeleteReceiverResponse(soap, tag ? tag : "trv:DeleteReceiverResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__DeleteReceiverResponse * SOAP_FMAC4 soap_get__trv__DeleteReceiverResponse(struct soap *soap, struct _trv__DeleteReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__DeleteReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__DeleteReceiver(struct soap *soap, struct _trv__DeleteReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__DeleteReceiver(struct soap *soap, const struct _trv__DeleteReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ReceiverToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__DeleteReceiver(struct soap *soap, const char *tag, int id, const struct _trv__DeleteReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__DeleteReceiver), type))
		return soap->error;
	if (!a->ReceiverToken)
	{	if (soap_element_empty(soap, "trv:ReceiverToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, (char*const*)&a->ReceiverToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__DeleteReceiver * SOAP_FMAC4 soap_in__trv__DeleteReceiver(struct soap *soap, const char *tag, struct _trv__DeleteReceiver *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__DeleteReceiver*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__DeleteReceiver, sizeof(struct _trv__DeleteReceiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__DeleteReceiver(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", (char**)&a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ReceiverToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__DeleteReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__DeleteReceiver, SOAP_TYPE__trv__DeleteReceiver, sizeof(struct _trv__DeleteReceiver), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__DeleteReceiver * SOAP_FMAC4 soap_new__trv__DeleteReceiver(struct soap *soap, int n)
{
	struct _trv__DeleteReceiver *p;
	struct _trv__DeleteReceiver *a = (struct _trv__DeleteReceiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__DeleteReceiver));
	for (p = a; p && n--; p++)
		soap_default__trv__DeleteReceiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__DeleteReceiver(struct soap *soap, const struct _trv__DeleteReceiver *a, const char *tag, const char *type)
{
	if (soap_out__trv__DeleteReceiver(soap, tag ? tag : "trv:DeleteReceiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__DeleteReceiver * SOAP_FMAC4 soap_get__trv__DeleteReceiver(struct soap *soap, struct _trv__DeleteReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__DeleteReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__CreateReceiverResponse(struct soap *soap, struct _trv__CreateReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Receiver = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__CreateReceiverResponse(struct soap *soap, const struct _trv__CreateReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Receiver(soap, &a->Receiver);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__CreateReceiverResponse(struct soap *soap, const char *tag, int id, const struct _trv__CreateReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__CreateReceiverResponse), type))
		return soap->error;
	if (a->Receiver)
		soap_element_result(soap, "trv:Receiver");
	if (!a->Receiver)
	{	if (soap_element_empty(soap, "trv:Receiver", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Receiver(soap, "trv:Receiver", -1, &a->Receiver, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__CreateReceiverResponse * SOAP_FMAC4 soap_in__trv__CreateReceiverResponse(struct soap *soap, const char *tag, struct _trv__CreateReceiverResponse *a, const char *type)
{
	size_t soap_flag_Receiver = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__CreateReceiverResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__CreateReceiverResponse, sizeof(struct _trv__CreateReceiverResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__CreateReceiverResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Receiver && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Receiver(soap, "trv:Receiver", &a->Receiver, "tt:Receiver"))
				{	soap_flag_Receiver--;
					continue;
				}
			}
			soap_check_result(soap, "trv:Receiver");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Receiver))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__CreateReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__CreateReceiverResponse, SOAP_TYPE__trv__CreateReceiverResponse, sizeof(struct _trv__CreateReceiverResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__CreateReceiverResponse * SOAP_FMAC4 soap_new__trv__CreateReceiverResponse(struct soap *soap, int n)
{
	struct _trv__CreateReceiverResponse *p;
	struct _trv__CreateReceiverResponse *a = (struct _trv__CreateReceiverResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__CreateReceiverResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__CreateReceiverResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__CreateReceiverResponse(struct soap *soap, const struct _trv__CreateReceiverResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__CreateReceiverResponse(soap, tag ? tag : "trv:CreateReceiverResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__CreateReceiverResponse * SOAP_FMAC4 soap_get__trv__CreateReceiverResponse(struct soap *soap, struct _trv__CreateReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__CreateReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__CreateReceiver(struct soap *soap, struct _trv__CreateReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__CreateReceiver(struct soap *soap, const struct _trv__CreateReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ReceiverConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__CreateReceiver(struct soap *soap, const char *tag, int id, const struct _trv__CreateReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__CreateReceiver), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "trv:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ReceiverConfiguration(soap, "trv:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__CreateReceiver * SOAP_FMAC4 soap_in__trv__CreateReceiver(struct soap *soap, const char *tag, struct _trv__CreateReceiver *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__CreateReceiver*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__CreateReceiver, sizeof(struct _trv__CreateReceiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__CreateReceiver(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReceiverConfiguration(soap, "trv:Configuration", &a->Configuration, "tt:ReceiverConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__CreateReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__CreateReceiver, SOAP_TYPE__trv__CreateReceiver, sizeof(struct _trv__CreateReceiver), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__CreateReceiver * SOAP_FMAC4 soap_new__trv__CreateReceiver(struct soap *soap, int n)
{
	struct _trv__CreateReceiver *p;
	struct _trv__CreateReceiver *a = (struct _trv__CreateReceiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__CreateReceiver));
	for (p = a; p && n--; p++)
		soap_default__trv__CreateReceiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__CreateReceiver(struct soap *soap, const struct _trv__CreateReceiver *a, const char *tag, const char *type)
{
	if (soap_out__trv__CreateReceiver(soap, tag ? tag : "trv:CreateReceiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__CreateReceiver * SOAP_FMAC4 soap_get__trv__CreateReceiver(struct soap *soap, struct _trv__CreateReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__CreateReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiverResponse(struct soap *soap, struct _trv__GetReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Receiver = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiverResponse(struct soap *soap, const struct _trv__GetReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Receiver(soap, &a->Receiver);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiverResponse(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiverResponse), type))
		return soap->error;
	if (a->Receiver)
		soap_element_result(soap, "trv:Receiver");
	if (!a->Receiver)
	{	if (soap_element_empty(soap, "trv:Receiver", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Receiver(soap, "trv:Receiver", -1, &a->Receiver, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiverResponse * SOAP_FMAC4 soap_in__trv__GetReceiverResponse(struct soap *soap, const char *tag, struct _trv__GetReceiverResponse *a, const char *type)
{
	size_t soap_flag_Receiver = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__GetReceiverResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiverResponse, sizeof(struct _trv__GetReceiverResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiverResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Receiver && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Receiver(soap, "trv:Receiver", &a->Receiver, "tt:Receiver"))
				{	soap_flag_Receiver--;
					continue;
				}
			}
			soap_check_result(soap, "trv:Receiver");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Receiver))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiverResponse, SOAP_TYPE__trv__GetReceiverResponse, sizeof(struct _trv__GetReceiverResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetReceiverResponse * SOAP_FMAC4 soap_new__trv__GetReceiverResponse(struct soap *soap, int n)
{
	struct _trv__GetReceiverResponse *p;
	struct _trv__GetReceiverResponse *a = (struct _trv__GetReceiverResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetReceiverResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__GetReceiverResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiverResponse(struct soap *soap, const struct _trv__GetReceiverResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetReceiverResponse(soap, tag ? tag : "trv:GetReceiverResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverResponse * SOAP_FMAC4 soap_get__trv__GetReceiverResponse(struct soap *soap, struct _trv__GetReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiver(struct soap *soap, struct _trv__GetReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiver(struct soap *soap, const struct _trv__GetReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ReceiverToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiver(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiver), type))
		return soap->error;
	if (!a->ReceiverToken)
	{	if (soap_element_empty(soap, "trv:ReceiverToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, (char*const*)&a->ReceiverToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiver * SOAP_FMAC4 soap_in__trv__GetReceiver(struct soap *soap, const char *tag, struct _trv__GetReceiver *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__GetReceiver*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiver, sizeof(struct _trv__GetReceiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiver(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", (char**)&a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ReceiverToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__GetReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiver, SOAP_TYPE__trv__GetReceiver, sizeof(struct _trv__GetReceiver), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetReceiver * SOAP_FMAC4 soap_new__trv__GetReceiver(struct soap *soap, int n)
{
	struct _trv__GetReceiver *p;
	struct _trv__GetReceiver *a = (struct _trv__GetReceiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetReceiver));
	for (p = a; p && n--; p++)
		soap_default__trv__GetReceiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiver(struct soap *soap, const struct _trv__GetReceiver *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetReceiver(soap, tag ? tag : "trv:GetReceiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiver * SOAP_FMAC4 soap_get__trv__GetReceiver(struct soap *soap, struct _trv__GetReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiversResponse(struct soap *soap, struct _trv__GetReceiversResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeReceivers = 0;
	a->Receivers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiversResponse(struct soap *soap, const struct _trv__GetReceiversResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Receivers)
	{	int i;
		for (i = 0; i < (int)a->__sizeReceivers; i++)
		{
			soap_embedded(soap, a->Receivers + i, SOAP_TYPE_tt__Receiver);
			soap_serialize_tt__Receiver(soap, a->Receivers + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiversResponse(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiversResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiversResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeReceivers");
	if (a->Receivers)
	{	int i;
		for (i = 0; i < (int)a->__sizeReceivers; i++)
			if (soap_out_tt__Receiver(soap, "trv:Receivers", -1, a->Receivers + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiversResponse * SOAP_FMAC4 soap_in__trv__GetReceiversResponse(struct soap *soap, const char *tag, struct _trv__GetReceiversResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Receivers = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__GetReceiversResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiversResponse, sizeof(struct _trv__GetReceiversResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiversResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trv:Receivers", 1, NULL))
			{	if (a->Receivers == NULL)
				{	if (soap_blist_Receivers == NULL)
						soap_blist_Receivers = soap_alloc_block(soap);
					a->Receivers = (struct tt__Receiver *)soap_push_block_max(soap, soap_blist_Receivers, sizeof(struct tt__Receiver));
					if (a->Receivers == NULL)
						return NULL;
					soap_default_tt__Receiver(soap, a->Receivers);
				}
				soap_revert(soap);
				if (soap_in_tt__Receiver(soap, "trv:Receivers", a->Receivers, "tt:Receiver"))
				{	a->__sizeReceivers++;
					a->Receivers = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeReceivers");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Receivers)
			soap_pop_block(soap, soap_blist_Receivers);
		if (a->__sizeReceivers)
		{	a->Receivers = (struct tt__Receiver *)soap_save_block(soap, soap_blist_Receivers, NULL, 1);
		}
		else
		{	a->Receivers = NULL;
			if (soap_blist_Receivers)
				soap_end_block(soap, soap_blist_Receivers);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiversResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiversResponse, SOAP_TYPE__trv__GetReceiversResponse, sizeof(struct _trv__GetReceiversResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetReceiversResponse * SOAP_FMAC4 soap_new__trv__GetReceiversResponse(struct soap *soap, int n)
{
	struct _trv__GetReceiversResponse *p;
	struct _trv__GetReceiversResponse *a = (struct _trv__GetReceiversResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetReceiversResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__GetReceiversResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiversResponse(struct soap *soap, const struct _trv__GetReceiversResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetReceiversResponse(soap, tag ? tag : "trv:GetReceiversResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiversResponse * SOAP_FMAC4 soap_get__trv__GetReceiversResponse(struct soap *soap, struct _trv__GetReceiversResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiversResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceivers(struct soap *soap, struct _trv__GetReceivers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceivers(struct soap *soap, const struct _trv__GetReceivers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceivers(struct soap *soap, const char *tag, int id, const struct _trv__GetReceivers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceivers), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceivers * SOAP_FMAC4 soap_in__trv__GetReceivers(struct soap *soap, const char *tag, struct _trv__GetReceivers *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__GetReceivers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceivers, sizeof(struct _trv__GetReceivers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceivers(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceivers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceivers, SOAP_TYPE__trv__GetReceivers, sizeof(struct _trv__GetReceivers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetReceivers * SOAP_FMAC4 soap_new__trv__GetReceivers(struct soap *soap, int n)
{
	struct _trv__GetReceivers *p;
	struct _trv__GetReceivers *a = (struct _trv__GetReceivers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetReceivers));
	for (p = a; p && n--; p++)
		soap_default__trv__GetReceivers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceivers(struct soap *soap, const struct _trv__GetReceivers *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetReceivers(soap, tag ? tag : "trv:GetReceivers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceivers * SOAP_FMAC4 soap_get__trv__GetReceivers(struct soap *soap, struct _trv__GetReceivers *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceivers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetServiceCapabilitiesResponse(struct soap *soap, struct _trv__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trv__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrv__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _trv__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "trv:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "trv:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotrv__Capabilities(soap, "trv:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__trv__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trv__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, sizeof(struct _trv__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotrv__Capabilities(soap, "trv:Capabilities", &a->Capabilities, "trv:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "trv:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, sizeof(struct _trv__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__trv__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _trv__GetServiceCapabilitiesResponse *p;
	struct _trv__GetServiceCapabilitiesResponse *a = (struct _trv__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trv__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetServiceCapabilitiesResponse(soap, tag ? tag : "trv:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__trv__GetServiceCapabilitiesResponse(struct soap *soap, struct _trv__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetServiceCapabilities(struct soap *soap, struct _trv__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetServiceCapabilities(struct soap *soap, const struct _trv__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _trv__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilities * SOAP_FMAC4 soap_in__trv__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trv__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trv__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetServiceCapabilities, sizeof(struct _trv__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetServiceCapabilities, SOAP_TYPE__trv__GetServiceCapabilities, sizeof(struct _trv__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetServiceCapabilities * SOAP_FMAC4 soap_new__trv__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _trv__GetServiceCapabilities *p;
	struct _trv__GetServiceCapabilities *a = (struct _trv__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__trv__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetServiceCapabilities(struct soap *soap, const struct _trv__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetServiceCapabilities(soap, tag ? tag : "trv:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilities * SOAP_FMAC4 soap_get__trv__GetServiceCapabilities(struct soap *soap, struct _trv__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trv__Capabilities(struct soap *soap, struct trv__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->RTP_USCOREMulticast = NULL;
	a->RTP_USCORETCP = NULL;
	a->RTP_USCORERTSP_USCORETCP = NULL;
	soap_default_int(soap, &a->SupportedReceivers);
	a->MaximumRTSPURILength = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trv__Capabilities(struct soap *soap, const struct trv__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trv__Capabilities(struct soap *soap, const char *tag, int id, const struct trv__Capabilities *a, const char *type)
{
	if (a->RTP_USCOREMulticast)
	{	soap_set_attr(soap, "RTP_Multicast", soap_xsd__boolean2s(soap, *a->RTP_USCOREMulticast), 1);
	}
	if (a->RTP_USCORETCP)
	{	soap_set_attr(soap, "RTP_TCP", soap_xsd__boolean2s(soap, *a->RTP_USCORETCP), 1);
	}
	if (a->RTP_USCORERTSP_USCORETCP)
	{	soap_set_attr(soap, "RTP_RTSP_TCP", soap_xsd__boolean2s(soap, *a->RTP_USCORERTSP_USCORETCP), 1);
	}
	soap_set_attr(soap, "SupportedReceivers", soap_int2s(soap, a->SupportedReceivers), 1);
	if (a->MaximumRTSPURILength)
	{	soap_set_attr(soap, "MaximumRTSPURILength", soap_int2s(soap, *a->MaximumRTSPURILength), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trv__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trv__Capabilities * SOAP_FMAC4 soap_in_trv__Capabilities(struct soap *soap, const char *tag, struct trv__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trv__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trv__Capabilities, sizeof(struct trv__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trv__Capabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "RTP_Multicast", 5, 0);
		if (t)
		{
			if (!(a->RTP_USCOREMulticast = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCOREMulticast))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RTP_TCP", 5, 0);
		if (t)
		{
			if (!(a->RTP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCORETCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RTP_RTSP_TCP", 5, 0);
		if (t)
		{
			if (!(a->RTP_USCORERTSP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCORERTSP_USCORETCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2int(soap, soap_attr_value(soap, "SupportedReceivers", 5, 1), &a->SupportedReceivers))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "MaximumRTSPURILength", 5, 0);
		if (t)
		{
			if (!(a->MaximumRTSPURILength = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaximumRTSPURILength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trv__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trv__Capabilities, SOAP_TYPE_trv__Capabilities, sizeof(struct trv__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trv__Capabilities * SOAP_FMAC4 soap_new_trv__Capabilities(struct soap *soap, int n)
{
	struct trv__Capabilities *p;
	struct trv__Capabilities *a = (struct trv__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trv__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_trv__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trv__Capabilities(struct soap *soap, const struct trv__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_trv__Capabilities(soap, tag ? tag : "trv:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trv__Capabilities * SOAP_FMAC4 soap_get_trv__Capabilities(struct soap *soap, struct trv__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trv__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->Endpoint);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__EndSearchResponse(struct soap *soap, const struct _tse__EndSearchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Endpoint, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__EndSearchResponse(struct soap *soap, const char *tag, int id, const struct _tse__EndSearchResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__EndSearchResponse), type))
		return soap->error;
	soap_element_result(soap, "tse:Endpoint");
	if (soap_out_dateTime(soap, "tse:Endpoint", -1, &a->Endpoint, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__EndSearchResponse * SOAP_FMAC4 soap_in__tse__EndSearchResponse(struct soap *soap, const char *tag, struct _tse__EndSearchResponse *a, const char *type)
{
	size_t soap_flag_Endpoint = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__EndSearchResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__EndSearchResponse, sizeof(struct _tse__EndSearchResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__EndSearchResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Endpoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tse:Endpoint", &a->Endpoint, "xsd:dateTime"))
				{	soap_flag_Endpoint--;
					continue;
				}
			}
			soap_check_result(soap, "tse:Endpoint");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Endpoint > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__EndSearchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__EndSearchResponse, SOAP_TYPE__tse__EndSearchResponse, sizeof(struct _tse__EndSearchResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__EndSearchResponse * SOAP_FMAC4 soap_new__tse__EndSearchResponse(struct soap *soap, int n)
{
	struct _tse__EndSearchResponse *p;
	struct _tse__EndSearchResponse *a = (struct _tse__EndSearchResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__EndSearchResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__EndSearchResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__EndSearchResponse(struct soap *soap, const struct _tse__EndSearchResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__EndSearchResponse(soap, tag ? tag : "tse:EndSearchResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__EndSearchResponse * SOAP_FMAC4 soap_get__tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__EndSearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__EndSearch(struct soap *soap, struct _tse__EndSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__EndSearch(struct soap *soap, const struct _tse__EndSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__EndSearch(struct soap *soap, const char *tag, int id, const struct _tse__EndSearch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__EndSearch), type))
		return soap->error;
	if (!a->SearchToken)
	{	if (soap_element_empty(soap, "tse:SearchToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__EndSearch * SOAP_FMAC4 soap_in__tse__EndSearch(struct soap *soap, const char *tag, struct _tse__EndSearch *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__EndSearch*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__EndSearch, sizeof(struct _tse__EndSearch), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__EndSearch(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__EndSearch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__EndSearch, SOAP_TYPE__tse__EndSearch, sizeof(struct _tse__EndSearch), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__EndSearch * SOAP_FMAC4 soap_new__tse__EndSearch(struct soap *soap, int n)
{
	struct _tse__EndSearch *p;
	struct _tse__EndSearch *a = (struct _tse__EndSearch*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__EndSearch));
	for (p = a; p && n--; p++)
		soap_default__tse__EndSearch(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__EndSearch(struct soap *soap, const struct _tse__EndSearch *a, const char *tag, const char *type)
{
	if (soap_out__tse__EndSearch(soap, tag ? tag : "tse:EndSearch", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__EndSearch * SOAP_FMAC4 soap_get__tse__EndSearch(struct soap *soap, struct _tse__EndSearch *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__EndSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->State);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetSearchStateResponse(struct soap *soap, const struct _tse__GetSearchStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetSearchStateResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetSearchStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetSearchStateResponse), type))
		return soap->error;
	soap_element_result(soap, "tse:State");
	if (soap_out_tt__SearchState(soap, "tse:State", -1, &a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse * SOAP_FMAC4 soap_in__tse__GetSearchStateResponse(struct soap *soap, const char *tag, struct _tse__GetSearchStateResponse *a, const char *type)
{
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetSearchStateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetSearchStateResponse, sizeof(struct _tse__GetSearchStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetSearchStateResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SearchState(soap, "tse:State", &a->State, "tt:SearchState"))
				{	soap_flag_State--;
					continue;
				}
			}
			soap_check_result(soap, "tse:State");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetSearchStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetSearchStateResponse, SOAP_TYPE__tse__GetSearchStateResponse, sizeof(struct _tse__GetSearchStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse * SOAP_FMAC4 soap_new__tse__GetSearchStateResponse(struct soap *soap, int n)
{
	struct _tse__GetSearchStateResponse *p;
	struct _tse__GetSearchStateResponse *a = (struct _tse__GetSearchStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetSearchStateResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetSearchStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetSearchStateResponse(struct soap *soap, const struct _tse__GetSearchStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetSearchStateResponse(soap, tag ? tag : "tse:GetSearchStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse * SOAP_FMAC4 soap_get__tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetSearchStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetSearchState(struct soap *soap, const struct _tse__GetSearchState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetSearchState(struct soap *soap, const char *tag, int id, const struct _tse__GetSearchState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetSearchState), type))
		return soap->error;
	if (!a->SearchToken)
	{	if (soap_element_empty(soap, "tse:SearchToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetSearchState * SOAP_FMAC4 soap_in__tse__GetSearchState(struct soap *soap, const char *tag, struct _tse__GetSearchState *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetSearchState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetSearchState, sizeof(struct _tse__GetSearchState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetSearchState(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetSearchState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetSearchState, SOAP_TYPE__tse__GetSearchState, sizeof(struct _tse__GetSearchState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetSearchState * SOAP_FMAC4 soap_new__tse__GetSearchState(struct soap *soap, int n)
{
	struct _tse__GetSearchState *p;
	struct _tse__GetSearchState *a = (struct _tse__GetSearchState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetSearchState));
	for (p = a; p && n--; p++)
		soap_default__tse__GetSearchState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetSearchState(struct soap *soap, const struct _tse__GetSearchState *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetSearchState(soap, tag ? tag : "tse:GetSearchState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetSearchState * SOAP_FMAC4 soap_get__tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetSearchState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResultList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetMetadataSearchResultsResponse(struct soap *soap, const struct _tse__GetMetadataSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FindMetadataResultList(soap, &a->ResultList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetMetadataSearchResultsResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetMetadataSearchResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse), type))
		return soap->error;
	if (a->ResultList)
		soap_element_result(soap, "tse:ResultList");
	if (!a->ResultList)
	{	if (soap_element_empty(soap, "tse:ResultList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FindMetadataResultList(soap, "tse:ResultList", -1, &a->ResultList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse * SOAP_FMAC4 soap_in__tse__GetMetadataSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetMetadataSearchResultsResponse *a, const char *type)
{
	size_t soap_flag_ResultList = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetMetadataSearchResultsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, sizeof(struct _tse__GetMetadataSearchResultsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetMetadataSearchResultsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FindMetadataResultList(soap, "tse:ResultList", &a->ResultList, "tt:FindMetadataResultList"))
				{	soap_flag_ResultList--;
					continue;
				}
			}
			soap_check_result(soap, "tse:ResultList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ResultList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetMetadataSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, sizeof(struct _tse__GetMetadataSearchResultsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse * SOAP_FMAC4 soap_new__tse__GetMetadataSearchResultsResponse(struct soap *soap, int n)
{
	struct _tse__GetMetadataSearchResultsResponse *p;
	struct _tse__GetMetadataSearchResultsResponse *a = (struct _tse__GetMetadataSearchResultsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetMetadataSearchResultsResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetMetadataSearchResultsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetMetadataSearchResultsResponse(struct soap *soap, const struct _tse__GetMetadataSearchResultsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetMetadataSearchResultsResponse(soap, tag ? tag : "tse:GetMetadataSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse * SOAP_FMAC4 soap_get__tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetMetadataSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
	a->MinResults = NULL;
	a->MaxResults = NULL;
	soap_default_xsd__duration(soap, &a->WaitTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetMetadataSearchResults(struct soap *soap, const struct _tse__GetMetadataSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
	soap_serialize_PointerToint(soap, &a->MinResults);
	soap_serialize_PointerToint(soap, &a->MaxResults);
	soap_serialize_xsd__duration(soap, (char*const*)&a->WaitTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetMetadataSearchResults(struct soap *soap, const char *tag, int id, const struct _tse__GetMetadataSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetMetadataSearchResults), type))
		return soap->error;
	if (!a->SearchToken)
	{	if (soap_element_empty(soap, "tse:SearchToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MinResults", -1, &a->MinResults, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxResults", -1, &a->MaxResults, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tse:WaitTime", -1, (char*const*)&a->WaitTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults * SOAP_FMAC4 soap_in__tse__GetMetadataSearchResults(struct soap *soap, const char *tag, struct _tse__GetMetadataSearchResults *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	size_t soap_flag_MinResults = 1;
	size_t soap_flag_MaxResults = 1;
	size_t soap_flag_WaitTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetMetadataSearchResults*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMetadataSearchResults, sizeof(struct _tse__GetMetadataSearchResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetMetadataSearchResults(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			}
			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tse:MinResults", &a->MinResults, "xsd:int"))
				{	soap_flag_MinResults--;
					continue;
				}
			}
			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tse:MaxResults", &a->MaxResults, "xsd:int"))
				{	soap_flag_MaxResults--;
					continue;
				}
			}
			if (soap_flag_WaitTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tse:WaitTime", (char**)&a->WaitTime, "xsd:duration"))
				{	soap_flag_WaitTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetMetadataSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMetadataSearchResults, SOAP_TYPE__tse__GetMetadataSearchResults, sizeof(struct _tse__GetMetadataSearchResults), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults * SOAP_FMAC4 soap_new__tse__GetMetadataSearchResults(struct soap *soap, int n)
{
	struct _tse__GetMetadataSearchResults *p;
	struct _tse__GetMetadataSearchResults *a = (struct _tse__GetMetadataSearchResults*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetMetadataSearchResults));
	for (p = a; p && n--; p++)
		soap_default__tse__GetMetadataSearchResults(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetMetadataSearchResults(struct soap *soap, const struct _tse__GetMetadataSearchResults *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetMetadataSearchResults(soap, tag ? tag : "tse:GetMetadataSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults * SOAP_FMAC4 soap_get__tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetMetadataSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindMetadataResponse(struct soap *soap, const struct _tse__FindMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindMetadataResponse(struct soap *soap, const char *tag, int id, const struct _tse__FindMetadataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindMetadataResponse), type))
		return soap->error;
	if (a->SearchToken)
		soap_element_result(soap, "tse:SearchToken");
	if (!a->SearchToken)
	{	if (soap_element_empty(soap, "tse:SearchToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindMetadataResponse * SOAP_FMAC4 soap_in__tse__FindMetadataResponse(struct soap *soap, const char *tag, struct _tse__FindMetadataResponse *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__FindMetadataResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindMetadataResponse, sizeof(struct _tse__FindMetadataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindMetadataResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			}
			soap_check_result(soap, "tse:SearchToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindMetadataResponse, SOAP_TYPE__tse__FindMetadataResponse, sizeof(struct _tse__FindMetadataResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindMetadataResponse * SOAP_FMAC4 soap_new__tse__FindMetadataResponse(struct soap *soap, int n)
{
	struct _tse__FindMetadataResponse *p;
	struct _tse__FindMetadataResponse *a = (struct _tse__FindMetadataResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindMetadataResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__FindMetadataResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindMetadataResponse(struct soap *soap, const struct _tse__FindMetadataResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindMetadataResponse(soap, tag ? tag : "tse:FindMetadataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindMetadataResponse * SOAP_FMAC4 soap_get__tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->StartPoint);
	a->EndPoint = NULL;
	a->Scope = NULL;
	a->MetadataFilter = NULL;
	a->MaxMatches = NULL;
	soap_default_xsd__duration(soap, &a->KeepAliveTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindMetadata(struct soap *soap, const struct _tse__FindMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->StartPoint, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->EndPoint);
	soap_serialize_PointerTott__SearchScope(soap, &a->Scope);
	soap_serialize_PointerTott__MetadataFilter(soap, &a->MetadataFilter);
	soap_serialize_PointerToint(soap, &a->MaxMatches);
	soap_serialize_xsd__duration(soap, (char*const*)&a->KeepAliveTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindMetadata(struct soap *soap, const char *tag, int id, const struct _tse__FindMetadata *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindMetadata), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tse:StartPoint", -1, &a->StartPoint, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tse:EndPoint", -1, &a->EndPoint, ""))
		return soap->error;
	if (!a->Scope)
	{	if (soap_element_empty(soap, "tse:Scope", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SearchScope(soap, "tse:Scope", -1, &a->Scope, ""))
		return soap->error;
	if (!a->MetadataFilter)
	{	if (soap_element_empty(soap, "tse:MetadataFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MetadataFilter(soap, "tse:MetadataFilter", -1, &a->MetadataFilter, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxMatches", -1, &a->MaxMatches, ""))
		return soap->error;
	if (!a->KeepAliveTime)
	{	if (soap_element_empty(soap, "tse:KeepAliveTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tse:KeepAliveTime", -1, (char*const*)&a->KeepAliveTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindMetadata * SOAP_FMAC4 soap_in__tse__FindMetadata(struct soap *soap, const char *tag, struct _tse__FindMetadata *a, const char *type)
{
	size_t soap_flag_StartPoint = 1;
	size_t soap_flag_EndPoint = 1;
	size_t soap_flag_Scope = 1;
	size_t soap_flag_MetadataFilter = 1;
	size_t soap_flag_MaxMatches = 1;
	size_t soap_flag_KeepAliveTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__FindMetadata*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindMetadata, sizeof(struct _tse__FindMetadata), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindMetadata(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tse:StartPoint", &a->StartPoint, "xsd:dateTime"))
				{	soap_flag_StartPoint--;
					continue;
				}
			}
			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "tse:EndPoint", &a->EndPoint, "xsd:dateTime"))
				{	soap_flag_EndPoint--;
					continue;
				}
			}
			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SearchScope(soap, "tse:Scope", &a->Scope, "tt:SearchScope"))
				{	soap_flag_Scope--;
					continue;
				}
			}
			if (soap_flag_MetadataFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataFilter(soap, "tse:MetadataFilter", &a->MetadataFilter, "tt:MetadataFilter"))
				{	soap_flag_MetadataFilter--;
					continue;
				}
			}
			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tse:MaxMatches", &a->MaxMatches, "xsd:int"))
				{	soap_flag_MaxMatches--;
					continue;
				}
			}
			if (soap_flag_KeepAliveTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tse:KeepAliveTime", (char**)&a->KeepAliveTime, "xsd:duration"))
				{	soap_flag_KeepAliveTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPoint > 0 || !a->Scope || !a->MetadataFilter || !a->KeepAliveTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindMetadata, SOAP_TYPE__tse__FindMetadata, sizeof(struct _tse__FindMetadata), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindMetadata * SOAP_FMAC4 soap_new__tse__FindMetadata(struct soap *soap, int n)
{
	struct _tse__FindMetadata *p;
	struct _tse__FindMetadata *a = (struct _tse__FindMetadata*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindMetadata));
	for (p = a; p && n--; p++)
		soap_default__tse__FindMetadata(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindMetadata(struct soap *soap, const struct _tse__FindMetadata *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindMetadata(soap, tag ? tag : "tse:FindMetadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindMetadata * SOAP_FMAC4 soap_get__tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResultList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const struct _tse__GetPTZPositionSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FindPTZPositionResultList(soap, &a->ResultList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetPTZPositionSearchResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse), type))
		return soap->error;
	if (a->ResultList)
		soap_element_result(soap, "tse:ResultList");
	if (!a->ResultList)
	{	if (soap_element_empty(soap, "tse:ResultList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FindPTZPositionResultList(soap, "tse:ResultList", -1, &a->ResultList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse * SOAP_FMAC4 soap_in__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetPTZPositionSearchResultsResponse *a, const char *type)
{
	size_t soap_flag_ResultList = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetPTZPositionSearchResultsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, sizeof(struct _tse__GetPTZPositionSearchResultsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetPTZPositionSearchResultsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FindPTZPositionResultList(soap, "tse:ResultList", &a->ResultList, "tt:FindPTZPositionResultList"))
				{	soap_flag_ResultList--;
					continue;
				}
			}
			soap_check_result(soap, "tse:ResultList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ResultList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetPTZPositionSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, sizeof(struct _tse__GetPTZPositionSearchResultsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse * SOAP_FMAC4 soap_new__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, int n)
{
	struct _tse__GetPTZPositionSearchResultsResponse *p;
	struct _tse__GetPTZPositionSearchResultsResponse *a = (struct _tse__GetPTZPositionSearchResultsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetPTZPositionSearchResultsResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetPTZPositionSearchResultsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const struct _tse__GetPTZPositionSearchResultsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetPTZPositionSearchResultsResponse(soap, tag ? tag : "tse:GetPTZPositionSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse * SOAP_FMAC4 soap_get__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetPTZPositionSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
	a->MinResults = NULL;
	a->MaxResults = NULL;
	soap_default_xsd__duration(soap, &a->WaitTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetPTZPositionSearchResults(struct soap *soap, const struct _tse__GetPTZPositionSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
	soap_serialize_PointerToint(soap, &a->MinResults);
	soap_serialize_PointerToint(soap, &a->MaxResults);
	soap_serialize_xsd__duration(soap, (char*const*)&a->WaitTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, int id, const struct _tse__GetPTZPositionSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetPTZPositionSearchResults), type))
		return soap->error;
	if (!a->SearchToken)
	{	if (soap_element_empty(soap, "tse:SearchToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MinResults", -1, &a->MinResults, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxResults", -1, &a->MaxResults, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tse:WaitTime", -1, (char*const*)&a->WaitTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults * SOAP_FMAC4 soap_in__tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, struct _tse__GetPTZPositionSearchResults *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	size_t soap_flag_MinResults = 1;
	size_t soap_flag_MaxResults = 1;
	size_t soap_flag_WaitTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetPTZPositionSearchResults*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetPTZPositionSearchResults, sizeof(struct _tse__GetPTZPositionSearchResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetPTZPositionSearchResults(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			}
			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tse:MinResults", &a->MinResults, "xsd:int"))
				{	soap_flag_MinResults--;
					continue;
				}
			}
			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tse:MaxResults", &a->MaxResults, "xsd:int"))
				{	soap_flag_MaxResults--;
					continue;
				}
			}
			if (soap_flag_WaitTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tse:WaitTime", (char**)&a->WaitTime, "xsd:duration"))
				{	soap_flag_WaitTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetPTZPositionSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetPTZPositionSearchResults, SOAP_TYPE__tse__GetPTZPositionSearchResults, sizeof(struct _tse__GetPTZPositionSearchResults), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults * SOAP_FMAC4 soap_new__tse__GetPTZPositionSearchResults(struct soap *soap, int n)
{
	struct _tse__GetPTZPositionSearchResults *p;
	struct _tse__GetPTZPositionSearchResults *a = (struct _tse__GetPTZPositionSearchResults*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetPTZPositionSearchResults));
	for (p = a; p && n--; p++)
		soap_default__tse__GetPTZPositionSearchResults(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetPTZPositionSearchResults(struct soap *soap, const struct _tse__GetPTZPositionSearchResults *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetPTZPositionSearchResults(soap, tag ? tag : "tse:GetPTZPositionSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults * SOAP_FMAC4 soap_get__tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetPTZPositionSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindPTZPositionResponse(struct soap *soap, const struct _tse__FindPTZPositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindPTZPositionResponse(struct soap *soap, const char *tag, int id, const struct _tse__FindPTZPositionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindPTZPositionResponse), type))
		return soap->error;
	if (a->SearchToken)
		soap_element_result(soap, "tse:SearchToken");
	if (!a->SearchToken)
	{	if (soap_element_empty(soap, "tse:SearchToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse * SOAP_FMAC4 soap_in__tse__FindPTZPositionResponse(struct soap *soap, const char *tag, struct _tse__FindPTZPositionResponse *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__FindPTZPositionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindPTZPositionResponse, sizeof(struct _tse__FindPTZPositionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindPTZPositionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			}
			soap_check_result(soap, "tse:SearchToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindPTZPositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindPTZPositionResponse, SOAP_TYPE__tse__FindPTZPositionResponse, sizeof(struct _tse__FindPTZPositionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse * SOAP_FMAC4 soap_new__tse__FindPTZPositionResponse(struct soap *soap, int n)
{
	struct _tse__FindPTZPositionResponse *p;
	struct _tse__FindPTZPositionResponse *a = (struct _tse__FindPTZPositionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindPTZPositionResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__FindPTZPositionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindPTZPositionResponse(struct soap *soap, const struct _tse__FindPTZPositionResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindPTZPositionResponse(soap, tag ? tag : "tse:FindPTZPositionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse * SOAP_FMAC4 soap_get__tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindPTZPositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->StartPoint);
	a->EndPoint = NULL;
	a->Scope = NULL;
	a->SearchFilter = NULL;
	a->MaxMatches = NULL;
	soap_default_xsd__duration(soap, &a->KeepAliveTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindPTZPosition(struct soap *soap, const struct _tse__FindPTZPosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->StartPoint, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->EndPoint);
	soap_serialize_PointerTott__SearchScope(soap, &a->Scope);
	soap_serialize_PointerTott__PTZPositionFilter(soap, &a->SearchFilter);
	soap_serialize_PointerToint(soap, &a->MaxMatches);
	soap_serialize_xsd__duration(soap, (char*const*)&a->KeepAliveTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindPTZPosition(struct soap *soap, const char *tag, int id, const struct _tse__FindPTZPosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindPTZPosition), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tse:StartPoint", -1, &a->StartPoint, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tse:EndPoint", -1, &a->EndPoint, ""))
		return soap->error;
	if (!a->Scope)
	{	if (soap_element_empty(soap, "tse:Scope", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SearchScope(soap, "tse:Scope", -1, &a->Scope, ""))
		return soap->error;
	if (!a->SearchFilter)
	{	if (soap_element_empty(soap, "tse:SearchFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPositionFilter(soap, "tse:SearchFilter", -1, &a->SearchFilter, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxMatches", -1, &a->MaxMatches, ""))
		return soap->error;
	if (!a->KeepAliveTime)
	{	if (soap_element_empty(soap, "tse:KeepAliveTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tse:KeepAliveTime", -1, (char*const*)&a->KeepAliveTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindPTZPosition * SOAP_FMAC4 soap_in__tse__FindPTZPosition(struct soap *soap, const char *tag, struct _tse__FindPTZPosition *a, const char *type)
{
	size_t soap_flag_StartPoint = 1;
	size_t soap_flag_EndPoint = 1;
	size_t soap_flag_Scope = 1;
	size_t soap_flag_SearchFilter = 1;
	size_t soap_flag_MaxMatches = 1;
	size_t soap_flag_KeepAliveTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__FindPTZPosition*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindPTZPosition, sizeof(struct _tse__FindPTZPosition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindPTZPosition(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tse:StartPoint", &a->StartPoint, "xsd:dateTime"))
				{	soap_flag_StartPoint--;
					continue;
				}
			}
			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "tse:EndPoint", &a->EndPoint, "xsd:dateTime"))
				{	soap_flag_EndPoint--;
					continue;
				}
			}
			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SearchScope(soap, "tse:Scope", &a->Scope, "tt:SearchScope"))
				{	soap_flag_Scope--;
					continue;
				}
			}
			if (soap_flag_SearchFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPositionFilter(soap, "tse:SearchFilter", &a->SearchFilter, "tt:PTZPositionFilter"))
				{	soap_flag_SearchFilter--;
					continue;
				}
			}
			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tse:MaxMatches", &a->MaxMatches, "xsd:int"))
				{	soap_flag_MaxMatches--;
					continue;
				}
			}
			if (soap_flag_KeepAliveTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tse:KeepAliveTime", (char**)&a->KeepAliveTime, "xsd:duration"))
				{	soap_flag_KeepAliveTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPoint > 0 || !a->Scope || !a->SearchFilter || !a->KeepAliveTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindPTZPosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindPTZPosition, SOAP_TYPE__tse__FindPTZPosition, sizeof(struct _tse__FindPTZPosition), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindPTZPosition * SOAP_FMAC4 soap_new__tse__FindPTZPosition(struct soap *soap, int n)
{
	struct _tse__FindPTZPosition *p;
	struct _tse__FindPTZPosition *a = (struct _tse__FindPTZPosition*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindPTZPosition));
	for (p = a; p && n--; p++)
		soap_default__tse__FindPTZPosition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindPTZPosition(struct soap *soap, const struct _tse__FindPTZPosition *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindPTZPosition(soap, tag ? tag : "tse:FindPTZPosition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindPTZPosition * SOAP_FMAC4 soap_get__tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindPTZPosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResultList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetEventSearchResultsResponse(struct soap *soap, const struct _tse__GetEventSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FindEventResultList(soap, &a->ResultList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetEventSearchResultsResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetEventSearchResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetEventSearchResultsResponse), type))
		return soap->error;
	if (a->ResultList)
		soap_element_result(soap, "tse:ResultList");
	if (!a->ResultList)
	{	if (soap_element_empty(soap, "tse:ResultList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FindEventResultList(soap, "tse:ResultList", -1, &a->ResultList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse * SOAP_FMAC4 soap_in__tse__GetEventSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetEventSearchResultsResponse *a, const char *type)
{
	size_t soap_flag_ResultList = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetEventSearchResultsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetEventSearchResultsResponse, sizeof(struct _tse__GetEventSearchResultsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetEventSearchResultsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FindEventResultList(soap, "tse:ResultList", &a->ResultList, "tt:FindEventResultList"))
				{	soap_flag_ResultList--;
					continue;
				}
			}
			soap_check_result(soap, "tse:ResultList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ResultList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetEventSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetEventSearchResultsResponse, SOAP_TYPE__tse__GetEventSearchResultsResponse, sizeof(struct _tse__GetEventSearchResultsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse * SOAP_FMAC4 soap_new__tse__GetEventSearchResultsResponse(struct soap *soap, int n)
{
	struct _tse__GetEventSearchResultsResponse *p;
	struct _tse__GetEventSearchResultsResponse *a = (struct _tse__GetEventSearchResultsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetEventSearchResultsResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetEventSearchResultsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetEventSearchResultsResponse(struct soap *soap, const struct _tse__GetEventSearchResultsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetEventSearchResultsResponse(soap, tag ? tag : "tse:GetEventSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse * SOAP_FMAC4 soap_get__tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetEventSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
	a->MinResults = NULL;
	a->MaxResults = NULL;
	soap_default_xsd__duration(soap, &a->WaitTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetEventSearchResults(struct soap *soap, const struct _tse__GetEventSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
	soap_serialize_PointerToint(soap, &a->MinResults);
	soap_serialize_PointerToint(soap, &a->MaxResults);
	soap_serialize_xsd__duration(soap, (char*const*)&a->WaitTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetEventSearchResults(struct soap *soap, const char *tag, int id, const struct _tse__GetEventSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetEventSearchResults), type))
		return soap->error;
	if (!a->SearchToken)
	{	if (soap_element_empty(soap, "tse:SearchToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MinResults", -1, &a->MinResults, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxResults", -1, &a->MaxResults, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tse:WaitTime", -1, (char*const*)&a->WaitTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetEventSearchResults * SOAP_FMAC4 soap_in__tse__GetEventSearchResults(struct soap *soap, const char *tag, struct _tse__GetEventSearchResults *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	size_t soap_flag_MinResults = 1;
	size_t soap_flag_MaxResults = 1;
	size_t soap_flag_WaitTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetEventSearchResults*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetEventSearchResults, sizeof(struct _tse__GetEventSearchResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetEventSearchResults(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			}
			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tse:MinResults", &a->MinResults, "xsd:int"))
				{	soap_flag_MinResults--;
					continue;
				}
			}
			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tse:MaxResults", &a->MaxResults, "xsd:int"))
				{	soap_flag_MaxResults--;
					continue;
				}
			}
			if (soap_flag_WaitTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tse:WaitTime", (char**)&a->WaitTime, "xsd:duration"))
				{	soap_flag_WaitTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetEventSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetEventSearchResults, SOAP_TYPE__tse__GetEventSearchResults, sizeof(struct _tse__GetEventSearchResults), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetEventSearchResults * SOAP_FMAC4 soap_new__tse__GetEventSearchResults(struct soap *soap, int n)
{
	struct _tse__GetEventSearchResults *p;
	struct _tse__GetEventSearchResults *a = (struct _tse__GetEventSearchResults*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetEventSearchResults));
	for (p = a; p && n--; p++)
		soap_default__tse__GetEventSearchResults(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetEventSearchResults(struct soap *soap, const struct _tse__GetEventSearchResults *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetEventSearchResults(soap, tag ? tag : "tse:GetEventSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetEventSearchResults * SOAP_FMAC4 soap_get__tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetEventSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindEventsResponse(struct soap *soap, const struct _tse__FindEventsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindEventsResponse(struct soap *soap, const char *tag, int id, const struct _tse__FindEventsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindEventsResponse), type))
		return soap->error;
	if (a->SearchToken)
		soap_element_result(soap, "tse:SearchToken");
	if (!a->SearchToken)
	{	if (soap_element_empty(soap, "tse:SearchToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindEventsResponse * SOAP_FMAC4 soap_in__tse__FindEventsResponse(struct soap *soap, const char *tag, struct _tse__FindEventsResponse *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__FindEventsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindEventsResponse, sizeof(struct _tse__FindEventsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindEventsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			}
			soap_check_result(soap, "tse:SearchToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindEventsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindEventsResponse, SOAP_TYPE__tse__FindEventsResponse, sizeof(struct _tse__FindEventsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindEventsResponse * SOAP_FMAC4 soap_new__tse__FindEventsResponse(struct soap *soap, int n)
{
	struct _tse__FindEventsResponse *p;
	struct _tse__FindEventsResponse *a = (struct _tse__FindEventsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindEventsResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__FindEventsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindEventsResponse(struct soap *soap, const struct _tse__FindEventsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindEventsResponse(soap, tag ? tag : "tse:FindEventsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindEventsResponse * SOAP_FMAC4 soap_get__tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindEventsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventFilter(struct soap *soap, struct tt__EventFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventFilter(struct soap *soap, const struct tt__EventFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventFilter(struct soap *soap, const char *tag, int id, const struct tt__EventFilter *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventFilter), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventFilter * SOAP_FMAC4 soap_in_tt__EventFilter(struct soap *soap, const char *tag, struct tt__EventFilter *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__EventFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventFilter, sizeof(struct tt__EventFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventFilter(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventFilter, SOAP_TYPE_tt__EventFilter, sizeof(struct tt__EventFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EventFilter * SOAP_FMAC4 soap_new_tt__EventFilter(struct soap *soap, int n)
{
	struct tt__EventFilter *p;
	struct tt__EventFilter *a = (struct tt__EventFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EventFilter));
	for (p = a; p && n--; p++)
		soap_default_tt__EventFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventFilter(struct soap *soap, const struct tt__EventFilter *a, const char *tag, const char *type)
{
	if (soap_out_tt__EventFilter(soap, tag ? tag : "tt:EventFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventFilter * SOAP_FMAC4 soap_get_tt__EventFilter(struct soap *soap, struct tt__EventFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindEvents(struct soap *soap, struct _tse__FindEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->StartPoint);
	a->EndPoint = NULL;
	a->Scope = NULL;
	a->SearchFilter = NULL;
	soap_default_xsd__boolean(soap, &a->IncludeStartState);
	a->MaxMatches = NULL;
	soap_default_xsd__duration(soap, &a->KeepAliveTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindEvents(struct soap *soap, const struct _tse__FindEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->StartPoint, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->EndPoint);
	soap_serialize_PointerTott__SearchScope(soap, &a->Scope);
	soap_serialize_PointerTott__EventFilter(soap, &a->SearchFilter);
	soap_embedded(soap, &a->IncludeStartState, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerToint(soap, &a->MaxMatches);
	soap_serialize_xsd__duration(soap, (char*const*)&a->KeepAliveTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindEvents(struct soap *soap, const char *tag, int id, const struct _tse__FindEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindEvents), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tse:StartPoint", -1, &a->StartPoint, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tse:EndPoint", -1, &a->EndPoint, ""))
		return soap->error;
	if (!a->Scope)
	{	if (soap_element_empty(soap, "tse:Scope", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SearchScope(soap, "tse:Scope", -1, &a->Scope, ""))
		return soap->error;
	if (!a->SearchFilter)
	{	if (soap_element_empty(soap, "tse:SearchFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__EventFilter(soap, "tse:SearchFilter", -1, &a->SearchFilter, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tse:IncludeStartState", -1, &a->IncludeStartState, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxMatches", -1, &a->MaxMatches, ""))
		return soap->error;
	if (!a->KeepAliveTime)
	{	if (soap_element_empty(soap, "tse:KeepAliveTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tse:KeepAliveTime", -1, (char*const*)&a->KeepAliveTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindEvents * SOAP_FMAC4 soap_in__tse__FindEvents(struct soap *soap, const char *tag, struct _tse__FindEvents *a, const char *type)
{
	size_t soap_flag_StartPoint = 1;
	size_t soap_flag_EndPoint = 1;
	size_t soap_flag_Scope = 1;
	size_t soap_flag_SearchFilter = 1;
	size_t soap_flag_IncludeStartState = 1;
	size_t soap_flag_MaxMatches = 1;
	size_t soap_flag_KeepAliveTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__FindEvents*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindEvents, sizeof(struct _tse__FindEvents), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindEvents(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tse:StartPoint", &a->StartPoint, "xsd:dateTime"))
				{	soap_flag_StartPoint--;
					continue;
				}
			}
			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "tse:EndPoint", &a->EndPoint, "xsd:dateTime"))
				{	soap_flag_EndPoint--;
					continue;
				}
			}
			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SearchScope(soap, "tse:Scope", &a->Scope, "tt:SearchScope"))
				{	soap_flag_Scope--;
					continue;
				}
			}
			if (soap_flag_SearchFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EventFilter(soap, "tse:SearchFilter", &a->SearchFilter, "tt:EventFilter"))
				{	soap_flag_SearchFilter--;
					continue;
				}
			}
			if (soap_flag_IncludeStartState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tse:IncludeStartState", &a->IncludeStartState, "xsd:boolean"))
				{	soap_flag_IncludeStartState--;
					continue;
				}
			}
			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tse:MaxMatches", &a->MaxMatches, "xsd:int"))
				{	soap_flag_MaxMatches--;
					continue;
				}
			}
			if (soap_flag_KeepAliveTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tse:KeepAliveTime", (char**)&a->KeepAliveTime, "xsd:duration"))
				{	soap_flag_KeepAliveTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPoint > 0 || !a->Scope || !a->SearchFilter || soap_flag_IncludeStartState > 0 || !a->KeepAliveTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindEvents, SOAP_TYPE__tse__FindEvents, sizeof(struct _tse__FindEvents), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindEvents * SOAP_FMAC4 soap_new__tse__FindEvents(struct soap *soap, int n)
{
	struct _tse__FindEvents *p;
	struct _tse__FindEvents *a = (struct _tse__FindEvents*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindEvents));
	for (p = a; p && n--; p++)
		soap_default__tse__FindEvents(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindEvents(struct soap *soap, const struct _tse__FindEvents *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindEvents(soap, tag ? tag : "tse:FindEvents", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindEvents * SOAP_FMAC4 soap_get__tse__FindEvents(struct soap *soap, struct _tse__FindEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResultList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingSearchResultsResponse(struct soap *soap, const struct _tse__GetRecordingSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FindRecordingResultList(soap, &a->ResultList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingSearchResultsResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingSearchResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse), type))
		return soap->error;
	if (a->ResultList)
		soap_element_result(soap, "tse:ResultList");
	if (!a->ResultList)
	{	if (soap_element_empty(soap, "tse:ResultList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FindRecordingResultList(soap, "tse:ResultList", -1, &a->ResultList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse * SOAP_FMAC4 soap_in__tse__GetRecordingSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingSearchResultsResponse *a, const char *type)
{
	size_t soap_flag_ResultList = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetRecordingSearchResultsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, sizeof(struct _tse__GetRecordingSearchResultsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingSearchResultsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FindRecordingResultList(soap, "tse:ResultList", &a->ResultList, "tt:FindRecordingResultList"))
				{	soap_flag_ResultList--;
					continue;
				}
			}
			soap_check_result(soap, "tse:ResultList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ResultList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, sizeof(struct _tse__GetRecordingSearchResultsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse * SOAP_FMAC4 soap_new__tse__GetRecordingSearchResultsResponse(struct soap *soap, int n)
{
	struct _tse__GetRecordingSearchResultsResponse *p;
	struct _tse__GetRecordingSearchResultsResponse *a = (struct _tse__GetRecordingSearchResultsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetRecordingSearchResultsResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetRecordingSearchResultsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingSearchResultsResponse(struct soap *soap, const struct _tse__GetRecordingSearchResultsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetRecordingSearchResultsResponse(soap, tag ? tag : "tse:GetRecordingSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse * SOAP_FMAC4 soap_get__tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
	a->MinResults = NULL;
	a->MaxResults = NULL;
	soap_default_xsd__duration(soap, &a->WaitTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingSearchResults(struct soap *soap, const struct _tse__GetRecordingSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
	soap_serialize_PointerToint(soap, &a->MinResults);
	soap_serialize_PointerToint(soap, &a->MaxResults);
	soap_serialize_xsd__duration(soap, (char*const*)&a->WaitTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingSearchResults(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingSearchResults), type))
		return soap->error;
	if (!a->SearchToken)
	{	if (soap_element_empty(soap, "tse:SearchToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MinResults", -1, &a->MinResults, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxResults", -1, &a->MaxResults, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tse:WaitTime", -1, (char*const*)&a->WaitTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults * SOAP_FMAC4 soap_in__tse__GetRecordingSearchResults(struct soap *soap, const char *tag, struct _tse__GetRecordingSearchResults *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	size_t soap_flag_MinResults = 1;
	size_t soap_flag_MaxResults = 1;
	size_t soap_flag_WaitTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetRecordingSearchResults*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSearchResults, sizeof(struct _tse__GetRecordingSearchResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingSearchResults(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			}
			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tse:MinResults", &a->MinResults, "xsd:int"))
				{	soap_flag_MinResults--;
					continue;
				}
			}
			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tse:MaxResults", &a->MaxResults, "xsd:int"))
				{	soap_flag_MaxResults--;
					continue;
				}
			}
			if (soap_flag_WaitTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tse:WaitTime", (char**)&a->WaitTime, "xsd:duration"))
				{	soap_flag_WaitTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSearchResults, SOAP_TYPE__tse__GetRecordingSearchResults, sizeof(struct _tse__GetRecordingSearchResults), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults * SOAP_FMAC4 soap_new__tse__GetRecordingSearchResults(struct soap *soap, int n)
{
	struct _tse__GetRecordingSearchResults *p;
	struct _tse__GetRecordingSearchResults *a = (struct _tse__GetRecordingSearchResults*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetRecordingSearchResults));
	for (p = a; p && n--; p++)
		soap_default__tse__GetRecordingSearchResults(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingSearchResults(struct soap *soap, const struct _tse__GetRecordingSearchResults *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetRecordingSearchResults(soap, tag ? tag : "tse:GetRecordingSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults * SOAP_FMAC4 soap_get__tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindRecordingsResponse(struct soap *soap, const struct _tse__FindRecordingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindRecordingsResponse(struct soap *soap, const char *tag, int id, const struct _tse__FindRecordingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindRecordingsResponse), type))
		return soap->error;
	if (a->SearchToken)
		soap_element_result(soap, "tse:SearchToken");
	if (!a->SearchToken)
	{	if (soap_element_empty(soap, "tse:SearchToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse * SOAP_FMAC4 soap_in__tse__FindRecordingsResponse(struct soap *soap, const char *tag, struct _tse__FindRecordingsResponse *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__FindRecordingsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindRecordingsResponse, sizeof(struct _tse__FindRecordingsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindRecordingsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			}
			soap_check_result(soap, "tse:SearchToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindRecordingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindRecordingsResponse, SOAP_TYPE__tse__FindRecordingsResponse, sizeof(struct _tse__FindRecordingsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse * SOAP_FMAC4 soap_new__tse__FindRecordingsResponse(struct soap *soap, int n)
{
	struct _tse__FindRecordingsResponse *p;
	struct _tse__FindRecordingsResponse *a = (struct _tse__FindRecordingsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindRecordingsResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__FindRecordingsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindRecordingsResponse(struct soap *soap, const struct _tse__FindRecordingsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindRecordingsResponse(soap, tag ? tag : "tse:FindRecordingsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse * SOAP_FMAC4 soap_get__tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindRecordingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Scope = NULL;
	a->MaxMatches = NULL;
	soap_default_xsd__duration(soap, &a->KeepAliveTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindRecordings(struct soap *soap, const struct _tse__FindRecordings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SearchScope(soap, &a->Scope);
	soap_serialize_PointerToint(soap, &a->MaxMatches);
	soap_serialize_xsd__duration(soap, (char*const*)&a->KeepAliveTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindRecordings(struct soap *soap, const char *tag, int id, const struct _tse__FindRecordings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindRecordings), type))
		return soap->error;
	if (!a->Scope)
	{	if (soap_element_empty(soap, "tse:Scope", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SearchScope(soap, "tse:Scope", -1, &a->Scope, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxMatches", -1, &a->MaxMatches, ""))
		return soap->error;
	if (!a->KeepAliveTime)
	{	if (soap_element_empty(soap, "tse:KeepAliveTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tse:KeepAliveTime", -1, (char*const*)&a->KeepAliveTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindRecordings * SOAP_FMAC4 soap_in__tse__FindRecordings(struct soap *soap, const char *tag, struct _tse__FindRecordings *a, const char *type)
{
	size_t soap_flag_Scope = 1;
	size_t soap_flag_MaxMatches = 1;
	size_t soap_flag_KeepAliveTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__FindRecordings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindRecordings, sizeof(struct _tse__FindRecordings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindRecordings(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SearchScope(soap, "tse:Scope", &a->Scope, "tt:SearchScope"))
				{	soap_flag_Scope--;
					continue;
				}
			}
			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tse:MaxMatches", &a->MaxMatches, "xsd:int"))
				{	soap_flag_MaxMatches--;
					continue;
				}
			}
			if (soap_flag_KeepAliveTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tse:KeepAliveTime", (char**)&a->KeepAliveTime, "xsd:duration"))
				{	soap_flag_KeepAliveTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Scope || !a->KeepAliveTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindRecordings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindRecordings, SOAP_TYPE__tse__FindRecordings, sizeof(struct _tse__FindRecordings), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindRecordings * SOAP_FMAC4 soap_new__tse__FindRecordings(struct soap *soap, int n)
{
	struct _tse__FindRecordings *p;
	struct _tse__FindRecordings *a = (struct _tse__FindRecordings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindRecordings));
	for (p = a; p && n--; p++)
		soap_default__tse__FindRecordings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindRecordings(struct soap *soap, const struct _tse__FindRecordings *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindRecordings(soap, tag ? tag : "tse:FindRecordings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindRecordings * SOAP_FMAC4 soap_get__tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindRecordings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMediaAttributes = 0;
	a->MediaAttributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetMediaAttributesResponse(struct soap *soap, const struct _tse__GetMediaAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->MediaAttributes)
	{	int i;
		for (i = 0; i < (int)a->__sizeMediaAttributes; i++)
		{
			soap_embedded(soap, a->MediaAttributes + i, SOAP_TYPE_tt__MediaAttributes);
			soap_serialize_tt__MediaAttributes(soap, a->MediaAttributes + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetMediaAttributesResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetMediaAttributesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetMediaAttributesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeMediaAttributes");
	if (a->MediaAttributes)
	{	int i;
		for (i = 0; i < (int)a->__sizeMediaAttributes; i++)
			if (soap_out_tt__MediaAttributes(soap, "tse:MediaAttributes", -1, a->MediaAttributes + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse * SOAP_FMAC4 soap_in__tse__GetMediaAttributesResponse(struct soap *soap, const char *tag, struct _tse__GetMediaAttributesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_MediaAttributes = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetMediaAttributesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMediaAttributesResponse, sizeof(struct _tse__GetMediaAttributesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetMediaAttributesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tse:MediaAttributes", 1, NULL))
			{	if (a->MediaAttributes == NULL)
				{	if (soap_blist_MediaAttributes == NULL)
						soap_blist_MediaAttributes = soap_alloc_block(soap);
					a->MediaAttributes = (struct tt__MediaAttributes *)soap_push_block_max(soap, soap_blist_MediaAttributes, sizeof(struct tt__MediaAttributes));
					if (a->MediaAttributes == NULL)
						return NULL;
					soap_default_tt__MediaAttributes(soap, a->MediaAttributes);
				}
				soap_revert(soap);
				if (soap_in_tt__MediaAttributes(soap, "tse:MediaAttributes", a->MediaAttributes, "tt:MediaAttributes"))
				{	a->__sizeMediaAttributes++;
					a->MediaAttributes = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeMediaAttributes");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->MediaAttributes)
			soap_pop_block(soap, soap_blist_MediaAttributes);
		if (a->__sizeMediaAttributes)
		{	a->MediaAttributes = (struct tt__MediaAttributes *)soap_save_block(soap, soap_blist_MediaAttributes, NULL, 1);
		}
		else
		{	a->MediaAttributes = NULL;
			if (soap_blist_MediaAttributes)
				soap_end_block(soap, soap_blist_MediaAttributes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMediaAttributesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMediaAttributesResponse, SOAP_TYPE__tse__GetMediaAttributesResponse, sizeof(struct _tse__GetMediaAttributesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse * SOAP_FMAC4 soap_new__tse__GetMediaAttributesResponse(struct soap *soap, int n)
{
	struct _tse__GetMediaAttributesResponse *p;
	struct _tse__GetMediaAttributesResponse *a = (struct _tse__GetMediaAttributesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetMediaAttributesResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetMediaAttributesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetMediaAttributesResponse(struct soap *soap, const struct _tse__GetMediaAttributesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetMediaAttributesResponse(soap, tag ? tag : "tse:GetMediaAttributesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse * SOAP_FMAC4 soap_get__tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetMediaAttributesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRecordingTokens = 0;
	a->RecordingTokens = NULL;
	soap_default_dateTime(soap, &a->Time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetMediaAttributes(struct soap *soap, const struct _tse__GetMediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RecordingTokens)
	{	int i;
		for (i = 0; i < (int)a->__sizeRecordingTokens; i++)
		{
			soap_serialize_tt__RecordingReference(soap, (char*const*)(a->RecordingTokens + i));
		}
	}
	soap_embedded(soap, &a->Time, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetMediaAttributes(struct soap *soap, const char *tag, int id, const struct _tse__GetMediaAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetMediaAttributes), type))
		return soap->error;
	if (a->RecordingTokens)
	{	int i;
		for (i = 0; i < (int)a->__sizeRecordingTokens; i++)
			if (soap_out_string(soap, "tse:RecordingTokens", -1, (char*const*)(a->RecordingTokens + i), ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "tse:Time", -1, &a->Time, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetMediaAttributes * SOAP_FMAC4 soap_in__tse__GetMediaAttributes(struct soap *soap, const char *tag, struct _tse__GetMediaAttributes *a, const char *type)
{
	struct soap_blist *soap_blist_RecordingTokens = NULL;
	size_t soap_flag_Time = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetMediaAttributes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMediaAttributes, sizeof(struct _tse__GetMediaAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetMediaAttributes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tse:RecordingTokens", 1, NULL))
			{	if (a->RecordingTokens == NULL)
				{	if (soap_blist_RecordingTokens == NULL)
						soap_blist_RecordingTokens = soap_alloc_block(soap);
					a->RecordingTokens = (char **)soap_push_block_max(soap, soap_blist_RecordingTokens, sizeof(char *));
					if (a->RecordingTokens == NULL)
						return NULL;
					*a->RecordingTokens = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingReference(soap, "tse:RecordingTokens", (char**)a->RecordingTokens, "tt:RecordingReference"))
				{	a->__sizeRecordingTokens++;
					a->RecordingTokens = NULL;
					continue;
				}
			}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tse:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RecordingTokens)
			soap_pop_block(soap, soap_blist_RecordingTokens);
		if (a->__sizeRecordingTokens)
		{	a->RecordingTokens = (char **)soap_save_block(soap, soap_blist_RecordingTokens, NULL, 1);
		}
		else
		{	a->RecordingTokens = NULL;
			if (soap_blist_RecordingTokens)
				soap_end_block(soap, soap_blist_RecordingTokens);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Time > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetMediaAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMediaAttributes, SOAP_TYPE__tse__GetMediaAttributes, sizeof(struct _tse__GetMediaAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetMediaAttributes * SOAP_FMAC4 soap_new__tse__GetMediaAttributes(struct soap *soap, int n)
{
	struct _tse__GetMediaAttributes *p;
	struct _tse__GetMediaAttributes *a = (struct _tse__GetMediaAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetMediaAttributes));
	for (p = a; p && n--; p++)
		soap_default__tse__GetMediaAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetMediaAttributes(struct soap *soap, const struct _tse__GetMediaAttributes *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetMediaAttributes(soap, tag ? tag : "tse:GetMediaAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMediaAttributes * SOAP_FMAC4 soap_get__tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetMediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecordingInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingInformationResponse(struct soap *soap, const struct _tse__GetRecordingInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingInformation(soap, &a->RecordingInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingInformationResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingInformationResponse), type))
		return soap->error;
	if (a->RecordingInformation)
		soap_element_result(soap, "tse:RecordingInformation");
	if (!a->RecordingInformation)
	{	if (soap_element_empty(soap, "tse:RecordingInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingInformation(soap, "tse:RecordingInformation", -1, &a->RecordingInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse * SOAP_FMAC4 soap_in__tse__GetRecordingInformationResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingInformationResponse *a, const char *type)
{
	size_t soap_flag_RecordingInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetRecordingInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingInformationResponse, sizeof(struct _tse__GetRecordingInformationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingInformationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingInformation(soap, "tse:RecordingInformation", &a->RecordingInformation, "tt:RecordingInformation"))
				{	soap_flag_RecordingInformation--;
					continue;
				}
			}
			soap_check_result(soap, "tse:RecordingInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingInformationResponse, SOAP_TYPE__tse__GetRecordingInformationResponse, sizeof(struct _tse__GetRecordingInformationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse * SOAP_FMAC4 soap_new__tse__GetRecordingInformationResponse(struct soap *soap, int n)
{
	struct _tse__GetRecordingInformationResponse *p;
	struct _tse__GetRecordingInformationResponse *a = (struct _tse__GetRecordingInformationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetRecordingInformationResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetRecordingInformationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingInformationResponse(struct soap *soap, const struct _tse__GetRecordingInformationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetRecordingInformationResponse(soap, tag ? tag : "tse:GetRecordingInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse * SOAP_FMAC4 soap_get__tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingInformation(struct soap *soap, const struct _tse__GetRecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingInformation(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingInformation), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "tse:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "tse:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingInformation * SOAP_FMAC4 soap_in__tse__GetRecordingInformation(struct soap *soap, const char *tag, struct _tse__GetRecordingInformation *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetRecordingInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingInformation, sizeof(struct _tse__GetRecordingInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "tse:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingInformation, SOAP_TYPE__tse__GetRecordingInformation, sizeof(struct _tse__GetRecordingInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetRecordingInformation * SOAP_FMAC4 soap_new__tse__GetRecordingInformation(struct soap *soap, int n)
{
	struct _tse__GetRecordingInformation *p;
	struct _tse__GetRecordingInformation *a = (struct _tse__GetRecordingInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetRecordingInformation));
	for (p = a; p && n--; p++)
		soap_default__tse__GetRecordingInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingInformation(struct soap *soap, const struct _tse__GetRecordingInformation *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetRecordingInformation(soap, tag ? tag : "tse:GetRecordingInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingInformation * SOAP_FMAC4 soap_get__tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Summary = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingSummaryResponse(struct soap *soap, const struct _tse__GetRecordingSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingSummary(soap, &a->Summary);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingSummaryResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingSummaryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingSummaryResponse), type))
		return soap->error;
	if (a->Summary)
		soap_element_result(soap, "tse:Summary");
	if (!a->Summary)
	{	if (soap_element_empty(soap, "tse:Summary", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingSummary(soap, "tse:Summary", -1, &a->Summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse * SOAP_FMAC4 soap_in__tse__GetRecordingSummaryResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingSummaryResponse *a, const char *type)
{
	size_t soap_flag_Summary = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetRecordingSummaryResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSummaryResponse, sizeof(struct _tse__GetRecordingSummaryResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingSummaryResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Summary && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingSummary(soap, "tse:Summary", &a->Summary, "tt:RecordingSummary"))
				{	soap_flag_Summary--;
					continue;
				}
			}
			soap_check_result(soap, "tse:Summary");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Summary))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSummaryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSummaryResponse, SOAP_TYPE__tse__GetRecordingSummaryResponse, sizeof(struct _tse__GetRecordingSummaryResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse * SOAP_FMAC4 soap_new__tse__GetRecordingSummaryResponse(struct soap *soap, int n)
{
	struct _tse__GetRecordingSummaryResponse *p;
	struct _tse__GetRecordingSummaryResponse *a = (struct _tse__GetRecordingSummaryResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetRecordingSummaryResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetRecordingSummaryResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingSummaryResponse(struct soap *soap, const struct _tse__GetRecordingSummaryResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetRecordingSummaryResponse(soap, tag ? tag : "tse:GetRecordingSummaryResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse * SOAP_FMAC4 soap_get__tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingSummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingSummary(struct soap *soap, const struct _tse__GetRecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingSummary(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingSummary *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingSummary), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingSummary * SOAP_FMAC4 soap_in__tse__GetRecordingSummary(struct soap *soap, const char *tag, struct _tse__GetRecordingSummary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetRecordingSummary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSummary, sizeof(struct _tse__GetRecordingSummary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingSummary(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSummary, SOAP_TYPE__tse__GetRecordingSummary, sizeof(struct _tse__GetRecordingSummary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetRecordingSummary * SOAP_FMAC4 soap_new__tse__GetRecordingSummary(struct soap *soap, int n)
{
	struct _tse__GetRecordingSummary *p;
	struct _tse__GetRecordingSummary *a = (struct _tse__GetRecordingSummary*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetRecordingSummary));
	for (p = a; p && n--; p++)
		soap_default__tse__GetRecordingSummary(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingSummary(struct soap *soap, const struct _tse__GetRecordingSummary *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetRecordingSummary(soap, tag ? tag : "tse:GetRecordingSummary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSummary * SOAP_FMAC4 soap_get__tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tse__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotse__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tse:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tse:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotse__Capabilities(soap, "tse:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tse__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tse__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, sizeof(struct _tse__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotse__Capabilities(soap, "tse:Capabilities", &a->Capabilities, "tse:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tse:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, sizeof(struct _tse__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tse__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tse__GetServiceCapabilitiesResponse *p;
	struct _tse__GetServiceCapabilitiesResponse *a = (struct _tse__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tse__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetServiceCapabilitiesResponse(soap, tag ? tag : "tse:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetServiceCapabilities(struct soap *soap, const struct _tse__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tse__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities * SOAP_FMAC4 soap_in__tse__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tse__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tse__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetServiceCapabilities, sizeof(struct _tse__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetServiceCapabilities, SOAP_TYPE__tse__GetServiceCapabilities, sizeof(struct _tse__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities * SOAP_FMAC4 soap_new__tse__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tse__GetServiceCapabilities *p;
	struct _tse__GetServiceCapabilities *a = (struct _tse__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tse__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetServiceCapabilities(struct soap *soap, const struct _tse__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetServiceCapabilities(soap, tag ? tag : "tse:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities * SOAP_FMAC4 soap_get__tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tse__Capabilities(struct soap *soap, struct tse__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->MetadataSearch = NULL;
	a->GeneralStartEvents = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tse__Capabilities(struct soap *soap, const struct tse__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tse__Capabilities(struct soap *soap, const char *tag, int id, const struct tse__Capabilities *a, const char *type)
{
	if (a->MetadataSearch)
	{	soap_set_attr(soap, "MetadataSearch", soap_xsd__boolean2s(soap, *a->MetadataSearch), 1);
	}
	if (a->GeneralStartEvents)
	{	soap_set_attr(soap, "GeneralStartEvents", soap_xsd__boolean2s(soap, *a->GeneralStartEvents), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tse__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tse__Capabilities * SOAP_FMAC4 soap_in_tse__Capabilities(struct soap *soap, const char *tag, struct tse__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tse__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tse__Capabilities, sizeof(struct tse__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tse__Capabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "MetadataSearch", 5, 0);
		if (t)
		{
			if (!(a->MetadataSearch = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->MetadataSearch))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeneralStartEvents", 5, 0);
		if (t)
		{
			if (!(a->GeneralStartEvents = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->GeneralStartEvents))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tse__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tse__Capabilities, SOAP_TYPE_tse__Capabilities, sizeof(struct tse__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tse__Capabilities * SOAP_FMAC4 soap_new_tse__Capabilities(struct soap *soap, int n)
{
	struct tse__Capabilities *p;
	struct tse__Capabilities *a = (struct tse__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tse__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tse__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tse__Capabilities(struct soap *soap, const struct tse__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tse__Capabilities(soap, tag ? tag : "tse:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tse__Capabilities * SOAP_FMAC4 soap_get_tse__Capabilities(struct soap *soap, struct tse__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tse__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetReplayConfigurationResponse(struct soap *soap, struct _trp__GetReplayConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetReplayConfigurationResponse(struct soap *soap, const struct _trp__GetReplayConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ReplayConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetReplayConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trp__GetReplayConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetReplayConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "trp:Configuration");
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "trp:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ReplayConfiguration(soap, "trp:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetReplayConfigurationResponse * SOAP_FMAC4 soap_in__trp__GetReplayConfigurationResponse(struct soap *soap, const char *tag, struct _trp__GetReplayConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trp__GetReplayConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayConfigurationResponse, sizeof(struct _trp__GetReplayConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetReplayConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReplayConfiguration(soap, "trp:Configuration", &a->Configuration, "tt:ReplayConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			soap_check_result(soap, "trp:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trp__GetReplayConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayConfigurationResponse, SOAP_TYPE__trp__GetReplayConfigurationResponse, sizeof(struct _trp__GetReplayConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__GetReplayConfigurationResponse * SOAP_FMAC4 soap_new__trp__GetReplayConfigurationResponse(struct soap *soap, int n)
{
	struct _trp__GetReplayConfigurationResponse *p;
	struct _trp__GetReplayConfigurationResponse *a = (struct _trp__GetReplayConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__GetReplayConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trp__GetReplayConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetReplayConfigurationResponse(struct soap *soap, const struct _trp__GetReplayConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trp__GetReplayConfigurationResponse(soap, tag ? tag : "trp:GetReplayConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayConfigurationResponse * SOAP_FMAC4 soap_get__trp__GetReplayConfigurationResponse(struct soap *soap, struct _trp__GetReplayConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetReplayConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetReplayConfiguration(struct soap *soap, struct _trp__GetReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetReplayConfiguration(struct soap *soap, const struct _trp__GetReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetReplayConfiguration(struct soap *soap, const char *tag, int id, const struct _trp__GetReplayConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetReplayConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetReplayConfiguration * SOAP_FMAC4 soap_in__trp__GetReplayConfiguration(struct soap *soap, const char *tag, struct _trp__GetReplayConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trp__GetReplayConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayConfiguration, sizeof(struct _trp__GetReplayConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetReplayConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__GetReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayConfiguration, SOAP_TYPE__trp__GetReplayConfiguration, sizeof(struct _trp__GetReplayConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__GetReplayConfiguration * SOAP_FMAC4 soap_new__trp__GetReplayConfiguration(struct soap *soap, int n)
{
	struct _trp__GetReplayConfiguration *p;
	struct _trp__GetReplayConfiguration *a = (struct _trp__GetReplayConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__GetReplayConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trp__GetReplayConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetReplayConfiguration(struct soap *soap, const struct _trp__GetReplayConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trp__GetReplayConfiguration(soap, tag ? tag : "trp:GetReplayConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayConfiguration * SOAP_FMAC4 soap_get__trp__GetReplayConfiguration(struct soap *soap, struct _trp__GetReplayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__SetReplayConfigurationResponse(struct soap *soap, struct _trp__SetReplayConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__SetReplayConfigurationResponse(struct soap *soap, const struct _trp__SetReplayConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__SetReplayConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trp__SetReplayConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__SetReplayConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__SetReplayConfigurationResponse * SOAP_FMAC4 soap_in__trp__SetReplayConfigurationResponse(struct soap *soap, const char *tag, struct _trp__SetReplayConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trp__SetReplayConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__SetReplayConfigurationResponse, sizeof(struct _trp__SetReplayConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__SetReplayConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__SetReplayConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__SetReplayConfigurationResponse, SOAP_TYPE__trp__SetReplayConfigurationResponse, sizeof(struct _trp__SetReplayConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__SetReplayConfigurationResponse * SOAP_FMAC4 soap_new__trp__SetReplayConfigurationResponse(struct soap *soap, int n)
{
	struct _trp__SetReplayConfigurationResponse *p;
	struct _trp__SetReplayConfigurationResponse *a = (struct _trp__SetReplayConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__SetReplayConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trp__SetReplayConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__SetReplayConfigurationResponse(struct soap *soap, const struct _trp__SetReplayConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trp__SetReplayConfigurationResponse(soap, tag ? tag : "trp:SetReplayConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__SetReplayConfigurationResponse * SOAP_FMAC4 soap_get__trp__SetReplayConfigurationResponse(struct soap *soap, struct _trp__SetReplayConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__SetReplayConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__SetReplayConfiguration(struct soap *soap, struct _trp__SetReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__SetReplayConfiguration(struct soap *soap, const struct _trp__SetReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ReplayConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__SetReplayConfiguration(struct soap *soap, const char *tag, int id, const struct _trp__SetReplayConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__SetReplayConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "trp:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ReplayConfiguration(soap, "trp:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__SetReplayConfiguration * SOAP_FMAC4 soap_in__trp__SetReplayConfiguration(struct soap *soap, const char *tag, struct _trp__SetReplayConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trp__SetReplayConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__SetReplayConfiguration, sizeof(struct _trp__SetReplayConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__SetReplayConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReplayConfiguration(soap, "trp:Configuration", &a->Configuration, "tt:ReplayConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trp__SetReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__SetReplayConfiguration, SOAP_TYPE__trp__SetReplayConfiguration, sizeof(struct _trp__SetReplayConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__SetReplayConfiguration * SOAP_FMAC4 soap_new__trp__SetReplayConfiguration(struct soap *soap, int n)
{
	struct _trp__SetReplayConfiguration *p;
	struct _trp__SetReplayConfiguration *a = (struct _trp__SetReplayConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__SetReplayConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trp__SetReplayConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__SetReplayConfiguration(struct soap *soap, const struct _trp__SetReplayConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trp__SetReplayConfiguration(soap, tag ? tag : "trp:SetReplayConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__SetReplayConfiguration * SOAP_FMAC4 soap_get__trp__SetReplayConfiguration(struct soap *soap, struct _trp__SetReplayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__SetReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetReplayUriResponse(struct soap *soap, struct _trp__GetReplayUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetReplayUriResponse(struct soap *soap, const struct _trp__GetReplayUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Uri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetReplayUriResponse(struct soap *soap, const char *tag, int id, const struct _trp__GetReplayUriResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetReplayUriResponse), type))
		return soap->error;
	if (a->Uri)
		soap_element_result(soap, "trp:Uri");
	if (!a->Uri)
	{	if (soap_element_empty(soap, "trp:Uri", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "trp:Uri", -1, (char*const*)&a->Uri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetReplayUriResponse * SOAP_FMAC4 soap_in__trp__GetReplayUriResponse(struct soap *soap, const char *tag, struct _trp__GetReplayUriResponse *a, const char *type)
{
	size_t soap_flag_Uri = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trp__GetReplayUriResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayUriResponse, sizeof(struct _trp__GetReplayUriResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetReplayUriResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "trp:Uri", (char**)&a->Uri, "xsd:anyURI"))
				{	soap_flag_Uri--;
					continue;
				}
			}
			soap_check_result(soap, "trp:Uri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Uri))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trp__GetReplayUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayUriResponse, SOAP_TYPE__trp__GetReplayUriResponse, sizeof(struct _trp__GetReplayUriResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__GetReplayUriResponse * SOAP_FMAC4 soap_new__trp__GetReplayUriResponse(struct soap *soap, int n)
{
	struct _trp__GetReplayUriResponse *p;
	struct _trp__GetReplayUriResponse *a = (struct _trp__GetReplayUriResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__GetReplayUriResponse));
	for (p = a; p && n--; p++)
		soap_default__trp__GetReplayUriResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetReplayUriResponse(struct soap *soap, const struct _trp__GetReplayUriResponse *a, const char *tag, const char *type)
{
	if (soap_out__trp__GetReplayUriResponse(soap, tag ? tag : "trp:GetReplayUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayUriResponse * SOAP_FMAC4 soap_get__trp__GetReplayUriResponse(struct soap *soap, struct _trp__GetReplayUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetReplayUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetReplayUri(struct soap *soap, struct _trp__GetReplayUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StreamSetup = NULL;
	soap_default_tt__ReferenceToken(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetReplayUri(struct soap *soap, const struct _trp__GetReplayUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__StreamSetup(soap, &a->StreamSetup);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetReplayUri(struct soap *soap, const char *tag, int id, const struct _trp__GetReplayUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetReplayUri), type))
		return soap->error;
	if (!a->StreamSetup)
	{	if (soap_element_empty(soap, "trp:StreamSetup", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__StreamSetup(soap, "trp:StreamSetup", -1, &a->StreamSetup, ""))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "trp:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trp:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetReplayUri * SOAP_FMAC4 soap_in__trp__GetReplayUri(struct soap *soap, const char *tag, struct _trp__GetReplayUri *a, const char *type)
{
	size_t soap_flag_StreamSetup = 1;
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trp__GetReplayUri*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayUri, sizeof(struct _trp__GetReplayUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetReplayUri(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StreamSetup(soap, "trp:StreamSetup", &a->StreamSetup, "tt:StreamSetup"))
				{	soap_flag_StreamSetup--;
					continue;
				}
			}
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trp:RecordingToken", (char**)&a->RecordingToken, "tt:ReferenceToken"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->StreamSetup || !a->RecordingToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trp__GetReplayUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayUri, SOAP_TYPE__trp__GetReplayUri, sizeof(struct _trp__GetReplayUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__GetReplayUri * SOAP_FMAC4 soap_new__trp__GetReplayUri(struct soap *soap, int n)
{
	struct _trp__GetReplayUri *p;
	struct _trp__GetReplayUri *a = (struct _trp__GetReplayUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__GetReplayUri));
	for (p = a; p && n--; p++)
		soap_default__trp__GetReplayUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetReplayUri(struct soap *soap, const struct _trp__GetReplayUri *a, const char *tag, const char *type)
{
	if (soap_out__trp__GetReplayUri(soap, tag ? tag : "trp:GetReplayUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayUri * SOAP_FMAC4 soap_get__trp__GetReplayUri(struct soap *soap, struct _trp__GetReplayUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetReplayUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetServiceCapabilitiesResponse(struct soap *soap, struct _trp__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trp__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrp__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _trp__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "trp:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "trp:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotrp__Capabilities(soap, "trp:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__trp__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trp__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trp__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, sizeof(struct _trp__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotrp__Capabilities(soap, "trp:Capabilities", &a->Capabilities, "trp:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "trp:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trp__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, sizeof(struct _trp__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__trp__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _trp__GetServiceCapabilitiesResponse *p;
	struct _trp__GetServiceCapabilitiesResponse *a = (struct _trp__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__trp__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trp__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trp__GetServiceCapabilitiesResponse(soap, tag ? tag : "trp:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__trp__GetServiceCapabilitiesResponse(struct soap *soap, struct _trp__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetServiceCapabilities(struct soap *soap, struct _trp__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetServiceCapabilities(struct soap *soap, const struct _trp__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _trp__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilities * SOAP_FMAC4 soap_in__trp__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trp__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trp__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetServiceCapabilities, sizeof(struct _trp__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetServiceCapabilities, SOAP_TYPE__trp__GetServiceCapabilities, sizeof(struct _trp__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__GetServiceCapabilities * SOAP_FMAC4 soap_new__trp__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _trp__GetServiceCapabilities *p;
	struct _trp__GetServiceCapabilities *a = (struct _trp__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__trp__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetServiceCapabilities(struct soap *soap, const struct _trp__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__trp__GetServiceCapabilities(soap, tag ? tag : "trp:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilities * SOAP_FMAC4 soap_get__trp__GetServiceCapabilities(struct soap *soap, struct _trp__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trp__Capabilities(struct soap *soap, struct trp__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->ReversePlayback = NULL;
	soap_default_tt__FloatAttrList(soap, &a->SessionTimeoutRange);
	a->RTP_USCORERTSP_USCORETCP = NULL;
	soap_default_xsd__anyURI(soap, &a->RTSPWebSocketUri);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trp__Capabilities(struct soap *soap, const struct trp__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trp__Capabilities(struct soap *soap, const char *tag, int id, const struct trp__Capabilities *a, const char *type)
{
	if (a->ReversePlayback)
	{	soap_set_attr(soap, "ReversePlayback", soap_xsd__boolean2s(soap, *a->ReversePlayback), 1);
	}
	if (a->SessionTimeoutRange)
		soap_set_attr(soap, "SessionTimeoutRange", soap_tt__FloatAttrList2s(soap, a->SessionTimeoutRange), 1);
	if (a->RTP_USCORERTSP_USCORETCP)
	{	soap_set_attr(soap, "RTP_RTSP_TCP", soap_xsd__boolean2s(soap, *a->RTP_USCORERTSP_USCORETCP), 1);
	}
	if (a->RTSPWebSocketUri)
		soap_set_attr(soap, "RTSPWebSocketUri", soap_xsd__anyURI2s(soap, a->RTSPWebSocketUri), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trp__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trp__Capabilities * SOAP_FMAC4 soap_in_trp__Capabilities(struct soap *soap, const char *tag, struct trp__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trp__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trp__Capabilities, sizeof(struct trp__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trp__Capabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "ReversePlayback", 5, 0);
		if (t)
		{
			if (!(a->ReversePlayback = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->ReversePlayback))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__FloatAttrList(soap, soap_attr_value(soap, "SessionTimeoutRange", 1, 0), &a->SessionTimeoutRange))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "RTP_RTSP_TCP", 5, 0);
		if (t)
		{
			if (!(a->RTP_USCORERTSP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCORERTSP_USCORETCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "RTSPWebSocketUri", 4, 0), &a->RTSPWebSocketUri))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trp__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trp__Capabilities, SOAP_TYPE_trp__Capabilities, sizeof(struct trp__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trp__Capabilities * SOAP_FMAC4 soap_new_trp__Capabilities(struct soap *soap, int n)
{
	struct trp__Capabilities *p;
	struct trp__Capabilities *a = (struct trp__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trp__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_trp__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trp__Capabilities(struct soap *soap, const struct trp__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_trp__Capabilities(soap, tag ? tag : "trp:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trp__Capabilities * SOAP_FMAC4 soap_get_trp__Capabilities(struct soap *soap, struct trp__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trp__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetExportRecordedDataStateResponse(struct soap *soap, struct _trc__GetExportRecordedDataStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Progress);
	a->FileProgressStatus = NULL;
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetExportRecordedDataStateResponse(struct soap *soap, const struct _trc__GetExportRecordedDataStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Progress, SOAP_TYPE_float);
	soap_serialize_PointerTott__ArrayOfFileProgress(soap, &a->FileProgressStatus);
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetExportRecordedDataStateResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetExportRecordedDataStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetExportRecordedDataStateResponse), type))
		return soap->error;
	soap_element_result(soap, "trc:Progress");
	if (soap_out_float(soap, "trc:Progress", -1, &a->Progress, ""))
		return soap->error;
	if (!a->FileProgressStatus)
	{	if (soap_element_empty(soap, "trc:FileProgressStatus", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ArrayOfFileProgress(soap, "trc:FileProgressStatus", -1, &a->FileProgressStatus, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetExportRecordedDataStateResponse * SOAP_FMAC4 soap_in__trc__GetExportRecordedDataStateResponse(struct soap *soap, const char *tag, struct _trc__GetExportRecordedDataStateResponse *a, const char *type)
{
	size_t soap_flag_Progress = 1;
	size_t soap_flag_FileProgressStatus = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetExportRecordedDataStateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetExportRecordedDataStateResponse, sizeof(struct _trc__GetExportRecordedDataStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetExportRecordedDataStateResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Progress && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "trc:Progress", &a->Progress, "xsd:float"))
				{	soap_flag_Progress--;
					continue;
				}
			}
			if (soap_flag_FileProgressStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ArrayOfFileProgress(soap, "trc:FileProgressStatus", &a->FileProgressStatus, "tt:ArrayOfFileProgress"))
				{	soap_flag_FileProgressStatus--;
					continue;
				}
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			soap_check_result(soap, "trc:Progress");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Progress > 0 || !a->FileProgressStatus))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetExportRecordedDataStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetExportRecordedDataStateResponse, SOAP_TYPE__trc__GetExportRecordedDataStateResponse, sizeof(struct _trc__GetExportRecordedDataStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetExportRecordedDataStateResponse * SOAP_FMAC4 soap_new__trc__GetExportRecordedDataStateResponse(struct soap *soap, int n)
{
	struct _trc__GetExportRecordedDataStateResponse *p;
	struct _trc__GetExportRecordedDataStateResponse *a = (struct _trc__GetExportRecordedDataStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetExportRecordedDataStateResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetExportRecordedDataStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetExportRecordedDataStateResponse(struct soap *soap, const struct _trc__GetExportRecordedDataStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetExportRecordedDataStateResponse(soap, tag ? tag : "trc:GetExportRecordedDataStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetExportRecordedDataStateResponse * SOAP_FMAC4 soap_get__trc__GetExportRecordedDataStateResponse(struct soap *soap, struct _trc__GetExportRecordedDataStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetExportRecordedDataStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetExportRecordedDataState(struct soap *soap, struct _trc__GetExportRecordedDataState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OperationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetExportRecordedDataState(struct soap *soap, const struct _trc__GetExportRecordedDataState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OperationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetExportRecordedDataState(struct soap *soap, const char *tag, int id, const struct _trc__GetExportRecordedDataState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetExportRecordedDataState), type))
		return soap->error;
	if (!a->OperationToken)
	{	if (soap_element_empty(soap, "trc:OperationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trc:OperationToken", -1, (char*const*)&a->OperationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetExportRecordedDataState * SOAP_FMAC4 soap_in__trc__GetExportRecordedDataState(struct soap *soap, const char *tag, struct _trc__GetExportRecordedDataState *a, const char *type)
{
	size_t soap_flag_OperationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetExportRecordedDataState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetExportRecordedDataState, sizeof(struct _trc__GetExportRecordedDataState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetExportRecordedDataState(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OperationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trc:OperationToken", (char**)&a->OperationToken, "tt:ReferenceToken"))
				{	soap_flag_OperationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OperationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetExportRecordedDataState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetExportRecordedDataState, SOAP_TYPE__trc__GetExportRecordedDataState, sizeof(struct _trc__GetExportRecordedDataState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetExportRecordedDataState * SOAP_FMAC4 soap_new__trc__GetExportRecordedDataState(struct soap *soap, int n)
{
	struct _trc__GetExportRecordedDataState *p;
	struct _trc__GetExportRecordedDataState *a = (struct _trc__GetExportRecordedDataState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetExportRecordedDataState));
	for (p = a; p && n--; p++)
		soap_default__trc__GetExportRecordedDataState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetExportRecordedDataState(struct soap *soap, const struct _trc__GetExportRecordedDataState *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetExportRecordedDataState(soap, tag ? tag : "trc:GetExportRecordedDataState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetExportRecordedDataState * SOAP_FMAC4 soap_get__trc__GetExportRecordedDataState(struct soap *soap, struct _trc__GetExportRecordedDataState *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetExportRecordedDataState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__StopExportRecordedDataResponse(struct soap *soap, struct _trc__StopExportRecordedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Progress);
	a->FileProgressStatus = NULL;
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__StopExportRecordedDataResponse(struct soap *soap, const struct _trc__StopExportRecordedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Progress, SOAP_TYPE_float);
	soap_serialize_PointerTott__ArrayOfFileProgress(soap, &a->FileProgressStatus);
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__StopExportRecordedDataResponse(struct soap *soap, const char *tag, int id, const struct _trc__StopExportRecordedDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__StopExportRecordedDataResponse), type))
		return soap->error;
	soap_element_result(soap, "trc:Progress");
	if (soap_out_float(soap, "trc:Progress", -1, &a->Progress, ""))
		return soap->error;
	if (!a->FileProgressStatus)
	{	if (soap_element_empty(soap, "trc:FileProgressStatus", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ArrayOfFileProgress(soap, "trc:FileProgressStatus", -1, &a->FileProgressStatus, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__StopExportRecordedDataResponse * SOAP_FMAC4 soap_in__trc__StopExportRecordedDataResponse(struct soap *soap, const char *tag, struct _trc__StopExportRecordedDataResponse *a, const char *type)
{
	size_t soap_flag_Progress = 1;
	size_t soap_flag_FileProgressStatus = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__StopExportRecordedDataResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__StopExportRecordedDataResponse, sizeof(struct _trc__StopExportRecordedDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__StopExportRecordedDataResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Progress && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "trc:Progress", &a->Progress, "xsd:float"))
				{	soap_flag_Progress--;
					continue;
				}
			}
			if (soap_flag_FileProgressStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ArrayOfFileProgress(soap, "trc:FileProgressStatus", &a->FileProgressStatus, "tt:ArrayOfFileProgress"))
				{	soap_flag_FileProgressStatus--;
					continue;
				}
			}
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			soap_check_result(soap, "trc:Progress");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Progress > 0 || !a->FileProgressStatus))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__StopExportRecordedDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__StopExportRecordedDataResponse, SOAP_TYPE__trc__StopExportRecordedDataResponse, sizeof(struct _trc__StopExportRecordedDataResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__StopExportRecordedDataResponse * SOAP_FMAC4 soap_new__trc__StopExportRecordedDataResponse(struct soap *soap, int n)
{
	struct _trc__StopExportRecordedDataResponse *p;
	struct _trc__StopExportRecordedDataResponse *a = (struct _trc__StopExportRecordedDataResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__StopExportRecordedDataResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__StopExportRecordedDataResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__StopExportRecordedDataResponse(struct soap *soap, const struct _trc__StopExportRecordedDataResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__StopExportRecordedDataResponse(soap, tag ? tag : "trc:StopExportRecordedDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__StopExportRecordedDataResponse * SOAP_FMAC4 soap_get__trc__StopExportRecordedDataResponse(struct soap *soap, struct _trc__StopExportRecordedDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__StopExportRecordedDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__StopExportRecordedData(struct soap *soap, struct _trc__StopExportRecordedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OperationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__StopExportRecordedData(struct soap *soap, const struct _trc__StopExportRecordedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OperationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__StopExportRecordedData(struct soap *soap, const char *tag, int id, const struct _trc__StopExportRecordedData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__StopExportRecordedData), type))
		return soap->error;
	if (!a->OperationToken)
	{	if (soap_element_empty(soap, "trc:OperationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trc:OperationToken", -1, (char*const*)&a->OperationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__StopExportRecordedData * SOAP_FMAC4 soap_in__trc__StopExportRecordedData(struct soap *soap, const char *tag, struct _trc__StopExportRecordedData *a, const char *type)
{
	size_t soap_flag_OperationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__StopExportRecordedData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__StopExportRecordedData, sizeof(struct _trc__StopExportRecordedData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__StopExportRecordedData(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OperationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trc:OperationToken", (char**)&a->OperationToken, "tt:ReferenceToken"))
				{	soap_flag_OperationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OperationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__StopExportRecordedData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__StopExportRecordedData, SOAP_TYPE__trc__StopExportRecordedData, sizeof(struct _trc__StopExportRecordedData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__StopExportRecordedData * SOAP_FMAC4 soap_new__trc__StopExportRecordedData(struct soap *soap, int n)
{
	struct _trc__StopExportRecordedData *p;
	struct _trc__StopExportRecordedData *a = (struct _trc__StopExportRecordedData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__StopExportRecordedData));
	for (p = a; p && n--; p++)
		soap_default__trc__StopExportRecordedData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__StopExportRecordedData(struct soap *soap, const struct _trc__StopExportRecordedData *a, const char *tag, const char *type)
{
	if (soap_out__trc__StopExportRecordedData(soap, tag ? tag : "trc:StopExportRecordedData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__StopExportRecordedData * SOAP_FMAC4 soap_get__trc__StopExportRecordedData(struct soap *soap, struct _trc__StopExportRecordedData *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__StopExportRecordedData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__ExportRecordedDataResponse_Extension(struct soap *soap, struct _trc__ExportRecordedDataResponse_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__ExportRecordedDataResponse_Extension(struct soap *soap, const struct _trc__ExportRecordedDataResponse_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__ExportRecordedDataResponse_Extension(struct soap *soap, const char *tag, int id, const struct _trc__ExportRecordedDataResponse_Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse_Extension * SOAP_FMAC4 soap_in__trc__ExportRecordedDataResponse_Extension(struct soap *soap, const char *tag, struct _trc__ExportRecordedDataResponse_Extension *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__ExportRecordedDataResponse_Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension, sizeof(struct _trc__ExportRecordedDataResponse_Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__ExportRecordedDataResponse_Extension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__ExportRecordedDataResponse_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension, sizeof(struct _trc__ExportRecordedDataResponse_Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse_Extension * SOAP_FMAC4 soap_new__trc__ExportRecordedDataResponse_Extension(struct soap *soap, int n)
{
	struct _trc__ExportRecordedDataResponse_Extension *p;
	struct _trc__ExportRecordedDataResponse_Extension *a = (struct _trc__ExportRecordedDataResponse_Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__ExportRecordedDataResponse_Extension));
	for (p = a; p && n--; p++)
		soap_default__trc__ExportRecordedDataResponse_Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__ExportRecordedDataResponse_Extension(struct soap *soap, const struct _trc__ExportRecordedDataResponse_Extension *a, const char *tag, const char *type)
{
	if (soap_out__trc__ExportRecordedDataResponse_Extension(soap, tag ? tag : "trc:ExportRecordedDataResponse-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse_Extension * SOAP_FMAC4 soap_get__trc__ExportRecordedDataResponse_Extension(struct soap *soap, struct _trc__ExportRecordedDataResponse_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__ExportRecordedDataResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__ExportRecordedDataResponse(struct soap *soap, struct _trc__ExportRecordedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OperationToken);
	a->__sizeFileNames = 0;
	a->FileNames = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__ExportRecordedDataResponse(struct soap *soap, const struct _trc__ExportRecordedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OperationToken);
	if (a->FileNames)
	{	int i;
		for (i = 0; i < (int)a->__sizeFileNames; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->FileNames + i));
		}
	}
	soap_serialize_PointerTo_trc__ExportRecordedDataResponse_Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__ExportRecordedDataResponse(struct soap *soap, const char *tag, int id, const struct _trc__ExportRecordedDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__ExportRecordedDataResponse), type))
		return soap->error;
	if (a->OperationToken)
		soap_element_result(soap, "trc:OperationToken");
	if (!a->OperationToken)
	{	if (soap_element_empty(soap, "trc:OperationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trc:OperationToken", -1, (char*const*)&a->OperationToken, ""))
		return soap->error;
	if (a->FileNames)
	{	int i;
		for (i = 0; i < (int)a->__sizeFileNames; i++)
			if (soap_out_string(soap, "trc:FileNames", -1, (char*const*)(a->FileNames + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTo_trc__ExportRecordedDataResponse_Extension(soap, "trc:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse * SOAP_FMAC4 soap_in__trc__ExportRecordedDataResponse(struct soap *soap, const char *tag, struct _trc__ExportRecordedDataResponse *a, const char *type)
{
	size_t soap_flag_OperationToken = 1;
	struct soap_blist *soap_blist_FileNames = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__ExportRecordedDataResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__ExportRecordedDataResponse, sizeof(struct _trc__ExportRecordedDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__ExportRecordedDataResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OperationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trc:OperationToken", (char**)&a->OperationToken, "tt:ReferenceToken"))
				{	soap_flag_OperationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trc:FileNames", 1, NULL))
			{	if (a->FileNames == NULL)
				{	if (soap_blist_FileNames == NULL)
						soap_blist_FileNames = soap_alloc_block(soap);
					a->FileNames = (char **)soap_push_block_max(soap, soap_blist_FileNames, sizeof(char *));
					if (a->FileNames == NULL)
						return NULL;
					*a->FileNames = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "trc:FileNames", (char**)a->FileNames, "xsd:string"))
				{	a->__sizeFileNames++;
					a->FileNames = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trc__ExportRecordedDataResponse_Extension(soap, "trc:Extension", &a->Extension, ""))
				{	soap_flag_Extension--;
					continue;
				}
			}
			soap_check_result(soap, "trc:OperationToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->FileNames)
			soap_pop_block(soap, soap_blist_FileNames);
		if (a->__sizeFileNames)
		{	a->FileNames = (char **)soap_save_block(soap, soap_blist_FileNames, NULL, 1);
		}
		else
		{	a->FileNames = NULL;
			if (soap_blist_FileNames)
				soap_end_block(soap, soap_blist_FileNames);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OperationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__ExportRecordedDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__ExportRecordedDataResponse, SOAP_TYPE__trc__ExportRecordedDataResponse, sizeof(struct _trc__ExportRecordedDataResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse * SOAP_FMAC4 soap_new__trc__ExportRecordedDataResponse(struct soap *soap, int n)
{
	struct _trc__ExportRecordedDataResponse *p;
	struct _trc__ExportRecordedDataResponse *a = (struct _trc__ExportRecordedDataResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__ExportRecordedDataResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__ExportRecordedDataResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__ExportRecordedDataResponse(struct soap *soap, const struct _trc__ExportRecordedDataResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__ExportRecordedDataResponse(soap, tag ? tag : "trc:ExportRecordedDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse * SOAP_FMAC4 soap_get__trc__ExportRecordedDataResponse(struct soap *soap, struct _trc__ExportRecordedDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__ExportRecordedDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__ExportRecordedData(struct soap *soap, struct _trc__ExportRecordedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StartPoint = NULL;
	a->EndPoint = NULL;
	a->SearchScope = NULL;
	soap_default_string(soap, &a->FileFormat);
	a->StorageDestination = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__ExportRecordedData(struct soap *soap, const struct _trc__ExportRecordedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTodateTime(soap, &a->StartPoint);
	soap_serialize_PointerTodateTime(soap, &a->EndPoint);
	soap_serialize_PointerTott__SearchScope(soap, &a->SearchScope);
	soap_serialize_string(soap, (char*const*)&a->FileFormat);
	soap_serialize_PointerTott__StorageReferencePath(soap, &a->StorageDestination);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__ExportRecordedData(struct soap *soap, const char *tag, int id, const struct _trc__ExportRecordedData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__ExportRecordedData), type))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "trc:StartPoint", -1, &a->StartPoint, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "trc:EndPoint", -1, &a->EndPoint, ""))
		return soap->error;
	if (!a->SearchScope)
	{	if (soap_element_empty(soap, "trc:SearchScope", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SearchScope(soap, "trc:SearchScope", -1, &a->SearchScope, ""))
		return soap->error;
	if (!a->FileFormat)
	{	if (soap_element_empty(soap, "trc:FileFormat", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "trc:FileFormat", -1, (char*const*)&a->FileFormat, ""))
		return soap->error;
	if (!a->StorageDestination)
	{	if (soap_element_empty(soap, "trc:StorageDestination", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__StorageReferencePath(soap, "trc:StorageDestination", -1, &a->StorageDestination, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__ExportRecordedData * SOAP_FMAC4 soap_in__trc__ExportRecordedData(struct soap *soap, const char *tag, struct _trc__ExportRecordedData *a, const char *type)
{
	size_t soap_flag_StartPoint = 1;
	size_t soap_flag_EndPoint = 1;
	size_t soap_flag_SearchScope = 1;
	size_t soap_flag_FileFormat = 1;
	size_t soap_flag_StorageDestination = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__ExportRecordedData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__ExportRecordedData, sizeof(struct _trc__ExportRecordedData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__ExportRecordedData(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "trc:StartPoint", &a->StartPoint, "xsd:dateTime"))
				{	soap_flag_StartPoint--;
					continue;
				}
			}
			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "trc:EndPoint", &a->EndPoint, "xsd:dateTime"))
				{	soap_flag_EndPoint--;
					continue;
				}
			}
			if (soap_flag_SearchScope && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SearchScope(soap, "trc:SearchScope", &a->SearchScope, "tt:SearchScope"))
				{	soap_flag_SearchScope--;
					continue;
				}
			}
			if (soap_flag_FileFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "trc:FileFormat", (char**)&a->FileFormat, "xsd:string"))
				{	soap_flag_FileFormat--;
					continue;
				}
			}
			if (soap_flag_StorageDestination && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StorageReferencePath(soap, "trc:StorageDestination", &a->StorageDestination, "tt:StorageReferencePath"))
				{	soap_flag_StorageDestination--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SearchScope || !a->FileFormat || !a->StorageDestination))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__ExportRecordedData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__ExportRecordedData, SOAP_TYPE__trc__ExportRecordedData, sizeof(struct _trc__ExportRecordedData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__ExportRecordedData * SOAP_FMAC4 soap_new__trc__ExportRecordedData(struct soap *soap, int n)
{
	struct _trc__ExportRecordedData *p;
	struct _trc__ExportRecordedData *a = (struct _trc__ExportRecordedData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__ExportRecordedData));
	for (p = a; p && n--; p++)
		soap_default__trc__ExportRecordedData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__ExportRecordedData(struct soap *soap, const struct _trc__ExportRecordedData *a, const char *tag, const char *type)
{
	if (soap_out__trc__ExportRecordedData(soap, tag ? tag : "trc:ExportRecordedData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__ExportRecordedData * SOAP_FMAC4 soap_get__trc__ExportRecordedData(struct soap *soap, struct _trc__ExportRecordedData *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__ExportRecordedData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingOptionsResponse(struct soap *soap, struct _trc__GetRecordingOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingOptionsResponse(struct soap *soap, const struct _trc__GetRecordingOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrc__RecordingOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trc:Options");
	if (!a->Options)
	{	if (soap_element_empty(soap, "trc:Options", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotrc__RecordingOptions(soap, "trc:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingOptionsResponse * SOAP_FMAC4 soap_in__trc__GetRecordingOptionsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetRecordingOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingOptionsResponse, sizeof(struct _trc__GetRecordingOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotrc__RecordingOptions(soap, "trc:Options", &a->Options, "trc:RecordingOptions"))
				{	soap_flag_Options--;
					continue;
				}
			}
			soap_check_result(soap, "trc:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingOptionsResponse, SOAP_TYPE__trc__GetRecordingOptionsResponse, sizeof(struct _trc__GetRecordingOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingOptionsResponse * SOAP_FMAC4 soap_new__trc__GetRecordingOptionsResponse(struct soap *soap, int n)
{
	struct _trc__GetRecordingOptionsResponse *p;
	struct _trc__GetRecordingOptionsResponse *a = (struct _trc__GetRecordingOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingOptionsResponse(struct soap *soap, const struct _trc__GetRecordingOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingOptionsResponse(soap, tag ? tag : "trc:GetRecordingOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingOptionsResponse * SOAP_FMAC4 soap_get__trc__GetRecordingOptionsResponse(struct soap *soap, struct _trc__GetRecordingOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
