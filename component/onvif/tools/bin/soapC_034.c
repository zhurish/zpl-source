/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:06 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DigitalInput(struct soap *soap, struct tt__DigitalInput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DigitalInput))
		soap_serialize_tt__DigitalInput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DigitalInput(struct soap *soap, const char *tag, int id, struct tt__DigitalInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DigitalInput, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DigitalInput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DigitalInput ** SOAP_FMAC4 soap_in_PointerTott__DigitalInput(struct soap *soap, const char *tag, struct tt__DigitalInput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DigitalInput **)soap_malloc(soap, sizeof(struct tt__DigitalInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DigitalInput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DigitalInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DigitalInput, sizeof(struct tt__DigitalInput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DigitalInput(struct soap *soap, struct tt__DigitalInput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DigitalInput(soap, tag ? tag : "tt:DigitalInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DigitalInput ** SOAP_FMAC4 soap_get_PointerTott__DigitalInput(struct soap *soap, struct tt__DigitalInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DigitalInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutput(struct soap *soap, struct tt__RelayOutput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutput))
		soap_serialize_tt__RelayOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutput(struct soap *soap, const char *tag, int id, struct tt__RelayOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutput, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelayOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelayOutput ** SOAP_FMAC4 soap_in_PointerTott__RelayOutput(struct soap *soap, const char *tag, struct tt__RelayOutput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelayOutput **)soap_malloc(soap, sizeof(struct tt__RelayOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelayOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelayOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutput(struct soap *soap, struct tt__RelayOutput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelayOutput(soap, tag ? tag : "tt:RelayOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutput ** SOAP_FMAC4 soap_get_PointerTott__RelayOutput(struct soap *soap, struct tt__RelayOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutputConfigurationOptions))
		soap_serialize_tt__AudioOutputConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutputConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioOutputConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioOutputConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioOutputConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(struct tt__AudioOutputConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioOutputConfigurationOptions(soap, tag ? tag : "tt:AudioOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceConfigurationOptions))
		soap_serialize_tt__AudioSourceConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioSourceConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(struct tt__AudioSourceConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioSourceConfigurationOptions(soap, tag ? tag : "tt:AudioSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoOutputConfigurationOptions(struct soap *soap, struct tt__VideoOutputConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoOutputConfigurationOptions))
		soap_serialize_tt__VideoOutputConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoOutputConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoOutputConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoOutputConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoOutputConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoOutputConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoOutputConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoOutputConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutputConfigurationOptions, sizeof(struct tt__VideoOutputConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoOutputConfigurationOptions(struct soap *soap, struct tt__VideoOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoOutputConfigurationOptions(soap, tag ? tag : "tt:VideoOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoOutputConfigurationOptions(struct soap *soap, struct tt__VideoOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptions))
		soap_serialize_tt__VideoSourceConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(struct tt__VideoSourceConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationOptions(soap, tag ? tag : "tt:VideoSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoOutputConfiguration(struct soap *soap, struct tt__VideoOutputConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoOutputConfiguration))
		soap_serialize_tt__VideoOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoOutputConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoOutputConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoOutputConfiguration(struct soap *soap, const char *tag, struct tt__VideoOutputConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoOutputConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(struct tt__VideoOutputConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoOutputConfiguration(struct soap *soap, struct tt__VideoOutputConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoOutputConfiguration(soap, tag ? tag : "tt:VideoOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoOutputConfiguration(struct soap *soap, struct tt__VideoOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfiguration))
		soap_serialize_tt__VideoSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, struct tt__VideoSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, tag ? tag : "tt:VideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutputConfiguration))
		soap_serialize_tt__AudioOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutputConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, struct tt__AudioOutputConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioOutputConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, tag ? tag : "tt:AudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceConfiguration))
		soap_serialize_tt__AudioSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, struct tt__AudioSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioSourceConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, tag ? tag : "tt:AudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoOutput(struct soap *soap, struct tt__VideoOutput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoOutput))
		soap_serialize_tt__VideoOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoOutput(struct soap *soap, const char *tag, int id, struct tt__VideoOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoOutput, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoOutput ** SOAP_FMAC4 soap_in_PointerTott__VideoOutput(struct soap *soap, const char *tag, struct tt__VideoOutput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoOutput **)soap_malloc(soap, sizeof(struct tt__VideoOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutput, sizeof(struct tt__VideoOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoOutput(struct soap *soap, struct tt__VideoOutput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoOutput(soap, tag ? tag : "tt:VideoOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutput ** SOAP_FMAC4 soap_get_PointerTott__VideoOutput(struct soap *soap, struct tt__VideoOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__RelayOutputOptions(struct soap *soap, struct tmd__RelayOutputOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__RelayOutputOptions))
		soap_serialize_tmd__RelayOutputOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__RelayOutputOptions(struct soap *soap, const char *tag, int id, struct tmd__RelayOutputOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__RelayOutputOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__RelayOutputOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__RelayOutputOptions ** SOAP_FMAC4 soap_in_PointerTotmd__RelayOutputOptions(struct soap *soap, const char *tag, struct tmd__RelayOutputOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__RelayOutputOptions **)soap_malloc(soap, sizeof(struct tmd__RelayOutputOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__RelayOutputOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__RelayOutputOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__RelayOutputOptions, sizeof(struct tmd__RelayOutputOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__RelayOutputOptions(struct soap *soap, struct tmd__RelayOutputOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotmd__RelayOutputOptions(soap, tag ? tag : "tmd:RelayOutputOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__RelayOutputOptions ** SOAP_FMAC4 soap_get_PointerTotmd__RelayOutputOptions(struct soap *soap, struct tmd__RelayOutputOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__RelayOutputOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__Capabilities(struct soap *soap, struct tmd__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__Capabilities))
		soap_serialize_tmd__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__Capabilities(struct soap *soap, const char *tag, int id, struct tmd__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__Capabilities ** SOAP_FMAC4 soap_in_PointerTotmd__Capabilities(struct soap *soap, const char *tag, struct tmd__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__Capabilities **)soap_malloc(soap, sizeof(struct tmd__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__Capabilities, sizeof(struct tmd__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__Capabilities(struct soap *soap, struct tmd__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotmd__Capabilities(soap, tag ? tag : "tmd:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__Capabilities ** SOAP_FMAC4 soap_get_PointerTotmd__Capabilities(struct soap *soap, struct tmd__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__ParityBit(struct soap *soap, enum tmd__ParityBit *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tmd__ParityBit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__ParityBit(struct soap *soap, const char *tag, int id, enum tmd__ParityBit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__ParityBit, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__ParityBit(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tmd__ParityBit ** SOAP_FMAC4 soap_in_PointerTotmd__ParityBit(struct soap *soap, const char *tag, enum tmd__ParityBit **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tmd__ParityBit **)soap_malloc(soap, sizeof(enum tmd__ParityBit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__ParityBit(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tmd__ParityBit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__ParityBit, sizeof(enum tmd__ParityBit), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__ParityBit(struct soap *soap, enum tmd__ParityBit *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotmd__ParityBit(soap, tag ? tag : "tmd:ParityBit", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tmd__ParityBit ** SOAP_FMAC4 soap_get_PointerTotmd__ParityBit(struct soap *soap, enum tmd__ParityBit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__ParityBit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FloatItems(struct soap *soap, struct tt__FloatItems *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FloatItems))
		soap_serialize_tt__FloatItems(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FloatItems(struct soap *soap, const char *tag, int id, struct tt__FloatItems *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FloatItems, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FloatItems(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FloatItems ** SOAP_FMAC4 soap_in_PointerTott__FloatItems(struct soap *soap, const char *tag, struct tt__FloatItems **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FloatItems **)soap_malloc(soap, sizeof(struct tt__FloatItems *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FloatItems(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FloatItems **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatItems, sizeof(struct tt__FloatItems), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FloatItems(struct soap *soap, struct tt__FloatItems *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FloatItems(soap, tag ? tag : "tt:FloatItems", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatItems ** SOAP_FMAC4 soap_get_PointerTott__FloatItems(struct soap *soap, struct tt__FloatItems **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FloatItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__ParityBitList(struct soap *soap, struct tmd__ParityBitList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__ParityBitList))
		soap_serialize_tmd__ParityBitList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__ParityBitList(struct soap *soap, const char *tag, int id, struct tmd__ParityBitList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__ParityBitList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__ParityBitList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__ParityBitList ** SOAP_FMAC4 soap_in_PointerTotmd__ParityBitList(struct soap *soap, const char *tag, struct tmd__ParityBitList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__ParityBitList **)soap_malloc(soap, sizeof(struct tmd__ParityBitList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__ParityBitList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__ParityBitList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__ParityBitList, sizeof(struct tmd__ParityBitList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__ParityBitList(struct soap *soap, struct tmd__ParityBitList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotmd__ParityBitList(soap, tag ? tag : "tmd:ParityBitList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__ParityBitList ** SOAP_FMAC4 soap_get_PointerTotmd__ParityBitList(struct soap *soap, struct tmd__ParityBitList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__ParityBitList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntItems(struct soap *soap, struct tt__IntItems *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntItems))
		soap_serialize_tt__IntItems(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntItems(struct soap *soap, const char *tag, int id, struct tt__IntItems *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntItems, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntItems(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntItems ** SOAP_FMAC4 soap_in_PointerTott__IntItems(struct soap *soap, const char *tag, struct tt__IntItems **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntItems **)soap_malloc(soap, sizeof(struct tt__IntItems *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntItems(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntItems **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntItems, sizeof(struct tt__IntItems), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntItems(struct soap *soap, struct tt__IntItems *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntItems(soap, tag ? tag : "tt:IntItems", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntItems ** SOAP_FMAC4 soap_get_PointerTott__IntItems(struct soap *soap, struct tt__IntItems **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DigitalIdleState(struct soap *soap, enum tt__DigitalIdleState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__DigitalIdleState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DigitalIdleState(struct soap *soap, const char *tag, int id, enum tt__DigitalIdleState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DigitalIdleState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DigitalIdleState(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__DigitalIdleState ** SOAP_FMAC4 soap_in_PointerTott__DigitalIdleState(struct soap *soap, const char *tag, enum tt__DigitalIdleState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__DigitalIdleState **)soap_malloc(soap, sizeof(enum tt__DigitalIdleState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DigitalIdleState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__DigitalIdleState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DigitalIdleState, sizeof(enum tt__DigitalIdleState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DigitalIdleState(struct soap *soap, enum tt__DigitalIdleState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DigitalIdleState(soap, tag ? tag : "tt:DigitalIdleState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DigitalIdleState ** SOAP_FMAC4 soap_get_PointerTott__DigitalIdleState(struct soap *soap, enum tt__DigitalIdleState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DigitalIdleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReferenceToken(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceToken))
		soap_serialize_tt__ReferenceToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReferenceToken(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReferenceToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReferenceToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__ReferenceToken(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReferenceToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReferenceToken, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReferenceToken(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__ReferenceToken(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__RelayOutputOptionsExtension(struct soap *soap, struct tmd__RelayOutputOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__RelayOutputOptionsExtension))
		soap_serialize_tmd__RelayOutputOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__RelayOutputOptionsExtension(struct soap *soap, const char *tag, int id, struct tmd__RelayOutputOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__RelayOutputOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__RelayOutputOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__RelayOutputOptionsExtension ** SOAP_FMAC4 soap_in_PointerTotmd__RelayOutputOptionsExtension(struct soap *soap, const char *tag, struct tmd__RelayOutputOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__RelayOutputOptionsExtension **)soap_malloc(soap, sizeof(struct tmd__RelayOutputOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__RelayOutputOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__RelayOutputOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__RelayOutputOptionsExtension, sizeof(struct tmd__RelayOutputOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__RelayOutputOptionsExtension(struct soap *soap, struct tmd__RelayOutputOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotmd__RelayOutputOptionsExtension(soap, tag ? tag : "tmd:RelayOutputOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__RelayOutputOptionsExtension ** SOAP_FMAC4 soap_get_PointerTotmd__RelayOutputOptionsExtension(struct soap *soap, struct tmd__RelayOutputOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__RelayOutputOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayMode(struct soap *soap, enum tt__RelayMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__RelayMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayMode(struct soap *soap, const char *tag, int id, enum tt__RelayMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelayMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__RelayMode ** SOAP_FMAC4 soap_in_PointerTott__RelayMode(struct soap *soap, const char *tag, enum tt__RelayMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__RelayMode **)soap_malloc(soap, sizeof(enum tt__RelayMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelayMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__RelayMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayMode(struct soap *soap, enum tt__RelayMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelayMode(soap, tag ? tag : "tt:RelayMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayMode ** SOAP_FMAC4 soap_get_PointerTott__RelayMode(struct soap *soap, enum tt__RelayMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, struct soap_dom_element *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		soap_serialize_xsd__anyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, struct soap_dom_element *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct soap_dom_element ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, struct soap_dom_element **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct soap_dom_element **)soap_malloc(soap, sizeof(struct soap_dom_element *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct soap_dom_element **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(struct soap_dom_element), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, struct soap_dom_element *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__anyType(soap, tag ? tag : "xsd:anyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_element ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, struct soap_dom_element **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__ConcreteTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__ConcreteTopicExpression, 5, 0, -1, "(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)(/([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ConcreteTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wstop__ConcreteTopicExpression(soap, tag ? tag : "wstop:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__ConcreteTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__FullTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__FullTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__FullTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__FullTopicExpression, 5, 0, -1, "([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*(\\|([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*)*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__FullTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wstop__FullTopicExpression(soap, tag ? tag : "wstop:FullTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__FullTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__FullTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceToken(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__ReferenceToken);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__ReferenceToken(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__ReferenceToken, 1, 0, 64, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceToken(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__ReferenceToken(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioClassType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__AudioClassType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__AudioClassType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__AudioClassType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__AudioClassType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassType(soap, tag ? tag : "tt:AudioClassType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__AudioClassType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobState(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobState(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__RecordingJobState);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__RecordingJobState(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__RecordingJobState, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobState(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobState(soap, tag ? tag : "tt:RecordingJobState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__RecordingJobState(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobMode(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobMode(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__RecordingJobMode);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__RecordingJobMode(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__RecordingJobMode, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobMode(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobMode(soap, tag ? tag : "tt:RecordingJobMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__RecordingJobMode(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__XPathExpression(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__XPathExpression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__XPathExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__XPathExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__XPathExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__XPathExpression, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__XPathExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__XPathExpression(soap, tag ? tag : "tt:XPathExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__XPathExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__XPathExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Description(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Description(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Description);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Description(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Description, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Description(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__Description(soap, tag ? tag : "tt:Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Description(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AuxiliaryData(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__AuxiliaryData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AuxiliaryData(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__AuxiliaryData);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__AuxiliaryData(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__AuxiliaryData, 1, 0, 128, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AuxiliaryData(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__AuxiliaryData(soap, tag ? tag : "tt:AuxiliaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__AuxiliaryData(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSKPassphrase(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKPassphrase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Dot11PSKPassphrase);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Dot11PSKPassphrase, 1, 0, -1, "[ -~]{8,63}");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKPassphrase(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11PSKPassphrase(soap, tag ? tag : "tt:Dot11PSKPassphrase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Dot11PSKPassphrase(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKPassphrase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Name(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Name);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Name(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Name, 1, 0, 64, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Name(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__Name(soap, tag ? tag : "tt:Name", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Name(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__EncodingTypes(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_trc__EncodingTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__EncodingTypes(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_trc__EncodingTypes);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_trc__EncodingTypes(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_trc__EncodingTypes, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__EncodingTypes(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_trc__EncodingTypes(soap, tag ? tag : "trc:EncodingTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_trc__EncodingTypes(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__EncodingTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trt__EncodingTypes(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_trt__EncodingTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trt__EncodingTypes(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_trt__EncodingTypes);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_trt__EncodingTypes(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_trt__EncodingTypes, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trt__EncodingTypes(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_trt__EncodingTypes(soap, tag ? tag : "trt:EncodingTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_trt__EncodingTypes(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_trt__EncodingTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag ? tag : "wsnt:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceTokenList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceTokenList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceTokenList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__ReferenceTokenList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__ReferenceTokenList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__ReferenceTokenList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceTokenList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__ReferenceTokenList(soap, tag ? tag : "tt:ReferenceTokenList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__ReferenceTokenList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceTokenList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__StringList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__StringList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__StringList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__StringList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__StringList(soap, tag ? tag : "tt:StringList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__StringList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringAttrList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__StringAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__StringAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__StringAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__StringAttrList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__StringAttrList(soap, tag ? tag : "tt:StringAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__StringAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatAttrList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__FloatAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__FloatAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__FloatAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__FloatAttrList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__FloatAttrList(soap, tag ? tag : "tt:FloatAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__FloatAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntAttrList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__IntAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__IntAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__IntAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__IntAttrList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__IntAttrList(soap, tag ? tag : "tt:IntAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__IntAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__EAPMethodTypes(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tds__EAPMethodTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__EAPMethodTypes(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tds__EAPMethodTypes);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tds__EAPMethodTypes(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tds__EAPMethodTypes, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__EAPMethodTypes(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tds__EAPMethodTypes(soap, tag ? tag : "tds:EAPMethodTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tds__EAPMethodTypes(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__EAPMethodTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__DelayTimes(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tmd__DelayTimes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__DelayTimes(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tmd__DelayTimes);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tmd__DelayTimes(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tmd__DelayTimes, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__DelayTimes(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tmd__DelayTimes(soap, tag ? tag : "tmd:DelayTimes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tmd__DelayTimes(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__DelayTimes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xml__lang(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 5, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 5, 0, -1, "\\+?\\d+");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__integer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 5, 0, -1, "[-+]?\\d+");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__duration, 5, 0, -1, "[-+]?P(\\d+Y)?(\\d+M)?(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+(\\.\\d*)?S)?)?");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 4, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anySimpleType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__anySimpleType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anySimpleType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anySimpleType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__anySimpleType(soap, tag ? tag : "xsd:anySimpleType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__NCName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 5, 0, -1, "[\\i-[:]][\\c-[:]]*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Header))
		soap_serialize_SOAP_ENV__Header(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Header *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Header, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Header(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Header **)soap_malloc(soap, sizeof(struct SOAP_ENV__Header *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Header(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemIRI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemIRI(soap, tag ? tag : "wsa5:ProblemIRI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Action(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Action(soap, tag ? tag : "wsa5:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__To(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__To(soap, tag ? tag : "wsa5:To", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__MessageID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__MessageID(soap, tag ? tag : "wsa5:MessageID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag ? tag : "wsa5:FaultCodesOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag ? tag : "wsa5:RelationshipTypeOpenEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveMatchesType))
		soap_serialize_wsdd__ResolveMatchesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveMatchesType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveMatchesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveMatchesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveMatchesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveMatchesType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveMatchesType **)soap_malloc(soap, sizeof(struct wsdd__ResolveMatchesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveMatchesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ResolveMatchesType(soap, tag ? tag : "wsdd:ResolveMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveType))
		soap_serialize_wsdd__ResolveType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveType(struct soap *soap, const char *tag, struct wsdd__ResolveType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveType **)soap_malloc(soap, sizeof(struct wsdd__ResolveType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ResolveType(soap, tag ? tag : "wsdd:ResolveType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeMatchesType))
		soap_serialize_wsdd__ProbeMatchesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeMatchesType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeMatchesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeMatchesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeMatchesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeMatchesType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeMatchesType **)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeMatchesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ProbeMatchesType(soap, tag ? tag : "wsdd:ProbeMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeType))
		soap_serialize_wsdd__ProbeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeType(struct soap *soap, const char *tag, struct wsdd__ProbeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeType **)soap_malloc(soap, sizeof(struct wsdd__ProbeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ProbeType(soap, tag ? tag : "wsdd:ProbeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ByeType))
		soap_serialize_wsdd__ByeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ByeType(struct soap *soap, const char *tag, int id, struct wsdd__ByeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ByeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ByeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ByeType ** SOAP_FMAC4 soap_in_PointerTowsdd__ByeType(struct soap *soap, const char *tag, struct wsdd__ByeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ByeType **)soap_malloc(soap, sizeof(struct wsdd__ByeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ByeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ByeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ByeType(soap, tag ? tag : "wsdd:ByeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ByeType ** SOAP_FMAC4 soap_get_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__HelloType))
		soap_serialize_wsdd__HelloType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__HelloType(struct soap *soap, const char *tag, int id, struct wsdd__HelloType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__HelloType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__HelloType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__HelloType ** SOAP_FMAC4 soap_in_PointerTowsdd__HelloType(struct soap *soap, const char *tag, struct wsdd__HelloType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__HelloType **)soap_malloc(soap, sizeof(struct wsdd__HelloType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__HelloType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__HelloType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__HelloType(soap, tag ? tag : "wsdd:HelloType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__HelloType ** SOAP_FMAC4 soap_get_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__AppSequenceType))
		soap_serialize_wsdd__AppSequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__AppSequenceType(struct soap *soap, const char *tag, int id, struct wsdd__AppSequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__AppSequenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__AppSequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__AppSequenceType ** SOAP_FMAC4 soap_in_PointerTowsdd__AppSequenceType(struct soap *soap, const char *tag, struct wsdd__AppSequenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__AppSequenceType **)soap_malloc(soap, sizeof(struct wsdd__AppSequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__AppSequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__AppSequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__AppSequenceType(soap, tag ? tag : "wsdd:AppSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__AppSequenceType ** SOAP_FMAC4 soap_get_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__AppSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Id(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Id(soap, tag ? tag : "wsdd:Id", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__SigType))
		soap_serialize_wsdd__SigType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__SigType(struct soap *soap, const char *tag, int id, struct wsdd__SigType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__SigType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__SigType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__SigType ** SOAP_FMAC4 soap_in_PointerTowsdd__SigType(struct soap *soap, const char *tag, struct wsdd__SigType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__SigType **)soap_malloc(soap, sizeof(struct wsdd__SigType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__SigType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__SigType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__SigType(soap, tag ? tag : "wsdd:SigType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SigType ** SOAP_FMAC4 soap_get_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveMatchType))
		soap_serialize_wsdd__ResolveMatchType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveMatchType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveMatchType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveMatchType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveMatchType **)soap_malloc(soap, sizeof(struct wsdd__ResolveMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ResolveMatchType(soap, tag ? tag : "wsdd:ResolveMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeMatchType))
		soap_serialize_wsdd__ProbeMatchType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeMatchType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeMatchType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeMatchType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeMatchType **)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ProbeMatchType(soap, tag ? tag : "wsdd:ProbeMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ScopesType))
		soap_serialize_wsdd__ScopesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ScopesType(struct soap *soap, const char *tag, int id, struct wsdd__ScopesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ScopesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ScopesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ScopesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ScopesType(struct soap *soap, const char *tag, struct wsdd__ScopesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ScopesType **)soap_malloc(soap, sizeof(struct wsdd__ScopesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ScopesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ScopesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ScopesType, sizeof(struct wsdd__ScopesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ScopesType(soap, tag ? tag : "wsdd:ScopesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ScopesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__FaultCodeOpenType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsdd__FaultCodeOpenType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__FaultCodeOpenType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsdd__FaultCodeOpenType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsdd__FaultCodeOpenType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsdd__FaultCodeOpenType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__FaultCodeOpenType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsdd__FaultCodeOpenType(soap, tag ? tag : "wsdd:FaultCodeOpenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsdd__FaultCodeOpenType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__FaultCodeOpenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__UriListType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsdd__UriListType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__UriListType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsdd__UriListType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsdd__UriListType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsdd__UriListType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__UriListType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsdd__UriListType(soap, tag ? tag : "wsdd:UriListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsdd__UriListType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__UriListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
