/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:06 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveMatchType(struct soap *soap, const struct wsdd__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveMatchType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveMatchType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveMatchType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_in_wsdd__ResolveMatchType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ResolveMatchType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveMatchType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveMatchType, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_new_wsdd__ResolveMatchType(struct soap *soap, int n)
{
	struct wsdd__ResolveMatchType *p;
	struct wsdd__ResolveMatchType *a = (struct wsdd__ResolveMatchType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ResolveMatchType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ResolveMatchType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveMatchType(struct soap *soap, const struct wsdd__ResolveMatchType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ResolveMatchType(soap, tag ? tag : "wsdd:ResolveMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_get_wsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResolveMatch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveMatchesType(struct soap *soap, const struct wsdd__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ResolveMatchType(soap, &a->ResolveMatch);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveMatchesType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveMatchesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveMatchesType), type))
		return soap->error;
	if (soap_out_PointerTowsdd__ResolveMatchType(soap, "wsdd:ResolveMatch", -1, &a->ResolveMatch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_in_wsdd__ResolveMatchesType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchesType *a, const char *type)
{
	size_t soap_flag_ResolveMatch = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ResolveMatchesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveMatchesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResolveMatch && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ResolveMatchType(soap, "wsdd:ResolveMatch", &a->ResolveMatch, "wsdd:ResolveMatchType"))
				{	soap_flag_ResolveMatch--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveMatchesType, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_new_wsdd__ResolveMatchesType(struct soap *soap, int n)
{
	struct wsdd__ResolveMatchesType *p;
	struct wsdd__ResolveMatchesType *a = (struct wsdd__ResolveMatchesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ResolveMatchesType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ResolveMatchesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveMatchesType(struct soap *soap, const struct wsdd__ResolveMatchesType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ResolveMatchesType(soap, tag ? tag : "wsdd:ResolveMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_get_wsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveType(struct soap *soap, const struct wsdd__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveType), type))
		return soap->error;
	soap_element_result(soap, "wsa:EndpointReference");
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_in_wsdd__ResolveType(struct soap *soap, const char *tag, struct wsdd__ResolveType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ResolveType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			soap_check_result(soap, "wsa:EndpointReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ResolveType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveType, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_new_wsdd__ResolveType(struct soap *soap, int n)
{
	struct wsdd__ResolveType *p;
	struct wsdd__ResolveType *a = (struct wsdd__ResolveType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ResolveType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ResolveType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveType(struct soap *soap, const struct wsdd__ResolveType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ResolveType(soap, tag ? tag : "wsdd:ResolveType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_get_wsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeMatchType(struct soap *soap, const struct wsdd__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeMatchType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeMatchType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeMatchType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_in_wsdd__ProbeMatchType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ProbeMatchType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeMatchType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeMatchType, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_new_wsdd__ProbeMatchType(struct soap *soap, int n)
{
	struct wsdd__ProbeMatchType *p;
	struct wsdd__ProbeMatchType *a = (struct wsdd__ProbeMatchType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ProbeMatchType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ProbeMatchType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeMatchType(struct soap *soap, const struct wsdd__ProbeMatchType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ProbeMatchType(soap, tag ? tag : "wsdd:ProbeMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_get_wsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProbeMatch = 0;
	a->ProbeMatch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeMatchesType(struct soap *soap, const struct wsdd__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < (int)a->__sizeProbeMatch; i++)
		{
			soap_embedded(soap, a->ProbeMatch + i, SOAP_TYPE_wsdd__ProbeMatchType);
			soap_serialize_wsdd__ProbeMatchType(soap, a->ProbeMatch + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeMatchesType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeMatchesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeMatchesType), type))
		return soap->error;
	soap_element_result(soap, "-sizeProbeMatch");
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < (int)a->__sizeProbeMatch; i++)
			if (soap_out_wsdd__ProbeMatchType(soap, "wsdd:ProbeMatch", -1, a->ProbeMatch + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_in_wsdd__ProbeMatchesType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchesType *a, const char *type)
{
	struct soap_blist *soap_blist_ProbeMatch = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ProbeMatchesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeMatchesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsdd:ProbeMatch", 1, NULL))
			{	if (a->ProbeMatch == NULL)
				{	if (soap_blist_ProbeMatch == NULL)
						soap_blist_ProbeMatch = soap_alloc_block(soap);
					a->ProbeMatch = (struct wsdd__ProbeMatchType *)soap_push_block_max(soap, soap_blist_ProbeMatch, sizeof(struct wsdd__ProbeMatchType));
					if (a->ProbeMatch == NULL)
						return NULL;
					soap_default_wsdd__ProbeMatchType(soap, a->ProbeMatch);
				}
				soap_revert(soap);
				if (soap_in_wsdd__ProbeMatchType(soap, "wsdd:ProbeMatch", a->ProbeMatch, "wsdd:ProbeMatchType"))
				{	a->__sizeProbeMatch++;
					a->ProbeMatch = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProbeMatch");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ProbeMatch)
			soap_pop_block(soap, soap_blist_ProbeMatch);
		if (a->__sizeProbeMatch)
		{	a->ProbeMatch = (struct wsdd__ProbeMatchType *)soap_save_block(soap, soap_blist_ProbeMatch, NULL, 1);
		}
		else
		{	a->ProbeMatch = NULL;
			if (soap_blist_ProbeMatch)
				soap_end_block(soap, soap_blist_ProbeMatch);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeMatchesType, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_new_wsdd__ProbeMatchesType(struct soap *soap, int n)
{
	struct wsdd__ProbeMatchesType *p;
	struct wsdd__ProbeMatchesType *a = (struct wsdd__ProbeMatchesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ProbeMatchesType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ProbeMatchesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeMatchesType(struct soap *soap, const struct wsdd__ProbeMatchesType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ProbeMatchesType(soap, tag ? tag : "wsdd:ProbeMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_get_wsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeType(struct soap *soap, const struct wsdd__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeType), type))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_in_wsdd__ProbeType(struct soap *soap, const char *tag, struct wsdd__ProbeType *a, const char *type)
{
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ProbeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeType, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_new_wsdd__ProbeType(struct soap *soap, int n)
{
	struct wsdd__ProbeType *p;
	struct wsdd__ProbeType *a = (struct wsdd__ProbeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ProbeType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ProbeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeType(struct soap *soap, const struct wsdd__ProbeType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ProbeType(soap, tag ? tag : "wsdd:ProbeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_get_wsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ByeType(struct soap *soap, struct wsdd__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	a->MetadataVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ByeType(struct soap *soap, const struct wsdd__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_serialize_PointerTounsignedInt(soap, &a->MetadataVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ByeType(struct soap *soap, const char *tag, int id, const struct wsdd__ByeType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ByeType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_in_wsdd__ByeType(struct soap *soap, const char *tag, struct wsdd__ByeType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ByeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ByeType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTounsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ByeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ByeType, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_new_wsdd__ByeType(struct soap *soap, int n)
{
	struct wsdd__ByeType *p;
	struct wsdd__ByeType *a = (struct wsdd__ByeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__ByeType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__ByeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ByeType(struct soap *soap, const struct wsdd__ByeType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ByeType(soap, tag ? tag : "wsdd:ByeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_get_wsdd__ByeType(struct soap *soap, struct wsdd__ByeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__HelloType(struct soap *soap, struct wsdd__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__HelloType(struct soap *soap, const struct wsdd__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__HelloType(struct soap *soap, const char *tag, int id, const struct wsdd__HelloType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__HelloType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_in_wsdd__HelloType(struct soap *soap, const char *tag, struct wsdd__HelloType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__HelloType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__HelloType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__HelloType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__HelloType, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_new_wsdd__HelloType(struct soap *soap, int n)
{
	struct wsdd__HelloType *p;
	struct wsdd__HelloType *a = (struct wsdd__HelloType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsdd__HelloType));
	for (p = a; p && n--; p++)
		soap_default_wsdd__HelloType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__HelloType(struct soap *soap, const struct wsdd__HelloType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__HelloType(soap, tag ? tag : "wsdd:HelloType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_get_wsdd__HelloType(struct soap *soap, struct wsdd__HelloType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{
	struct SOAP_ENV__Fault *p;
	struct SOAP_ENV__Fault *a = (struct SOAP_ENV__Fault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Fault));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Fault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{
	struct SOAP_ENV__Reason *p;
	struct SOAP_ENV__Reason *a = (struct SOAP_ENV__Reason*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Reason));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Reason(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{
	struct SOAP_ENV__Code *p;
	struct SOAP_ENV__Code *a = (struct SOAP_ENV__Code*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Code));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	a->wsnt__InvalidFilterFault = NULL;
	a->wsnt__InvalidMessageContentExpressionFault = NULL;
	a->wsnt__InvalidProducerPropertiesExpressionFault = NULL;
	a->wsnt__InvalidTopicExpressionFault = NULL;
	a->wsnt__MultipleTopicsSpecifiedFault = NULL;
	a->wsnt__NoCurrentMessageOnTopicFault = NULL;
	a->wsnt__NotifyMessageNotSupportedFault = NULL;
	a->wsnt__PauseFailedFault = NULL;
	a->tev__PullMessagesFaultResponse = NULL;
	a->wsrfr__ResourceUnknownFault = NULL;
	a->wsnt__ResumeFailedFault = NULL;
	a->wsnt__SubscribeCreationFailedFault = NULL;
	a->wsnt__TopicExpressionDialectUnknownFault = NULL;
	a->wsnt__TopicNotSupportedFault = NULL;
	a->wsnt__UnableToCreatePullPointFault = NULL;
	a->wsnt__UnableToDestroyPullPointFault = NULL;
	a->wsnt__UnableToDestroySubscriptionFault = NULL;
	a->wsnt__UnableToGetMessagesFault = NULL;
	a->wsnt__UnacceptableInitialTerminationTimeFault = NULL;
	a->wsnt__UnacceptableTerminationTimeFault = NULL;
	a->wsnt__UnrecognizedPolicyRequestFault = NULL;
	a->wsnt__UnsupportedPolicyRequestFault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__InvalidFilterFaultType(soap, &a->wsnt__InvalidFilterFault);
	soap_serialize_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, &a->wsnt__InvalidMessageContentExpressionFault);
	soap_serialize_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, &a->wsnt__InvalidProducerPropertiesExpressionFault);
	soap_serialize_PointerTowsnt__InvalidTopicExpressionFaultType(soap, &a->wsnt__InvalidTopicExpressionFault);
	soap_serialize_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, &a->wsnt__MultipleTopicsSpecifiedFault);
	soap_serialize_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, &a->wsnt__NoCurrentMessageOnTopicFault);
	soap_serialize_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, &a->wsnt__NotifyMessageNotSupportedFault);
	soap_serialize_PointerTowsnt__PauseFailedFaultType(soap, &a->wsnt__PauseFailedFault);
	soap_serialize_PointerTo_tev__PullMessagesFaultResponse(soap, &a->tev__PullMessagesFaultResponse);
	soap_serialize_PointerTowsrfr__ResourceUnknownFaultType(soap, &a->wsrfr__ResourceUnknownFault);
	soap_serialize_PointerTowsnt__ResumeFailedFaultType(soap, &a->wsnt__ResumeFailedFault);
	soap_serialize_PointerTowsnt__SubscribeCreationFailedFaultType(soap, &a->wsnt__SubscribeCreationFailedFault);
	soap_serialize_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, &a->wsnt__TopicExpressionDialectUnknownFault);
	soap_serialize_PointerTowsnt__TopicNotSupportedFaultType(soap, &a->wsnt__TopicNotSupportedFault);
	soap_serialize_PointerTowsnt__UnableToCreatePullPointFaultType(soap, &a->wsnt__UnableToCreatePullPointFault);
	soap_serialize_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, &a->wsnt__UnableToDestroyPullPointFault);
	soap_serialize_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, &a->wsnt__UnableToDestroySubscriptionFault);
	soap_serialize_PointerTowsnt__UnableToGetMessagesFaultType(soap, &a->wsnt__UnableToGetMessagesFault);
	soap_serialize_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, &a->wsnt__UnacceptableInitialTerminationTimeFault);
	soap_serialize_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, &a->wsnt__UnacceptableTerminationTimeFault);
	soap_serialize_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, &a->wsnt__UnrecognizedPolicyRequestFault);
	soap_serialize_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, &a->wsnt__UnsupportedPolicyRequestFault);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidFilterFaultType(soap, "wsnt:InvalidFilterFault", -1, &a->wsnt__InvalidFilterFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, "wsnt:InvalidMessageContentExpressionFault", -1, &a->wsnt__InvalidMessageContentExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, "wsnt:InvalidProducerPropertiesExpressionFault", -1, &a->wsnt__InvalidProducerPropertiesExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(soap, "wsnt:InvalidTopicExpressionFault", -1, &a->wsnt__InvalidTopicExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, "wsnt:MultipleTopicsSpecifiedFault", -1, &a->wsnt__MultipleTopicsSpecifiedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, "wsnt:NoCurrentMessageOnTopicFault", -1, &a->wsnt__NoCurrentMessageOnTopicFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, "wsnt:NotifyMessageNotSupportedFault", -1, &a->wsnt__NotifyMessageNotSupportedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__PauseFailedFaultType(soap, "wsnt:PauseFailedFault", -1, &a->wsnt__PauseFailedFault, ""))
		return soap->error;
	if (soap_out_PointerTo_tev__PullMessagesFaultResponse(soap, "tev:PullMessagesFaultResponse", -1, &a->tev__PullMessagesFaultResponse, ""))
		return soap->error;
	if (soap_out_PointerTowsrfr__ResourceUnknownFaultType(soap, "wsrfr:ResourceUnknownFault", -1, &a->wsrfr__ResourceUnknownFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__ResumeFailedFaultType(soap, "wsnt:ResumeFailedFault", -1, &a->wsnt__ResumeFailedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(soap, "wsnt:SubscribeCreationFailedFault", -1, &a->wsnt__SubscribeCreationFailedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, "wsnt:TopicExpressionDialectUnknownFault", -1, &a->wsnt__TopicExpressionDialectUnknownFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicNotSupportedFaultType(soap, "wsnt:TopicNotSupportedFault", -1, &a->wsnt__TopicNotSupportedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(soap, "wsnt:UnableToCreatePullPointFault", -1, &a->wsnt__UnableToCreatePullPointFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, "wsnt:UnableToDestroyPullPointFault", -1, &a->wsnt__UnableToDestroyPullPointFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, "wsnt:UnableToDestroySubscriptionFault", -1, &a->wsnt__UnableToDestroySubscriptionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToGetMessagesFaultType(soap, "wsnt:UnableToGetMessagesFault", -1, &a->wsnt__UnableToGetMessagesFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, "wsnt:UnacceptableInitialTerminationTimeFault", -1, &a->wsnt__UnacceptableInitialTerminationTimeFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, "wsnt:UnacceptableTerminationTimeFault", -1, &a->wsnt__UnacceptableTerminationTimeFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, "wsnt:UnrecognizedPolicyRequestFault", -1, &a->wsnt__UnrecognizedPolicyRequestFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, "wsnt:UnsupportedPolicyRequestFault", -1, &a->wsnt__UnsupportedPolicyRequestFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_wsnt__InvalidFilterFault = 1;
	size_t soap_flag_wsnt__InvalidMessageContentExpressionFault = 1;
	size_t soap_flag_wsnt__InvalidProducerPropertiesExpressionFault = 1;
	size_t soap_flag_wsnt__InvalidTopicExpressionFault = 1;
	size_t soap_flag_wsnt__MultipleTopicsSpecifiedFault = 1;
	size_t soap_flag_wsnt__NoCurrentMessageOnTopicFault = 1;
	size_t soap_flag_wsnt__NotifyMessageNotSupportedFault = 1;
	size_t soap_flag_wsnt__PauseFailedFault = 1;
	size_t soap_flag_tev__PullMessagesFaultResponse = 1;
	size_t soap_flag_wsrfr__ResourceUnknownFault = 1;
	size_t soap_flag_wsnt__ResumeFailedFault = 1;
	size_t soap_flag_wsnt__SubscribeCreationFailedFault = 1;
	size_t soap_flag_wsnt__TopicExpressionDialectUnknownFault = 1;
	size_t soap_flag_wsnt__TopicNotSupportedFault = 1;
	size_t soap_flag_wsnt__UnableToCreatePullPointFault = 1;
	size_t soap_flag_wsnt__UnableToDestroyPullPointFault = 1;
	size_t soap_flag_wsnt__UnableToDestroySubscriptionFault = 1;
	size_t soap_flag_wsnt__UnableToGetMessagesFault = 1;
	size_t soap_flag_wsnt__UnacceptableInitialTerminationTimeFault = 1;
	size_t soap_flag_wsnt__UnacceptableTerminationTimeFault = 1;
	size_t soap_flag_wsnt__UnrecognizedPolicyRequestFault = 1;
	size_t soap_flag_wsnt__UnsupportedPolicyRequestFault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__InvalidFilterFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__InvalidFilterFaultType(soap, "wsnt:InvalidFilterFault", &a->wsnt__InvalidFilterFault, "wsnt:InvalidFilterFaultType"))
				{	soap_flag_wsnt__InvalidFilterFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__InvalidMessageContentExpressionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, "wsnt:InvalidMessageContentExpressionFault", &a->wsnt__InvalidMessageContentExpressionFault, "wsnt:InvalidMessageContentExpressionFaultType"))
				{	soap_flag_wsnt__InvalidMessageContentExpressionFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__InvalidProducerPropertiesExpressionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, "wsnt:InvalidProducerPropertiesExpressionFault", &a->wsnt__InvalidProducerPropertiesExpressionFault, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
				{	soap_flag_wsnt__InvalidProducerPropertiesExpressionFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__InvalidTopicExpressionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(soap, "wsnt:InvalidTopicExpressionFault", &a->wsnt__InvalidTopicExpressionFault, "wsnt:InvalidTopicExpressionFaultType"))
				{	soap_flag_wsnt__InvalidTopicExpressionFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__MultipleTopicsSpecifiedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, "wsnt:MultipleTopicsSpecifiedFault", &a->wsnt__MultipleTopicsSpecifiedFault, "wsnt:MultipleTopicsSpecifiedFaultType"))
				{	soap_flag_wsnt__MultipleTopicsSpecifiedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__NoCurrentMessageOnTopicFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, "wsnt:NoCurrentMessageOnTopicFault", &a->wsnt__NoCurrentMessageOnTopicFault, "wsnt:NoCurrentMessageOnTopicFaultType"))
				{	soap_flag_wsnt__NoCurrentMessageOnTopicFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__NotifyMessageNotSupportedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, "wsnt:NotifyMessageNotSupportedFault", &a->wsnt__NotifyMessageNotSupportedFault, "wsnt:NotifyMessageNotSupportedFaultType"))
				{	soap_flag_wsnt__NotifyMessageNotSupportedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__PauseFailedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__PauseFailedFaultType(soap, "wsnt:PauseFailedFault", &a->wsnt__PauseFailedFault, "wsnt:PauseFailedFaultType"))
				{	soap_flag_wsnt__PauseFailedFault--;
					continue;
				}
			}
			if (soap_flag_tev__PullMessagesFaultResponse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__PullMessagesFaultResponse(soap, "tev:PullMessagesFaultResponse", &a->tev__PullMessagesFaultResponse, ""))
				{	soap_flag_tev__PullMessagesFaultResponse--;
					continue;
				}
			}
			if (soap_flag_wsrfr__ResourceUnknownFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsrfr__ResourceUnknownFaultType(soap, "wsrfr:ResourceUnknownFault", &a->wsrfr__ResourceUnknownFault, "wsrfr:ResourceUnknownFaultType"))
				{	soap_flag_wsrfr__ResourceUnknownFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__ResumeFailedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__ResumeFailedFaultType(soap, "wsnt:ResumeFailedFault", &a->wsnt__ResumeFailedFault, "wsnt:ResumeFailedFaultType"))
				{	soap_flag_wsnt__ResumeFailedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__SubscribeCreationFailedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(soap, "wsnt:SubscribeCreationFailedFault", &a->wsnt__SubscribeCreationFailedFault, "wsnt:SubscribeCreationFailedFaultType"))
				{	soap_flag_wsnt__SubscribeCreationFailedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__TopicExpressionDialectUnknownFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, "wsnt:TopicExpressionDialectUnknownFault", &a->wsnt__TopicExpressionDialectUnknownFault, "wsnt:TopicExpressionDialectUnknownFaultType"))
				{	soap_flag_wsnt__TopicExpressionDialectUnknownFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__TopicNotSupportedFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicNotSupportedFaultType(soap, "wsnt:TopicNotSupportedFault", &a->wsnt__TopicNotSupportedFault, "wsnt:TopicNotSupportedFaultType"))
				{	soap_flag_wsnt__TopicNotSupportedFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnableToCreatePullPointFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(soap, "wsnt:UnableToCreatePullPointFault", &a->wsnt__UnableToCreatePullPointFault, "wsnt:UnableToCreatePullPointFaultType"))
				{	soap_flag_wsnt__UnableToCreatePullPointFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnableToDestroyPullPointFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, "wsnt:UnableToDestroyPullPointFault", &a->wsnt__UnableToDestroyPullPointFault, "wsnt:UnableToDestroyPullPointFaultType"))
				{	soap_flag_wsnt__UnableToDestroyPullPointFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnableToDestroySubscriptionFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, "wsnt:UnableToDestroySubscriptionFault", &a->wsnt__UnableToDestroySubscriptionFault, "wsnt:UnableToDestroySubscriptionFaultType"))
				{	soap_flag_wsnt__UnableToDestroySubscriptionFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnableToGetMessagesFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnableToGetMessagesFaultType(soap, "wsnt:UnableToGetMessagesFault", &a->wsnt__UnableToGetMessagesFault, "wsnt:UnableToGetMessagesFaultType"))
				{	soap_flag_wsnt__UnableToGetMessagesFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnacceptableInitialTerminationTimeFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, "wsnt:UnacceptableInitialTerminationTimeFault", &a->wsnt__UnacceptableInitialTerminationTimeFault, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
				{	soap_flag_wsnt__UnacceptableInitialTerminationTimeFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnacceptableTerminationTimeFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, "wsnt:UnacceptableTerminationTimeFault", &a->wsnt__UnacceptableTerminationTimeFault, "wsnt:UnacceptableTerminationTimeFaultType"))
				{	soap_flag_wsnt__UnacceptableTerminationTimeFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnrecognizedPolicyRequestFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, "wsnt:UnrecognizedPolicyRequestFault", &a->wsnt__UnrecognizedPolicyRequestFault, "wsnt:UnrecognizedPolicyRequestFaultType"))
				{	soap_flag_wsnt__UnrecognizedPolicyRequestFault--;
					continue;
				}
			}
			if (soap_flag_wsnt__UnsupportedPolicyRequestFault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, "wsnt:UnsupportedPolicyRequestFault", &a->wsnt__UnsupportedPolicyRequestFault, "wsnt:UnsupportedPolicyRequestFaultType"))
				{	soap_flag_wsnt__UnsupportedPolicyRequestFault--;
					continue;
				}
			}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{
	struct SOAP_ENV__Detail *p;
	struct SOAP_ENV__Detail *a = (struct SOAP_ENV__Detail*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Detail));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Detail(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__MessageID(soap, &a->wsa__MessageID);
	a->wsa__RelatesTo = NULL;
	a->wsa__From = NULL;
	a->wsa__ReplyTo = NULL;
	a->wsa__FaultTo = NULL;
	soap_default__wsa__To(soap, &a->wsa__To);
	soap_default__wsa__Action(soap, &a->wsa__Action);
	a->wsdd__AppSequence = NULL;
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__MessageID(soap, (char*const*)&a->wsa__MessageID);
	soap_serialize_PointerTo_wsa__RelatesTo(soap, &a->wsa__RelatesTo);
	soap_serialize_PointerTo_wsa__From(soap, &a->wsa__From);
	soap_serialize_PointerTo_wsa__ReplyTo(soap, &a->wsa__ReplyTo);
	soap_serialize_PointerTo_wsa__FaultTo(soap, &a->wsa__FaultTo);
	soap_serialize__wsa__To(soap, (char*const*)&a->wsa__To);
	soap_serialize__wsa__Action(soap, (char*const*)&a->wsa__Action);
	soap_serialize_PointerTowsdd__AppSequenceType(soap, &a->wsdd__AppSequence);
	soap_serialize__wsa5__MessageID(soap, (char*const*)&a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, (char*const*)&a->wsa5__To);
	soap_serialize__wsa5__Action(soap, (char*const*)&a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa__MessageID(soap, "wsa:MessageID", -1, (char*const*)&a->wsa__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", -1, &a->wsa__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__From(soap, "wsa:From", -1, &a->wsa__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", -1, &a->wsa__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", -1, &a->wsa__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__To(soap, "wsa:To", -1, (char*const*)&a->wsa__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__Action(soap, "wsa:Action", -1, (char*const*)&a->wsa__Action, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", -1, &a->wsdd__AppSequence, ""))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, (char*const*)&a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, (char*const*)&a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, (char*const*)&a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa__MessageID = 1;
	size_t soap_flag_wsa__RelatesTo = 1;
	size_t soap_flag_wsa__From = 1;
	size_t soap_flag_wsa__ReplyTo = 1;
	size_t soap_flag_wsa__FaultTo = 1;
	size_t soap_flag_wsa__To = 1;
	size_t soap_flag_wsa__Action = 1;
	size_t soap_flag_wsdd__AppSequence = 1;
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa__MessageID(soap, "wsa:MessageID", (char**)&a->wsa__MessageID, ""))
				{	soap_flag_wsa__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", &a->wsa__RelatesTo, ""))
				{	soap_flag_wsa__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__From(soap, "wsa:From", &a->wsa__From, ""))
				{	soap_flag_wsa__From--;
					continue;
				}
			}
			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", &a->wsa__ReplyTo, ""))
				{	soap_flag_wsa__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", &a->wsa__FaultTo, ""))
				{	soap_flag_wsa__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa__To(soap, "wsa:To", (char**)&a->wsa__To, ""))
				{	soap_flag_wsa__To--;
					continue;
				}
			}
			if (soap_flag_wsa__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa__Action(soap, "wsa:Action", (char**)&a->wsa__Action, ""))
				{	soap_flag_wsa__Action--;
					continue;
				}
			}
			if (soap_flag_wsdd__AppSequence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", &a->wsdd__AppSequence, "wsdd:AppSequenceType"))
				{	soap_flag_wsdd__AppSequence--;
					continue;
				}
			}
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", (char**)&a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__To(soap, "wsa5:To", (char**)&a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__Action(soap, "wsa5:Action", (char**)&a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{
	struct SOAP_ENV__Header *p;
	struct SOAP_ENV__Header *a = (struct SOAP_ENV__Header*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Header));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Header(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__FaultTo(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa__FaultTo(soap, tag ? tag : "wsa:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__ReplyTo(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa__ReplyTo(soap, tag ? tag : "wsa:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__From(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa__From(soap, tag ? tag : "wsa:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__RelatesTo(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	if (soap_out__wsa__RelatesTo(soap, tag ? tag : "wsa:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa__EndpointReference(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa__EndpointReference(soap, tag ? tag : "wsa:EndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__Relationship(struct soap *soap, struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__QName(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__Relationship(struct soap *soap, const char *tag, int id, const struct wsa__Relationship *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap__QName2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_in_wsa__Relationship(struct soap *soap, const char *tag, struct wsa__Relationship *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa__Relationship *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__Relationship, sizeof(struct wsa__Relationship), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__Relationship(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "RelationshipType", 2, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa:Relationship"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_new_wsa__Relationship(struct soap *soap, int n)
{
	struct wsa__Relationship *p;
	struct wsa__Relationship *a = (struct wsa__Relationship*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__Relationship));
	for (p = a; p && n--; p++)
		soap_default_wsa__Relationship(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	if (soap_out_wsa__Relationship(soap, tag ? tag : "wsa:Relationship", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_get_wsa__Relationship(struct soap *soap, struct wsa__Relationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__Relationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->__item);
	soap_default_string(soap, &a->PortName);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ServiceNameType(struct soap *soap, const char *tag, int id, const struct wsa__ServiceNameType *a, const char *type)
{
	const char *soap_tmp___item;
	soap_tmp___item = soap_QName2s(soap, a->__item);
	if (a->PortName)
		soap_set_attr(soap, "PortName", soap_string2s(soap, a->PortName), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out__QName(soap, tag, id, (char*const*)(void*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_in_wsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa__ServiceNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__ServiceNameType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PortName", 1, 0), &a->PortName))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in__QName(soap, tag, (char**)&a->__item, "wsa:ServiceNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_new_wsa__ServiceNameType(struct soap *soap, int n)
{
	struct wsa__ServiceNameType *p;
	struct wsa__ServiceNameType *a = (struct wsa__ServiceNameType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__ServiceNameType));
	for (p = a; p && n--; p++)
		soap_default_wsa__ServiceNameType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ServiceNameType(soap, tag ? tag : "wsa:ServiceNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_get_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferenceParametersType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_new_wsa__ReferenceParametersType(struct soap *soap, int n)
{
	struct wsa__ReferenceParametersType *p;
	struct wsa__ReferenceParametersType *a = (struct wsa__ReferenceParametersType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__ReferenceParametersType));
	for (p = a; p && n--; p++)
		soap_default_wsa__ReferenceParametersType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ReferenceParametersType(soap, tag ? tag : "wsa:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, const struct wsa__ReferencePropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferencePropertiesType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_in_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa__ReferencePropertiesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferencePropertiesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferencePropertiesType, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_new_wsa__ReferencePropertiesType(struct soap *soap, int n)
{
	struct wsa__ReferencePropertiesType *p;
	struct wsa__ReferencePropertiesType *a = (struct wsa__ReferencePropertiesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__ReferencePropertiesType));
	for (p = a; p && n--; p++)
		soap_default_wsa__ReferencePropertiesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ReferencePropertiesType(soap, tag ? tag : "wsa:ReferencePropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_get_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceProperties = NULL;
	a->ReferenceParameters = NULL;
	a->PortType = NULL;
	a->ServiceName = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa__ReferencePropertiesType(soap, &a->ReferenceProperties);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTo_QName(soap, &a->PortType);
	soap_serialize_PointerTowsa__ServiceNameType(soap, &a->ServiceName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	const char *soap_tmp_PortType;
	soap_tmp_PortType = a->PortType ? soap_QName2s(soap, *a->PortType) : NULL;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsa:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", -1, &a->ReferenceProperties, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out__QName(soap, "wsa:PortType", -1, (char*const*)(void*)&soap_tmp_PortType, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", -1, &a->ServiceName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceProperties = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_PortType = 1;
	size_t soap_flag_ServiceName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceProperties && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", &a->ReferenceProperties, "wsa:ReferencePropertiesType"))
				{	soap_flag_ReferenceProperties--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_PortType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_QName(soap, "wsa:PortType", &a->PortType, ""))
				{	soap_flag_PortType--;
					continue;
				}
			}
			if (soap_flag_ServiceName && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", &a->ServiceName, "wsa:ServiceNameType"))
				{	soap_flag_ServiceName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_new_wsa__EndpointReferenceType(struct soap *soap, int n)
{
	struct wsa__EndpointReferenceType *p;
	struct wsa__EndpointReferenceType *a = (struct wsa__EndpointReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__EndpointReferenceType));
	for (p = a; p && n--; p++)
		soap_default_wsa__EndpointReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__EndpointReferenceType(soap, tag ? tag : "wsa:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct soap_dom_attribute * SOAP_FMAC4 soap_new_xsd__anyAttribute(struct soap *soap, int n)
{
	struct soap_dom_attribute *p;
	struct soap_dom_attribute *a = (struct soap_dom_attribute*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct soap_dom_attribute));
	for (p = a; p && n--; p++)
		soap_default_xsd__anyAttribute(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyAttribute(struct soap *soap, const struct soap_dom_attribute *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, tag ? tag : "xsd:anyAttribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_attribute * SOAP_FMAC4 soap_get_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct soap_dom_element * SOAP_FMAC4 soap_new_xsd__anyType(struct soap *soap, int n)
{
	struct soap_dom_element *p;
	struct soap_dom_element *a = (struct soap_dom_element*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct soap_dom_element));
	for (p = a; p && n--; p++)
		soap_default_xsd__anyType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyType(struct soap *soap, const struct soap_dom_element *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyType(soap, tag ? tag : "xsd:anyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_element * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, struct soap_dom_element *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_EventStream(struct soap *soap, int choice, const union _tt__union_EventStream *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage:
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &a->wsnt__NotificationMessage);
		break;
	case SOAP_UNION__tt__union_EventStream_Extension:
		soap_serialize_PointerTott__EventStreamExtension(soap, &a->Extension);
		break;
	case SOAP_UNION__tt__union_EventStream___any:
		soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
		soap_serialize_xsd__anyType(soap, &a->__any);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_EventStream(struct soap *soap, int choice, const union _tt__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage:
		return soap_out_PointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->wsnt__NotificationMessage, "");
	case SOAP_UNION__tt__union_EventStream_Extension:
		return soap_out_PointerTott__EventStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	case SOAP_UNION__tt__union_EventStream___any:
		return soap_out_xsd__anyType(soap, "-any", -1, &a->__any, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_EventStream * SOAP_FMAC4 soap_in__tt__union_EventStream(struct soap *soap, int *choice, union _tt__union_EventStream *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->wsnt__NotificationMessage = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->wsnt__NotificationMessage, "wsnt:NotificationMessageHolderType"))
	{	*choice = SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__EventStreamExtension(soap, "tt:Extension", &a->Extension, "tt:EventStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_EventStream_Extension;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_xsd__anyType(soap, "-any", &a->__any, NULL))
	{	*choice = SOAP_UNION__tt__union_EventStream___any;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_PTZStream(struct soap *soap, int choice, const union _tt__union_PTZStream *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZStream_PTZStatus:
		soap_serialize_PointerTott__PTZStatus(soap, &a->PTZStatus);
		break;
	case SOAP_UNION__tt__union_PTZStream_Extension:
		soap_serialize_PointerTott__PTZStreamExtension(soap, &a->Extension);
		break;
	case SOAP_UNION__tt__union_PTZStream___any:
		soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
		soap_serialize_xsd__anyType(soap, &a->__any);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_PTZStream(struct soap *soap, int choice, const union _tt__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZStream_PTZStatus:
		return soap_out_PointerTott__PTZStatus(soap, "tt:PTZStatus", -1, &a->PTZStatus, "");
	case SOAP_UNION__tt__union_PTZStream_Extension:
		return soap_out_PointerTott__PTZStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	case SOAP_UNION__tt__union_PTZStream___any:
		return soap_out_xsd__anyType(soap, "-any", -1, &a->__any, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_PTZStream * SOAP_FMAC4 soap_in__tt__union_PTZStream(struct soap *soap, int *choice, union _tt__union_PTZStream *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->PTZStatus = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStatus(soap, "tt:PTZStatus", &a->PTZStatus, "tt:PTZStatus"))
	{	*choice = SOAP_UNION__tt__union_PTZStream_PTZStatus;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStreamExtension(soap, "tt:Extension", &a->Extension, "tt:PTZStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_PTZStream_Extension;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_xsd__anyType(soap, "-any", &a->__any, NULL))
	{	*choice = SOAP_UNION__tt__union_PTZStream___any;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _tt__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Frame:
		soap_serialize_PointerTott__Frame(soap, &a->Frame);
		break;
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Extension:
		soap_serialize_PointerTott__VideoAnalyticsStreamExtension(soap, &a->Extension);
		break;
	case SOAP_UNION__tt__union_VideoAnalyticsStream___any:
		soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
		soap_serialize_xsd__anyType(soap, &a->__any);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _tt__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Frame:
		return soap_out_PointerTott__Frame(soap, "tt:Frame", -1, &a->Frame, "");
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Extension:
		return soap_out_PointerTott__VideoAnalyticsStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	case SOAP_UNION__tt__union_VideoAnalyticsStream___any:
		return soap_out_xsd__anyType(soap, "-any", -1, &a->__any, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_in__tt__union_VideoAnalyticsStream(struct soap *soap, int *choice, union _tt__union_VideoAnalyticsStream *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->Frame = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__Frame(soap, "tt:Frame", &a->Frame, "tt:Frame"))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream_Frame;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__VideoAnalyticsStreamExtension(soap, "tt:Extension", &a->Extension, "tt:VideoAnalyticsStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream_Extension;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_xsd__anyType(soap, "-any", &a->__any, NULL))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream___any;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_MetadataStream(struct soap *soap, int choice, const union _tt__union_MetadataStream *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tt__union_MetadataStream_VideoAnalytics:
		soap_serialize_PointerTott__VideoAnalyticsStream(soap, &a->VideoAnalytics);
		break;
	case SOAP_UNION__tt__union_MetadataStream_PTZ:
		soap_serialize_PointerTott__PTZStream(soap, &a->PTZ);
		break;
	case SOAP_UNION__tt__union_MetadataStream_Event:
		soap_serialize_PointerTott__EventStream(soap, &a->Event);
		break;
	case SOAP_UNION__tt__union_MetadataStream_Extension:
		soap_serialize_PointerTott__MetadataStreamExtension(soap, &a->Extension);
		break;
	case SOAP_UNION__tt__union_MetadataStream___any:
		soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
		soap_serialize_xsd__anyType(soap, &a->__any);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_MetadataStream(struct soap *soap, int choice, const union _tt__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_MetadataStream_VideoAnalytics:
		return soap_out_PointerTott__VideoAnalyticsStream(soap, "tt:VideoAnalytics", -1, &a->VideoAnalytics, "");
	case SOAP_UNION__tt__union_MetadataStream_PTZ:
		return soap_out_PointerTott__PTZStream(soap, "tt:PTZ", -1, &a->PTZ, "");
	case SOAP_UNION__tt__union_MetadataStream_Event:
		return soap_out_PointerTott__EventStream(soap, "tt:Event", -1, &a->Event, "");
	case SOAP_UNION__tt__union_MetadataStream_Extension:
		return soap_out_PointerTott__MetadataStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	case SOAP_UNION__tt__union_MetadataStream___any:
		return soap_out_xsd__anyType(soap, "-any", -1, &a->__any, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_MetadataStream * SOAP_FMAC4 soap_in__tt__union_MetadataStream(struct soap *soap, int *choice, union _tt__union_MetadataStream *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->VideoAnalytics = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__VideoAnalyticsStream(soap, "tt:VideoAnalytics", &a->VideoAnalytics, "tt:VideoAnalyticsStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_VideoAnalytics;
		return a;
	}
	a->PTZ = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStream(soap, "tt:PTZ", &a->PTZ, "tt:PTZStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_PTZ;
		return a;
	}
	a->Event = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__EventStream(soap, "tt:Event", &a->Event, "tt:EventStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_Event;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__MetadataStreamExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_Extension;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_xsd__anyType(soap, "-any", &a->__any, NULL))
	{	*choice = SOAP_UNION__tt__union_MetadataStream___any;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int choice, const union _tt__union_PTZPresetTourPresetDetail *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken:
		soap_serialize_tt__ReferenceToken(soap, &a->PresetToken);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home:
		soap_embedded(soap, &a->Home, SOAP_TYPE_xsd__boolean);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition:
		soap_serialize_PointerTott__PTZVector(soap, &a->PTZPosition);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension:
		soap_serialize_PointerTott__PTZPresetTourTypeExtension(soap, &a->TypeExtension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int choice, const union _tt__union_PTZPresetTourPresetDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken:
		return soap_out_tt__ReferenceToken(soap, "tt:PresetToken", -1, (char*const*)&a->PresetToken, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home:
		return soap_out_xsd__boolean(soap, "tt:Home", -1, &a->Home, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition:
		return soap_out_PointerTott__PTZVector(soap, "tt:PTZPosition", -1, &a->PTZPosition, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension:
		return soap_out_PointerTott__PTZPresetTourTypeExtension(soap, "tt:TypeExtension", -1, &a->TypeExtension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_PTZPresetTourPresetDetail * SOAP_FMAC4 soap_in__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int *choice, union _tt__union_PTZPresetTourPresetDetail *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->PresetToken = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_tt__ReferenceToken(soap, "tt:PresetToken", &a->PresetToken, "tt:ReferenceToken"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_xsd__boolean(soap, "tt:Home", &a->Home, "xsd:boolean"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home;
		return a;
	}
	a->PTZPosition = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &a->PTZPosition, "tt:PTZVector"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition;
		return a;
	}
	a->TypeExtension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZPresetTourTypeExtension(soap, "tt:TypeExtension", &a->TypeExtension, "tt:PTZPresetTourTypeExtension"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__union_SerialData(struct soap *soap, int choice, const union _tmd__union_SerialData *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tmd__union_SerialData_Binary:
		soap_serialize_xsd__base64Binary(soap, &a->Binary);
		break;
	case SOAP_UNION__tmd__union_SerialData_String:
		soap_serialize_string(soap, &a->String);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__union_SerialData(struct soap *soap, int choice, const union _tmd__union_SerialData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tmd__union_SerialData_Binary:
		return soap_out_xsd__base64Binary(soap, "tmd:Binary", -1, &a->Binary, "");
	case SOAP_UNION__tmd__union_SerialData_String:
		return soap_out_string(soap, "tmd:String", -1, (char*const*)&a->String, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tmd__union_SerialData * SOAP_FMAC4 soap_in__tmd__union_SerialData(struct soap *soap, int *choice, union _tmd__union_SerialData *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_xsd__base64Binary(soap, "tmd:Binary", &a->Binary, "xsd:base64Binary"))
	{	*choice = SOAP_UNION__tmd__union_SerialData_Binary;
		return a;
	}
	a->String = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "tmd:String", &a->String, "xsd:string"))
	{	*choice = SOAP_UNION__tmd__union_SerialData_String;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse))
		soap_serialize__tse__GetMetadataSearchResultsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, const char *tag, int id, struct _tse__GetMetadataSearchResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetMetadataSearchResultsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetMetadataSearchResultsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetMetadataSearchResultsResponse **)soap_malloc(soap, sizeof(struct _tse__GetMetadataSearchResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetMetadataSearchResultsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMetadataSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, sizeof(struct _tse__GetMetadataSearchResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetMetadataSearchResultsResponse(soap, tag ? tag : "tse:GetMetadataSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetMetadataSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetMetadataSearchResults))
		soap_serialize__tse__GetMetadataSearchResults(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, const char *tag, int id, struct _tse__GetMetadataSearchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetMetadataSearchResults, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetMetadataSearchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults ** SOAP_FMAC4 soap_in_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, const char *tag, struct _tse__GetMetadataSearchResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetMetadataSearchResults **)soap_malloc(soap, sizeof(struct _tse__GetMetadataSearchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetMetadataSearchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMetadataSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMetadataSearchResults, sizeof(struct _tse__GetMetadataSearchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetMetadataSearchResults(soap, tag ? tag : "tse:GetMetadataSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults ** SOAP_FMAC4 soap_get_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetMetadataSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindMetadataResponse))
		soap_serialize__tse__FindMetadataResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindMetadataResponse(struct soap *soap, const char *tag, int id, struct _tse__FindMetadataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindMetadataResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindMetadataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindMetadataResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__FindMetadataResponse(struct soap *soap, const char *tag, struct _tse__FindMetadataResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindMetadataResponse **)soap_malloc(soap, sizeof(struct _tse__FindMetadataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindMetadataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindMetadataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindMetadataResponse, sizeof(struct _tse__FindMetadataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindMetadataResponse(soap, tag ? tag : "tse:FindMetadataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindMetadataResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindMetadata))
		soap_serialize__tse__FindMetadata(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindMetadata(struct soap *soap, const char *tag, int id, struct _tse__FindMetadata *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindMetadata, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindMetadata(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindMetadata ** SOAP_FMAC4 soap_in_PointerTo_tse__FindMetadata(struct soap *soap, const char *tag, struct _tse__FindMetadata **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindMetadata **)soap_malloc(soap, sizeof(struct _tse__FindMetadata *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindMetadata(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindMetadata **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindMetadata, sizeof(struct _tse__FindMetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindMetadata(soap, tag ? tag : "tse:FindMetadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindMetadata ** SOAP_FMAC4 soap_get_PointerTo_tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__EndSearchResponse))
		soap_serialize__tse__EndSearchResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__EndSearchResponse(struct soap *soap, const char *tag, int id, struct _tse__EndSearchResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__EndSearchResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__EndSearchResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__EndSearchResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__EndSearchResponse(struct soap *soap, const char *tag, struct _tse__EndSearchResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__EndSearchResponse **)soap_malloc(soap, sizeof(struct _tse__EndSearchResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__EndSearchResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__EndSearchResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__EndSearchResponse, sizeof(struct _tse__EndSearchResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__EndSearchResponse(soap, tag ? tag : "tse:EndSearchResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__EndSearchResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__EndSearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__EndSearch(struct soap *soap, struct _tse__EndSearch *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__EndSearch))
		soap_serialize__tse__EndSearch(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__EndSearch(struct soap *soap, const char *tag, int id, struct _tse__EndSearch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__EndSearch, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__EndSearch(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__EndSearch ** SOAP_FMAC4 soap_in_PointerTo_tse__EndSearch(struct soap *soap, const char *tag, struct _tse__EndSearch **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__EndSearch **)soap_malloc(soap, sizeof(struct _tse__EndSearch *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__EndSearch(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__EndSearch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__EndSearch, sizeof(struct _tse__EndSearch), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__EndSearch(struct soap *soap, struct _tse__EndSearch *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__EndSearch(soap, tag ? tag : "tse:EndSearch", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__EndSearch ** SOAP_FMAC4 soap_get_PointerTo_tse__EndSearch(struct soap *soap, struct _tse__EndSearch **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__EndSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetSearchStateResponse))
		soap_serialize__tse__GetSearchStateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetSearchStateResponse(struct soap *soap, const char *tag, int id, struct _tse__GetSearchStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetSearchStateResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetSearchStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetSearchStateResponse(struct soap *soap, const char *tag, struct _tse__GetSearchStateResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetSearchStateResponse **)soap_malloc(soap, sizeof(struct _tse__GetSearchStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetSearchStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetSearchStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetSearchStateResponse, sizeof(struct _tse__GetSearchStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetSearchStateResponse(soap, tag ? tag : "tse:GetSearchStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetSearchStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetSearchState))
		soap_serialize__tse__GetSearchState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetSearchState(struct soap *soap, const char *tag, int id, struct _tse__GetSearchState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetSearchState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetSearchState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetSearchState ** SOAP_FMAC4 soap_in_PointerTo_tse__GetSearchState(struct soap *soap, const char *tag, struct _tse__GetSearchState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetSearchState **)soap_malloc(soap, sizeof(struct _tse__GetSearchState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetSearchState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetSearchState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetSearchState, sizeof(struct _tse__GetSearchState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetSearchState(soap, tag ? tag : "tse:GetSearchState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetSearchState ** SOAP_FMAC4 soap_get_PointerTo_tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetSearchState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse))
		soap_serialize__tse__GetPTZPositionSearchResultsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const char *tag, int id, struct _tse__GetPTZPositionSearchResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetPTZPositionSearchResultsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetPTZPositionSearchResultsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetPTZPositionSearchResultsResponse **)soap_malloc(soap, sizeof(struct _tse__GetPTZPositionSearchResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetPTZPositionSearchResultsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetPTZPositionSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, sizeof(struct _tse__GetPTZPositionSearchResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetPTZPositionSearchResultsResponse(soap, tag ? tag : "tse:GetPTZPositionSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetPTZPositionSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetPTZPositionSearchResults))
		soap_serialize__tse__GetPTZPositionSearchResults(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, int id, struct _tse__GetPTZPositionSearchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetPTZPositionSearchResults, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetPTZPositionSearchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults ** SOAP_FMAC4 soap_in_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, struct _tse__GetPTZPositionSearchResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetPTZPositionSearchResults **)soap_malloc(soap, sizeof(struct _tse__GetPTZPositionSearchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetPTZPositionSearchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetPTZPositionSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetPTZPositionSearchResults, sizeof(struct _tse__GetPTZPositionSearchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetPTZPositionSearchResults(soap, tag ? tag : "tse:GetPTZPositionSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults ** SOAP_FMAC4 soap_get_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetPTZPositionSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindPTZPositionResponse))
		soap_serialize__tse__FindPTZPositionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, const char *tag, int id, struct _tse__FindPTZPositionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindPTZPositionResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindPTZPositionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, const char *tag, struct _tse__FindPTZPositionResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindPTZPositionResponse **)soap_malloc(soap, sizeof(struct _tse__FindPTZPositionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindPTZPositionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindPTZPositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindPTZPositionResponse, sizeof(struct _tse__FindPTZPositionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindPTZPositionResponse(soap, tag ? tag : "tse:FindPTZPositionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindPTZPositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindPTZPosition))
		soap_serialize__tse__FindPTZPosition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindPTZPosition(struct soap *soap, const char *tag, int id, struct _tse__FindPTZPosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindPTZPosition, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindPTZPosition(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindPTZPosition ** SOAP_FMAC4 soap_in_PointerTo_tse__FindPTZPosition(struct soap *soap, const char *tag, struct _tse__FindPTZPosition **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindPTZPosition **)soap_malloc(soap, sizeof(struct _tse__FindPTZPosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindPTZPosition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindPTZPosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindPTZPosition, sizeof(struct _tse__FindPTZPosition), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindPTZPosition(soap, tag ? tag : "tse:FindPTZPosition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindPTZPosition ** SOAP_FMAC4 soap_get_PointerTo_tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindPTZPosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetEventSearchResultsResponse))
		soap_serialize__tse__GetEventSearchResultsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, const char *tag, int id, struct _tse__GetEventSearchResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetEventSearchResultsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetEventSearchResultsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetEventSearchResultsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetEventSearchResultsResponse **)soap_malloc(soap, sizeof(struct _tse__GetEventSearchResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetEventSearchResultsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetEventSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetEventSearchResultsResponse, sizeof(struct _tse__GetEventSearchResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetEventSearchResultsResponse(soap, tag ? tag : "tse:GetEventSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetEventSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetEventSearchResults))
		soap_serialize__tse__GetEventSearchResults(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetEventSearchResults(struct soap *soap, const char *tag, int id, struct _tse__GetEventSearchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetEventSearchResults, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetEventSearchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetEventSearchResults ** SOAP_FMAC4 soap_in_PointerTo_tse__GetEventSearchResults(struct soap *soap, const char *tag, struct _tse__GetEventSearchResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetEventSearchResults **)soap_malloc(soap, sizeof(struct _tse__GetEventSearchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetEventSearchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetEventSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetEventSearchResults, sizeof(struct _tse__GetEventSearchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetEventSearchResults(soap, tag ? tag : "tse:GetEventSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetEventSearchResults ** SOAP_FMAC4 soap_get_PointerTo_tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetEventSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindEventsResponse))
		soap_serialize__tse__FindEventsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindEventsResponse(struct soap *soap, const char *tag, int id, struct _tse__FindEventsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindEventsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindEventsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindEventsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__FindEventsResponse(struct soap *soap, const char *tag, struct _tse__FindEventsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindEventsResponse **)soap_malloc(soap, sizeof(struct _tse__FindEventsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindEventsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindEventsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindEventsResponse, sizeof(struct _tse__FindEventsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindEventsResponse(soap, tag ? tag : "tse:FindEventsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindEventsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindEventsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindEvents(struct soap *soap, struct _tse__FindEvents *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindEvents))
		soap_serialize__tse__FindEvents(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindEvents(struct soap *soap, const char *tag, int id, struct _tse__FindEvents *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindEvents, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindEvents(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindEvents ** SOAP_FMAC4 soap_in_PointerTo_tse__FindEvents(struct soap *soap, const char *tag, struct _tse__FindEvents **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindEvents **)soap_malloc(soap, sizeof(struct _tse__FindEvents *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindEvents(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindEvents **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindEvents, sizeof(struct _tse__FindEvents), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindEvents(struct soap *soap, struct _tse__FindEvents *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindEvents(soap, tag ? tag : "tse:FindEvents", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindEvents ** SOAP_FMAC4 soap_get_PointerTo_tse__FindEvents(struct soap *soap, struct _tse__FindEvents **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse))
		soap_serialize__tse__GetRecordingSearchResultsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingSearchResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingSearchResultsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingSearchResultsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingSearchResultsResponse **)soap_malloc(soap, sizeof(struct _tse__GetRecordingSearchResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingSearchResultsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, sizeof(struct _tse__GetRecordingSearchResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetRecordingSearchResultsResponse(soap, tag ? tag : "tse:GetRecordingSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingSearchResults))
		soap_serialize__tse__GetRecordingSearchResults(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingSearchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingSearchResults, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingSearchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, const char *tag, struct _tse__GetRecordingSearchResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingSearchResults **)soap_malloc(soap, sizeof(struct _tse__GetRecordingSearchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingSearchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSearchResults, sizeof(struct _tse__GetRecordingSearchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetRecordingSearchResults(soap, tag ? tag : "tse:GetRecordingSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindRecordingsResponse))
		soap_serialize__tse__FindRecordingsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindRecordingsResponse(struct soap *soap, const char *tag, int id, struct _tse__FindRecordingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindRecordingsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindRecordingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__FindRecordingsResponse(struct soap *soap, const char *tag, struct _tse__FindRecordingsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindRecordingsResponse **)soap_malloc(soap, sizeof(struct _tse__FindRecordingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindRecordingsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindRecordingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindRecordingsResponse, sizeof(struct _tse__FindRecordingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindRecordingsResponse(soap, tag ? tag : "tse:FindRecordingsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindRecordingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindRecordings))
		soap_serialize__tse__FindRecordings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindRecordings(struct soap *soap, const char *tag, int id, struct _tse__FindRecordings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindRecordings, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindRecordings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindRecordings ** SOAP_FMAC4 soap_in_PointerTo_tse__FindRecordings(struct soap *soap, const char *tag, struct _tse__FindRecordings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindRecordings **)soap_malloc(soap, sizeof(struct _tse__FindRecordings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindRecordings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindRecordings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindRecordings, sizeof(struct _tse__FindRecordings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindRecordings(soap, tag ? tag : "tse:FindRecordings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindRecordings ** SOAP_FMAC4 soap_get_PointerTo_tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindRecordings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetMediaAttributesResponse))
		soap_serialize__tse__GetMediaAttributesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, const char *tag, int id, struct _tse__GetMediaAttributesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetMediaAttributesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetMediaAttributesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, const char *tag, struct _tse__GetMediaAttributesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetMediaAttributesResponse **)soap_malloc(soap, sizeof(struct _tse__GetMediaAttributesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetMediaAttributesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMediaAttributesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMediaAttributesResponse, sizeof(struct _tse__GetMediaAttributesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetMediaAttributesResponse(soap, tag ? tag : "tse:GetMediaAttributesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetMediaAttributesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetMediaAttributes))
		soap_serialize__tse__GetMediaAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetMediaAttributes(struct soap *soap, const char *tag, int id, struct _tse__GetMediaAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetMediaAttributes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetMediaAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetMediaAttributes ** SOAP_FMAC4 soap_in_PointerTo_tse__GetMediaAttributes(struct soap *soap, const char *tag, struct _tse__GetMediaAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetMediaAttributes **)soap_malloc(soap, sizeof(struct _tse__GetMediaAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetMediaAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMediaAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMediaAttributes, sizeof(struct _tse__GetMediaAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetMediaAttributes(soap, tag ? tag : "tse:GetMediaAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMediaAttributes ** SOAP_FMAC4 soap_get_PointerTo_tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetMediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingInformationResponse))
		soap_serialize__tse__GetRecordingInformationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingInformationResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingInformationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingInformationResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingInformationResponse **)soap_malloc(soap, sizeof(struct _tse__GetRecordingInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingInformationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingInformationResponse, sizeof(struct _tse__GetRecordingInformationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetRecordingInformationResponse(soap, tag ? tag : "tse:GetRecordingInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingInformation))
		soap_serialize__tse__GetRecordingInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingInformation(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingInformation ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingInformation(struct soap *soap, const char *tag, struct _tse__GetRecordingInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingInformation **)soap_malloc(soap, sizeof(struct _tse__GetRecordingInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingInformation, sizeof(struct _tse__GetRecordingInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetRecordingInformation(soap, tag ? tag : "tse:GetRecordingInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingInformation ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingSummaryResponse))
		soap_serialize__tse__GetRecordingSummaryResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingSummaryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingSummaryResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingSummaryResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingSummaryResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingSummaryResponse **)soap_malloc(soap, sizeof(struct _tse__GetRecordingSummaryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingSummaryResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSummaryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSummaryResponse, sizeof(struct _tse__GetRecordingSummaryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetRecordingSummaryResponse(soap, tag ? tag : "tse:GetRecordingSummaryResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingSummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingSummary))
		soap_serialize__tse__GetRecordingSummary(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingSummary(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingSummary, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingSummary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingSummary ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingSummary(struct soap *soap, const char *tag, struct _tse__GetRecordingSummary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingSummary **)soap_malloc(soap, sizeof(struct _tse__GetRecordingSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingSummary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSummary, sizeof(struct _tse__GetRecordingSummary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetRecordingSummary(soap, tag ? tag : "tse:GetRecordingSummary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSummary ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse))
		soap_serialize__tse__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tse__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tse__GetServiceCapabilitiesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tse__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, sizeof(struct _tse__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetServiceCapabilitiesResponse(soap, tag ? tag : "tse:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetServiceCapabilities))
		soap_serialize__tse__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tse__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tse__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tse__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tse__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetServiceCapabilities, sizeof(struct _tse__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetServiceCapabilities(soap, tag ? tag : "tse:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceiverStateResponse))
		soap_serialize__trv__GetReceiverStateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, const char *tag, int id, struct _trv__GetReceiverStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceiverStateResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceiverStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, const char *tag, struct _trv__GetReceiverStateResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceiverStateResponse **)soap_malloc(soap, sizeof(struct _trv__GetReceiverStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceiverStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiverStateResponse, sizeof(struct _trv__GetReceiverStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__GetReceiverStateResponse(soap, tag ? tag : "trv:GetReceiverStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceiverStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceiverState))
		soap_serialize__trv__GetReceiverState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceiverState(struct soap *soap, const char *tag, int id, struct _trv__GetReceiverState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceiverState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceiverState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceiverState ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceiverState(struct soap *soap, const char *tag, struct _trv__GetReceiverState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceiverState **)soap_malloc(soap, sizeof(struct _trv__GetReceiverState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceiverState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiverState, sizeof(struct _trv__GetReceiverState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__GetReceiverState(soap, tag ? tag : "trv:GetReceiverState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverState ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceiverState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__SetReceiverModeResponse))
		soap_serialize__trv__SetReceiverModeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, const char *tag, int id, struct _trv__SetReceiverModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__SetReceiverModeResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__SetReceiverModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, const char *tag, struct _trv__SetReceiverModeResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__SetReceiverModeResponse **)soap_malloc(soap, sizeof(struct _trv__SetReceiverModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__SetReceiverModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__SetReceiverModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__SetReceiverModeResponse, sizeof(struct _trv__SetReceiverModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__SetReceiverModeResponse(soap, tag ? tag : "trv:SetReceiverModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__SetReceiverModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__SetReceiverMode))
		soap_serialize__trv__SetReceiverMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__SetReceiverMode(struct soap *soap, const char *tag, int id, struct _trv__SetReceiverMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__SetReceiverMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__SetReceiverMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__SetReceiverMode ** SOAP_FMAC4 soap_in_PointerTo_trv__SetReceiverMode(struct soap *soap, const char *tag, struct _trv__SetReceiverMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__SetReceiverMode **)soap_malloc(soap, sizeof(struct _trv__SetReceiverMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__SetReceiverMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__SetReceiverMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__SetReceiverMode, sizeof(struct _trv__SetReceiverMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__SetReceiverMode(soap, tag ? tag : "trv:SetReceiverMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__SetReceiverMode ** SOAP_FMAC4 soap_get_PointerTo_trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__SetReceiverMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__ConfigureReceiverResponse(struct soap *soap, struct _trv__ConfigureReceiverResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__ConfigureReceiverResponse))
		soap_serialize__trv__ConfigureReceiverResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__ConfigureReceiverResponse(struct soap *soap, const char *tag, int id, struct _trv__ConfigureReceiverResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__ConfigureReceiverResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__ConfigureReceiverResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__ConfigureReceiverResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__ConfigureReceiverResponse(struct soap *soap, const char *tag, struct _trv__ConfigureReceiverResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__ConfigureReceiverResponse **)soap_malloc(soap, sizeof(struct _trv__ConfigureReceiverResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__ConfigureReceiverResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__ConfigureReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__ConfigureReceiverResponse, sizeof(struct _trv__ConfigureReceiverResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__ConfigureReceiverResponse(struct soap *soap, struct _trv__ConfigureReceiverResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__ConfigureReceiverResponse(soap, tag ? tag : "trv:ConfigureReceiverResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__ConfigureReceiverResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__ConfigureReceiverResponse(struct soap *soap, struct _trv__ConfigureReceiverResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__ConfigureReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__ConfigureReceiver(struct soap *soap, struct _trv__ConfigureReceiver *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__ConfigureReceiver))
		soap_serialize__trv__ConfigureReceiver(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__ConfigureReceiver(struct soap *soap, const char *tag, int id, struct _trv__ConfigureReceiver *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__ConfigureReceiver, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__ConfigureReceiver(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__ConfigureReceiver ** SOAP_FMAC4 soap_in_PointerTo_trv__ConfigureReceiver(struct soap *soap, const char *tag, struct _trv__ConfigureReceiver **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__ConfigureReceiver **)soap_malloc(soap, sizeof(struct _trv__ConfigureReceiver *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__ConfigureReceiver(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__ConfigureReceiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__ConfigureReceiver, sizeof(struct _trv__ConfigureReceiver), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__ConfigureReceiver(struct soap *soap, struct _trv__ConfigureReceiver *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__ConfigureReceiver(soap, tag ? tag : "trv:ConfigureReceiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__ConfigureReceiver ** SOAP_FMAC4 soap_get_PointerTo_trv__ConfigureReceiver(struct soap *soap, struct _trv__ConfigureReceiver **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__ConfigureReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__DeleteReceiverResponse(struct soap *soap, struct _trv__DeleteReceiverResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__DeleteReceiverResponse))
		soap_serialize__trv__DeleteReceiverResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__DeleteReceiverResponse(struct soap *soap, const char *tag, int id, struct _trv__DeleteReceiverResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__DeleteReceiverResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__DeleteReceiverResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__DeleteReceiverResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__DeleteReceiverResponse(struct soap *soap, const char *tag, struct _trv__DeleteReceiverResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__DeleteReceiverResponse **)soap_malloc(soap, sizeof(struct _trv__DeleteReceiverResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__DeleteReceiverResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__DeleteReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__DeleteReceiverResponse, sizeof(struct _trv__DeleteReceiverResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__DeleteReceiverResponse(struct soap *soap, struct _trv__DeleteReceiverResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__DeleteReceiverResponse(soap, tag ? tag : "trv:DeleteReceiverResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__DeleteReceiverResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__DeleteReceiverResponse(struct soap *soap, struct _trv__DeleteReceiverResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__DeleteReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__DeleteReceiver(struct soap *soap, struct _trv__DeleteReceiver *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__DeleteReceiver))
		soap_serialize__trv__DeleteReceiver(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__DeleteReceiver(struct soap *soap, const char *tag, int id, struct _trv__DeleteReceiver *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__DeleteReceiver, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__DeleteReceiver(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__DeleteReceiver ** SOAP_FMAC4 soap_in_PointerTo_trv__DeleteReceiver(struct soap *soap, const char *tag, struct _trv__DeleteReceiver **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__DeleteReceiver **)soap_malloc(soap, sizeof(struct _trv__DeleteReceiver *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__DeleteReceiver(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__DeleteReceiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__DeleteReceiver, sizeof(struct _trv__DeleteReceiver), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__DeleteReceiver(struct soap *soap, struct _trv__DeleteReceiver *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__DeleteReceiver(soap, tag ? tag : "trv:DeleteReceiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__DeleteReceiver ** SOAP_FMAC4 soap_get_PointerTo_trv__DeleteReceiver(struct soap *soap, struct _trv__DeleteReceiver **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__DeleteReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__CreateReceiverResponse(struct soap *soap, struct _trv__CreateReceiverResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__CreateReceiverResponse))
		soap_serialize__trv__CreateReceiverResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__CreateReceiverResponse(struct soap *soap, const char *tag, int id, struct _trv__CreateReceiverResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__CreateReceiverResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__CreateReceiverResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__CreateReceiverResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__CreateReceiverResponse(struct soap *soap, const char *tag, struct _trv__CreateReceiverResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__CreateReceiverResponse **)soap_malloc(soap, sizeof(struct _trv__CreateReceiverResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__CreateReceiverResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__CreateReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__CreateReceiverResponse, sizeof(struct _trv__CreateReceiverResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__CreateReceiverResponse(struct soap *soap, struct _trv__CreateReceiverResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__CreateReceiverResponse(soap, tag ? tag : "trv:CreateReceiverResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__CreateReceiverResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__CreateReceiverResponse(struct soap *soap, struct _trv__CreateReceiverResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__CreateReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__CreateReceiver(struct soap *soap, struct _trv__CreateReceiver *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__CreateReceiver))
		soap_serialize__trv__CreateReceiver(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__CreateReceiver(struct soap *soap, const char *tag, int id, struct _trv__CreateReceiver *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__CreateReceiver, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__CreateReceiver(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__CreateReceiver ** SOAP_FMAC4 soap_in_PointerTo_trv__CreateReceiver(struct soap *soap, const char *tag, struct _trv__CreateReceiver **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__CreateReceiver **)soap_malloc(soap, sizeof(struct _trv__CreateReceiver *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__CreateReceiver(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__CreateReceiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__CreateReceiver, sizeof(struct _trv__CreateReceiver), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__CreateReceiver(struct soap *soap, struct _trv__CreateReceiver *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__CreateReceiver(soap, tag ? tag : "trv:CreateReceiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__CreateReceiver ** SOAP_FMAC4 soap_get_PointerTo_trv__CreateReceiver(struct soap *soap, struct _trv__CreateReceiver **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__CreateReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceiverResponse(struct soap *soap, struct _trv__GetReceiverResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceiverResponse))
		soap_serialize__trv__GetReceiverResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceiverResponse(struct soap *soap, const char *tag, int id, struct _trv__GetReceiverResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceiverResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceiverResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceiverResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceiverResponse(struct soap *soap, const char *tag, struct _trv__GetReceiverResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceiverResponse **)soap_malloc(soap, sizeof(struct _trv__GetReceiverResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceiverResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiverResponse, sizeof(struct _trv__GetReceiverResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceiverResponse(struct soap *soap, struct _trv__GetReceiverResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__GetReceiverResponse(soap, tag ? tag : "trv:GetReceiverResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceiverResponse(struct soap *soap, struct _trv__GetReceiverResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceiver(struct soap *soap, struct _trv__GetReceiver *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceiver))
		soap_serialize__trv__GetReceiver(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceiver(struct soap *soap, const char *tag, int id, struct _trv__GetReceiver *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceiver, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceiver(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceiver ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceiver(struct soap *soap, const char *tag, struct _trv__GetReceiver **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceiver **)soap_malloc(soap, sizeof(struct _trv__GetReceiver *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceiver(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiver, sizeof(struct _trv__GetReceiver), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceiver(struct soap *soap, struct _trv__GetReceiver *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__GetReceiver(soap, tag ? tag : "trv:GetReceiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiver ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceiver(struct soap *soap, struct _trv__GetReceiver **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceiversResponse(struct soap *soap, struct _trv__GetReceiversResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceiversResponse))
		soap_serialize__trv__GetReceiversResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceiversResponse(struct soap *soap, const char *tag, int id, struct _trv__GetReceiversResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceiversResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceiversResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceiversResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceiversResponse(struct soap *soap, const char *tag, struct _trv__GetReceiversResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceiversResponse **)soap_malloc(soap, sizeof(struct _trv__GetReceiversResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceiversResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiversResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiversResponse, sizeof(struct _trv__GetReceiversResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceiversResponse(struct soap *soap, struct _trv__GetReceiversResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__GetReceiversResponse(soap, tag ? tag : "trv:GetReceiversResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiversResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceiversResponse(struct soap *soap, struct _trv__GetReceiversResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceiversResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceivers(struct soap *soap, struct _trv__GetReceivers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceivers))
		soap_serialize__trv__GetReceivers(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceivers(struct soap *soap, const char *tag, int id, struct _trv__GetReceivers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceivers, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceivers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceivers ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceivers(struct soap *soap, const char *tag, struct _trv__GetReceivers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceivers **)soap_malloc(soap, sizeof(struct _trv__GetReceivers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceivers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceivers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceivers, sizeof(struct _trv__GetReceivers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceivers(struct soap *soap, struct _trv__GetReceivers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__GetReceivers(soap, tag ? tag : "trv:GetReceivers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceivers ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceivers(struct soap *soap, struct _trv__GetReceivers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceivers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetServiceCapabilitiesResponse(struct soap *soap, struct _trv__GetServiceCapabilitiesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetServiceCapabilitiesResponse))
		soap_serialize__trv__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _trv__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trv__GetServiceCapabilitiesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _trv__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, sizeof(struct _trv__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetServiceCapabilitiesResponse(struct soap *soap, struct _trv__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__GetServiceCapabilitiesResponse(soap, tag ? tag : "trv:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__GetServiceCapabilitiesResponse(struct soap *soap, struct _trv__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetServiceCapabilities(struct soap *soap, struct _trv__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetServiceCapabilities))
		soap_serialize__trv__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _trv__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_trv__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trv__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _trv__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetServiceCapabilities, sizeof(struct _trv__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetServiceCapabilities(struct soap *soap, struct _trv__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__GetServiceCapabilities(soap, tag ? tag : "trv:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_trv__GetServiceCapabilities(struct soap *soap, struct _trv__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__DeleteOSDResponse(struct soap *soap, struct _trt__DeleteOSDResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__DeleteOSDResponse))
		soap_serialize__trt__DeleteOSDResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__DeleteOSDResponse(struct soap *soap, const char *tag, int id, struct _trt__DeleteOSDResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__DeleteOSDResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__DeleteOSDResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__DeleteOSDResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__DeleteOSDResponse(struct soap *soap, const char *tag, struct _trt__DeleteOSDResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__DeleteOSDResponse **)soap_malloc(soap, sizeof(struct _trt__DeleteOSDResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__DeleteOSDResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteOSDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteOSDResponse, sizeof(struct _trt__DeleteOSDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__DeleteOSDResponse(struct soap *soap, struct _trt__DeleteOSDResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__DeleteOSDResponse(soap, tag ? tag : "trt:DeleteOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteOSDResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__DeleteOSDResponse(struct soap *soap, struct _trt__DeleteOSDResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__DeleteOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__DeleteOSD(struct soap *soap, struct _trt__DeleteOSD *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__DeleteOSD))
		soap_serialize__trt__DeleteOSD(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__DeleteOSD(struct soap *soap, const char *tag, int id, struct _trt__DeleteOSD *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__DeleteOSD, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__DeleteOSD(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__DeleteOSD ** SOAP_FMAC4 soap_in_PointerTo_trt__DeleteOSD(struct soap *soap, const char *tag, struct _trt__DeleteOSD **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__DeleteOSD **)soap_malloc(soap, sizeof(struct _trt__DeleteOSD *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__DeleteOSD(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteOSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteOSD, sizeof(struct _trt__DeleteOSD), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__DeleteOSD(struct soap *soap, struct _trt__DeleteOSD *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__DeleteOSD(soap, tag ? tag : "trt:DeleteOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteOSD ** SOAP_FMAC4 soap_get_PointerTo_trt__DeleteOSD(struct soap *soap, struct _trt__DeleteOSD **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__DeleteOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__CreateOSDResponse(struct soap *soap, struct _trt__CreateOSDResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__CreateOSDResponse))
		soap_serialize__trt__CreateOSDResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__CreateOSDResponse(struct soap *soap, const char *tag, int id, struct _trt__CreateOSDResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__CreateOSDResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__CreateOSDResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__CreateOSDResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__CreateOSDResponse(struct soap *soap, const char *tag, struct _trt__CreateOSDResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__CreateOSDResponse **)soap_malloc(soap, sizeof(struct _trt__CreateOSDResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__CreateOSDResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__CreateOSDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateOSDResponse, sizeof(struct _trt__CreateOSDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__CreateOSDResponse(struct soap *soap, struct _trt__CreateOSDResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__CreateOSDResponse(soap, tag ? tag : "trt:CreateOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateOSDResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__CreateOSDResponse(struct soap *soap, struct _trt__CreateOSDResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__CreateOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__CreateOSD(struct soap *soap, struct _trt__CreateOSD *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__CreateOSD))
		soap_serialize__trt__CreateOSD(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__CreateOSD(struct soap *soap, const char *tag, int id, struct _trt__CreateOSD *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__CreateOSD, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__CreateOSD(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__CreateOSD ** SOAP_FMAC4 soap_in_PointerTo_trt__CreateOSD(struct soap *soap, const char *tag, struct _trt__CreateOSD **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__CreateOSD **)soap_malloc(soap, sizeof(struct _trt__CreateOSD *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__CreateOSD(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__CreateOSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateOSD, sizeof(struct _trt__CreateOSD), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__CreateOSD(struct soap *soap, struct _trt__CreateOSD *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__CreateOSD(soap, tag ? tag : "trt:CreateOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateOSD ** SOAP_FMAC4 soap_get_PointerTo_trt__CreateOSD(struct soap *soap, struct _trt__CreateOSD **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__CreateOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetOSDResponse(struct soap *soap, struct _trt__SetOSDResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetOSDResponse))
		soap_serialize__trt__SetOSDResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetOSDResponse(struct soap *soap, const char *tag, int id, struct _trt__SetOSDResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetOSDResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetOSDResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetOSDResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetOSDResponse(struct soap *soap, const char *tag, struct _trt__SetOSDResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetOSDResponse **)soap_malloc(soap, sizeof(struct _trt__SetOSDResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetOSDResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetOSDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetOSDResponse, sizeof(struct _trt__SetOSDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetOSDResponse(struct soap *soap, struct _trt__SetOSDResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetOSDResponse(soap, tag ? tag : "trt:SetOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetOSDResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetOSDResponse(struct soap *soap, struct _trt__SetOSDResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetOSD(struct soap *soap, struct _trt__SetOSD *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetOSD))
		soap_serialize__trt__SetOSD(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetOSD(struct soap *soap, const char *tag, int id, struct _trt__SetOSD *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetOSD, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetOSD(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetOSD ** SOAP_FMAC4 soap_in_PointerTo_trt__SetOSD(struct soap *soap, const char *tag, struct _trt__SetOSD **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetOSD **)soap_malloc(soap, sizeof(struct _trt__SetOSD *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetOSD(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetOSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetOSD, sizeof(struct _trt__SetOSD), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetOSD(struct soap *soap, struct _trt__SetOSD *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetOSD(soap, tag ? tag : "trt:SetOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetOSD ** SOAP_FMAC4 soap_get_PointerTo_trt__SetOSD(struct soap *soap, struct _trt__SetOSD **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetOSDOptionsResponse(struct soap *soap, struct _trt__GetOSDOptionsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetOSDOptionsResponse))
		soap_serialize__trt__GetOSDOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetOSDOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetOSDOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetOSDOptionsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetOSDOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetOSDOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetOSDOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetOSDOptionsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetOSDOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetOSDOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetOSDOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetOSDOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSDOptionsResponse, sizeof(struct _trt__GetOSDOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetOSDOptionsResponse(struct soap *soap, struct _trt__GetOSDOptionsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetOSDOptionsResponse(soap, tag ? tag : "trt:GetOSDOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetOSDOptionsResponse(struct soap *soap, struct _trt__GetOSDOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetOSDOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetOSDOptions(struct soap *soap, struct _trt__GetOSDOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetOSDOptions))
		soap_serialize__trt__GetOSDOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetOSDOptions(struct soap *soap, const char *tag, int id, struct _trt__GetOSDOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetOSDOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetOSDOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetOSDOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetOSDOptions(struct soap *soap, const char *tag, struct _trt__GetOSDOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetOSDOptions **)soap_malloc(soap, sizeof(struct _trt__GetOSDOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetOSDOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetOSDOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSDOptions, sizeof(struct _trt__GetOSDOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetOSDOptions(struct soap *soap, struct _trt__GetOSDOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetOSDOptions(soap, tag ? tag : "trt:GetOSDOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetOSDOptions(struct soap *soap, struct _trt__GetOSDOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetOSDOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetOSDResponse(struct soap *soap, struct _trt__GetOSDResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetOSDResponse))
		soap_serialize__trt__GetOSDResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetOSDResponse(struct soap *soap, const char *tag, int id, struct _trt__GetOSDResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetOSDResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetOSDResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetOSDResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetOSDResponse(struct soap *soap, const char *tag, struct _trt__GetOSDResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetOSDResponse **)soap_malloc(soap, sizeof(struct _trt__GetOSDResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetOSDResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetOSDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSDResponse, sizeof(struct _trt__GetOSDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetOSDResponse(struct soap *soap, struct _trt__GetOSDResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetOSDResponse(soap, tag ? tag : "trt:GetOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetOSDResponse(struct soap *soap, struct _trt__GetOSDResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetOSD(struct soap *soap, struct _trt__GetOSD *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetOSD))
		soap_serialize__trt__GetOSD(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetOSD(struct soap *soap, const char *tag, int id, struct _trt__GetOSD *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetOSD, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetOSD(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetOSD ** SOAP_FMAC4 soap_in_PointerTo_trt__GetOSD(struct soap *soap, const char *tag, struct _trt__GetOSD **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetOSD **)soap_malloc(soap, sizeof(struct _trt__GetOSD *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetOSD(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetOSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSD, sizeof(struct _trt__GetOSD), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetOSD(struct soap *soap, struct _trt__GetOSD *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetOSD(soap, tag ? tag : "trt:GetOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSD ** SOAP_FMAC4 soap_get_PointerTo_trt__GetOSD(struct soap *soap, struct _trt__GetOSD **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetOSDsResponse(struct soap *soap, struct _trt__GetOSDsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetOSDsResponse))
		soap_serialize__trt__GetOSDsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetOSDsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetOSDsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetOSDsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetOSDsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetOSDsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetOSDsResponse(struct soap *soap, const char *tag, struct _trt__GetOSDsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetOSDsResponse **)soap_malloc(soap, sizeof(struct _trt__GetOSDsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetOSDsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetOSDsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSDsResponse, sizeof(struct _trt__GetOSDsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetOSDsResponse(struct soap *soap, struct _trt__GetOSDsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetOSDsResponse(soap, tag ? tag : "trt:GetOSDsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetOSDsResponse(struct soap *soap, struct _trt__GetOSDsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetOSDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetOSDs(struct soap *soap, struct _trt__GetOSDs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetOSDs))
		soap_serialize__trt__GetOSDs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetOSDs(struct soap *soap, const char *tag, int id, struct _trt__GetOSDs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetOSDs, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetOSDs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetOSDs ** SOAP_FMAC4 soap_in_PointerTo_trt__GetOSDs(struct soap *soap, const char *tag, struct _trt__GetOSDs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetOSDs **)soap_malloc(soap, sizeof(struct _trt__GetOSDs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetOSDs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetOSDs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSDs, sizeof(struct _trt__GetOSDs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetOSDs(struct soap *soap, struct _trt__GetOSDs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetOSDs(soap, tag ? tag : "trt:GetOSDs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDs ** SOAP_FMAC4 soap_get_PointerTo_trt__GetOSDs(struct soap *soap, struct _trt__GetOSDs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoSourceModeResponse(struct soap *soap, struct _trt__SetVideoSourceModeResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoSourceModeResponse))
		soap_serialize__trt__SetVideoSourceModeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoSourceModeResponse(struct soap *soap, const char *tag, int id, struct _trt__SetVideoSourceModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoSourceModeResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoSourceModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoSourceModeResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoSourceModeResponse(struct soap *soap, const char *tag, struct _trt__SetVideoSourceModeResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoSourceModeResponse **)soap_malloc(soap, sizeof(struct _trt__SetVideoSourceModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoSourceModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoSourceModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceModeResponse, sizeof(struct _trt__SetVideoSourceModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoSourceModeResponse(struct soap *soap, struct _trt__SetVideoSourceModeResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetVideoSourceModeResponse(soap, tag ? tag : "trt:SetVideoSourceModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoSourceModeResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoSourceModeResponse(struct soap *soap, struct _trt__SetVideoSourceModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoSourceModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoSourceMode(struct soap *soap, struct _trt__SetVideoSourceMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoSourceMode))
		soap_serialize__trt__SetVideoSourceMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoSourceMode(struct soap *soap, const char *tag, int id, struct _trt__SetVideoSourceMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoSourceMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoSourceMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoSourceMode ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoSourceMode(struct soap *soap, const char *tag, struct _trt__SetVideoSourceMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoSourceMode **)soap_malloc(soap, sizeof(struct _trt__SetVideoSourceMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoSourceMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoSourceMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceMode, sizeof(struct _trt__SetVideoSourceMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoSourceMode(struct soap *soap, struct _trt__SetVideoSourceMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetVideoSourceMode(soap, tag ? tag : "trt:SetVideoSourceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoSourceMode ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoSourceMode(struct soap *soap, struct _trt__SetVideoSourceMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceModesResponse(struct soap *soap, struct _trt__GetVideoSourceModesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceModesResponse))
		soap_serialize__trt__GetVideoSourceModesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceModesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceModesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceModesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceModesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceModesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceModesResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceModesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceModesResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceModesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceModesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceModesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceModesResponse, sizeof(struct _trt__GetVideoSourceModesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceModesResponse(struct soap *soap, struct _trt__GetVideoSourceModesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoSourceModesResponse(soap, tag ? tag : "trt:GetVideoSourceModesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceModesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceModesResponse(struct soap *soap, struct _trt__GetVideoSourceModesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceModesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceModes(struct soap *soap, struct _trt__GetVideoSourceModes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceModes))
		soap_serialize__trt__GetVideoSourceModes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceModes(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceModes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceModes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceModes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceModes ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceModes(struct soap *soap, const char *tag, struct _trt__GetVideoSourceModes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceModes **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceModes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceModes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceModes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceModes, sizeof(struct _trt__GetVideoSourceModes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceModes(struct soap *soap, struct _trt__GetVideoSourceModes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoSourceModes(soap, tag ? tag : "trt:GetVideoSourceModes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceModes ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceModes(struct soap *soap, struct _trt__GetVideoSourceModes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetSnapshotUriResponse))
		soap_serialize__trt__GetSnapshotUriResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, struct _trt__GetSnapshotUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetSnapshotUriResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetSnapshotUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, struct _trt__GetSnapshotUriResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetSnapshotUriResponse **)soap_malloc(soap, sizeof(struct _trt__GetSnapshotUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetSnapshotUriResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetSnapshotUriResponse(soap, tag ? tag : "trt:GetSnapshotUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetSnapshotUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetSnapshotUri))
		soap_serialize__trt__GetSnapshotUri(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, struct _trt__GetSnapshotUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetSnapshotUri, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetSnapshotUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri ** SOAP_FMAC4 soap_in_PointerTo_trt__GetSnapshotUri(struct soap *soap, const char *tag, struct _trt__GetSnapshotUri **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetSnapshotUri **)soap_malloc(soap, sizeof(struct _trt__GetSnapshotUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetSnapshotUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetSnapshotUri(soap, tag ? tag : "trt:GetSnapshotUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri ** SOAP_FMAC4 soap_get_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetSynchronizationPointResponse))
		soap_serialize__trt__SetSynchronizationPointResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, struct _trt__SetSynchronizationPointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetSynchronizationPointResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetSynchronizationPointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPointResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetSynchronizationPointResponse **)soap_malloc(soap, sizeof(struct _trt__SetSynchronizationPointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetSynchronizationPointResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetSynchronizationPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(struct _trt__SetSynchronizationPointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetSynchronizationPointResponse(soap, tag ? tag : "trt:SetSynchronizationPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetSynchronizationPoint))
		soap_serialize__trt__SetSynchronizationPoint(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, struct _trt__SetSynchronizationPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetSynchronizationPoint, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetSynchronizationPoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint ** SOAP_FMAC4 soap_in_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPoint **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetSynchronizationPoint **)soap_malloc(soap, sizeof(struct _trt__SetSynchronizationPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetSynchronizationPoint(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetSynchronizationPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(struct _trt__SetSynchronizationPoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetSynchronizationPoint(soap, tag ? tag : "trt:SetSynchronizationPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint ** SOAP_FMAC4 soap_get_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StopMulticastStreamingResponse))
		soap_serialize__trt__StopMulticastStreamingResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, int id, struct _trt__StopMulticastStreamingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StopMulticastStreamingResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__StopMulticastStreamingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StopMulticastStreamingResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__StopMulticastStreamingResponse **)soap_malloc(soap, sizeof(struct _trt__StopMulticastStreamingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__StopMulticastStreamingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__StopMulticastStreamingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(struct _trt__StopMulticastStreamingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__StopMulticastStreamingResponse(soap, tag ? tag : "trt:StopMulticastStreamingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StopMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StopMulticastStreaming))
		soap_serialize__trt__StopMulticastStreaming(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StopMulticastStreaming(struct soap *soap, const char *tag, int id, struct _trt__StopMulticastStreaming *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StopMulticastStreaming, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__StopMulticastStreaming(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming ** SOAP_FMAC4 soap_in_PointerTo_trt__StopMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StopMulticastStreaming **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__StopMulticastStreaming **)soap_malloc(soap, sizeof(struct _trt__StopMulticastStreaming *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__StopMulticastStreaming(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__StopMulticastStreaming **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(struct _trt__StopMulticastStreaming), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__StopMulticastStreaming(soap, tag ? tag : "trt:StopMulticastStreaming", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming ** SOAP_FMAC4 soap_get_PointerTo_trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StopMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StartMulticastStreamingResponse))
		soap_serialize__trt__StartMulticastStreamingResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, int id, struct _trt__StartMulticastStreamingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StartMulticastStreamingResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__StartMulticastStreamingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StartMulticastStreamingResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__StartMulticastStreamingResponse **)soap_malloc(soap, sizeof(struct _trt__StartMulticastStreamingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__StartMulticastStreamingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__StartMulticastStreamingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(struct _trt__StartMulticastStreamingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__StartMulticastStreamingResponse(soap, tag ? tag : "trt:StartMulticastStreamingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StartMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StartMulticastStreaming))
		soap_serialize__trt__StartMulticastStreaming(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StartMulticastStreaming(struct soap *soap, const char *tag, int id, struct _trt__StartMulticastStreaming *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StartMulticastStreaming, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__StartMulticastStreaming(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming ** SOAP_FMAC4 soap_in_PointerTo_trt__StartMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StartMulticastStreaming **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__StartMulticastStreaming **)soap_malloc(soap, sizeof(struct _trt__StartMulticastStreaming *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__StartMulticastStreaming(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__StartMulticastStreaming **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(struct _trt__StartMulticastStreaming), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__StartMulticastStreaming(soap, tag ? tag : "trt:StartMulticastStreaming", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming ** SOAP_FMAC4 soap_get_PointerTo_trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StartMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetStreamUriResponse))
		soap_serialize__trt__GetStreamUriResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetStreamUriResponse(struct soap *soap, const char *tag, int id, struct _trt__GetStreamUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetStreamUriResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetStreamUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetStreamUriResponse(struct soap *soap, const char *tag, struct _trt__GetStreamUriResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetStreamUriResponse **)soap_malloc(soap, sizeof(struct _trt__GetStreamUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetStreamUriResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetStreamUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(struct _trt__GetStreamUriResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetStreamUriResponse(soap, tag ? tag : "trt:GetStreamUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetStreamUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
