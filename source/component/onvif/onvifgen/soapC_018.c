/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:06 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetHostname(struct soap *soap, struct _tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetHostname(struct soap *soap, const struct _tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostname(struct soap *soap, const char *tag, int id, const struct _tds__GetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostname), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_in__tds__GetHostname(struct soap *soap, const char *tag, struct _tds__GetHostname *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetHostname*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetHostname(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostname, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_new__tds__GetHostname(struct soap *soap, int n)
{
	struct _tds__GetHostname *p;
	struct _tds__GetHostname *a = (struct _tds__GetHostname*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetHostname));
	for (p = a; p && n--; p++)
		soap_default__tds__GetHostname(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetHostname(struct soap *soap, const struct _tds__GetHostname *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetHostname(soap, tag ? tag : "tds:GetHostname", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_get__tds__GetHostname(struct soap *soap, struct _tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Capabilities(struct soap *soap, struct tt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Analytics = NULL;
	a->Device = NULL;
	a->Events = NULL;
	a->Imaging = NULL;
	a->Media = NULL;
	a->PTZ = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Capabilities(struct soap *soap, const struct tt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsCapabilities(soap, &a->Analytics);
	soap_serialize_PointerTott__DeviceCapabilities(soap, &a->Device);
	soap_serialize_PointerTott__EventCapabilities(soap, &a->Events);
	soap_serialize_PointerTott__ImagingCapabilities(soap, &a->Imaging);
	soap_serialize_PointerTott__MediaCapabilities(soap, &a->Media);
	soap_serialize_PointerTott__PTZCapabilities(soap, &a->PTZ);
	soap_serialize_PointerTott__CapabilitiesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Capabilities(struct soap *soap, const char *tag, int id, const struct tt__Capabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Capabilities), type))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", -1, &a->Analytics, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilities(soap, "tt:Device", -1, &a->Device, ""))
		return soap->error;
	if (soap_out_PointerTott__EventCapabilities(soap, "tt:Events", -1, &a->Events, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingCapabilities(soap, "tt:Imaging", -1, &a->Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilities(soap, "tt:Media", -1, &a->Media, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZCapabilities(soap, "tt:PTZ", -1, &a->PTZ, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_in_tt__Capabilities(struct soap *soap, const char *tag, struct tt__Capabilities *a, const char *type)
{
	size_t soap_flag_Analytics = 1;
	size_t soap_flag_Device = 1;
	size_t soap_flag_Events = 1;
	size_t soap_flag_Imaging = 1;
	size_t soap_flag_Media = 1;
	size_t soap_flag_PTZ = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Capabilities(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", &a->Analytics, "tt:AnalyticsCapabilities"))
				{	soap_flag_Analytics--;
					continue;
				}
			}
			if (soap_flag_Device && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceCapabilities(soap, "tt:Device", &a->Device, "tt:DeviceCapabilities"))
				{	soap_flag_Device--;
					continue;
				}
			}
			if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EventCapabilities(soap, "tt:Events", &a->Events, "tt:EventCapabilities"))
				{	soap_flag_Events--;
					continue;
				}
			}
			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingCapabilities(soap, "tt:Imaging", &a->Imaging, "tt:ImagingCapabilities"))
				{	soap_flag_Imaging--;
					continue;
				}
			}
			if (soap_flag_Media && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaCapabilities(soap, "tt:Media", &a->Media, "tt:MediaCapabilities"))
				{	soap_flag_Media--;
					continue;
				}
			}
			if (soap_flag_PTZ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZCapabilities(soap, "tt:PTZ", &a->PTZ, "tt:PTZCapabilities"))
				{	soap_flag_PTZ--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:CapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Capabilities, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_new_tt__Capabilities(struct soap *soap, int n)
{
	struct tt__Capabilities *p;
	struct tt__Capabilities *a = (struct tt__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Capabilities(struct soap *soap, const struct tt__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__Capabilities(soap, tag ? tag : "tt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_get_tt__Capabilities(struct soap *soap, struct tt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCapabilitiesResponse(struct soap *soap, const struct _tds__GetCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Capabilities(soap, "tds:Capabilities", &a->Capabilities, "tt:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilitiesResponse, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_new__tds__GetCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tds__GetCapabilitiesResponse *p;
	struct _tds__GetCapabilitiesResponse *a = (struct _tds__GetCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCapabilitiesResponse(struct soap *soap, const struct _tds__GetCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCapabilitiesResponse(soap, tag ? tag : "tds:GetCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCategory = 0;
	a->Category = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCapabilities(struct soap *soap, const struct _tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Category)
	{	int i;
		for (i = 0; i < (int)a->__sizeCategory; i++)
		{
			soap_embedded(soap, a->Category + i, SOAP_TYPE_tt__CapabilityCategory);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilities), type))
		return soap->error;
	if (a->Category)
	{	int i;
		for (i = 0; i < (int)a->__sizeCategory; i++)
			if (soap_out_tt__CapabilityCategory(soap, "tds:Category", -1, a->Category + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_in__tds__GetCapabilities(struct soap *soap, const char *tag, struct _tds__GetCapabilities *a, const char *type)
{
	struct soap_blist *soap_blist_Category = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Category", 1, NULL))
			{	if (a->Category == NULL)
				{	if (soap_blist_Category == NULL)
						soap_blist_Category = soap_alloc_block(soap);
					a->Category = (enum tt__CapabilityCategory *)soap_push_block_max(soap, soap_blist_Category, sizeof(enum tt__CapabilityCategory));
					if (a->Category == NULL)
						return NULL;
					soap_default_tt__CapabilityCategory(soap, a->Category);
				}
				soap_revert(soap);
				if (soap_in_tt__CapabilityCategory(soap, "tds:Category", a->Category, "tt:CapabilityCategory"))
				{	a->__sizeCategory++;
					a->Category = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Category)
			soap_pop_block(soap, soap_blist_Category);
		if (a->__sizeCategory)
		{	a->Category = (enum tt__CapabilityCategory *)soap_save_block(soap, soap_blist_Category, NULL, 1);
		}
		else
		{	a->Category = NULL;
			if (soap_blist_Category)
				soap_end_block(soap, soap_blist_Category);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilities, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_new__tds__GetCapabilities(struct soap *soap, int n)
{
	struct _tds__GetCapabilities *p;
	struct _tds__GetCapabilities *a = (struct _tds__GetCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCapabilities(struct soap *soap, const struct _tds__GetCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCapabilities(soap, tag ? tag : "tds:GetCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_get__tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->WsdlUrl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetWsdlUrlResponse(struct soap *soap, const struct _tds__GetWsdlUrlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->WsdlUrl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetWsdlUrlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrlResponse), type))
		return soap->error;
	if (a->WsdlUrl)
		soap_element_result(soap, "tds:WsdlUrl");
	if (!a->WsdlUrl)
	{	if (soap_element_empty(soap, "tds:WsdlUrl", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tds:WsdlUrl", -1, (char*const*)&a->WsdlUrl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_in__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, struct _tds__GetWsdlUrlResponse *a, const char *type)
{
	size_t soap_flag_WsdlUrl = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetWsdlUrlResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(struct _tds__GetWsdlUrlResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetWsdlUrlResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WsdlUrl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:WsdlUrl", (char**)&a->WsdlUrl, "xsd:anyURI"))
				{	soap_flag_WsdlUrl--;
					continue;
				}
			}
			soap_check_result(soap, "tds:WsdlUrl");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->WsdlUrl))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetWsdlUrlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrlResponse, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(struct _tds__GetWsdlUrlResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_new__tds__GetWsdlUrlResponse(struct soap *soap, int n)
{
	struct _tds__GetWsdlUrlResponse *p;
	struct _tds__GetWsdlUrlResponse *a = (struct _tds__GetWsdlUrlResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetWsdlUrlResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetWsdlUrlResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetWsdlUrlResponse(struct soap *soap, const struct _tds__GetWsdlUrlResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetWsdlUrlResponse(soap, tag ? tag : "tds:GetWsdlUrlResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_get__tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetWsdlUrl(struct soap *soap, const struct _tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, const struct _tds__GetWsdlUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrl), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetWsdlUrl * SOAP_FMAC4 soap_in__tds__GetWsdlUrl(struct soap *soap, const char *tag, struct _tds__GetWsdlUrl *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetWsdlUrl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(struct _tds__GetWsdlUrl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetWsdlUrl(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetWsdlUrl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrl, SOAP_TYPE__tds__GetWsdlUrl, sizeof(struct _tds__GetWsdlUrl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetWsdlUrl * SOAP_FMAC4 soap_new__tds__GetWsdlUrl(struct soap *soap, int n)
{
	struct _tds__GetWsdlUrl *p;
	struct _tds__GetWsdlUrl *a = (struct _tds__GetWsdlUrl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetWsdlUrl));
	for (p = a; p && n--; p++)
		soap_default__tds__GetWsdlUrl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetWsdlUrl(struct soap *soap, const struct _tds__GetWsdlUrl *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetWsdlUrl(soap, tag ? tag : "tds:GetWsdlUrl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetWsdlUrl * SOAP_FMAC4 soap_get__tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetUserResponse(struct soap *soap, const struct _tds__SetUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_in__tds__SetUserResponse(struct soap *soap, const char *tag, struct _tds__SetUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetUserResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetUserResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUserResponse, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_new__tds__SetUserResponse(struct soap *soap, int n)
{
	struct _tds__SetUserResponse *p;
	struct _tds__SetUserResponse *a = (struct _tds__SetUserResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetUserResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetUserResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetUserResponse(struct soap *soap, const struct _tds__SetUserResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetUserResponse(soap, tag ? tag : "tds:SetUserResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_get__tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetUser(struct soap *soap, struct _tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetUser(struct soap *soap, const struct _tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUser(struct soap *soap, const char *tag, int id, const struct _tds__SetUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUser), type))
		return soap->error;
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_in__tds__SetUser(struct soap *soap, const char *tag, struct _tds__SetUser *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->User == NULL)
				{	if (soap_blist_User == NULL)
						soap_blist_User = soap_alloc_block(soap);
					a->User = (struct tt__User *)soap_push_block_max(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
		{	a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		}
		else
		{	a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUser < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUser, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_new__tds__SetUser(struct soap *soap, int n)
{
	struct _tds__SetUser *p;
	struct _tds__SetUser *a = (struct _tds__SetUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetUser));
	for (p = a; p && n--; p++)
		soap_default__tds__SetUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetUser(struct soap *soap, const struct _tds__SetUser *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetUser(soap, tag ? tag : "tds:SetUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_get__tds__SetUser(struct soap *soap, struct _tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteUsersResponse(struct soap *soap, const struct _tds__DeleteUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_in__tds__DeleteUsersResponse(struct soap *soap, const char *tag, struct _tds__DeleteUsersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__DeleteUsersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteUsersResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsersResponse, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_new__tds__DeleteUsersResponse(struct soap *soap, int n)
{
	struct _tds__DeleteUsersResponse *p;
	struct _tds__DeleteUsersResponse *a = (struct _tds__DeleteUsersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteUsersResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteUsersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteUsersResponse(struct soap *soap, const struct _tds__DeleteUsersResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteUsersResponse(soap, tag ? tag : "tds:DeleteUsersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_get__tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUsername = 0;
	a->Username = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteUsers(struct soap *soap, const struct _tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Username)
	{	int i;
		for (i = 0; i < (int)a->__sizeUsername; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->Username + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsers(struct soap *soap, const char *tag, int id, const struct _tds__DeleteUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsers), type))
		return soap->error;
	if (a->Username)
	{	int i;
		for (i = 0; i < (int)a->__sizeUsername; i++)
			if (soap_out_string(soap, "tds:Username", -1, (char*const*)(a->Username + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_in__tds__DeleteUsers(struct soap *soap, const char *tag, struct _tds__DeleteUsers *a, const char *type)
{
	struct soap_blist *soap_blist_Username = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__DeleteUsers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteUsers(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Username", 1, NULL))
			{	if (a->Username == NULL)
				{	if (soap_blist_Username == NULL)
						soap_blist_Username = soap_alloc_block(soap);
					a->Username = (char **)soap_push_block_max(soap, soap_blist_Username, sizeof(char *));
					if (a->Username == NULL)
						return NULL;
					*a->Username = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tds:Username", (char**)a->Username, "xsd:string"))
				{	a->__sizeUsername++;
					a->Username = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Username)
			soap_pop_block(soap, soap_blist_Username);
		if (a->__sizeUsername)
		{	a->Username = (char **)soap_save_block(soap, soap_blist_Username, NULL, 1);
		}
		else
		{	a->Username = NULL;
			if (soap_blist_Username)
				soap_end_block(soap, soap_blist_Username);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUsername < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__DeleteUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsers, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_new__tds__DeleteUsers(struct soap *soap, int n)
{
	struct _tds__DeleteUsers *p;
	struct _tds__DeleteUsers *a = (struct _tds__DeleteUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteUsers));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteUsers(struct soap *soap, const struct _tds__DeleteUsers *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteUsers(soap, tag ? tag : "tds:DeleteUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_get__tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateUsersResponse(struct soap *soap, const struct _tds__CreateUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_in__tds__CreateUsersResponse(struct soap *soap, const char *tag, struct _tds__CreateUsersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__CreateUsersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateUsersResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsersResponse, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_new__tds__CreateUsersResponse(struct soap *soap, int n)
{
	struct _tds__CreateUsersResponse *p;
	struct _tds__CreateUsersResponse *a = (struct _tds__CreateUsersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateUsersResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateUsersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateUsersResponse(struct soap *soap, const struct _tds__CreateUsersResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateUsersResponse(soap, tag ? tag : "tds:CreateUsersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_get__tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateUsers(struct soap *soap, const struct _tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsers(struct soap *soap, const char *tag, int id, const struct _tds__CreateUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsers), type))
		return soap->error;
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_in__tds__CreateUsers(struct soap *soap, const char *tag, struct _tds__CreateUsers *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__CreateUsers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateUsers(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->User == NULL)
				{	if (soap_blist_User == NULL)
						soap_blist_User = soap_alloc_block(soap);
					a->User = (struct tt__User *)soap_push_block_max(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
		{	a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		}
		else
		{	a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUser < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__CreateUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsers, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_new__tds__CreateUsers(struct soap *soap, int n)
{
	struct _tds__CreateUsers *p;
	struct _tds__CreateUsers *a = (struct _tds__CreateUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateUsers));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateUsers(struct soap *soap, const struct _tds__CreateUsers *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateUsers(soap, tag ? tag : "tds:CreateUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_get__tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__User(struct soap *soap, struct tt__User *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_tt__UserLevel(soap, &a->UserLevel);
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__User(struct soap *soap, const struct tt__User *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Username);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_serialize_PointerTott__UserExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__User(struct soap *soap, const char *tag, int id, const struct tt__User *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__User), type))
		return soap->error;
	if (!a->Username)
	{	if (soap_element_empty(soap, "tt:Username", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Username", -1, (char*const*)&a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Password", -1, (char*const*)&a->Password, ""))
		return soap->error;
	if (soap_out_tt__UserLevel(soap, "tt:UserLevel", -1, &a->UserLevel, ""))
		return soap->error;
	if (soap_out_PointerTott__UserExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_in_tt__User(struct soap *soap, const char *tag, struct tt__User *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_UserLevel = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__User*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__User, sizeof(struct tt__User), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__User(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Username", (char**)&a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			}
			if (soap_flag_UserLevel && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__UserLevel(soap, "tt:UserLevel", &a->UserLevel, "tt:UserLevel"))
				{	soap_flag_UserLevel--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__UserExtension(soap, "tt:Extension", &a->Extension, "tt:UserExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Username || soap_flag_UserLevel > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__User, SOAP_TYPE_tt__User, sizeof(struct tt__User), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_new_tt__User(struct soap *soap, int n)
{
	struct tt__User *p;
	struct tt__User *a = (struct tt__User*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__User));
	for (p = a; p && n--; p++)
		soap_default_tt__User(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__User(struct soap *soap, const struct tt__User *a, const char *tag, const char *type)
{
	if (soap_out_tt__User(soap, tag ? tag : "tt:User", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_get_tt__User(struct soap *soap, struct tt__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetUsersResponse(struct soap *soap, const struct _tds__GetUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsersResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeUser");
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_in__tds__GetUsersResponse(struct soap *soap, const char *tag, struct _tds__GetUsersResponse *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetUsersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetUsersResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->User == NULL)
				{	if (soap_blist_User == NULL)
						soap_blist_User = soap_alloc_block(soap);
					a->User = (struct tt__User *)soap_push_block_max(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeUser");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
		{	a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		}
		else
		{	a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsersResponse, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_new__tds__GetUsersResponse(struct soap *soap, int n)
{
	struct _tds__GetUsersResponse *p;
	struct _tds__GetUsersResponse *a = (struct _tds__GetUsersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetUsersResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetUsersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetUsersResponse(struct soap *soap, const struct _tds__GetUsersResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetUsersResponse(soap, tag ? tag : "tds:GetUsersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_get__tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetUsers(struct soap *soap, struct _tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetUsers(struct soap *soap, const struct _tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsers(struct soap *soap, const char *tag, int id, const struct _tds__GetUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsers), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_in__tds__GetUsers(struct soap *soap, const char *tag, struct _tds__GetUsers *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetUsers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetUsers(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsers, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_new__tds__GetUsers(struct soap *soap, int n)
{
	struct _tds__GetUsers *p;
	struct _tds__GetUsers *a = (struct _tds__GetUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetUsers));
	for (p = a; p && n--; p++)
		soap_default__tds__GetUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetUsers(struct soap *soap, const struct _tds__GetUsers *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetUsers(soap, tag ? tag : "tds:GetUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_get__tds__GetUsers(struct soap *soap, struct _tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteUserResponse(struct soap *soap, const struct _tds__SetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_in__tds__SetRemoteUserResponse(struct soap *soap, const char *tag, struct _tds__SetRemoteUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetRemoteUserResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(struct _tds__SetRemoteUserResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteUserResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUserResponse, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(struct _tds__SetRemoteUserResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_new__tds__SetRemoteUserResponse(struct soap *soap, int n)
{
	struct _tds__SetRemoteUserResponse *p;
	struct _tds__SetRemoteUserResponse *a = (struct _tds__SetRemoteUserResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRemoteUserResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRemoteUserResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteUserResponse(struct soap *soap, const struct _tds__SetRemoteUserResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRemoteUserResponse(soap, tag ? tag : "tds:SetRemoteUserResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_get__tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteUser(struct soap *soap, const struct _tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RemoteUser(soap, &a->RemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteUser(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteUser), type))
		return soap->error;
	if (soap_out_PointerTott__RemoteUser(soap, "tds:RemoteUser", -1, &a->RemoteUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteUser * SOAP_FMAC4 soap_in__tds__SetRemoteUser(struct soap *soap, const char *tag, struct _tds__SetRemoteUser *a, const char *type)
{
	size_t soap_flag_RemoteUser = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetRemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUser, sizeof(struct _tds__SetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RemoteUser(soap, "tds:RemoteUser", &a->RemoteUser, "tt:RemoteUser"))
				{	soap_flag_RemoteUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUser, SOAP_TYPE__tds__SetRemoteUser, sizeof(struct _tds__SetRemoteUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRemoteUser * SOAP_FMAC4 soap_new__tds__SetRemoteUser(struct soap *soap, int n)
{
	struct _tds__SetRemoteUser *p;
	struct _tds__SetRemoteUser *a = (struct _tds__SetRemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRemoteUser));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteUser(struct soap *soap, const struct _tds__SetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRemoteUser(soap, tag ? tag : "tds:SetRemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteUser * SOAP_FMAC4 soap_get__tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RemoteUser(struct soap *soap, struct tt__RemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_xsd__boolean(soap, &a->UseDerivedPassword);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RemoteUser(struct soap *soap, const struct tt__RemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Username);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_embedded(soap, &a->UseDerivedPassword, SOAP_TYPE_xsd__boolean);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RemoteUser(struct soap *soap, const char *tag, int id, const struct tt__RemoteUser *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RemoteUser), type))
		return soap->error;
	if (!a->Username)
	{	if (soap_element_empty(soap, "tt:Username", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Username", -1, (char*const*)&a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Password", -1, (char*const*)&a->Password, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:UseDerivedPassword", -1, &a->UseDerivedPassword, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RemoteUser * SOAP_FMAC4 soap_in_tt__RemoteUser(struct soap *soap, const char *tag, struct tt__RemoteUser *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_UseDerivedPassword = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__RemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RemoteUser(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Username", (char**)&a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			}
			if (soap_flag_UseDerivedPassword && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:UseDerivedPassword", &a->UseDerivedPassword, "xsd:boolean"))
				{	soap_flag_UseDerivedPassword--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Username || soap_flag_UseDerivedPassword > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RemoteUser, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RemoteUser * SOAP_FMAC4 soap_new_tt__RemoteUser(struct soap *soap, int n)
{
	struct tt__RemoteUser *p;
	struct tt__RemoteUser *a = (struct tt__RemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RemoteUser));
	for (p = a; p && n--; p++)
		soap_default_tt__RemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RemoteUser(struct soap *soap, const struct tt__RemoteUser *a, const char *tag, const char *type)
{
	if (soap_out_tt__RemoteUser(soap, tag ? tag : "tt:RemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RemoteUser * SOAP_FMAC4 soap_get_tt__RemoteUser(struct soap *soap, struct tt__RemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteUserResponse(struct soap *soap, const struct _tds__GetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RemoteUser(soap, &a->RemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteUserResponse), type))
		return soap->error;
	if (a->RemoteUser)
		soap_element_result(soap, "tds:RemoteUser");
	if (soap_out_PointerTott__RemoteUser(soap, "tds:RemoteUser", -1, &a->RemoteUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_in__tds__GetRemoteUserResponse(struct soap *soap, const char *tag, struct _tds__GetRemoteUserResponse *a, const char *type)
{
	size_t soap_flag_RemoteUser = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetRemoteUserResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(struct _tds__GetRemoteUserResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteUserResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RemoteUser(soap, "tds:RemoteUser", &a->RemoteUser, "tt:RemoteUser"))
				{	soap_flag_RemoteUser--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RemoteUser");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUserResponse, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(struct _tds__GetRemoteUserResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_new__tds__GetRemoteUserResponse(struct soap *soap, int n)
{
	struct _tds__GetRemoteUserResponse *p;
	struct _tds__GetRemoteUserResponse *a = (struct _tds__GetRemoteUserResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRemoteUserResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRemoteUserResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteUserResponse(struct soap *soap, const struct _tds__GetRemoteUserResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRemoteUserResponse(soap, tag ? tag : "tds:GetRemoteUserResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_get__tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteUser(struct soap *soap, const struct _tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteUser(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteUser), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteUser * SOAP_FMAC4 soap_in__tds__GetRemoteUser(struct soap *soap, const char *tag, struct _tds__GetRemoteUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetRemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUser, sizeof(struct _tds__GetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUser, SOAP_TYPE__tds__GetRemoteUser, sizeof(struct _tds__GetRemoteUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRemoteUser * SOAP_FMAC4 soap_new__tds__GetRemoteUser(struct soap *soap, int n)
{
	struct _tds__GetRemoteUser *p;
	struct _tds__GetRemoteUser *a = (struct _tds__GetRemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRemoteUser));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteUser(struct soap *soap, const struct _tds__GetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRemoteUser(soap, tag ? tag : "tds:GetRemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteUser * SOAP_FMAC4 soap_get__tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->GUID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetEndpointReferenceResponse(struct soap *soap, const struct _tds__GetEndpointReferenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->GUID);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetEndpointReferenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse), type))
		return soap->error;
	if (a->GUID)
		soap_element_result(soap, "tds:GUID");
	if (!a->GUID)
	{	if (soap_element_empty(soap, "tds:GUID", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tds:GUID", -1, (char*const*)&a->GUID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_in__tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, struct _tds__GetEndpointReferenceResponse *a, const char *type)
{
	size_t soap_flag_GUID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetEndpointReferenceResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(struct _tds__GetEndpointReferenceResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetEndpointReferenceResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:GUID", (char**)&a->GUID, "xsd:string"))
				{	soap_flag_GUID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tds:GUID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->GUID))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetEndpointReferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReferenceResponse, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(struct _tds__GetEndpointReferenceResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_new__tds__GetEndpointReferenceResponse(struct soap *soap, int n)
{
	struct _tds__GetEndpointReferenceResponse *p;
	struct _tds__GetEndpointReferenceResponse *a = (struct _tds__GetEndpointReferenceResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetEndpointReferenceResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetEndpointReferenceResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetEndpointReferenceResponse(struct soap *soap, const struct _tds__GetEndpointReferenceResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetEndpointReferenceResponse(soap, tag ? tag : "tds:GetEndpointReferenceResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_get__tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetEndpointReferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetEndpointReference(struct soap *soap, const struct _tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetEndpointReference(struct soap *soap, const char *tag, int id, const struct _tds__GetEndpointReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetEndpointReference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetEndpointReference * SOAP_FMAC4 soap_in__tds__GetEndpointReference(struct soap *soap, const char *tag, struct _tds__GetEndpointReference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetEndpointReference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReference, sizeof(struct _tds__GetEndpointReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetEndpointReference(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetEndpointReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReference, SOAP_TYPE__tds__GetEndpointReference, sizeof(struct _tds__GetEndpointReference), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetEndpointReference * SOAP_FMAC4 soap_new__tds__GetEndpointReference(struct soap *soap, int n)
{
	struct _tds__GetEndpointReference *p;
	struct _tds__GetEndpointReference *a = (struct _tds__GetEndpointReference*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetEndpointReference));
	for (p = a; p && n--; p++)
		soap_default__tds__GetEndpointReference(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetEndpointReference(struct soap *soap, const struct _tds__GetEndpointReference *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetEndpointReference(soap, tag ? tag : "tds:GetEndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetEndpointReference * SOAP_FMAC4 soap_get__tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDPAddressesResponse(struct soap *soap, const struct _tds__SetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDPAddressesResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDPAddressesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDPAddressesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_in__tds__SetDPAddressesResponse(struct soap *soap, const char *tag, struct _tds__SetDPAddressesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDPAddressesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(struct _tds__SetDPAddressesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDPAddressesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddressesResponse, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(struct _tds__SetDPAddressesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_new__tds__SetDPAddressesResponse(struct soap *soap, int n)
{
	struct _tds__SetDPAddressesResponse *p;
	struct _tds__SetDPAddressesResponse *a = (struct _tds__SetDPAddressesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDPAddressesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDPAddressesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDPAddressesResponse(struct soap *soap, const struct _tds__SetDPAddressesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDPAddressesResponse(soap, tag ? tag : "tds:SetDPAddressesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_get__tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDPAddress = 0;
	a->DPAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDPAddresses(struct soap *soap, const struct _tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < (int)a->__sizeDPAddress; i++)
		{
			soap_embedded(soap, a->DPAddress + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->DPAddress + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDPAddresses(struct soap *soap, const char *tag, int id, const struct _tds__SetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDPAddresses), type))
		return soap->error;
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < (int)a->__sizeDPAddress; i++)
			if (soap_out_tt__NetworkHost(soap, "tds:DPAddress", -1, a->DPAddress + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDPAddresses * SOAP_FMAC4 soap_in__tds__SetDPAddresses(struct soap *soap, const char *tag, struct _tds__SetDPAddresses *a, const char *type)
{
	struct soap_blist *soap_blist_DPAddress = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDPAddresses*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddresses, sizeof(struct _tds__SetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDPAddresses(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DPAddress", 1, NULL))
			{	if (a->DPAddress == NULL)
				{	if (soap_blist_DPAddress == NULL)
						soap_blist_DPAddress = soap_alloc_block(soap);
					a->DPAddress = (struct tt__NetworkHost *)soap_push_block_max(soap, soap_blist_DPAddress, sizeof(struct tt__NetworkHost));
					if (a->DPAddress == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->DPAddress);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tds:DPAddress", a->DPAddress, "tt:NetworkHost"))
				{	a->__sizeDPAddress++;
					a->DPAddress = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DPAddress)
			soap_pop_block(soap, soap_blist_DPAddress);
		if (a->__sizeDPAddress)
		{	a->DPAddress = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_DPAddress, NULL, 1);
		}
		else
		{	a->DPAddress = NULL;
			if (soap_blist_DPAddress)
				soap_end_block(soap, soap_blist_DPAddress);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddresses, SOAP_TYPE__tds__SetDPAddresses, sizeof(struct _tds__SetDPAddresses), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDPAddresses * SOAP_FMAC4 soap_new__tds__SetDPAddresses(struct soap *soap, int n)
{
	struct _tds__SetDPAddresses *p;
	struct _tds__SetDPAddresses *a = (struct _tds__SetDPAddresses*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDPAddresses));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDPAddresses(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDPAddresses(struct soap *soap, const struct _tds__SetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDPAddresses(soap, tag ? tag : "tds:SetDPAddresses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDPAddresses * SOAP_FMAC4 soap_get__tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkHost(struct soap *soap, struct tt__NetworkHost *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__NetworkHostType(soap, &a->Type);
	soap_default_tt__IPv4Address(soap, &a->IPv4Address);
	soap_default_tt__IPv6Address(soap, &a->IPv6Address);
	soap_default_tt__DNSName(soap, &a->DNSname);
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkHost(struct soap *soap, const struct tt__NetworkHost *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__IPv4Address(soap, (char*const*)&a->IPv4Address);
	soap_serialize_tt__IPv6Address(soap, (char*const*)&a->IPv6Address);
	soap_serialize_tt__DNSName(soap, (char*const*)&a->DNSname);
	soap_serialize_PointerTott__NetworkHostExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHost(struct soap *soap, const char *tag, int id, const struct tt__NetworkHost *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHost), type))
		return soap->error;
	if (soap_out_tt__NetworkHostType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_tt__IPv4Address(soap, "tt:IPv4Address", -1, (char*const*)&a->IPv4Address, ""))
		return soap->error;
	if (soap_out_tt__IPv6Address(soap, "tt:IPv6Address", -1, (char*const*)&a->IPv6Address, ""))
		return soap->error;
	if (soap_out_tt__DNSName(soap, "tt:DNSname", -1, (char*const*)&a->DNSname, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkHostExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_in_tt__NetworkHost(struct soap *soap, const char *tag, struct tt__NetworkHost *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	size_t soap_flag_DNSname = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__NetworkHost*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkHost(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__NetworkHostType(soap, "tt:Type", &a->Type, "tt:NetworkHostType"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_IPv4Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv4Address(soap, "tt:IPv4Address", (char**)&a->IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address--;
					continue;
				}
			}
			if (soap_flag_IPv6Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv6Address(soap, "tt:IPv6Address", (char**)&a->IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address--;
					continue;
				}
			}
			if (soap_flag_DNSname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__DNSName(soap, "tt:DNSname", (char**)&a->DNSname, "tt:DNSName"))
				{	soap_flag_DNSname--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkHostExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkHostExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkHost *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHost, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_new_tt__NetworkHost(struct soap *soap, int n)
{
	struct tt__NetworkHost *p;
	struct tt__NetworkHost *a = (struct tt__NetworkHost*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkHost));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkHost(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHost(struct soap *soap, const struct tt__NetworkHost *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkHost(soap, tag ? tag : "tt:NetworkHost", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_get_tt__NetworkHost(struct soap *soap, struct tt__NetworkHost *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDPAddress = 0;
	a->DPAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDPAddressesResponse(struct soap *soap, const struct _tds__GetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < (int)a->__sizeDPAddress; i++)
		{
			soap_embedded(soap, a->DPAddress + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->DPAddress + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDPAddressesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDPAddressesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDPAddressesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeDPAddress");
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < (int)a->__sizeDPAddress; i++)
			if (soap_out_tt__NetworkHost(soap, "tds:DPAddress", -1, a->DPAddress + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_in__tds__GetDPAddressesResponse(struct soap *soap, const char *tag, struct _tds__GetDPAddressesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_DPAddress = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDPAddressesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(struct _tds__GetDPAddressesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDPAddressesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DPAddress", 1, NULL))
			{	if (a->DPAddress == NULL)
				{	if (soap_blist_DPAddress == NULL)
						soap_blist_DPAddress = soap_alloc_block(soap);
					a->DPAddress = (struct tt__NetworkHost *)soap_push_block_max(soap, soap_blist_DPAddress, sizeof(struct tt__NetworkHost));
					if (a->DPAddress == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->DPAddress);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tds:DPAddress", a->DPAddress, "tt:NetworkHost"))
				{	a->__sizeDPAddress++;
					a->DPAddress = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeDPAddress");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DPAddress)
			soap_pop_block(soap, soap_blist_DPAddress);
		if (a->__sizeDPAddress)
		{	a->DPAddress = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_DPAddress, NULL, 1);
		}
		else
		{	a->DPAddress = NULL;
			if (soap_blist_DPAddress)
				soap_end_block(soap, soap_blist_DPAddress);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddressesResponse, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(struct _tds__GetDPAddressesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_new__tds__GetDPAddressesResponse(struct soap *soap, int n)
{
	struct _tds__GetDPAddressesResponse *p;
	struct _tds__GetDPAddressesResponse *a = (struct _tds__GetDPAddressesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDPAddressesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDPAddressesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDPAddressesResponse(struct soap *soap, const struct _tds__GetDPAddressesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDPAddressesResponse(soap, tag ? tag : "tds:GetDPAddressesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_get__tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDPAddresses(struct soap *soap, const struct _tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDPAddresses(struct soap *soap, const char *tag, int id, const struct _tds__GetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDPAddresses), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDPAddresses * SOAP_FMAC4 soap_in__tds__GetDPAddresses(struct soap *soap, const char *tag, struct _tds__GetDPAddresses *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDPAddresses*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddresses, sizeof(struct _tds__GetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDPAddresses(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddresses, SOAP_TYPE__tds__GetDPAddresses, sizeof(struct _tds__GetDPAddresses), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDPAddresses * SOAP_FMAC4 soap_new__tds__GetDPAddresses(struct soap *soap, int n)
{
	struct _tds__GetDPAddresses *p;
	struct _tds__GetDPAddresses *a = (struct _tds__GetDPAddresses*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDPAddresses));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDPAddresses(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDPAddresses(struct soap *soap, const struct _tds__GetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDPAddresses(soap, tag ? tag : "tds:GetDPAddresses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDPAddresses * SOAP_FMAC4 soap_get__tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__SetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__SetRemoteDiscoveryModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetRemoteDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteDiscoveryModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_new__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, int n)
{
	struct _tds__SetRemoteDiscoveryModeResponse *p;
	struct _tds__SetRemoteDiscoveryModeResponse *a = (struct _tds__SetRemoteDiscoveryModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRemoteDiscoveryModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRemoteDiscoveryModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__SetRemoteDiscoveryModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRemoteDiscoveryModeResponse(soap, tag ? tag : "tds:SetRemoteDiscoveryModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->RemoteDiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteDiscoveryMode(struct soap *soap, const struct _tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode), type))
		return soap->error;
	if (soap_out_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", -1, &a->RemoteDiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_in__tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct _tds__SetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_RemoteDiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetRemoteDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(struct _tds__SetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteDiscoveryMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", &a->RemoteDiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_RemoteDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemoteDiscoveryMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryMode, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(struct _tds__SetRemoteDiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_new__tds__SetRemoteDiscoveryMode(struct soap *soap, int n)
{
	struct _tds__SetRemoteDiscoveryMode *p;
	struct _tds__SetRemoteDiscoveryMode *a = (struct _tds__SetRemoteDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRemoteDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRemoteDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteDiscoveryMode(struct soap *soap, const struct _tds__SetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRemoteDiscoveryMode(soap, tag ? tag : "tds:SetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_get__tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->RemoteDiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__GetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RemoteDiscoveryMode");
	if (soap_out_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", -1, &a->RemoteDiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__GetRemoteDiscoveryModeResponse *a, const char *type)
{
	size_t soap_flag_RemoteDiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetRemoteDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteDiscoveryModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", &a->RemoteDiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_RemoteDiscoveryMode--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RemoteDiscoveryMode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemoteDiscoveryMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_new__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, int n)
{
	struct _tds__GetRemoteDiscoveryModeResponse *p;
	struct _tds__GetRemoteDiscoveryModeResponse *a = (struct _tds__GetRemoteDiscoveryModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRemoteDiscoveryModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRemoteDiscoveryModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__GetRemoteDiscoveryModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRemoteDiscoveryModeResponse(soap, tag ? tag : "tds:GetRemoteDiscoveryModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteDiscoveryMode(struct soap *soap, const struct _tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_in__tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct _tds__GetRemoteDiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetRemoteDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(struct _tds__GetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteDiscoveryMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryMode, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(struct _tds__GetRemoteDiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_new__tds__GetRemoteDiscoveryMode(struct soap *soap, int n)
{
	struct _tds__GetRemoteDiscoveryMode *p;
	struct _tds__GetRemoteDiscoveryMode *a = (struct _tds__GetRemoteDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRemoteDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRemoteDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteDiscoveryMode(struct soap *soap, const struct _tds__GetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRemoteDiscoveryMode(soap, tag ? tag : "tds:GetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_get__tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDiscoveryModeResponse(struct soap *soap, const struct _tds__SetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__SetDiscoveryModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(struct _tds__SetDiscoveryModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDiscoveryModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryModeResponse, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(struct _tds__SetDiscoveryModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_new__tds__SetDiscoveryModeResponse(struct soap *soap, int n)
{
	struct _tds__SetDiscoveryModeResponse *p;
	struct _tds__SetDiscoveryModeResponse *a = (struct _tds__SetDiscoveryModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDiscoveryModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDiscoveryModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDiscoveryModeResponse(struct soap *soap, const struct _tds__SetDiscoveryModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDiscoveryModeResponse(soap, tag ? tag : "tds:SetDiscoveryModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->DiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDiscoveryMode(struct soap *soap, const struct _tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__SetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDiscoveryMode), type))
		return soap->error;
	if (soap_out_tt__DiscoveryMode(soap, "tds:DiscoveryMode", -1, &a->DiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode * SOAP_FMAC4 soap_in__tds__SetDiscoveryMode(struct soap *soap, const char *tag, struct _tds__SetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_DiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(struct _tds__SetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDiscoveryMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:DiscoveryMode", &a->DiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_DiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryMode, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(struct _tds__SetDiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode * SOAP_FMAC4 soap_new__tds__SetDiscoveryMode(struct soap *soap, int n)
{
	struct _tds__SetDiscoveryMode *p;
	struct _tds__SetDiscoveryMode *a = (struct _tds__SetDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDiscoveryMode(struct soap *soap, const struct _tds__SetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDiscoveryMode(soap, tag ? tag : "tds:SetDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode * SOAP_FMAC4 soap_get__tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->DiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDiscoveryModeResponse(struct soap *soap, const struct _tds__GetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:DiscoveryMode");
	if (soap_out_tt__DiscoveryMode(soap, "tds:DiscoveryMode", -1, &a->DiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__GetDiscoveryModeResponse *a, const char *type)
{
	size_t soap_flag_DiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(struct _tds__GetDiscoveryModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDiscoveryModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:DiscoveryMode", &a->DiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_DiscoveryMode--;
					continue;
				}
			}
			soap_check_result(soap, "tds:DiscoveryMode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryModeResponse, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(struct _tds__GetDiscoveryModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_new__tds__GetDiscoveryModeResponse(struct soap *soap, int n)
{
	struct _tds__GetDiscoveryModeResponse *p;
	struct _tds__GetDiscoveryModeResponse *a = (struct _tds__GetDiscoveryModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDiscoveryModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDiscoveryModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDiscoveryModeResponse(struct soap *soap, const struct _tds__GetDiscoveryModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDiscoveryModeResponse(soap, tag ? tag : "tds:GetDiscoveryModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDiscoveryMode(struct soap *soap, const struct _tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__GetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDiscoveryMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode * SOAP_FMAC4 soap_in__tds__GetDiscoveryMode(struct soap *soap, const char *tag, struct _tds__GetDiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(struct _tds__GetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDiscoveryMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryMode, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(struct _tds__GetDiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode * SOAP_FMAC4 soap_new__tds__GetDiscoveryMode(struct soap *soap, int n)
{
	struct _tds__GetDiscoveryMode *p;
	struct _tds__GetDiscoveryMode *a = (struct _tds__GetDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDiscoveryMode(struct soap *soap, const struct _tds__GetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDiscoveryMode(soap, tag ? tag : "tds:GetDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode * SOAP_FMAC4 soap_get__tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopeItem = 0;
	a->ScopeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveScopesResponse(struct soap *soap, const struct _tds__RemoveScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ScopeItem + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__RemoveScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveScopesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeScopeItem");
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
			if (soap_out_string(soap, "tds:ScopeItem", -1, (char*const*)(a->ScopeItem + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse * SOAP_FMAC4 soap_in__tds__RemoveScopesResponse(struct soap *soap, const char *tag, struct _tds__RemoveScopesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_ScopeItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__RemoveScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(struct _tds__RemoveScopesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RemoveScopesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
			{	if (a->ScopeItem == NULL)
				{	if (soap_blist_ScopeItem == NULL)
						soap_blist_ScopeItem = soap_alloc_block(soap);
					a->ScopeItem = (char **)soap_push_block_max(soap, soap_blist_ScopeItem, sizeof(char *));
					if (a->ScopeItem == NULL)
						return NULL;
					*a->ScopeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tds:ScopeItem", (char**)a->ScopeItem, "xsd:anyURI"))
				{	a->__sizeScopeItem++;
					a->ScopeItem = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeScopeItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScopeItem)
			soap_pop_block(soap, soap_blist_ScopeItem);
		if (a->__sizeScopeItem)
		{	a->ScopeItem = (char **)soap_save_block(soap, soap_blist_ScopeItem, NULL, 1);
		}
		else
		{	a->ScopeItem = NULL;
			if (soap_blist_ScopeItem)
				soap_end_block(soap, soap_blist_ScopeItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopesResponse, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(struct _tds__RemoveScopesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse * SOAP_FMAC4 soap_new__tds__RemoveScopesResponse(struct soap *soap, int n)
{
	struct _tds__RemoveScopesResponse *p;
	struct _tds__RemoveScopesResponse *a = (struct _tds__RemoveScopesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__RemoveScopesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__RemoveScopesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveScopesResponse(struct soap *soap, const struct _tds__RemoveScopesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__RemoveScopesResponse(soap, tag ? tag : "tds:RemoveScopesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse * SOAP_FMAC4 soap_get__tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopeItem = 0;
	a->ScopeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveScopes(struct soap *soap, const struct _tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ScopeItem + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveScopes(struct soap *soap, const char *tag, int id, const struct _tds__RemoveScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveScopes), type))
		return soap->error;
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
			if (soap_out_string(soap, "tds:ScopeItem", -1, (char*const*)(a->ScopeItem + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveScopes * SOAP_FMAC4 soap_in__tds__RemoveScopes(struct soap *soap, const char *tag, struct _tds__RemoveScopes *a, const char *type)
{
	struct soap_blist *soap_blist_ScopeItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__RemoveScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopes, sizeof(struct _tds__RemoveScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RemoveScopes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
			{	if (a->ScopeItem == NULL)
				{	if (soap_blist_ScopeItem == NULL)
						soap_blist_ScopeItem = soap_alloc_block(soap);
					a->ScopeItem = (char **)soap_push_block_max(soap, soap_blist_ScopeItem, sizeof(char *));
					if (a->ScopeItem == NULL)
						return NULL;
					*a->ScopeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tds:ScopeItem", (char**)a->ScopeItem, "xsd:anyURI"))
				{	a->__sizeScopeItem++;
					a->ScopeItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScopeItem)
			soap_pop_block(soap, soap_blist_ScopeItem);
		if (a->__sizeScopeItem)
		{	a->ScopeItem = (char **)soap_save_block(soap, soap_blist_ScopeItem, NULL, 1);
		}
		else
		{	a->ScopeItem = NULL;
			if (soap_blist_ScopeItem)
				soap_end_block(soap, soap_blist_ScopeItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopeItem < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__RemoveScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopes, SOAP_TYPE__tds__RemoveScopes, sizeof(struct _tds__RemoveScopes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__RemoveScopes * SOAP_FMAC4 soap_new__tds__RemoveScopes(struct soap *soap, int n)
{
	struct _tds__RemoveScopes *p;
	struct _tds__RemoveScopes *a = (struct _tds__RemoveScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__RemoveScopes));
	for (p = a; p && n--; p++)
		soap_default__tds__RemoveScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveScopes(struct soap *soap, const struct _tds__RemoveScopes *a, const char *tag, const char *type)
{
	if (soap_out__tds__RemoveScopes(soap, tag ? tag : "tds:RemoveScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveScopes * SOAP_FMAC4 soap_get__tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddScopesResponse(struct soap *soap, const struct _tds__AddScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__AddScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddScopesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddScopesResponse * SOAP_FMAC4 soap_in__tds__AddScopesResponse(struct soap *soap, const char *tag, struct _tds__AddScopesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__AddScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopesResponse, sizeof(struct _tds__AddScopesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__AddScopesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__AddScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopesResponse, SOAP_TYPE__tds__AddScopesResponse, sizeof(struct _tds__AddScopesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__AddScopesResponse * SOAP_FMAC4 soap_new__tds__AddScopesResponse(struct soap *soap, int n)
{
	struct _tds__AddScopesResponse *p;
	struct _tds__AddScopesResponse *a = (struct _tds__AddScopesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__AddScopesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__AddScopesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddScopesResponse(struct soap *soap, const struct _tds__AddScopesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__AddScopesResponse(soap, tag ? tag : "tds:AddScopesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddScopesResponse * SOAP_FMAC4 soap_get__tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddScopes(struct soap *soap, struct _tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopeItem = 0;
	a->ScopeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddScopes(struct soap *soap, const struct _tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ScopeItem + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddScopes(struct soap *soap, const char *tag, int id, const struct _tds__AddScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddScopes), type))
		return soap->error;
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
			if (soap_out_string(soap, "tds:ScopeItem", -1, (char*const*)(a->ScopeItem + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddScopes * SOAP_FMAC4 soap_in__tds__AddScopes(struct soap *soap, const char *tag, struct _tds__AddScopes *a, const char *type)
{
	struct soap_blist *soap_blist_ScopeItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__AddScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopes, sizeof(struct _tds__AddScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__AddScopes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
			{	if (a->ScopeItem == NULL)
				{	if (soap_blist_ScopeItem == NULL)
						soap_blist_ScopeItem = soap_alloc_block(soap);
					a->ScopeItem = (char **)soap_push_block_max(soap, soap_blist_ScopeItem, sizeof(char *));
					if (a->ScopeItem == NULL)
						return NULL;
					*a->ScopeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tds:ScopeItem", (char**)a->ScopeItem, "xsd:anyURI"))
				{	a->__sizeScopeItem++;
					a->ScopeItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScopeItem)
			soap_pop_block(soap, soap_blist_ScopeItem);
		if (a->__sizeScopeItem)
		{	a->ScopeItem = (char **)soap_save_block(soap, soap_blist_ScopeItem, NULL, 1);
		}
		else
		{	a->ScopeItem = NULL;
			if (soap_blist_ScopeItem)
				soap_end_block(soap, soap_blist_ScopeItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopeItem < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__AddScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopes, SOAP_TYPE__tds__AddScopes, sizeof(struct _tds__AddScopes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__AddScopes * SOAP_FMAC4 soap_new__tds__AddScopes(struct soap *soap, int n)
{
	struct _tds__AddScopes *p;
	struct _tds__AddScopes *a = (struct _tds__AddScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__AddScopes));
	for (p = a; p && n--; p++)
		soap_default__tds__AddScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddScopes(struct soap *soap, const struct _tds__AddScopes *a, const char *tag, const char *type)
{
	if (soap_out__tds__AddScopes(soap, tag ? tag : "tds:AddScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddScopes * SOAP_FMAC4 soap_get__tds__AddScopes(struct soap *soap, struct _tds__AddScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetScopesResponse(struct soap *soap, const struct _tds__SetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetScopesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetScopesResponse * SOAP_FMAC4 soap_in__tds__SetScopesResponse(struct soap *soap, const char *tag, struct _tds__SetScopesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopesResponse, sizeof(struct _tds__SetScopesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetScopesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopesResponse, SOAP_TYPE__tds__SetScopesResponse, sizeof(struct _tds__SetScopesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetScopesResponse * SOAP_FMAC4 soap_new__tds__SetScopesResponse(struct soap *soap, int n)
{
	struct _tds__SetScopesResponse *p;
	struct _tds__SetScopesResponse *a = (struct _tds__SetScopesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetScopesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetScopesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetScopesResponse(struct soap *soap, const struct _tds__SetScopesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetScopesResponse(soap, tag ? tag : "tds:SetScopesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetScopesResponse * SOAP_FMAC4 soap_get__tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetScopes(struct soap *soap, struct _tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopes = 0;
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetScopes(struct soap *soap, const struct _tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Scopes)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopes; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->Scopes + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetScopes(struct soap *soap, const char *tag, int id, const struct _tds__SetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetScopes), type))
		return soap->error;
	if (a->Scopes)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopes; i++)
			if (soap_out_string(soap, "tds:Scopes", -1, (char*const*)(a->Scopes + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetScopes * SOAP_FMAC4 soap_in__tds__SetScopes(struct soap *soap, const char *tag, struct _tds__SetScopes *a, const char *type)
{
	struct soap_blist *soap_blist_Scopes = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopes, sizeof(struct _tds__SetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetScopes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Scopes", 1, NULL))
			{	if (a->Scopes == NULL)
				{	if (soap_blist_Scopes == NULL)
						soap_blist_Scopes = soap_alloc_block(soap);
					a->Scopes = (char **)soap_push_block_max(soap, soap_blist_Scopes, sizeof(char *));
					if (a->Scopes == NULL)
						return NULL;
					*a->Scopes = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tds:Scopes", (char**)a->Scopes, "xsd:anyURI"))
				{	a->__sizeScopes++;
					a->Scopes = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Scopes)
			soap_pop_block(soap, soap_blist_Scopes);
		if (a->__sizeScopes)
		{	a->Scopes = (char **)soap_save_block(soap, soap_blist_Scopes, NULL, 1);
		}
		else
		{	a->Scopes = NULL;
			if (soap_blist_Scopes)
				soap_end_block(soap, soap_blist_Scopes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopes < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopes, SOAP_TYPE__tds__SetScopes, sizeof(struct _tds__SetScopes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetScopes * SOAP_FMAC4 soap_new__tds__SetScopes(struct soap *soap, int n)
{
	struct _tds__SetScopes *p;
	struct _tds__SetScopes *a = (struct _tds__SetScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetScopes));
	for (p = a; p && n--; p++)
		soap_default__tds__SetScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetScopes(struct soap *soap, const struct _tds__SetScopes *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetScopes(soap, tag ? tag : "tds:SetScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetScopes * SOAP_FMAC4 soap_get__tds__SetScopes(struct soap *soap, struct _tds__SetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Scope(struct soap *soap, struct tt__Scope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ScopeDefinition(soap, &a->ScopeDef);
	soap_default_xsd__anyURI(soap, &a->ScopeItem);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Scope(struct soap *soap, const struct tt__Scope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->ScopeItem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Scope(struct soap *soap, const char *tag, int id, const struct tt__Scope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Scope), type))
		return soap->error;
	if (soap_out_tt__ScopeDefinition(soap, "tt:ScopeDef", -1, &a->ScopeDef, ""))
		return soap->error;
	if (!a->ScopeItem)
	{	if (soap_element_empty(soap, "tt:ScopeItem", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tt:ScopeItem", -1, (char*const*)&a->ScopeItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Scope * SOAP_FMAC4 soap_in_tt__Scope(struct soap *soap, const char *tag, struct tt__Scope *a, const char *type)
{
	size_t soap_flag_ScopeDef = 1;
	size_t soap_flag_ScopeItem = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__Scope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Scope(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScopeDef && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ScopeDefinition(soap, "tt:ScopeDef", &a->ScopeDef, "tt:ScopeDefinition"))
				{	soap_flag_ScopeDef--;
					continue;
				}
			}
			if (soap_flag_ScopeItem && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:ScopeItem", (char**)&a->ScopeItem, "xsd:anyURI"))
				{	soap_flag_ScopeItem--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ScopeDef > 0 || !a->ScopeItem))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Scope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Scope, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Scope * SOAP_FMAC4 soap_new_tt__Scope(struct soap *soap, int n)
{
	struct tt__Scope *p;
	struct tt__Scope *a = (struct tt__Scope*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Scope));
	for (p = a; p && n--; p++)
		soap_default_tt__Scope(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Scope(struct soap *soap, const struct tt__Scope *a, const char *tag, const char *type)
{
	if (soap_out_tt__Scope(soap, tag ? tag : "tt:Scope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Scope * SOAP_FMAC4 soap_get_tt__Scope(struct soap *soap, struct tt__Scope *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopes = 0;
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetScopesResponse(struct soap *soap, const struct _tds__GetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Scopes)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopes; i++)
		{
			soap_embedded(soap, a->Scopes + i, SOAP_TYPE_tt__Scope);
			soap_serialize_tt__Scope(soap, a->Scopes + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetScopesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeScopes");
	if (a->Scopes)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopes; i++)
			if (soap_out_tt__Scope(soap, "tds:Scopes", -1, a->Scopes + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetScopesResponse * SOAP_FMAC4 soap_in__tds__GetScopesResponse(struct soap *soap, const char *tag, struct _tds__GetScopesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Scopes = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopesResponse, sizeof(struct _tds__GetScopesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetScopesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Scopes", 1, NULL))
			{	if (a->Scopes == NULL)
				{	if (soap_blist_Scopes == NULL)
						soap_blist_Scopes = soap_alloc_block(soap);
					a->Scopes = (struct tt__Scope *)soap_push_block_max(soap, soap_blist_Scopes, sizeof(struct tt__Scope));
					if (a->Scopes == NULL)
						return NULL;
					soap_default_tt__Scope(soap, a->Scopes);
				}
				soap_revert(soap);
				if (soap_in_tt__Scope(soap, "tds:Scopes", a->Scopes, "tt:Scope"))
				{	a->__sizeScopes++;
					a->Scopes = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeScopes");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Scopes)
			soap_pop_block(soap, soap_blist_Scopes);
		if (a->__sizeScopes)
		{	a->Scopes = (struct tt__Scope *)soap_save_block(soap, soap_blist_Scopes, NULL, 1);
		}
		else
		{	a->Scopes = NULL;
			if (soap_blist_Scopes)
				soap_end_block(soap, soap_blist_Scopes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopes < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopesResponse, SOAP_TYPE__tds__GetScopesResponse, sizeof(struct _tds__GetScopesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetScopesResponse * SOAP_FMAC4 soap_new__tds__GetScopesResponse(struct soap *soap, int n)
{
	struct _tds__GetScopesResponse *p;
	struct _tds__GetScopesResponse *a = (struct _tds__GetScopesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetScopesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetScopesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetScopesResponse(struct soap *soap, const struct _tds__GetScopesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetScopesResponse(soap, tag ? tag : "tds:GetScopesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetScopesResponse * SOAP_FMAC4 soap_get__tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetScopes(struct soap *soap, struct _tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetScopes(struct soap *soap, const struct _tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetScopes(struct soap *soap, const char *tag, int id, const struct _tds__GetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetScopes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetScopes * SOAP_FMAC4 soap_in__tds__GetScopes(struct soap *soap, const char *tag, struct _tds__GetScopes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopes, sizeof(struct _tds__GetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetScopes(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopes, SOAP_TYPE__tds__GetScopes, sizeof(struct _tds__GetScopes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetScopes * SOAP_FMAC4 soap_new__tds__GetScopes(struct soap *soap, int n)
{
	struct _tds__GetScopes *p;
	struct _tds__GetScopes *a = (struct _tds__GetScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetScopes));
	for (p = a; p && n--; p++)
		soap_default__tds__GetScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetScopes(struct soap *soap, const struct _tds__GetScopes *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetScopes(soap, tag ? tag : "tds:GetScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetScopes * SOAP_FMAC4 soap_get__tds__GetScopes(struct soap *soap, struct _tds__GetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemLog(struct soap *soap, struct tt__SystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Binary = NULL;
	soap_default_string(soap, &a->String);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemLog(struct soap *soap, const struct tt__SystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &a->Binary);
	soap_serialize_string(soap, (char*const*)&a->String);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLog(struct soap *soap, const char *tag, int id, const struct tt__SystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLog), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->Binary, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:String", -1, (char*const*)&a->String, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemLog * SOAP_FMAC4 soap_in_tt__SystemLog(struct soap *soap, const char *tag, struct tt__SystemLog *a, const char *type)
{
	size_t soap_flag_Binary = 1;
	size_t soap_flag_String = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SystemLog*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemLog(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->Binary, "tt:AttachmentData"))
				{	soap_flag_Binary--;
					continue;
				}
			}
			if (soap_flag_String && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:String", (char**)&a->String, "xsd:string"))
				{	soap_flag_String--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLog, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemLog * SOAP_FMAC4 soap_new_tt__SystemLog(struct soap *soap, int n)
{
	struct tt__SystemLog *p;
	struct tt__SystemLog *a = (struct tt__SystemLog*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemLog));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemLog(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLog(struct soap *soap, const struct tt__SystemLog *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemLog(soap, tag ? tag : "tt:SystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLog * SOAP_FMAC4 soap_get_tt__SystemLog(struct soap *soap, struct tt__SystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SystemLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemLogResponse(struct soap *soap, const struct _tds__GetSystemLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemLog(soap, &a->SystemLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemLogResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemLogResponse), type))
		return soap->error;
	if (a->SystemLog)
		soap_element_result(soap, "tds:SystemLog");
	if (!a->SystemLog)
	{	if (soap_element_empty(soap, "tds:SystemLog", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SystemLog(soap, "tds:SystemLog", -1, &a->SystemLog, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse * SOAP_FMAC4 soap_in__tds__GetSystemLogResponse(struct soap *soap, const char *tag, struct _tds__GetSystemLogResponse *a, const char *type)
{
	size_t soap_flag_SystemLog = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemLogResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(struct _tds__GetSystemLogResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemLogResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLog && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemLog(soap, "tds:SystemLog", &a->SystemLog, "tt:SystemLog"))
				{	soap_flag_SystemLog--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SystemLog");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SystemLog))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLogResponse, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(struct _tds__GetSystemLogResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse * SOAP_FMAC4 soap_new__tds__GetSystemLogResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemLogResponse *p;
	struct _tds__GetSystemLogResponse *a = (struct _tds__GetSystemLogResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemLogResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemLogResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemLogResponse(struct soap *soap, const struct _tds__GetSystemLogResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemLogResponse(soap, tag ? tag : "tds:GetSystemLogResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse * SOAP_FMAC4 soap_get__tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SystemLogType(soap, &a->LogType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemLog(struct soap *soap, const struct _tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemLog(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemLog), type))
		return soap->error;
	if (soap_out_tt__SystemLogType(soap, "tds:LogType", -1, &a->LogType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemLog * SOAP_FMAC4 soap_in__tds__GetSystemLog(struct soap *soap, const char *tag, struct _tds__GetSystemLog *a, const char *type)
{
	size_t soap_flag_LogType = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemLog*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemLog(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LogType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SystemLogType(soap, "tds:LogType", &a->LogType, "tt:SystemLogType"))
				{	soap_flag_LogType--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LogType > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLog, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemLog * SOAP_FMAC4 soap_new__tds__GetSystemLog(struct soap *soap, int n)
{
	struct _tds__GetSystemLog *p;
	struct _tds__GetSystemLog *a = (struct _tds__GetSystemLog*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemLog));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemLog(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemLog(struct soap *soap, const struct _tds__GetSystemLog *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemLog(soap, tag ? tag : "tds:GetSystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLog * SOAP_FMAC4 soap_get__tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportInformation(struct soap *soap, struct tt__SupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Binary = NULL;
	soap_default_string(soap, &a->String);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportInformation(struct soap *soap, const struct tt__SupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &a->Binary);
	soap_serialize_string(soap, (char*const*)&a->String);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportInformation(struct soap *soap, const char *tag, int id, const struct tt__SupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportInformation), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->Binary, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:String", -1, (char*const*)&a->String, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportInformation * SOAP_FMAC4 soap_in_tt__SupportInformation(struct soap *soap, const char *tag, struct tt__SupportInformation *a, const char *type)
{
	size_t soap_flag_Binary = 1;
	size_t soap_flag_String = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SupportInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->Binary, "tt:AttachmentData"))
				{	soap_flag_Binary--;
					continue;
				}
			}
			if (soap_flag_String && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:String", (char**)&a->String, "xsd:string"))
				{	soap_flag_String--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportInformation, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SupportInformation * SOAP_FMAC4 soap_new_tt__SupportInformation(struct soap *soap, int n)
{
	struct tt__SupportInformation *p;
	struct tt__SupportInformation *a = (struct tt__SupportInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SupportInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__SupportInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportInformation(struct soap *soap, const struct tt__SupportInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__SupportInformation(soap, tag ? tag : "tt:SupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportInformation * SOAP_FMAC4 soap_get_tt__SupportInformation(struct soap *soap, struct tt__SupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SupportInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemSupportInformationResponse(struct soap *soap, const struct _tds__GetSystemSupportInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SupportInformation(soap, &a->SupportInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemSupportInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse), type))
		return soap->error;
	if (a->SupportInformation)
		soap_element_result(soap, "tds:SupportInformation");
	if (!a->SupportInformation)
	{	if (soap_element_empty(soap, "tds:SupportInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SupportInformation(soap, "tds:SupportInformation", -1, &a->SupportInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_in__tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, struct _tds__GetSystemSupportInformationResponse *a, const char *type)
{
	size_t soap_flag_SupportInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemSupportInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(struct _tds__GetSystemSupportInformationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemSupportInformationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SupportInformation(soap, "tds:SupportInformation", &a->SupportInformation, "tt:SupportInformation"))
				{	soap_flag_SupportInformation--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SupportInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SupportInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemSupportInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformationResponse, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(struct _tds__GetSystemSupportInformationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_new__tds__GetSystemSupportInformationResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemSupportInformationResponse *p;
	struct _tds__GetSystemSupportInformationResponse *a = (struct _tds__GetSystemSupportInformationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemSupportInformationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemSupportInformationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemSupportInformationResponse(struct soap *soap, const struct _tds__GetSystemSupportInformationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemSupportInformationResponse(soap, tag ? tag : "tds:GetSystemSupportInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_get__tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemSupportInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemSupportInformation(struct soap *soap, const struct _tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemSupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemSupportInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_in__tds__GetSystemSupportInformation(struct soap *soap, const char *tag, struct _tds__GetSystemSupportInformation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemSupportInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(struct _tds__GetSystemSupportInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemSupportInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemSupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformation, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(struct _tds__GetSystemSupportInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_new__tds__GetSystemSupportInformation(struct soap *soap, int n)
{
	struct _tds__GetSystemSupportInformation *p;
	struct _tds__GetSystemSupportInformation *a = (struct _tds__GetSystemSupportInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemSupportInformation));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemSupportInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemSupportInformation(struct soap *soap, const struct _tds__GetSystemSupportInformation *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemSupportInformation(soap, tag ? tag : "tds:GetSystemSupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_get__tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeBackupFiles = 0;
	a->BackupFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemBackupResponse(struct soap *soap, const struct _tds__GetSystemBackupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeBackupFiles; i++)
		{
			soap_embedded(soap, a->BackupFiles + i, SOAP_TYPE_tt__BackupFile);
			soap_serialize_tt__BackupFile(soap, a->BackupFiles + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemBackupResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemBackupResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemBackupResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeBackupFiles");
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeBackupFiles; i++)
			if (soap_out_tt__BackupFile(soap, "tds:BackupFiles", -1, a->BackupFiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_in__tds__GetSystemBackupResponse(struct soap *soap, const char *tag, struct _tds__GetSystemBackupResponse *a, const char *type)
{
	struct soap_blist *soap_blist_BackupFiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemBackupResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemBackupResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:BackupFiles", 1, NULL))
			{	if (a->BackupFiles == NULL)
				{	if (soap_blist_BackupFiles == NULL)
						soap_blist_BackupFiles = soap_alloc_block(soap);
					a->BackupFiles = (struct tt__BackupFile *)soap_push_block_max(soap, soap_blist_BackupFiles, sizeof(struct tt__BackupFile));
					if (a->BackupFiles == NULL)
						return NULL;
					soap_default_tt__BackupFile(soap, a->BackupFiles);
				}
				soap_revert(soap);
				if (soap_in_tt__BackupFile(soap, "tds:BackupFiles", a->BackupFiles, "tt:BackupFile"))
				{	a->__sizeBackupFiles++;
					a->BackupFiles = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeBackupFiles");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->BackupFiles)
			soap_pop_block(soap, soap_blist_BackupFiles);
		if (a->__sizeBackupFiles)
		{	a->BackupFiles = (struct tt__BackupFile *)soap_save_block(soap, soap_blist_BackupFiles, NULL, 1);
		}
		else
		{	a->BackupFiles = NULL;
			if (soap_blist_BackupFiles)
				soap_end_block(soap, soap_blist_BackupFiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeBackupFiles < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackupResponse, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_new__tds__GetSystemBackupResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemBackupResponse *p;
	struct _tds__GetSystemBackupResponse *a = (struct _tds__GetSystemBackupResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemBackupResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemBackupResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemBackupResponse(struct soap *soap, const struct _tds__GetSystemBackupResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemBackupResponse(soap, tag ? tag : "tds:GetSystemBackupResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_get__tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemBackupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemBackup(struct soap *soap, const struct _tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemBackup(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemBackup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemBackup), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemBackup * SOAP_FMAC4 soap_in__tds__GetSystemBackup(struct soap *soap, const char *tag, struct _tds__GetSystemBackup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemBackup*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemBackup(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackup, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemBackup * SOAP_FMAC4 soap_new__tds__GetSystemBackup(struct soap *soap, int n)
{
	struct _tds__GetSystemBackup *p;
	struct _tds__GetSystemBackup *a = (struct _tds__GetSystemBackup*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemBackup));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemBackup(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemBackup(struct soap *soap, const struct _tds__GetSystemBackup *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemBackup(soap, tag ? tag : "tds:GetSystemBackup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackup * SOAP_FMAC4 soap_get__tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RestoreSystemResponse(struct soap *soap, const struct _tds__RestoreSystemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RestoreSystemResponse(struct soap *soap, const char *tag, int id, const struct _tds__RestoreSystemResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RestoreSystemResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse * SOAP_FMAC4 soap_in__tds__RestoreSystemResponse(struct soap *soap, const char *tag, struct _tds__RestoreSystemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__RestoreSystemResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(struct _tds__RestoreSystemResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RestoreSystemResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__RestoreSystemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RestoreSystemResponse, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(struct _tds__RestoreSystemResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse * SOAP_FMAC4 soap_new__tds__RestoreSystemResponse(struct soap *soap, int n)
{
	struct _tds__RestoreSystemResponse *p;
	struct _tds__RestoreSystemResponse *a = (struct _tds__RestoreSystemResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__RestoreSystemResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__RestoreSystemResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RestoreSystemResponse(struct soap *soap, const struct _tds__RestoreSystemResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__RestoreSystemResponse(soap, tag ? tag : "tds:RestoreSystemResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse * SOAP_FMAC4 soap_get__tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RestoreSystemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BackupFile(struct soap *soap, struct tt__BackupFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	a->Data = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BackupFile(struct soap *soap, const struct tt__BackupFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__AttachmentData(soap, &a->Data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BackupFile(struct soap *soap, const char *tag, int id, const struct tt__BackupFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BackupFile), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (!a->Data)
	{	if (soap_element_empty(soap, "tt:Data", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AttachmentData(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BackupFile * SOAP_FMAC4 soap_in_tt__BackupFile(struct soap *soap, const char *tag, struct tt__BackupFile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Data = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__BackupFile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BackupFile, sizeof(struct tt__BackupFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BackupFile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Name", (char**)&a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Data", &a->Data, "tt:AttachmentData"))
				{	soap_flag_Data--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || !a->Data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__BackupFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BackupFile, SOAP_TYPE_tt__BackupFile, sizeof(struct tt__BackupFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__BackupFile * SOAP_FMAC4 soap_new_tt__BackupFile(struct soap *soap, int n)
{
	struct tt__BackupFile *p;
	struct tt__BackupFile *a = (struct tt__BackupFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__BackupFile));
	for (p = a; p && n--; p++)
		soap_default_tt__BackupFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BackupFile(struct soap *soap, const struct tt__BackupFile *a, const char *tag, const char *type)
{
	if (soap_out_tt__BackupFile(soap, tag ? tag : "tt:BackupFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BackupFile * SOAP_FMAC4 soap_get_tt__BackupFile(struct soap *soap, struct tt__BackupFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeBackupFiles = 0;
	a->BackupFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RestoreSystem(struct soap *soap, const struct _tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeBackupFiles; i++)
		{
			soap_embedded(soap, a->BackupFiles + i, SOAP_TYPE_tt__BackupFile);
			soap_serialize_tt__BackupFile(soap, a->BackupFiles + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RestoreSystem(struct soap *soap, const char *tag, int id, const struct _tds__RestoreSystem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RestoreSystem), type))
		return soap->error;
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeBackupFiles; i++)
			if (soap_out_tt__BackupFile(soap, "tds:BackupFiles", -1, a->BackupFiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RestoreSystem * SOAP_FMAC4 soap_in__tds__RestoreSystem(struct soap *soap, const char *tag, struct _tds__RestoreSystem *a, const char *type)
{
	struct soap_blist *soap_blist_BackupFiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__RestoreSystem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RestoreSystem, sizeof(struct _tds__RestoreSystem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RestoreSystem(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:BackupFiles", 1, NULL))
			{	if (a->BackupFiles == NULL)
				{	if (soap_blist_BackupFiles == NULL)
						soap_blist_BackupFiles = soap_alloc_block(soap);
					a->BackupFiles = (struct tt__BackupFile *)soap_push_block_max(soap, soap_blist_BackupFiles, sizeof(struct tt__BackupFile));
					if (a->BackupFiles == NULL)
						return NULL;
					soap_default_tt__BackupFile(soap, a->BackupFiles);
				}
				soap_revert(soap);
				if (soap_in_tt__BackupFile(soap, "tds:BackupFiles", a->BackupFiles, "tt:BackupFile"))
				{	a->__sizeBackupFiles++;
					a->BackupFiles = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->BackupFiles)
			soap_pop_block(soap, soap_blist_BackupFiles);
		if (a->__sizeBackupFiles)
		{	a->BackupFiles = (struct tt__BackupFile *)soap_save_block(soap, soap_blist_BackupFiles, NULL, 1);
		}
		else
		{	a->BackupFiles = NULL;
			if (soap_blist_BackupFiles)
				soap_end_block(soap, soap_blist_BackupFiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeBackupFiles < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__RestoreSystem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RestoreSystem, SOAP_TYPE__tds__RestoreSystem, sizeof(struct _tds__RestoreSystem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__RestoreSystem * SOAP_FMAC4 soap_new__tds__RestoreSystem(struct soap *soap, int n)
{
	struct _tds__RestoreSystem *p;
	struct _tds__RestoreSystem *a = (struct _tds__RestoreSystem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__RestoreSystem));
	for (p = a; p && n--; p++)
		soap_default__tds__RestoreSystem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RestoreSystem(struct soap *soap, const struct _tds__RestoreSystem *a, const char *tag, const char *type)
{
	if (soap_out__tds__RestoreSystem(soap, tag ? tag : "tds:RestoreSystem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RestoreSystem * SOAP_FMAC4 soap_get__tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SystemRebootResponse(struct soap *soap, const struct _tds__SystemRebootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, const struct _tds__SystemRebootResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemRebootResponse), type))
		return soap->error;
	if (a->Message)
		soap_element_result(soap, "tds:Message");
	if (!a->Message)
	{	if (soap_element_empty(soap, "tds:Message", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tds:Message", -1, (char*const*)&a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_in__tds__SystemRebootResponse(struct soap *soap, const char *tag, struct _tds__SystemRebootResponse *a, const char *type)
{
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SystemRebootResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SystemRebootResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:Message", (char**)&a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Message");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Message))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SystemRebootResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemRebootResponse, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_new__tds__SystemRebootResponse(struct soap *soap, int n)
{
	struct _tds__SystemRebootResponse *p;
	struct _tds__SystemRebootResponse *a = (struct _tds__SystemRebootResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SystemRebootResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SystemRebootResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SystemRebootResponse(struct soap *soap, const struct _tds__SystemRebootResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SystemRebootResponse(soap, tag ? tag : "tds:SystemRebootResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_get__tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SystemReboot(struct soap *soap, const struct _tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemReboot(struct soap *soap, const char *tag, int id, const struct _tds__SystemReboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemReboot), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_in__tds__SystemReboot(struct soap *soap, const char *tag, struct _tds__SystemReboot *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SystemReboot*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SystemReboot(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemReboot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemReboot, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_new__tds__SystemReboot(struct soap *soap, int n)
{
	struct _tds__SystemReboot *p;
	struct _tds__SystemReboot *a = (struct _tds__SystemReboot*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SystemReboot));
	for (p = a; p && n--; p++)
		soap_default__tds__SystemReboot(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SystemReboot(struct soap *soap, const struct _tds__SystemReboot *a, const char *tag, const char *type)
{
	if (soap_out__tds__SystemReboot(soap, tag ? tag : "tds:SystemReboot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_get__tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const struct _tds__UpgradeSystemFirmwareResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, int id, const struct _tds__UpgradeSystemFirmwareResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse), type))
		return soap->error;
	if (a->Message)
		soap_element_result(soap, "tds:Message");
	if (soap_out_string(soap, "tds:Message", -1, (char*const*)&a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC4 soap_in__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, struct _tds__UpgradeSystemFirmwareResponse *a, const char *type)
{
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__UpgradeSystemFirmwareResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(struct _tds__UpgradeSystemFirmwareResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__UpgradeSystemFirmwareResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:Message", (char**)&a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Message");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__UpgradeSystemFirmwareResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(struct _tds__UpgradeSystemFirmwareResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC4 soap_new__tds__UpgradeSystemFirmwareResponse(struct soap *soap, int n)
{
	struct _tds__UpgradeSystemFirmwareResponse *p;
	struct _tds__UpgradeSystemFirmwareResponse *a = (struct _tds__UpgradeSystemFirmwareResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__UpgradeSystemFirmwareResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__UpgradeSystemFirmwareResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const struct _tds__UpgradeSystemFirmwareResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__UpgradeSystemFirmwareResponse(soap, tag ? tag : "tds:UpgradeSystemFirmwareResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC4 soap_get__tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UpgradeSystemFirmwareResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AttachmentData(struct soap *soap, struct tt__AttachmentData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__xop__Include(soap, &a->xop__Include);
	soap_default_string(soap, &a->xmime__contentType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AttachmentData(struct soap *soap, const struct tt__AttachmentData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__xop__Include(soap, &a->xop__Include);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AttachmentData(struct soap *soap, const char *tag, int id, const struct tt__AttachmentData *a, const char *type)
{
	if (a->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", soap_string2s(soap, a->xmime__contentType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AttachmentData), type))
		return soap->error;
	if (soap_out__xop__Include(soap, "xop:Include", -1, &a->xop__Include, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AttachmentData * SOAP_FMAC4 soap_in_tt__AttachmentData(struct soap *soap, const char *tag, struct tt__AttachmentData *a, const char *type)
{
	size_t soap_flag_xop__Include = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AttachmentData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AttachmentData, sizeof(struct tt__AttachmentData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AttachmentData(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 1, 0), &a->xmime__contentType))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xop__Include && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__xop__Include(soap, "xop:Include", &a->xop__Include, ""))
				{	soap_flag_xop__Include--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xop__Include > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AttachmentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AttachmentData, SOAP_TYPE_tt__AttachmentData, sizeof(struct tt__AttachmentData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AttachmentData * SOAP_FMAC4 soap_new_tt__AttachmentData(struct soap *soap, int n)
{
	struct tt__AttachmentData *p;
	struct tt__AttachmentData *a = (struct tt__AttachmentData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AttachmentData));
	for (p = a; p && n--; p++)
		soap_default_tt__AttachmentData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AttachmentData(struct soap *soap, const struct tt__AttachmentData *a, const char *tag, const char *type)
{
	if (soap_out_tt__AttachmentData(soap, tag ? tag : "tt:AttachmentData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AttachmentData * SOAP_FMAC4 soap_get_tt__AttachmentData(struct soap *soap, struct tt__AttachmentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Firmware = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__UpgradeSystemFirmware(struct soap *soap, const struct _tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &a->Firmware);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, const struct _tds__UpgradeSystemFirmware *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UpgradeSystemFirmware), type))
		return soap->error;
	if (!a->Firmware)
	{	if (soap_element_empty(soap, "tds:Firmware", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AttachmentData(soap, "tds:Firmware", -1, &a->Firmware, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_in__tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, struct _tds__UpgradeSystemFirmware *a, const char *type)
{
	size_t soap_flag_Firmware = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__UpgradeSystemFirmware*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(struct _tds__UpgradeSystemFirmware), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__UpgradeSystemFirmware(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Firmware && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tds:Firmware", &a->Firmware, "tt:AttachmentData"))
				{	soap_flag_Firmware--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Firmware))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__UpgradeSystemFirmware *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UpgradeSystemFirmware, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(struct _tds__UpgradeSystemFirmware), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_new__tds__UpgradeSystemFirmware(struct soap *soap, int n)
{
	struct _tds__UpgradeSystemFirmware *p;
	struct _tds__UpgradeSystemFirmware *a = (struct _tds__UpgradeSystemFirmware*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__UpgradeSystemFirmware));
	for (p = a; p && n--; p++)
		soap_default__tds__UpgradeSystemFirmware(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__UpgradeSystemFirmware(struct soap *soap, const struct _tds__UpgradeSystemFirmware *a, const char *tag, const char *type)
{
	if (soap_out__tds__UpgradeSystemFirmware(soap, tag ? tag : "tds:UpgradeSystemFirmware", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_get__tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const struct _tds__SetSystemFactoryDefaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemFactoryDefaultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_in__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefaultResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetSystemFactoryDefaultResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemFactoryDefaultResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemFactoryDefaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_new__tds__SetSystemFactoryDefaultResponse(struct soap *soap, int n)
{
	struct _tds__SetSystemFactoryDefaultResponse *p;
	struct _tds__SetSystemFactoryDefaultResponse *a = (struct _tds__SetSystemFactoryDefaultResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetSystemFactoryDefaultResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetSystemFactoryDefaultResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const struct _tds__SetSystemFactoryDefaultResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetSystemFactoryDefaultResponse(soap, tag ? tag : "tds:SetSystemFactoryDefaultResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_get__tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemFactoryDefaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__FactoryDefaultType(soap, &a->FactoryDefault);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemFactoryDefault(struct soap *soap, const struct _tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemFactoryDefault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemFactoryDefault), type))
		return soap->error;
	if (soap_out_tt__FactoryDefaultType(soap, "tds:FactoryDefault", -1, &a->FactoryDefault, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_in__tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefault *a, const char *type)
{
	size_t soap_flag_FactoryDefault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetSystemFactoryDefault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemFactoryDefault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FactoryDefault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__FactoryDefaultType(soap, "tds:FactoryDefault", &a->FactoryDefault, "tt:FactoryDefaultType"))
				{	soap_flag_FactoryDefault--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FactoryDefault > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetSystemFactoryDefault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefault, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_new__tds__SetSystemFactoryDefault(struct soap *soap, int n)
{
	struct _tds__SetSystemFactoryDefault *p;
	struct _tds__SetSystemFactoryDefault *a = (struct _tds__SetSystemFactoryDefault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetSystemFactoryDefault));
	for (p = a; p && n--; p++)
		soap_default__tds__SetSystemFactoryDefault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemFactoryDefault(struct soap *soap, const struct _tds__SetSystemFactoryDefault *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetSystemFactoryDefault(soap, tag ? tag : "tds:SetSystemFactoryDefault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_get__tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SetDateTimeType(soap, &a->DateTimeType);
	soap_default_xsd__boolean(soap, &a->DaylightSavings);
	a->TimeZone = NULL;
	a->UTCDateTime = NULL;
	a->LocalDateTime = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemDateTime(struct soap *soap, const struct tt__SystemDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->DaylightSavings, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__TimeZone(soap, &a->TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &a->UTCDateTime);
	soap_serialize_PointerTott__DateTime(soap, &a->LocalDateTime);
	soap_serialize_PointerTott__SystemDateTimeExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTime(struct soap *soap, const char *tag, int id, const struct tt__SystemDateTime *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tt:DateTimeType", -1, &a->DateTimeType, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:DaylightSavings", -1, &a->DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tt:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:UTCDateTime", -1, &a->UTCDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:LocalDateTime", -1, &a->LocalDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemDateTime * SOAP_FMAC4 soap_in_tt__SystemDateTime(struct soap *soap, const char *tag, struct tt__SystemDateTime *a, const char *type)
{
	size_t soap_flag_DateTimeType = 1;
	size_t soap_flag_DaylightSavings = 1;
	size_t soap_flag_TimeZone = 1;
	size_t soap_flag_UTCDateTime = 1;
	size_t soap_flag_LocalDateTime = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__SystemDateTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemDateTime(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SetDateTimeType(soap, "tt:DateTimeType", &a->DateTimeType, "tt:SetDateTimeType"))
				{	soap_flag_DateTimeType--;
					continue;
				}
			}
			if (soap_flag_DaylightSavings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tt:DaylightSavings", &a->DaylightSavings, "xsd:boolean"))
				{	soap_flag_DaylightSavings--;
					continue;
				}
			}
			if (soap_flag_TimeZone && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TimeZone(soap, "tt:TimeZone", &a->TimeZone, "tt:TimeZone"))
				{	soap_flag_TimeZone--;
					continue;
				}
			}
			if (soap_flag_UTCDateTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTime(soap, "tt:UTCDateTime", &a->UTCDateTime, "tt:DateTime"))
				{	soap_flag_UTCDateTime--;
					continue;
				}
			}
			if (soap_flag_LocalDateTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTime(soap, "tt:LocalDateTime", &a->LocalDateTime, "tt:DateTime"))
				{	soap_flag_LocalDateTime--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", &a->Extension, "tt:SystemDateTimeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType > 0 || soap_flag_DaylightSavings > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SystemDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTime, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemDateTime * SOAP_FMAC4 soap_new_tt__SystemDateTime(struct soap *soap, int n)
{
	struct tt__SystemDateTime *p;
	struct tt__SystemDateTime *a = (struct tt__SystemDateTime*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemDateTime));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemDateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemDateTime(struct soap *soap, const struct tt__SystemDateTime *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemDateTime(soap, tag ? tag : "tt:SystemDateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTime * SOAP_FMAC4 soap_get_tt__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__GetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemDateTime(soap, &a->SystemDateAndTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemDateAndTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse), type))
		return soap->error;
	if (a->SystemDateAndTime)
		soap_element_result(soap, "tds:SystemDateAndTime");
	if (!a->SystemDateAndTime)
	{	if (soap_element_empty(soap, "tds:SystemDateAndTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SystemDateTime(soap, "tds:SystemDateAndTime", -1, &a->SystemDateAndTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_in__tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTimeResponse *a, const char *type)
{
	size_t soap_flag_SystemDateAndTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemDateAndTimeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemDateAndTimeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemDateTime(soap, "tds:SystemDateAndTime", &a->SystemDateAndTime, "tt:SystemDateTime"))
				{	soap_flag_SystemDateAndTime--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SystemDateAndTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SystemDateAndTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_new__tds__GetSystemDateAndTimeResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemDateAndTimeResponse *p;
	struct _tds__GetSystemDateAndTimeResponse *a = (struct _tds__GetSystemDateAndTimeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemDateAndTimeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemDateAndTimeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__GetSystemDateAndTimeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemDateAndTimeResponse(soap, tag ? tag : "tds:GetSystemDateAndTimeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_get__tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemDateAndTime(struct soap *soap, const struct _tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemDateAndTime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_in__tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetSystemDateAndTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemDateAndTime(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTime, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_new__tds__GetSystemDateAndTime(struct soap *soap, int n)
{
	struct _tds__GetSystemDateAndTime *p;
	struct _tds__GetSystemDateAndTime *a = (struct _tds__GetSystemDateAndTime*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemDateAndTime));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemDateAndTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemDateAndTime(struct soap *soap, const struct _tds__GetSystemDateAndTime *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemDateAndTime(soap, tag ? tag : "tds:GetSystemDateAndTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_get__tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__SetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemDateAndTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_in__tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTimeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetSystemDateAndTimeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemDateAndTimeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_new__tds__SetSystemDateAndTimeResponse(struct soap *soap, int n)
{
	struct _tds__SetSystemDateAndTimeResponse *p;
	struct _tds__SetSystemDateAndTimeResponse *a = (struct _tds__SetSystemDateAndTimeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetSystemDateAndTimeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetSystemDateAndTimeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__SetSystemDateAndTimeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetSystemDateAndTimeResponse(soap, tag ? tag : "tds:SetSystemDateAndTimeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_get__tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DateTime(struct soap *soap, struct tt__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Time = NULL;
	a->Date = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DateTime(struct soap *soap, const struct tt__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Time(soap, &a->Time);
	soap_serialize_PointerTott__Date(soap, &a->Date);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTime(struct soap *soap, const char *tag, int id, const struct tt__DateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTime), type))
		return soap->error;
	if (!a->Time)
	{	if (soap_element_empty(soap, "tt:Time", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Time(soap, "tt:Time", -1, &a->Time, ""))
		return soap->error;
	if (!a->Date)
	{	if (soap_element_empty(soap, "tt:Date", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Date(soap, "tt:Date", -1, &a->Date, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DateTime * SOAP_FMAC4 soap_in_tt__DateTime(struct soap *soap, const char *tag, struct tt__DateTime *a, const char *type)
{
	size_t soap_flag_Time = 1;
	size_t soap_flag_Date = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__DateTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DateTime(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Time(soap, "tt:Time", &a->Time, "tt:Time"))
				{	soap_flag_Time--;
					continue;
				}
			}
			if (soap_flag_Date && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Date(soap, "tt:Date", &a->Date, "tt:Date"))
				{	soap_flag_Date--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Time || !a->Date))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTime, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DateTime * SOAP_FMAC4 soap_new_tt__DateTime(struct soap *soap, int n)
{
	struct tt__DateTime *p;
	struct tt__DateTime *a = (struct tt__DateTime*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DateTime));
	for (p = a; p && n--; p++)
		soap_default_tt__DateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DateTime(struct soap *soap, const struct tt__DateTime *a, const char *tag, const char *type)
{
	if (soap_out_tt__DateTime(soap, tag ? tag : "tt:DateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTime * SOAP_FMAC4 soap_get_tt__DateTime(struct soap *soap, struct tt__DateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TimeZone(struct soap *soap, struct tt__TimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->TZ);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TimeZone(struct soap *soap, const struct tt__TimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->TZ);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TimeZone(struct soap *soap, const char *tag, int id, const struct tt__TimeZone *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TimeZone), type))
		return soap->error;
	if (!a->TZ)
	{	if (soap_element_empty(soap, "tt:TZ", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__token(soap, "tt:TZ", -1, (char*const*)&a->TZ, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TimeZone * SOAP_FMAC4 soap_in_tt__TimeZone(struct soap *soap, const char *tag, struct tt__TimeZone *a, const char *type)
{
	size_t soap_flag_TZ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__TimeZone*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TimeZone(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TZ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:TZ", (char**)&a->TZ, "xsd:token"))
				{	soap_flag_TZ--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->TZ))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__TimeZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TimeZone, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TimeZone * SOAP_FMAC4 soap_new_tt__TimeZone(struct soap *soap, int n)
{
	struct tt__TimeZone *p;
	struct tt__TimeZone *a = (struct tt__TimeZone*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TimeZone));
	for (p = a; p && n--; p++)
		soap_default_tt__TimeZone(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TimeZone(struct soap *soap, const struct tt__TimeZone *a, const char *tag, const char *type)
{
	if (soap_out_tt__TimeZone(soap, tag ? tag : "tt:TimeZone", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TimeZone * SOAP_FMAC4 soap_get_tt__TimeZone(struct soap *soap, struct tt__TimeZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SetDateTimeType(soap, &a->DateTimeType);
	soap_default_xsd__boolean(soap, &a->DaylightSavings);
	a->TimeZone = NULL;
	a->UTCDateTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemDateAndTime(struct soap *soap, const struct _tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->DaylightSavings, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__TimeZone(soap, &a->TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &a->UTCDateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemDateAndTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tds:DateTimeType", -1, &a->DateTimeType, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:DaylightSavings", -1, &a->DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tds:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tds:UTCDateTime", -1, &a->UTCDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_in__tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_DateTimeType = 1;
	size_t soap_flag_DaylightSavings = 1;
	size_t soap_flag_TimeZone = 1;
	size_t soap_flag_UTCDateTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__SetSystemDateAndTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemDateAndTime(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SetDateTimeType(soap, "tds:DateTimeType", &a->DateTimeType, "tt:SetDateTimeType"))
				{	soap_flag_DateTimeType--;
					continue;
				}
			}
			if (soap_flag_DaylightSavings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tds:DaylightSavings", &a->DaylightSavings, "xsd:boolean"))
				{	soap_flag_DaylightSavings--;
					continue;
				}
			}
			if (soap_flag_TimeZone && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TimeZone(soap, "tds:TimeZone", &a->TimeZone, "tt:TimeZone"))
				{	soap_flag_TimeZone--;
					continue;
				}
			}
			if (soap_flag_UTCDateTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTime(soap, "tds:UTCDateTime", &a->UTCDateTime, "tt:DateTime"))
				{	soap_flag_UTCDateTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType > 0 || soap_flag_DaylightSavings > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTime, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_new__tds__SetSystemDateAndTime(struct soap *soap, int n)
{
	struct _tds__SetSystemDateAndTime *p;
	struct _tds__SetSystemDateAndTime *a = (struct _tds__SetSystemDateAndTime*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetSystemDateAndTime));
	for (p = a; p && n--; p++)
		soap_default__tds__SetSystemDateAndTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemDateAndTime(struct soap *soap, const struct _tds__SetSystemDateAndTime *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetSystemDateAndTime(soap, tag ? tag : "tds:SetSystemDateAndTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_get__tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Manufacturer);
	soap_default_string(soap, &a->Model);
	soap_default_string(soap, &a->FirmwareVersion);
	soap_default_string(soap, &a->SerialNumber);
	soap_default_string(soap, &a->HardwareId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDeviceInformationResponse(struct soap *soap, const struct _tds__GetDeviceInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Manufacturer);
	soap_serialize_string(soap, (char*const*)&a->Model);
	soap_serialize_string(soap, (char*const*)&a->FirmwareVersion);
	soap_serialize_string(soap, (char*const*)&a->SerialNumber);
	soap_serialize_string(soap, (char*const*)&a->HardwareId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDeviceInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformationResponse), type))
		return soap->error;
	if (a->Manufacturer)
		soap_element_result(soap, "tds:Manufacturer");
	if (!a->Manufacturer)
	{	if (soap_element_empty(soap, "tds:Manufacturer", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tds:Manufacturer", -1, (char*const*)&a->Manufacturer, ""))
		return soap->error;
	if (!a->Model)
	{	if (soap_element_empty(soap, "tds:Model", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tds:Model", -1, (char*const*)&a->Model, ""))
		return soap->error;
	if (!a->FirmwareVersion)
	{	if (soap_element_empty(soap, "tds:FirmwareVersion", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tds:FirmwareVersion", -1, (char*const*)&a->FirmwareVersion, ""))
		return soap->error;
	if (!a->SerialNumber)
	{	if (soap_element_empty(soap, "tds:SerialNumber", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tds:SerialNumber", -1, (char*const*)&a->SerialNumber, ""))
		return soap->error;
	if (!a->HardwareId)
	{	if (soap_element_empty(soap, "tds:HardwareId", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tds:HardwareId", -1, (char*const*)&a->HardwareId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_in__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, struct _tds__GetDeviceInformationResponse *a, const char *type)
{
	size_t soap_flag_Manufacturer = 1;
	size_t soap_flag_Model = 1;
	size_t soap_flag_FirmwareVersion = 1;
	size_t soap_flag_SerialNumber = 1;
	size_t soap_flag_HardwareId = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDeviceInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDeviceInformationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Manufacturer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:Manufacturer", (char**)&a->Manufacturer, "xsd:string"))
				{	soap_flag_Manufacturer--;
					continue;
				}
			}
			if (soap_flag_Model && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:Model", (char**)&a->Model, "xsd:string"))
				{	soap_flag_Model--;
					continue;
				}
			}
			if (soap_flag_FirmwareVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:FirmwareVersion", (char**)&a->FirmwareVersion, "xsd:string"))
				{	soap_flag_FirmwareVersion--;
					continue;
				}
			}
			if (soap_flag_SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:SerialNumber", (char**)&a->SerialNumber, "xsd:string"))
				{	soap_flag_SerialNumber--;
					continue;
				}
			}
			if (soap_flag_HardwareId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:HardwareId", (char**)&a->HardwareId, "xsd:string"))
				{	soap_flag_HardwareId--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Manufacturer");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Manufacturer || !a->Model || !a->FirmwareVersion || !a->SerialNumber || !a->HardwareId))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformationResponse, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_new__tds__GetDeviceInformationResponse(struct soap *soap, int n)
{
	struct _tds__GetDeviceInformationResponse *p;
	struct _tds__GetDeviceInformationResponse *a = (struct _tds__GetDeviceInformationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDeviceInformationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDeviceInformationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDeviceInformationResponse(struct soap *soap, const struct _tds__GetDeviceInformationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDeviceInformationResponse(soap, tag ? tag : "tds:GetDeviceInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_get__tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDeviceInformation(struct soap *soap, const struct _tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const struct _tds__GetDeviceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_in__tds__GetDeviceInformation(struct soap *soap, const char *tag, struct _tds__GetDeviceInformation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetDeviceInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDeviceInformation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformation, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_new__tds__GetDeviceInformation(struct soap *soap, int n)
{
	struct _tds__GetDeviceInformation *p;
	struct _tds__GetDeviceInformation *a = (struct _tds__GetDeviceInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDeviceInformation));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDeviceInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDeviceInformation(struct soap *soap, const struct _tds__GetDeviceInformation *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDeviceInformation(soap, tag ? tag : "tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_get__tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tds__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__DeviceServiceCapabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__DeviceServiceCapabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__DeviceServiceCapabilities(soap, "tds:Capabilities", &a->Capabilities, "tds:DeviceServiceCapabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tds__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tds__GetServiceCapabilitiesResponse *p;
	struct _tds__GetServiceCapabilitiesResponse *a = (struct _tds__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tds__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetServiceCapabilitiesResponse(soap, tag ? tag : "tds:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServiceCapabilities(struct soap *soap, const struct _tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities * SOAP_FMAC4 soap_in__tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilities, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities * SOAP_FMAC4 soap_new__tds__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tds__GetServiceCapabilities *p;
	struct _tds__GetServiceCapabilities *a = (struct _tds__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tds__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServiceCapabilities(struct soap *soap, const struct _tds__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetServiceCapabilities(soap, tag ? tag : "tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities * SOAP_FMAC4 soap_get__tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeService = 0;
	a->Service = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServicesResponse(struct soap *soap, const struct _tds__GetServicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Service)
	{	int i;
		for (i = 0; i < (int)a->__sizeService; i++)
		{
			soap_embedded(soap, a->Service + i, SOAP_TYPE_tds__Service);
			soap_serialize_tds__Service(soap, a->Service + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServicesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetServicesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServicesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeService");
	if (a->Service)
	{	int i;
		for (i = 0; i < (int)a->__sizeService; i++)
			if (soap_out_tds__Service(soap, "tds:Service", -1, a->Service + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServicesResponse * SOAP_FMAC4 soap_in__tds__GetServicesResponse(struct soap *soap, const char *tag, struct _tds__GetServicesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Service = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetServicesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServicesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Service", 1, NULL))
			{	if (a->Service == NULL)
				{	if (soap_blist_Service == NULL)
						soap_blist_Service = soap_alloc_block(soap);
					a->Service = (struct tds__Service *)soap_push_block_max(soap, soap_blist_Service, sizeof(struct tds__Service));
					if (a->Service == NULL)
						return NULL;
					soap_default_tds__Service(soap, a->Service);
				}
				soap_revert(soap);
				if (soap_in_tds__Service(soap, "tds:Service", a->Service, "tds:Service"))
				{	a->__sizeService++;
					a->Service = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeService");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Service)
			soap_pop_block(soap, soap_blist_Service);
		if (a->__sizeService)
		{	a->Service = (struct tds__Service *)soap_save_block(soap, soap_blist_Service, NULL, 1);
		}
		else
		{	a->Service = NULL;
			if (soap_blist_Service)
				soap_end_block(soap, soap_blist_Service);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeService < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetServicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServicesResponse, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetServicesResponse * SOAP_FMAC4 soap_new__tds__GetServicesResponse(struct soap *soap, int n)
{
	struct _tds__GetServicesResponse *p;
	struct _tds__GetServicesResponse *a = (struct _tds__GetServicesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetServicesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetServicesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServicesResponse(struct soap *soap, const struct _tds__GetServicesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetServicesResponse(soap, tag ? tag : "tds:GetServicesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServicesResponse * SOAP_FMAC4 soap_get__tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServices(struct soap *soap, struct _tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->IncludeCapability);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServices(struct soap *soap, const struct _tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->IncludeCapability, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServices(struct soap *soap, const char *tag, int id, const struct _tds__GetServices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServices), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:IncludeCapability", -1, &a->IncludeCapability, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServices * SOAP_FMAC4 soap_in__tds__GetServices(struct soap *soap, const char *tag, struct _tds__GetServices *a, const char *type)
{
	size_t soap_flag_IncludeCapability = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__GetServices*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServices(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IncludeCapability && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tds:IncludeCapability", &a->IncludeCapability, "xsd:boolean"))
				{	soap_flag_IncludeCapability--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IncludeCapability > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetServices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServices, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetServices * SOAP_FMAC4 soap_new__tds__GetServices(struct soap *soap, int n)
{
	struct _tds__GetServices *p;
	struct _tds__GetServices *a = (struct _tds__GetServices*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetServices));
	for (p = a; p && n--; p++)
		soap_default__tds__GetServices(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServices(struct soap *soap, const struct _tds__GetServices *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetServices(soap, tag ? tag : "tds:GetServices", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServices * SOAP_FMAC4 soap_get__tds__GetServices(struct soap *soap, struct _tds__GetServices *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StorageConfigurationData_Extension(struct soap *soap, struct _tds__StorageConfigurationData_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StorageConfigurationData_Extension(struct soap *soap, const struct _tds__StorageConfigurationData_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, int id, const struct _tds__StorageConfigurationData_Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StorageConfigurationData_Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StorageConfigurationData_Extension * SOAP_FMAC4 soap_in__tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, struct _tds__StorageConfigurationData_Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__StorageConfigurationData_Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(struct _tds__StorageConfigurationData_Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StorageConfigurationData_Extension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StorageConfigurationData_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StorageConfigurationData_Extension, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(struct _tds__StorageConfigurationData_Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__StorageConfigurationData_Extension * SOAP_FMAC4 soap_new__tds__StorageConfigurationData_Extension(struct soap *soap, int n)
{
	struct _tds__StorageConfigurationData_Extension *p;
	struct _tds__StorageConfigurationData_Extension *a = (struct _tds__StorageConfigurationData_Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__StorageConfigurationData_Extension));
	for (p = a; p && n--; p++)
		soap_default__tds__StorageConfigurationData_Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StorageConfigurationData_Extension(struct soap *soap, const struct _tds__StorageConfigurationData_Extension *a, const char *tag, const char *type)
{
	if (soap_out__tds__StorageConfigurationData_Extension(soap, tag ? tag : "tds:StorageConfigurationData-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StorageConfigurationData_Extension * SOAP_FMAC4 soap_get__tds__StorageConfigurationData_Extension(struct soap *soap, struct _tds__StorageConfigurationData_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StorageConfigurationData_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->LocalPath);
	soap_default_xsd__anyURI(soap, &a->StorageUri);
	a->User = NULL;
	a->Extension = NULL;
	soap_default_string(soap, &a->type);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__StorageConfigurationData(struct soap *soap, const struct tds__StorageConfigurationData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->LocalPath);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->StorageUri);
	soap_serialize_PointerTotds__UserCredential(soap, &a->User);
	soap_serialize_PointerTo_tds__StorageConfigurationData_Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__StorageConfigurationData(struct soap *soap, const char *tag, int id, const struct tds__StorageConfigurationData *a, const char *type)
{
	soap_set_attr(soap, "type", a->type ? soap_string2s(soap, a->type) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__StorageConfigurationData), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:LocalPath", -1, (char*const*)&a->LocalPath, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:StorageUri", -1, (char*const*)&a->StorageUri, ""))
		return soap->error;
	if (soap_out_PointerTotds__UserCredential(soap, "tds:User", -1, &a->User, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__StorageConfigurationData_Extension(soap, "tds:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__StorageConfigurationData * SOAP_FMAC4 soap_in_tds__StorageConfigurationData(struct soap *soap, const char *tag, struct tds__StorageConfigurationData *a, const char *type)
{
	size_t soap_flag_LocalPath = 1;
	size_t soap_flag_StorageUri = 1;
	size_t soap_flag_User = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tds__StorageConfigurationData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageConfigurationData, sizeof(struct tds__StorageConfigurationData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__StorageConfigurationData(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "type", 1, 1), &a->type))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LocalPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:LocalPath", (char**)&a->LocalPath, "xsd:anyURI"))
				{	soap_flag_LocalPath--;
					continue;
				}
			}
			if (soap_flag_StorageUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:StorageUri", (char**)&a->StorageUri, "xsd:anyURI"))
				{	soap_flag_StorageUri--;
					continue;
				}
			}
			if (soap_flag_User && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__UserCredential(soap, "tds:User", &a->User, "tds:UserCredential"))
				{	soap_flag_User--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__StorageConfigurationData_Extension(soap, "tds:Extension", &a->Extension, ""))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__StorageConfigurationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageConfigurationData, SOAP_TYPE_tds__StorageConfigurationData, sizeof(struct tds__StorageConfigurationData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__StorageConfigurationData * SOAP_FMAC4 soap_new_tds__StorageConfigurationData(struct soap *soap, int n)
{
	struct tds__StorageConfigurationData *p;
	struct tds__StorageConfigurationData *a = (struct tds__StorageConfigurationData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__StorageConfigurationData));
	for (p = a; p && n--; p++)
		soap_default_tds__StorageConfigurationData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__StorageConfigurationData(struct soap *soap, const struct tds__StorageConfigurationData *a, const char *tag, const char *type)
{
	if (soap_out_tds__StorageConfigurationData(soap, tag ? tag : "tds:StorageConfigurationData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__StorageConfigurationData * SOAP_FMAC4 soap_get_tds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__StorageConfigurationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__UserCredential_Extension(struct soap *soap, struct _tds__UserCredential_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__UserCredential_Extension(struct soap *soap, const struct _tds__UserCredential_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UserCredential_Extension(struct soap *soap, const char *tag, int id, const struct _tds__UserCredential_Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UserCredential_Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__UserCredential_Extension * SOAP_FMAC4 soap_in__tds__UserCredential_Extension(struct soap *soap, const char *tag, struct _tds__UserCredential_Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__UserCredential_Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UserCredential_Extension, sizeof(struct _tds__UserCredential_Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__UserCredential_Extension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__UserCredential_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UserCredential_Extension, SOAP_TYPE__tds__UserCredential_Extension, sizeof(struct _tds__UserCredential_Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__UserCredential_Extension * SOAP_FMAC4 soap_new__tds__UserCredential_Extension(struct soap *soap, int n)
{
	struct _tds__UserCredential_Extension *p;
	struct _tds__UserCredential_Extension *a = (struct _tds__UserCredential_Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__UserCredential_Extension));
	for (p = a; p && n--; p++)
		soap_default__tds__UserCredential_Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__UserCredential_Extension(struct soap *soap, const struct _tds__UserCredential_Extension *a, const char *tag, const char *type)
{
	if (soap_out__tds__UserCredential_Extension(soap, tag ? tag : "tds:UserCredential-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UserCredential_Extension * SOAP_FMAC4 soap_get__tds__UserCredential_Extension(struct soap *soap, struct _tds__UserCredential_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UserCredential_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__UserCredential(struct soap *soap, struct tds__UserCredential *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->UserName);
	soap_default_string(soap, &a->Password);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__UserCredential(struct soap *soap, const struct tds__UserCredential *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->UserName);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_serialize_PointerTo_tds__UserCredential_Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__UserCredential(struct soap *soap, const char *tag, int id, const struct tds__UserCredential *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__UserCredential), type))
		return soap->error;
	if (!a->UserName)
	{	if (soap_element_empty(soap, "tds:UserName", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tds:UserName", -1, (char*const*)&a->UserName, ""))
		return soap->error;
	if (soap_out_string(soap, "tds:Password", -1, (char*const*)&a->Password, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__UserCredential_Extension(soap, "tds:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__UserCredential * SOAP_FMAC4 soap_in_tds__UserCredential(struct soap *soap, const char *tag, struct tds__UserCredential *a, const char *type)
{
	size_t soap_flag_UserName = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tds__UserCredential*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__UserCredential, sizeof(struct tds__UserCredential), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__UserCredential(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:UserName", (char**)&a->UserName, "xsd:string"))
				{	soap_flag_UserName--;
					continue;
				}
			}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tds:Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__UserCredential_Extension(soap, "tds:Extension", &a->Extension, ""))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->UserName))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tds__UserCredential *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__UserCredential, SOAP_TYPE_tds__UserCredential, sizeof(struct tds__UserCredential), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__UserCredential * SOAP_FMAC4 soap_new_tds__UserCredential(struct soap *soap, int n)
{
	struct tds__UserCredential *p;
	struct tds__UserCredential *a = (struct tds__UserCredential*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__UserCredential));
	for (p = a; p && n--; p++)
		soap_default_tds__UserCredential(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__UserCredential(struct soap *soap, const struct tds__UserCredential *a, const char *tag, const char *type)
{
	if (soap_out_tds__UserCredential(soap, tag ? tag : "tds:UserCredential", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__UserCredential * SOAP_FMAC4 soap_get_tds__UserCredential(struct soap *soap, struct tds__UserCredential *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__UserCredential(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__StringAttrList(soap, &a->AuxiliaryCommands);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__MiscCapabilities(struct soap *soap, const struct tds__MiscCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__MiscCapabilities(struct soap *soap, const char *tag, int id, const struct tds__MiscCapabilities *a, const char *type)
{
	if (a->AuxiliaryCommands)
		soap_set_attr(soap, "AuxiliaryCommands", soap_tt__StringAttrList2s(soap, a->AuxiliaryCommands), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__MiscCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__MiscCapabilities * SOAP_FMAC4 soap_in_tds__MiscCapabilities(struct soap *soap, const char *tag, struct tds__MiscCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tds__MiscCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__MiscCapabilities, sizeof(struct tds__MiscCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__MiscCapabilities(soap, a);
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "AuxiliaryCommands", 1, 0), &a->AuxiliaryCommands))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__MiscCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__MiscCapabilities, SOAP_TYPE_tds__MiscCapabilities, sizeof(struct tds__MiscCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__MiscCapabilities * SOAP_FMAC4 soap_new_tds__MiscCapabilities(struct soap *soap, int n)
{
	struct tds__MiscCapabilities *p;
	struct tds__MiscCapabilities *a = (struct tds__MiscCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__MiscCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tds__MiscCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__MiscCapabilities(struct soap *soap, const struct tds__MiscCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tds__MiscCapabilities(soap, tag ? tag : "tds:MiscCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__MiscCapabilities * SOAP_FMAC4 soap_get_tds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__MiscCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DiscoveryResolve = NULL;
	a->DiscoveryBye = NULL;
	a->RemoteDiscovery = NULL;
	a->SystemBackup = NULL;
	a->SystemLogging = NULL;
	a->FirmwareUpgrade = NULL;
	a->HttpFirmwareUpgrade = NULL;
	a->HttpSystemBackup = NULL;
	a->HttpSystemLogging = NULL;
	a->HttpSupportInformation = NULL;
	a->StorageConfiguration = NULL;
	a->MaxStorageConfigurations = NULL;
	a->GeoLocationEntries = NULL;
	soap_default_tt__StringAttrList(soap, &a->AutoGeo);
	soap_default_tt__StringAttrList(soap, &a->StorageTypesSupported);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__SystemCapabilities(struct soap *soap, const struct tds__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__SystemCapabilities(struct soap *soap, const char *tag, int id, const struct tds__SystemCapabilities *a, const char *type)
{
	if (a->DiscoveryResolve)
	{	soap_set_attr(soap, "DiscoveryResolve", soap_xsd__boolean2s(soap, *a->DiscoveryResolve), 1);
	}
	if (a->DiscoveryBye)
	{	soap_set_attr(soap, "DiscoveryBye", soap_xsd__boolean2s(soap, *a->DiscoveryBye), 1);
	}
	if (a->RemoteDiscovery)
	{	soap_set_attr(soap, "RemoteDiscovery", soap_xsd__boolean2s(soap, *a->RemoteDiscovery), 1);
	}
	if (a->SystemBackup)
	{	soap_set_attr(soap, "SystemBackup", soap_xsd__boolean2s(soap, *a->SystemBackup), 1);
	}
	if (a->SystemLogging)
	{	soap_set_attr(soap, "SystemLogging", soap_xsd__boolean2s(soap, *a->SystemLogging), 1);
	}
	if (a->FirmwareUpgrade)
	{	soap_set_attr(soap, "FirmwareUpgrade", soap_xsd__boolean2s(soap, *a->FirmwareUpgrade), 1);
	}
	if (a->HttpFirmwareUpgrade)
	{	soap_set_attr(soap, "HttpFirmwareUpgrade", soap_xsd__boolean2s(soap, *a->HttpFirmwareUpgrade), 1);
	}
	if (a->HttpSystemBackup)
	{	soap_set_attr(soap, "HttpSystemBackup", soap_xsd__boolean2s(soap, *a->HttpSystemBackup), 1);
	}
	if (a->HttpSystemLogging)
	{	soap_set_attr(soap, "HttpSystemLogging", soap_xsd__boolean2s(soap, *a->HttpSystemLogging), 1);
	}
	if (a->HttpSupportInformation)
	{	soap_set_attr(soap, "HttpSupportInformation", soap_xsd__boolean2s(soap, *a->HttpSupportInformation), 1);
	}
	if (a->StorageConfiguration)
	{	soap_set_attr(soap, "StorageConfiguration", soap_xsd__boolean2s(soap, *a->StorageConfiguration), 1);
	}
	if (a->MaxStorageConfigurations)
	{	soap_set_attr(soap, "MaxStorageConfigurations", soap_int2s(soap, *a->MaxStorageConfigurations), 1);
	}
	if (a->GeoLocationEntries)
	{	soap_set_attr(soap, "GeoLocationEntries", soap_int2s(soap, *a->GeoLocationEntries), 1);
	}
	if (a->AutoGeo)
		soap_set_attr(soap, "AutoGeo", soap_tt__StringAttrList2s(soap, a->AutoGeo), 1);
	if (a->StorageTypesSupported)
		soap_set_attr(soap, "StorageTypesSupported", soap_tt__StringAttrList2s(soap, a->StorageTypesSupported), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__SystemCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__SystemCapabilities * SOAP_FMAC4 soap_in_tds__SystemCapabilities(struct soap *soap, const char *tag, struct tds__SystemCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tds__SystemCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__SystemCapabilities, sizeof(struct tds__SystemCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__SystemCapabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "DiscoveryResolve", 5, 0);
		if (t)
		{
			if (!(a->DiscoveryResolve = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DiscoveryResolve))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DiscoveryBye", 5, 0);
		if (t)
		{
			if (!(a->DiscoveryBye = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DiscoveryBye))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RemoteDiscovery", 5, 0);
		if (t)
		{
			if (!(a->RemoteDiscovery = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RemoteDiscovery))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SystemBackup", 5, 0);
		if (t)
		{
			if (!(a->SystemBackup = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->SystemBackup))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SystemLogging", 5, 0);
		if (t)
		{
			if (!(a->SystemLogging = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->SystemLogging))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "FirmwareUpgrade", 5, 0);
		if (t)
		{
			if (!(a->FirmwareUpgrade = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->FirmwareUpgrade))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpFirmwareUpgrade", 5, 0);
		if (t)
		{
			if (!(a->HttpFirmwareUpgrade = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->HttpFirmwareUpgrade))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpSystemBackup", 5, 0);
		if (t)
		{
			if (!(a->HttpSystemBackup = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->HttpSystemBackup))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpSystemLogging", 5, 0);
		if (t)
		{
			if (!(a->HttpSystemLogging = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->HttpSystemLogging))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpSupportInformation", 5, 0);
		if (t)
		{
			if (!(a->HttpSupportInformation = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->HttpSupportInformation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "StorageConfiguration", 5, 0);
		if (t)
		{
			if (!(a->StorageConfiguration = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->StorageConfiguration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxStorageConfigurations", 5, 0);
		if (t)
		{
			if (!(a->MaxStorageConfigurations = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxStorageConfigurations))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoLocationEntries", 5, 0);
		if (t)
		{
			if (!(a->GeoLocationEntries = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->GeoLocationEntries))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "AutoGeo", 1, 0), &a->AutoGeo))
		return NULL;
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "StorageTypesSupported", 1, 0), &a->StorageTypesSupported))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__SystemCapabilities, SOAP_TYPE_tds__SystemCapabilities, sizeof(struct tds__SystemCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__SystemCapabilities * SOAP_FMAC4 soap_new_tds__SystemCapabilities(struct soap *soap, int n)
{
	struct tds__SystemCapabilities *p;
	struct tds__SystemCapabilities *a = (struct tds__SystemCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__SystemCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tds__SystemCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__SystemCapabilities(struct soap *soap, const struct tds__SystemCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tds__SystemCapabilities(soap, tag ? tag : "tds:SystemCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__SystemCapabilities * SOAP_FMAC4 soap_get_tds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TLS1_x002e0 = NULL;
	a->TLS1_x002e1 = NULL;
	a->TLS1_x002e2 = NULL;
	a->OnboardKeyGeneration = NULL;
	a->AccessPolicyConfig = NULL;
	a->DefaultAccessPolicy = NULL;
	a->Dot1X = NULL;
	a->RemoteUserHandling = NULL;
	a->X_x002e509Token = NULL;
	a->SAMLToken = NULL;
	a->KerberosToken = NULL;
	a->UsernameToken = NULL;
	a->HttpDigest = NULL;
	a->RELToken = NULL;
	soap_default_tds__EAPMethodTypes(soap, &a->SupportedEAPMethods);
	a->MaxUsers = NULL;
	a->MaxUserNameLength = NULL;
	a->MaxPasswordLength = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__SecurityCapabilities(struct soap *soap, const struct tds__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__SecurityCapabilities(struct soap *soap, const char *tag, int id, const struct tds__SecurityCapabilities *a, const char *type)
{
	if (a->TLS1_x002e0)
	{	soap_set_attr(soap, "TLS1.0", soap_xsd__boolean2s(soap, *a->TLS1_x002e0), 1);
	}
	if (a->TLS1_x002e1)
	{	soap_set_attr(soap, "TLS1.1", soap_xsd__boolean2s(soap, *a->TLS1_x002e1), 1);
	}
	if (a->TLS1_x002e2)
	{	soap_set_attr(soap, "TLS1.2", soap_xsd__boolean2s(soap, *a->TLS1_x002e2), 1);
	}
	if (a->OnboardKeyGeneration)
	{	soap_set_attr(soap, "OnboardKeyGeneration", soap_xsd__boolean2s(soap, *a->OnboardKeyGeneration), 1);
	}
	if (a->AccessPolicyConfig)
	{	soap_set_attr(soap, "AccessPolicyConfig", soap_xsd__boolean2s(soap, *a->AccessPolicyConfig), 1);
	}
	if (a->DefaultAccessPolicy)
	{	soap_set_attr(soap, "DefaultAccessPolicy", soap_xsd__boolean2s(soap, *a->DefaultAccessPolicy), 1);
	}
	if (a->Dot1X)
	{	soap_set_attr(soap, "Dot1X", soap_xsd__boolean2s(soap, *a->Dot1X), 1);
	}
	if (a->RemoteUserHandling)
	{	soap_set_attr(soap, "RemoteUserHandling", soap_xsd__boolean2s(soap, *a->RemoteUserHandling), 1);
	}
	if (a->X_x002e509Token)
	{	soap_set_attr(soap, "X.509Token", soap_xsd__boolean2s(soap, *a->X_x002e509Token), 1);
	}
	if (a->SAMLToken)
	{	soap_set_attr(soap, "SAMLToken", soap_xsd__boolean2s(soap, *a->SAMLToken), 1);
	}
	if (a->KerberosToken)
	{	soap_set_attr(soap, "KerberosToken", soap_xsd__boolean2s(soap, *a->KerberosToken), 1);
	}
	if (a->UsernameToken)
	{	soap_set_attr(soap, "UsernameToken", soap_xsd__boolean2s(soap, *a->UsernameToken), 1);
	}
	if (a->HttpDigest)
	{	soap_set_attr(soap, "HttpDigest", soap_xsd__boolean2s(soap, *a->HttpDigest), 1);
	}
	if (a->RELToken)
	{	soap_set_attr(soap, "RELToken", soap_xsd__boolean2s(soap, *a->RELToken), 1);
	}
	if (a->SupportedEAPMethods)
		soap_set_attr(soap, "SupportedEAPMethods", soap_tds__EAPMethodTypes2s(soap, a->SupportedEAPMethods), 1);
	if (a->MaxUsers)
	{	soap_set_attr(soap, "MaxUsers", soap_int2s(soap, *a->MaxUsers), 1);
	}
	if (a->MaxUserNameLength)
	{	soap_set_attr(soap, "MaxUserNameLength", soap_int2s(soap, *a->MaxUserNameLength), 1);
	}
	if (a->MaxPasswordLength)
	{	soap_set_attr(soap, "MaxPasswordLength", soap_int2s(soap, *a->MaxPasswordLength), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__SecurityCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__SecurityCapabilities * SOAP_FMAC4 soap_in_tds__SecurityCapabilities(struct soap *soap, const char *tag, struct tds__SecurityCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tds__SecurityCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__SecurityCapabilities, sizeof(struct tds__SecurityCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__SecurityCapabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "TLS1.0", 5, 0);
		if (t)
		{
			if (!(a->TLS1_x002e0 = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->TLS1_x002e0))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "TLS1.1", 5, 0);
		if (t)
		{
			if (!(a->TLS1_x002e1 = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->TLS1_x002e1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "TLS1.2", 5, 0);
		if (t)
		{
			if (!(a->TLS1_x002e2 = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->TLS1_x002e2))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "OnboardKeyGeneration", 5, 0);
		if (t)
		{
			if (!(a->OnboardKeyGeneration = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->OnboardKeyGeneration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "AccessPolicyConfig", 5, 0);
		if (t)
		{
			if (!(a->AccessPolicyConfig = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->AccessPolicyConfig))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DefaultAccessPolicy", 5, 0);
		if (t)
		{
			if (!(a->DefaultAccessPolicy = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DefaultAccessPolicy))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Dot1X", 5, 0);
		if (t)
		{
			if (!(a->Dot1X = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Dot1X))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RemoteUserHandling", 5, 0);
		if (t)
		{
			if (!(a->RemoteUserHandling = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RemoteUserHandling))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "X.509Token", 5, 0);
		if (t)
		{
			if (!(a->X_x002e509Token = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->X_x002e509Token))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SAMLToken", 5, 0);
		if (t)
		{
			if (!(a->SAMLToken = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->SAMLToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "KerberosToken", 5, 0);
		if (t)
		{
			if (!(a->KerberosToken = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->KerberosToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "UsernameToken", 5, 0);
		if (t)
		{
			if (!(a->UsernameToken = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->UsernameToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpDigest", 5, 0);
		if (t)
		{
			if (!(a->HttpDigest = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->HttpDigest))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RELToken", 5, 0);
		if (t)
		{
			if (!(a->RELToken = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RELToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tds__EAPMethodTypes(soap, soap_attr_value(soap, "SupportedEAPMethods", 1, 0), &a->SupportedEAPMethods))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "MaxUsers", 5, 0);
		if (t)
		{
			if (!(a->MaxUsers = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxUsers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxUserNameLength", 5, 0);
		if (t)
		{
			if (!(a->MaxUserNameLength = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxUserNameLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxPasswordLength", 5, 0);
		if (t)
		{
			if (!(a->MaxPasswordLength = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxPasswordLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__SecurityCapabilities, SOAP_TYPE_tds__SecurityCapabilities, sizeof(struct tds__SecurityCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__SecurityCapabilities * SOAP_FMAC4 soap_new_tds__SecurityCapabilities(struct soap *soap, int n)
{
	struct tds__SecurityCapabilities *p;
	struct tds__SecurityCapabilities *a = (struct tds__SecurityCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__SecurityCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tds__SecurityCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__SecurityCapabilities(struct soap *soap, const struct tds__SecurityCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tds__SecurityCapabilities(soap, tag ? tag : "tds:SecurityCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__SecurityCapabilities * SOAP_FMAC4 soap_get_tds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPFilter = NULL;
	a->ZeroConfiguration = NULL;
	a->IPVersion6 = NULL;
	a->DynDNS = NULL;
	a->Dot11Configuration = NULL;
	a->Dot1XConfigurations = NULL;
	a->HostnameFromDHCP = NULL;
	a->NTP = NULL;
	a->DHCPv6 = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__NetworkCapabilities(struct soap *soap, const struct tds__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__NetworkCapabilities(struct soap *soap, const char *tag, int id, const struct tds__NetworkCapabilities *a, const char *type)
{
	if (a->IPFilter)
	{	soap_set_attr(soap, "IPFilter", soap_xsd__boolean2s(soap, *a->IPFilter), 1);
	}
	if (a->ZeroConfiguration)
	{	soap_set_attr(soap, "ZeroConfiguration", soap_xsd__boolean2s(soap, *a->ZeroConfiguration), 1);
	}
	if (a->IPVersion6)
	{	soap_set_attr(soap, "IPVersion6", soap_xsd__boolean2s(soap, *a->IPVersion6), 1);
	}
	if (a->DynDNS)
	{	soap_set_attr(soap, "DynDNS", soap_xsd__boolean2s(soap, *a->DynDNS), 1);
	}
	if (a->Dot11Configuration)
	{	soap_set_attr(soap, "Dot11Configuration", soap_xsd__boolean2s(soap, *a->Dot11Configuration), 1);
	}
	if (a->Dot1XConfigurations)
	{	soap_set_attr(soap, "Dot1XConfigurations", soap_int2s(soap, *a->Dot1XConfigurations), 1);
	}
	if (a->HostnameFromDHCP)
	{	soap_set_attr(soap, "HostnameFromDHCP", soap_xsd__boolean2s(soap, *a->HostnameFromDHCP), 1);
	}
	if (a->NTP)
	{	soap_set_attr(soap, "NTP", soap_int2s(soap, *a->NTP), 1);
	}
	if (a->DHCPv6)
	{	soap_set_attr(soap, "DHCPv6", soap_xsd__boolean2s(soap, *a->DHCPv6), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__NetworkCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__NetworkCapabilities * SOAP_FMAC4 soap_in_tds__NetworkCapabilities(struct soap *soap, const char *tag, struct tds__NetworkCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tds__NetworkCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__NetworkCapabilities, sizeof(struct tds__NetworkCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__NetworkCapabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "IPFilter", 5, 0);
		if (t)
		{
			if (!(a->IPFilter = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->IPFilter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "ZeroConfiguration", 5, 0);
		if (t)
		{
			if (!(a->ZeroConfiguration = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->ZeroConfiguration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "IPVersion6", 5, 0);
		if (t)
		{
			if (!(a->IPVersion6 = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->IPVersion6))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DynDNS", 5, 0);
		if (t)
		{
			if (!(a->DynDNS = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DynDNS))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Dot11Configuration", 5, 0);
		if (t)
		{
			if (!(a->Dot11Configuration = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Dot11Configuration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Dot1XConfigurations", 5, 0);
		if (t)
		{
			if (!(a->Dot1XConfigurations = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Dot1XConfigurations))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HostnameFromDHCP", 5, 0);
		if (t)
		{
			if (!(a->HostnameFromDHCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->HostnameFromDHCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NTP", 5, 0);
		if (t)
		{
			if (!(a->NTP = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->NTP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DHCPv6", 5, 0);
		if (t)
		{
			if (!(a->DHCPv6 = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DHCPv6))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__NetworkCapabilities, SOAP_TYPE_tds__NetworkCapabilities, sizeof(struct tds__NetworkCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__NetworkCapabilities * SOAP_FMAC4 soap_new_tds__NetworkCapabilities(struct soap *soap, int n)
{
	struct tds__NetworkCapabilities *p;
	struct tds__NetworkCapabilities *a = (struct tds__NetworkCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__NetworkCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tds__NetworkCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__NetworkCapabilities(struct soap *soap, const struct tds__NetworkCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tds__NetworkCapabilities(soap, tag ? tag : "tds:NetworkCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__NetworkCapabilities * SOAP_FMAC4 soap_get_tds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Network = NULL;
	a->Security = NULL;
	a->System = NULL;
	a->Misc = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__DeviceServiceCapabilities(struct soap *soap, const struct tds__DeviceServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__NetworkCapabilities(soap, &a->Network);
	soap_serialize_PointerTotds__SecurityCapabilities(soap, &a->Security);
	soap_serialize_PointerTotds__SystemCapabilities(soap, &a->System);
	soap_serialize_PointerTotds__MiscCapabilities(soap, &a->Misc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__DeviceServiceCapabilities(struct soap *soap, const char *tag, int id, const struct tds__DeviceServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__DeviceServiceCapabilities), type))
		return soap->error;
	if (!a->Network)
	{	if (soap_element_empty(soap, "tds:Network", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__NetworkCapabilities(soap, "tds:Network", -1, &a->Network, ""))
		return soap->error;
	if (!a->Security)
	{	if (soap_element_empty(soap, "tds:Security", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__SecurityCapabilities(soap, "tds:Security", -1, &a->Security, ""))
		return soap->error;
	if (!a->System)
	{	if (soap_element_empty(soap, "tds:System", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__SystemCapabilities(soap, "tds:System", -1, &a->System, ""))
		return soap->error;
	if (soap_out_PointerTotds__MiscCapabilities(soap, "tds:Misc", -1, &a->Misc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_in_tds__DeviceServiceCapabilities(struct soap *soap, const char *tag, struct tds__DeviceServiceCapabilities *a, const char *type)
{
	size_t soap_flag_Network = 1;
	size_t soap_flag_Security = 1;
	size_t soap_flag_System = 1;
	size_t soap_flag_Misc = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tds__DeviceServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__DeviceServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Network && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__NetworkCapabilities(soap, "tds:Network", &a->Network, "tds:NetworkCapabilities"))
				{	soap_flag_Network--;
					continue;
				}
			}
			if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__SecurityCapabilities(soap, "tds:Security", &a->Security, "tds:SecurityCapabilities"))
				{	soap_flag_Security--;
					continue;
				}
			}
			if (soap_flag_System && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__SystemCapabilities(soap, "tds:System", &a->System, "tds:SystemCapabilities"))
				{	soap_flag_System--;
					continue;
				}
			}
			if (soap_flag_Misc && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__MiscCapabilities(soap, "tds:Misc", &a->Misc, "tds:MiscCapabilities"))
				{	soap_flag_Misc--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Network || !a->Security || !a->System))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tds__DeviceServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__DeviceServiceCapabilities, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_new_tds__DeviceServiceCapabilities(struct soap *soap, int n)
{
	struct tds__DeviceServiceCapabilities *p;
	struct tds__DeviceServiceCapabilities *a = (struct tds__DeviceServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__DeviceServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tds__DeviceServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__DeviceServiceCapabilities(struct soap *soap, const struct tds__DeviceServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tds__DeviceServiceCapabilities(soap, tag ? tag : "tds:DeviceServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_get_tds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__DeviceServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Major);
	soap_default_int(soap, &a->Minor);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OnvifVersion(struct soap *soap, const struct tt__OnvifVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Major, SOAP_TYPE_int);
	soap_embedded(soap, &a->Minor, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OnvifVersion(struct soap *soap, const char *tag, int id, const struct tt__OnvifVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OnvifVersion), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Major", -1, &a->Major, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minor", -1, &a->Minor, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_in_tt__OnvifVersion(struct soap *soap, const char *tag, struct tt__OnvifVersion *a, const char *type)
{
	size_t soap_flag_Major = 1;
	size_t soap_flag_Minor = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__OnvifVersion*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OnvifVersion(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Major && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Major", &a->Major, "xsd:int"))
				{	soap_flag_Major--;
					continue;
				}
			}
			if (soap_flag_Minor && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Minor", &a->Minor, "xsd:int"))
				{	soap_flag_Minor--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Major > 0 || soap_flag_Minor > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OnvifVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OnvifVersion, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_new_tt__OnvifVersion(struct soap *soap, int n)
{
	struct tt__OnvifVersion *p;
	struct tt__OnvifVersion *a = (struct tt__OnvifVersion*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OnvifVersion));
	for (p = a; p && n--; p++)
		soap_default_tt__OnvifVersion(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OnvifVersion(struct soap *soap, const struct tt__OnvifVersion *a, const char *tag, const char *type)
{
	if (soap_out_tt__OnvifVersion(soap, tag ? tag : "tt:OnvifVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_get_tt__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__Service_Capabilities(struct soap *soap, const struct _tds__Service_Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__Service_Capabilities(struct soap *soap, const char *tag, int id, const struct _tds__Service_Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__Service_Capabilities), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__Service_Capabilities * SOAP_FMAC4 soap_in__tds__Service_Capabilities(struct soap *soap, const char *tag, struct _tds__Service_Capabilities *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tds__Service_Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__Service_Capabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__Service_Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__Service_Capabilities, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__Service_Capabilities * SOAP_FMAC4 soap_new__tds__Service_Capabilities(struct soap *soap, int n)
{
	struct _tds__Service_Capabilities *p;
	struct _tds__Service_Capabilities *a = (struct _tds__Service_Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__Service_Capabilities));
	for (p = a; p && n--; p++)
		soap_default__tds__Service_Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__Service_Capabilities(struct soap *soap, const struct _tds__Service_Capabilities *a, const char *tag, const char *type)
{
	if (soap_out__tds__Service_Capabilities(soap, tag ? tag : "tds:Service-Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__Service_Capabilities * SOAP_FMAC4 soap_get__tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__Service_Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__Service(struct soap *soap, struct tds__Service *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Namespace);
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->Capabilities = NULL;
	a->Version = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__Service(struct soap *soap, const struct tds__Service *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Namespace);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_serialize_PointerTo_tds__Service_Capabilities(soap, &a->Capabilities);
	soap_serialize_PointerTott__OnvifVersion(soap, &a->Version);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__Service(struct soap *soap, const char *tag, int id, const struct tds__Service *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__Service), type))
		return soap->error;
	if (!a->Namespace)
	{	if (soap_element_empty(soap, "tds:Namespace", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tds:Namespace", -1, (char*const*)&a->Namespace, ""))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_empty(soap, "tds:XAddr", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tds:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__Service_Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	if (!a->Version)
	{	if (soap_element_empty(soap, "tds:Version", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__OnvifVersion(soap, "tds:Version", -1, &a->Version, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__Service * SOAP_FMAC4 soap_in_tds__Service(struct soap *soap, const char *tag, struct tds__Service *a, const char *type)
{
	size_t soap_flag_Namespace = 1;
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_Capabilities = 1;
	size_t soap_flag_Version = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tds__Service*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__Service(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Namespace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:Namespace", (char**)&a->Namespace, "xsd:anyURI"))
				{	soap_flag_Namespace--;
					continue;
				}
			}
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			}
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__Service_Capabilities(soap, "tds:Capabilities", &a->Capabilities, ""))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			if (soap_flag_Version && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OnvifVersion(soap, "tds:Version", &a->Version, "tt:OnvifVersion"))
				{	soap_flag_Version--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Namespace || !a->XAddr || !a->Version))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tds__Service *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__Service, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__Service * SOAP_FMAC4 soap_new_tds__Service(struct soap *soap, int n)
{
	struct tds__Service *p;
	struct tds__Service *a = (struct tds__Service*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__Service));
	for (p = a; p && n--; p++)
		soap_default_tds__Service(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__Service(struct soap *soap, const struct tds__Service *a, const char *tag, const char *type)
{
	if (soap_out_tds__Service(soap, tag ? tag : "tds:Service", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__Service * SOAP_FMAC4 soap_get_tds__Service(struct soap *soap, struct tds__Service *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SendReceiveSerialCommandResponse(struct soap *soap, struct _tmd__SendReceiveSerialCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SerialData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SendReceiveSerialCommandResponse(struct soap *soap, const struct _tmd__SendReceiveSerialCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotmd__SerialData(soap, &a->SerialData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SendReceiveSerialCommandResponse(struct soap *soap, const char *tag, int id, const struct _tmd__SendReceiveSerialCommandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SendReceiveSerialCommandResponse), type))
		return soap->error;
	if (a->SerialData)
		soap_element_result(soap, "tmd:SerialData");
	if (soap_out_PointerTotmd__SerialData(soap, "tmd:SerialData", -1, &a->SerialData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SendReceiveSerialCommandResponse * SOAP_FMAC4 soap_in__tmd__SendReceiveSerialCommandResponse(struct soap *soap, const char *tag, struct _tmd__SendReceiveSerialCommandResponse *a, const char *type)
{
	size_t soap_flag_SerialData = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SendReceiveSerialCommandResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SendReceiveSerialCommandResponse, sizeof(struct _tmd__SendReceiveSerialCommandResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SendReceiveSerialCommandResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SerialData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotmd__SerialData(soap, "tmd:SerialData", &a->SerialData, "tmd:SerialData"))
				{	soap_flag_SerialData--;
					continue;
				}
			}
			soap_check_result(soap, "tmd:SerialData");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__SendReceiveSerialCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SendReceiveSerialCommandResponse, SOAP_TYPE__tmd__SendReceiveSerialCommandResponse, sizeof(struct _tmd__SendReceiveSerialCommandResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SendReceiveSerialCommandResponse * SOAP_FMAC4 soap_new__tmd__SendReceiveSerialCommandResponse(struct soap *soap, int n)
{
	struct _tmd__SendReceiveSerialCommandResponse *p;
	struct _tmd__SendReceiveSerialCommandResponse *a = (struct _tmd__SendReceiveSerialCommandResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SendReceiveSerialCommandResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__SendReceiveSerialCommandResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SendReceiveSerialCommandResponse(struct soap *soap, const struct _tmd__SendReceiveSerialCommandResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SendReceiveSerialCommandResponse(soap, tag ? tag : "tmd:SendReceiveSerialCommandResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SendReceiveSerialCommandResponse * SOAP_FMAC4 soap_get__tmd__SendReceiveSerialCommandResponse(struct soap *soap, struct _tmd__SendReceiveSerialCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SendReceiveSerialCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SendReceiveSerialCommand(struct soap *soap, struct _tmd__SendReceiveSerialCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
	a->SerialData = NULL;
	soap_default_xsd__duration(soap, &a->TimeOut);
	soap_default_xsd__integer(soap, &a->DataLength);
	soap_default_string(soap, &a->Delimiter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SendReceiveSerialCommand(struct soap *soap, const struct _tmd__SendReceiveSerialCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
	soap_serialize_PointerTotmd__SerialData(soap, &a->SerialData);
	soap_serialize_xsd__duration(soap, (char*const*)&a->TimeOut);
	soap_serialize_xsd__integer(soap, (char*const*)&a->DataLength);
	soap_serialize_string(soap, (char*const*)&a->Delimiter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SendReceiveSerialCommand(struct soap *soap, const char *tag, int id, const struct _tmd__SendReceiveSerialCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SendReceiveSerialCommand), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tmd:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	if (soap_out_PointerTotmd__SerialData(soap, "tmd:SerialData", -1, &a->SerialData, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tmd:TimeOut", -1, (char*const*)&a->TimeOut, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "tmd:DataLength", -1, (char*const*)&a->DataLength, ""))
		return soap->error;
	if (soap_out_string(soap, "tmd:Delimiter", -1, (char*const*)&a->Delimiter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SendReceiveSerialCommand * SOAP_FMAC4 soap_in__tmd__SendReceiveSerialCommand(struct soap *soap, const char *tag, struct _tmd__SendReceiveSerialCommand *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_SerialData = 1;
	size_t soap_flag_TimeOut = 1;
	size_t soap_flag_DataLength = 1;
	size_t soap_flag_Delimiter = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SendReceiveSerialCommand*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SendReceiveSerialCommand, sizeof(struct _tmd__SendReceiveSerialCommand), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SendReceiveSerialCommand(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			}
			if (soap_flag_SerialData && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotmd__SerialData(soap, "tmd:SerialData", &a->SerialData, "tmd:SerialData"))
				{	soap_flag_SerialData--;
					continue;
				}
			}
			if (soap_flag_TimeOut && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tmd:TimeOut", (char**)&a->TimeOut, "xsd:duration"))
				{	soap_flag_TimeOut--;
					continue;
				}
			}
			if (soap_flag_DataLength && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "tmd:DataLength", (char**)&a->DataLength, "xsd:integer"))
				{	soap_flag_DataLength--;
					continue;
				}
			}
			if (soap_flag_Delimiter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tmd:Delimiter", (char**)&a->Delimiter, "xsd:string"))
				{	soap_flag_Delimiter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__SendReceiveSerialCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SendReceiveSerialCommand, SOAP_TYPE__tmd__SendReceiveSerialCommand, sizeof(struct _tmd__SendReceiveSerialCommand), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SendReceiveSerialCommand * SOAP_FMAC4 soap_new__tmd__SendReceiveSerialCommand(struct soap *soap, int n)
{
	struct _tmd__SendReceiveSerialCommand *p;
	struct _tmd__SendReceiveSerialCommand *a = (struct _tmd__SendReceiveSerialCommand*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SendReceiveSerialCommand));
	for (p = a; p && n--; p++)
		soap_default__tmd__SendReceiveSerialCommand(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SendReceiveSerialCommand(struct soap *soap, const struct _tmd__SendReceiveSerialCommand *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SendReceiveSerialCommand(soap, tag ? tag : "tmd:SendReceiveSerialCommand", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SendReceiveSerialCommand * SOAP_FMAC4 soap_get__tmd__SendReceiveSerialCommand(struct soap *soap, struct _tmd__SendReceiveSerialCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SendReceiveSerialCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetSerialPortConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetSerialPortConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SerialPortOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetSerialPortConfigurationOptionsResponse(struct soap *soap, const struct _tmd__GetSerialPortConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotmd__SerialPortConfigurationOptions(soap, &a->SerialPortOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetSerialPortConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetSerialPortConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse), type))
		return soap->error;
	if (a->SerialPortOptions)
		soap_element_result(soap, "tmd:SerialPortOptions");
	if (!a->SerialPortOptions)
	{	if (soap_element_empty(soap, "tmd:SerialPortOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotmd__SerialPortConfigurationOptions(soap, "tmd:SerialPortOptions", -1, &a->SerialPortOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationOptionsResponse * SOAP_FMAC4 soap_in__tmd__GetSerialPortConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetSerialPortConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_SerialPortOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetSerialPortConfigurationOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse, sizeof(struct _tmd__GetSerialPortConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetSerialPortConfigurationOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SerialPortOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotmd__SerialPortConfigurationOptions(soap, "tmd:SerialPortOptions", &a->SerialPortOptions, "tmd:SerialPortConfigurationOptions"))
				{	soap_flag_SerialPortOptions--;
					continue;
				}
			}
			soap_check_result(soap, "tmd:SerialPortOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SerialPortOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetSerialPortConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse, SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse, sizeof(struct _tmd__GetSerialPortConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationOptionsResponse * SOAP_FMAC4 soap_new__tmd__GetSerialPortConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _tmd__GetSerialPortConfigurationOptionsResponse *p;
	struct _tmd__GetSerialPortConfigurationOptionsResponse *a = (struct _tmd__GetSerialPortConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetSerialPortConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetSerialPortConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetSerialPortConfigurationOptionsResponse(struct soap *soap, const struct _tmd__GetSerialPortConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetSerialPortConfigurationOptionsResponse(soap, tag ? tag : "tmd:GetSerialPortConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationOptionsResponse * SOAP_FMAC4 soap_get__tmd__GetSerialPortConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetSerialPortConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetSerialPortConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetSerialPortConfigurationOptions(struct soap *soap, struct _tmd__GetSerialPortConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->SerialPortToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetSerialPortConfigurationOptions(struct soap *soap, const struct _tmd__GetSerialPortConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->SerialPortToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetSerialPortConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _tmd__GetSerialPortConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetSerialPortConfigurationOptions), type))
		return soap->error;
	if (!a->SerialPortToken)
	{	if (soap_element_empty(soap, "tmd:SerialPortToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tmd:SerialPortToken", -1, (char*const*)&a->SerialPortToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationOptions * SOAP_FMAC4 soap_in__tmd__GetSerialPortConfigurationOptions(struct soap *soap, const char *tag, struct _tmd__GetSerialPortConfigurationOptions *a, const char *type)
{
	size_t soap_flag_SerialPortToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetSerialPortConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetSerialPortConfigurationOptions, sizeof(struct _tmd__GetSerialPortConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetSerialPortConfigurationOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SerialPortToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:SerialPortToken", (char**)&a->SerialPortToken, "tt:ReferenceToken"))
				{	soap_flag_SerialPortToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SerialPortToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetSerialPortConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetSerialPortConfigurationOptions, SOAP_TYPE__tmd__GetSerialPortConfigurationOptions, sizeof(struct _tmd__GetSerialPortConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationOptions * SOAP_FMAC4 soap_new__tmd__GetSerialPortConfigurationOptions(struct soap *soap, int n)
{
	struct _tmd__GetSerialPortConfigurationOptions *p;
	struct _tmd__GetSerialPortConfigurationOptions *a = (struct _tmd__GetSerialPortConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetSerialPortConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetSerialPortConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetSerialPortConfigurationOptions(struct soap *soap, const struct _tmd__GetSerialPortConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetSerialPortConfigurationOptions(soap, tag ? tag : "tmd:GetSerialPortConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationOptions * SOAP_FMAC4 soap_get__tmd__GetSerialPortConfigurationOptions(struct soap *soap, struct _tmd__GetSerialPortConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetSerialPortConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetSerialPortConfigurationResponse(struct soap *soap, struct _tmd__SetSerialPortConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetSerialPortConfigurationResponse(struct soap *soap, const struct _tmd__SetSerialPortConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetSerialPortConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tmd__SetSerialPortConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetSerialPortConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetSerialPortConfigurationResponse * SOAP_FMAC4 soap_in__tmd__SetSerialPortConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__SetSerialPortConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetSerialPortConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetSerialPortConfigurationResponse, sizeof(struct _tmd__SetSerialPortConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetSerialPortConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetSerialPortConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetSerialPortConfigurationResponse, SOAP_TYPE__tmd__SetSerialPortConfigurationResponse, sizeof(struct _tmd__SetSerialPortConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetSerialPortConfigurationResponse * SOAP_FMAC4 soap_new__tmd__SetSerialPortConfigurationResponse(struct soap *soap, int n)
{
	struct _tmd__SetSerialPortConfigurationResponse *p;
	struct _tmd__SetSerialPortConfigurationResponse *a = (struct _tmd__SetSerialPortConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetSerialPortConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetSerialPortConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetSerialPortConfigurationResponse(struct soap *soap, const struct _tmd__SetSerialPortConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetSerialPortConfigurationResponse(soap, tag ? tag : "tmd:SetSerialPortConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetSerialPortConfigurationResponse * SOAP_FMAC4 soap_get__tmd__SetSerialPortConfigurationResponse(struct soap *soap, struct _tmd__SetSerialPortConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetSerialPortConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetSerialPortConfiguration(struct soap *soap, struct _tmd__SetSerialPortConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SerialPortConfiguration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistance);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetSerialPortConfiguration(struct soap *soap, const struct _tmd__SetSerialPortConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotmd__SerialPortConfiguration(soap, &a->SerialPortConfiguration);
	soap_embedded(soap, &a->ForcePersistance, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetSerialPortConfiguration(struct soap *soap, const char *tag, int id, const struct _tmd__SetSerialPortConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetSerialPortConfiguration), type))
		return soap->error;
	if (!a->SerialPortConfiguration)
	{	if (soap_element_empty(soap, "tmd:SerialPortConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotmd__SerialPortConfiguration(soap, "tmd:SerialPortConfiguration", -1, &a->SerialPortConfiguration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tmd:ForcePersistance", -1, &a->ForcePersistance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetSerialPortConfiguration * SOAP_FMAC4 soap_in__tmd__SetSerialPortConfiguration(struct soap *soap, const char *tag, struct _tmd__SetSerialPortConfiguration *a, const char *type)
{
	size_t soap_flag_SerialPortConfiguration = 1;
	size_t soap_flag_ForcePersistance = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetSerialPortConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetSerialPortConfiguration, sizeof(struct _tmd__SetSerialPortConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetSerialPortConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SerialPortConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotmd__SerialPortConfiguration(soap, "tmd:SerialPortConfiguration", &a->SerialPortConfiguration, "tmd:SerialPortConfiguration"))
				{	soap_flag_SerialPortConfiguration--;
					continue;
				}
			}
			if (soap_flag_ForcePersistance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tmd:ForcePersistance", &a->ForcePersistance, "xsd:boolean"))
				{	soap_flag_ForcePersistance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SerialPortConfiguration || soap_flag_ForcePersistance > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__SetSerialPortConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetSerialPortConfiguration, SOAP_TYPE__tmd__SetSerialPortConfiguration, sizeof(struct _tmd__SetSerialPortConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetSerialPortConfiguration * SOAP_FMAC4 soap_new__tmd__SetSerialPortConfiguration(struct soap *soap, int n)
{
	struct _tmd__SetSerialPortConfiguration *p;
	struct _tmd__SetSerialPortConfiguration *a = (struct _tmd__SetSerialPortConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetSerialPortConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetSerialPortConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetSerialPortConfiguration(struct soap *soap, const struct _tmd__SetSerialPortConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetSerialPortConfiguration(soap, tag ? tag : "tmd:SetSerialPortConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetSerialPortConfiguration * SOAP_FMAC4 soap_get__tmd__SetSerialPortConfiguration(struct soap *soap, struct _tmd__SetSerialPortConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetSerialPortConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetSerialPortConfigurationResponse(struct soap *soap, struct _tmd__GetSerialPortConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SerialPortConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetSerialPortConfigurationResponse(struct soap *soap, const struct _tmd__GetSerialPortConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotmd__SerialPortConfiguration(soap, &a->SerialPortConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetSerialPortConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetSerialPortConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetSerialPortConfigurationResponse), type))
		return soap->error;
	if (a->SerialPortConfiguration)
		soap_element_result(soap, "tmd:SerialPortConfiguration");
	if (!a->SerialPortConfiguration)
	{	if (soap_element_empty(soap, "tmd:SerialPortConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotmd__SerialPortConfiguration(soap, "tmd:SerialPortConfiguration", -1, &a->SerialPortConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationResponse * SOAP_FMAC4 soap_in__tmd__GetSerialPortConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__GetSerialPortConfigurationResponse *a, const char *type)
{
	size_t soap_flag_SerialPortConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetSerialPortConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetSerialPortConfigurationResponse, sizeof(struct _tmd__GetSerialPortConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetSerialPortConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SerialPortConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotmd__SerialPortConfiguration(soap, "tmd:SerialPortConfiguration", &a->SerialPortConfiguration, "tmd:SerialPortConfiguration"))
				{	soap_flag_SerialPortConfiguration--;
					continue;
				}
			}
			soap_check_result(soap, "tmd:SerialPortConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SerialPortConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetSerialPortConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetSerialPortConfigurationResponse, SOAP_TYPE__tmd__GetSerialPortConfigurationResponse, sizeof(struct _tmd__GetSerialPortConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationResponse * SOAP_FMAC4 soap_new__tmd__GetSerialPortConfigurationResponse(struct soap *soap, int n)
{
	struct _tmd__GetSerialPortConfigurationResponse *p;
	struct _tmd__GetSerialPortConfigurationResponse *a = (struct _tmd__GetSerialPortConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetSerialPortConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetSerialPortConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetSerialPortConfigurationResponse(struct soap *soap, const struct _tmd__GetSerialPortConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetSerialPortConfigurationResponse(soap, tag ? tag : "tmd:GetSerialPortConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationResponse * SOAP_FMAC4 soap_get__tmd__GetSerialPortConfigurationResponse(struct soap *soap, struct _tmd__GetSerialPortConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetSerialPortConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetSerialPortConfiguration(struct soap *soap, struct _tmd__GetSerialPortConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->SerialPortToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetSerialPortConfiguration(struct soap *soap, const struct _tmd__GetSerialPortConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->SerialPortToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetSerialPortConfiguration(struct soap *soap, const char *tag, int id, const struct _tmd__GetSerialPortConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetSerialPortConfiguration), type))
		return soap->error;
	if (!a->SerialPortToken)
	{	if (soap_element_empty(soap, "tmd:SerialPortToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tmd:SerialPortToken", -1, (char*const*)&a->SerialPortToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfiguration * SOAP_FMAC4 soap_in__tmd__GetSerialPortConfiguration(struct soap *soap, const char *tag, struct _tmd__GetSerialPortConfiguration *a, const char *type)
{
	size_t soap_flag_SerialPortToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetSerialPortConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetSerialPortConfiguration, sizeof(struct _tmd__GetSerialPortConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetSerialPortConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SerialPortToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tmd:SerialPortToken", (char**)&a->SerialPortToken, "tt:ReferenceToken"))
				{	soap_flag_SerialPortToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SerialPortToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__GetSerialPortConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetSerialPortConfiguration, SOAP_TYPE__tmd__GetSerialPortConfiguration, sizeof(struct _tmd__GetSerialPortConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfiguration * SOAP_FMAC4 soap_new__tmd__GetSerialPortConfiguration(struct soap *soap, int n)
{
	struct _tmd__GetSerialPortConfiguration *p;
	struct _tmd__GetSerialPortConfiguration *a = (struct _tmd__GetSerialPortConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetSerialPortConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetSerialPortConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetSerialPortConfiguration(struct soap *soap, const struct _tmd__GetSerialPortConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetSerialPortConfiguration(soap, tag ? tag : "tmd:GetSerialPortConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfiguration * SOAP_FMAC4 soap_get__tmd__GetSerialPortConfiguration(struct soap *soap, struct _tmd__GetSerialPortConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetSerialPortConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tmd__SerialPort(struct soap *soap, struct tmd__SerialPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__SerialPort(struct soap *soap, const struct tmd__SerialPort *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__SerialPort(struct soap *soap, const char *tag, int id, const struct tmd__SerialPort *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tmd__SerialPort), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tmd__SerialPort * SOAP_FMAC4 soap_in_tmd__SerialPort(struct soap *soap, const char *tag, struct tmd__SerialPort *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tmd__SerialPort*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tmd__SerialPort, sizeof(struct tmd__SerialPort), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tmd__SerialPort(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tmd__SerialPort *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tmd__SerialPort, SOAP_TYPE_tmd__SerialPort, sizeof(struct tmd__SerialPort), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tmd__SerialPort * SOAP_FMAC4 soap_new_tmd__SerialPort(struct soap *soap, int n)
{
	struct tmd__SerialPort *p;
	struct tmd__SerialPort *a = (struct tmd__SerialPort*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tmd__SerialPort));
	for (p = a; p && n--; p++)
		soap_default_tmd__SerialPort(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__SerialPort(struct soap *soap, const struct tmd__SerialPort *a, const char *tag, const char *type)
{
	if (soap_out_tmd__SerialPort(soap, tag ? tag : "tmd:SerialPort", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__SerialPort * SOAP_FMAC4 soap_get_tmd__SerialPort(struct soap *soap, struct tmd__SerialPort *p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__SerialPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetSerialPortsResponse(struct soap *soap, struct _tmd__GetSerialPortsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSerialPort = 0;
	a->SerialPort = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetSerialPortsResponse(struct soap *soap, const struct _tmd__GetSerialPortsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->SerialPort)
	{	int i;
		for (i = 0; i < (int)a->__sizeSerialPort; i++)
		{
			soap_embedded(soap, a->SerialPort + i, SOAP_TYPE_tmd__SerialPort);
			soap_serialize_tmd__SerialPort(soap, a->SerialPort + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetSerialPortsResponse(struct soap *soap, const char *tag, int id, const struct _tmd__GetSerialPortsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetSerialPortsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeSerialPort");
	if (a->SerialPort)
	{	int i;
		for (i = 0; i < (int)a->__sizeSerialPort; i++)
			if (soap_out_tmd__SerialPort(soap, "tmd:SerialPort", -1, a->SerialPort + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetSerialPortsResponse * SOAP_FMAC4 soap_in__tmd__GetSerialPortsResponse(struct soap *soap, const char *tag, struct _tmd__GetSerialPortsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_SerialPort = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetSerialPortsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetSerialPortsResponse, sizeof(struct _tmd__GetSerialPortsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetSerialPortsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:SerialPort", 1, NULL))
			{	if (a->SerialPort == NULL)
				{	if (soap_blist_SerialPort == NULL)
						soap_blist_SerialPort = soap_alloc_block(soap);
					a->SerialPort = (struct tmd__SerialPort *)soap_push_block_max(soap, soap_blist_SerialPort, sizeof(struct tmd__SerialPort));
					if (a->SerialPort == NULL)
						return NULL;
					soap_default_tmd__SerialPort(soap, a->SerialPort);
				}
				soap_revert(soap);
				if (soap_in_tmd__SerialPort(soap, "tmd:SerialPort", a->SerialPort, "tmd:SerialPort"))
				{	a->__sizeSerialPort++;
					a->SerialPort = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeSerialPort");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SerialPort)
			soap_pop_block(soap, soap_blist_SerialPort);
		if (a->__sizeSerialPort)
		{	a->SerialPort = (struct tmd__SerialPort *)soap_save_block(soap, soap_blist_SerialPort, NULL, 1);
		}
		else
		{	a->SerialPort = NULL;
			if (soap_blist_SerialPort)
				soap_end_block(soap, soap_blist_SerialPort);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetSerialPortsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetSerialPortsResponse, SOAP_TYPE__tmd__GetSerialPortsResponse, sizeof(struct _tmd__GetSerialPortsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetSerialPortsResponse * SOAP_FMAC4 soap_new__tmd__GetSerialPortsResponse(struct soap *soap, int n)
{
	struct _tmd__GetSerialPortsResponse *p;
	struct _tmd__GetSerialPortsResponse *a = (struct _tmd__GetSerialPortsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetSerialPortsResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetSerialPortsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetSerialPortsResponse(struct soap *soap, const struct _tmd__GetSerialPortsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetSerialPortsResponse(soap, tag ? tag : "tmd:GetSerialPortsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetSerialPortsResponse * SOAP_FMAC4 soap_get__tmd__GetSerialPortsResponse(struct soap *soap, struct _tmd__GetSerialPortsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetSerialPortsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__GetSerialPorts(struct soap *soap, struct _tmd__GetSerialPorts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__GetSerialPorts(struct soap *soap, const struct _tmd__GetSerialPorts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__GetSerialPorts(struct soap *soap, const char *tag, int id, const struct _tmd__GetSerialPorts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__GetSerialPorts), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__GetSerialPorts * SOAP_FMAC4 soap_in__tmd__GetSerialPorts(struct soap *soap, const char *tag, struct _tmd__GetSerialPorts *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__GetSerialPorts*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__GetSerialPorts, sizeof(struct _tmd__GetSerialPorts), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__GetSerialPorts(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetSerialPorts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__GetSerialPorts, SOAP_TYPE__tmd__GetSerialPorts, sizeof(struct _tmd__GetSerialPorts), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__GetSerialPorts * SOAP_FMAC4 soap_new__tmd__GetSerialPorts(struct soap *soap, int n)
{
	struct _tmd__GetSerialPorts *p;
	struct _tmd__GetSerialPorts *a = (struct _tmd__GetSerialPorts*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__GetSerialPorts));
	for (p = a; p && n--; p++)
		soap_default__tmd__GetSerialPorts(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__GetSerialPorts(struct soap *soap, const struct _tmd__GetSerialPorts *a, const char *tag, const char *type)
{
	if (soap_out__tmd__GetSerialPorts(soap, tag ? tag : "tmd:GetSerialPorts", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetSerialPorts * SOAP_FMAC4 soap_get__tmd__GetSerialPorts(struct soap *soap, struct _tmd__GetSerialPorts *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__GetSerialPorts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetDigitalInputConfigurationsResponse(struct soap *soap, struct _tmd__SetDigitalInputConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetDigitalInputConfigurationsResponse(struct soap *soap, const struct _tmd__SetDigitalInputConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetDigitalInputConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tmd__SetDigitalInputConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetDigitalInputConfigurationsResponse * SOAP_FMAC4 soap_in__tmd__SetDigitalInputConfigurationsResponse(struct soap *soap, const char *tag, struct _tmd__SetDigitalInputConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetDigitalInputConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse, sizeof(struct _tmd__SetDigitalInputConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetDigitalInputConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetDigitalInputConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse, SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse, sizeof(struct _tmd__SetDigitalInputConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetDigitalInputConfigurationsResponse * SOAP_FMAC4 soap_new__tmd__SetDigitalInputConfigurationsResponse(struct soap *soap, int n)
{
	struct _tmd__SetDigitalInputConfigurationsResponse *p;
	struct _tmd__SetDigitalInputConfigurationsResponse *a = (struct _tmd__SetDigitalInputConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetDigitalInputConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetDigitalInputConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetDigitalInputConfigurationsResponse(struct soap *soap, const struct _tmd__SetDigitalInputConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetDigitalInputConfigurationsResponse(soap, tag ? tag : "tmd:SetDigitalInputConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetDigitalInputConfigurationsResponse * SOAP_FMAC4 soap_get__tmd__SetDigitalInputConfigurationsResponse(struct soap *soap, struct _tmd__SetDigitalInputConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetDigitalInputConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tmd__SetDigitalInputConfigurations(struct soap *soap, struct _tmd__SetDigitalInputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDigitalInputs = 0;
	a->DigitalInputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__SetDigitalInputConfigurations(struct soap *soap, const struct _tmd__SetDigitalInputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->DigitalInputs)
	{	int i;
		for (i = 0; i < (int)a->__sizeDigitalInputs; i++)
		{
			soap_embedded(soap, a->DigitalInputs + i, SOAP_TYPE_tt__DigitalInput);
			soap_serialize_tt__DigitalInput(soap, a->DigitalInputs + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__SetDigitalInputConfigurations(struct soap *soap, const char *tag, int id, const struct _tmd__SetDigitalInputConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tmd__SetDigitalInputConfigurations), type))
		return soap->error;
	if (a->DigitalInputs)
	{	int i;
		for (i = 0; i < (int)a->__sizeDigitalInputs; i++)
			if (soap_out_tt__DigitalInput(soap, "tmd:DigitalInputs", -1, a->DigitalInputs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tmd__SetDigitalInputConfigurations * SOAP_FMAC4 soap_in__tmd__SetDigitalInputConfigurations(struct soap *soap, const char *tag, struct _tmd__SetDigitalInputConfigurations *a, const char *type)
{
	struct soap_blist *soap_blist_DigitalInputs = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tmd__SetDigitalInputConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tmd__SetDigitalInputConfigurations, sizeof(struct _tmd__SetDigitalInputConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tmd__SetDigitalInputConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tmd:DigitalInputs", 1, NULL))
			{	if (a->DigitalInputs == NULL)
				{	if (soap_blist_DigitalInputs == NULL)
						soap_blist_DigitalInputs = soap_alloc_block(soap);
					a->DigitalInputs = (struct tt__DigitalInput *)soap_push_block_max(soap, soap_blist_DigitalInputs, sizeof(struct tt__DigitalInput));
					if (a->DigitalInputs == NULL)
						return NULL;
					soap_default_tt__DigitalInput(soap, a->DigitalInputs);
				}
				soap_revert(soap);
				if (soap_in_tt__DigitalInput(soap, "tmd:DigitalInputs", a->DigitalInputs, "tt:DigitalInput"))
				{	a->__sizeDigitalInputs++;
					a->DigitalInputs = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DigitalInputs)
			soap_pop_block(soap, soap_blist_DigitalInputs);
		if (a->__sizeDigitalInputs)
		{	a->DigitalInputs = (struct tt__DigitalInput *)soap_save_block(soap, soap_blist_DigitalInputs, NULL, 1);
		}
		else
		{	a->DigitalInputs = NULL;
			if (soap_blist_DigitalInputs)
				soap_end_block(soap, soap_blist_DigitalInputs);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeDigitalInputs < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tmd__SetDigitalInputConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tmd__SetDigitalInputConfigurations, SOAP_TYPE__tmd__SetDigitalInputConfigurations, sizeof(struct _tmd__SetDigitalInputConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tmd__SetDigitalInputConfigurations * SOAP_FMAC4 soap_new__tmd__SetDigitalInputConfigurations(struct soap *soap, int n)
{
	struct _tmd__SetDigitalInputConfigurations *p;
	struct _tmd__SetDigitalInputConfigurations *a = (struct _tmd__SetDigitalInputConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tmd__SetDigitalInputConfigurations));
	for (p = a; p && n--; p++)
		soap_default__tmd__SetDigitalInputConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tmd__SetDigitalInputConfigurations(struct soap *soap, const struct _tmd__SetDigitalInputConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__tmd__SetDigitalInputConfigurations(soap, tag ? tag : "tmd:SetDigitalInputConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetDigitalInputConfigurations * SOAP_FMAC4 soap_get__tmd__SetDigitalInputConfigurations(struct soap *soap, struct _tmd__SetDigitalInputConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tmd__SetDigitalInputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
