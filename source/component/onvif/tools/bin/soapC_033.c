/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:06 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoResolution2(struct soap *soap, struct tt__VideoResolution2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoResolution2))
		soap_serialize_tt__VideoResolution2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoResolution2(struct soap *soap, const char *tag, int id, struct tt__VideoResolution2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoResolution2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoResolution2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoResolution2 ** SOAP_FMAC4 soap_in_PointerTott__VideoResolution2(struct soap *soap, const char *tag, struct tt__VideoResolution2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoResolution2 **)soap_malloc(soap, sizeof(struct tt__VideoResolution2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoResolution2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoResolution2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoResolution2, sizeof(struct tt__VideoResolution2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoResolution2(struct soap *soap, struct tt__VideoResolution2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoResolution2(soap, tag ? tag : "tt:VideoResolution2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoResolution2 ** SOAP_FMAC4 soap_get_PointerTott__VideoResolution2(struct soap *soap, struct tt__VideoResolution2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoResolution2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FloatRange))
		soap_serialize_tt__FloatRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FloatRange(struct soap *soap, const char *tag, int id, struct tt__FloatRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FloatRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FloatRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FloatRange ** SOAP_FMAC4 soap_in_PointerTott__FloatRange(struct soap *soap, const char *tag, struct tt__FloatRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FloatRange **)soap_malloc(soap, sizeof(struct tt__FloatRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FloatRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FloatRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FloatRange(soap, tag ? tag : "tt:FloatRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatRange ** SOAP_FMAC4 soap_get_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Profile(struct soap *soap, enum tt__H264Profile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__H264Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Profile(struct soap *soap, const char *tag, int id, enum tt__H264Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Profile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__H264Profile ** SOAP_FMAC4 soap_in_PointerTott__H264Profile(struct soap *soap, const char *tag, enum tt__H264Profile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__H264Profile **)soap_malloc(soap, sizeof(enum tt__H264Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__H264Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Profile(struct soap *soap, enum tt__H264Profile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Profile(soap, tag ? tag : "tt:H264Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__H264Profile ** SOAP_FMAC4 soap_get_PointerTott__H264Profile(struct soap *soap, enum tt__H264Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Profile(struct soap *soap, const char *tag, int id, enum tt__Mpeg4Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Profile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Mpeg4Profile ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Profile(struct soap *soap, const char *tag, enum tt__Mpeg4Profile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__Mpeg4Profile **)soap_malloc(soap, sizeof(enum tt__Mpeg4Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__Mpeg4Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Profile(soap, tag ? tag : "tt:Mpeg4Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Mpeg4Profile ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoResolution))
		soap_serialize_tt__VideoResolution(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoResolution(struct soap *soap, const char *tag, int id, struct tt__VideoResolution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoResolution, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoResolution(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoResolution ** SOAP_FMAC4 soap_in_PointerTott__VideoResolution(struct soap *soap, const char *tag, struct tt__VideoResolution **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoResolution **)soap_malloc(soap, sizeof(struct tt__VideoResolution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoResolution(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoResolution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoResolution(soap, tag ? tag : "tt:VideoResolution", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoResolution ** SOAP_FMAC4 soap_get_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2))
		soap_serialize_tt__VideoEncoderOptionsExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderOptionsExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderOptionsExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderOptionsExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoEncoderOptionsExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, tag ? tag : "tt:VideoEncoderOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options2))
		soap_serialize_tt__H264Options2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options2(struct soap *soap, const char *tag, int id, struct tt__H264Options2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Options2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Options2 ** SOAP_FMAC4 soap_in_PointerTott__H264Options2(struct soap *soap, const char *tag, struct tt__H264Options2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264Options2 **)soap_malloc(soap, sizeof(struct tt__H264Options2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Options2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Options2(soap, tag ? tag : "tt:H264Options2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options2 ** SOAP_FMAC4 soap_get_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options2))
		soap_serialize_tt__Mpeg4Options2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options2(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Options2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Options2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options2(struct soap *soap, const char *tag, struct tt__Mpeg4Options2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4Options2 **)soap_malloc(soap, sizeof(struct tt__Mpeg4Options2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Options2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Options2(soap, tag ? tag : "tt:Mpeg4Options2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions2))
		soap_serialize_tt__JpegOptions2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions2(struct soap *soap, const char *tag, int id, struct tt__JpegOptions2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__JpegOptions2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__JpegOptions2 ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions2(struct soap *soap, const char *tag, struct tt__JpegOptions2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__JpegOptions2 **)soap_malloc(soap, sizeof(struct tt__JpegOptions2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__JpegOptions2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__JpegOptions2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__JpegOptions2(soap, tag ? tag : "tt:JpegOptions2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions2 ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension))
		soap_serialize_tt__VideoEncoderOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderOptionsExtension **)soap_malloc(soap, sizeof(struct tt__VideoEncoderOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, tag ? tag : "tt:VideoEncoderOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options(struct soap *soap, struct tt__H264Options *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options))
		soap_serialize_tt__H264Options(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options(struct soap *soap, const char *tag, int id, struct tt__H264Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Options(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Options ** SOAP_FMAC4 soap_in_PointerTott__H264Options(struct soap *soap, const char *tag, struct tt__H264Options **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264Options **)soap_malloc(soap, sizeof(struct tt__H264Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Options(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options(struct soap *soap, struct tt__H264Options *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Options(soap, tag ? tag : "tt:H264Options", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options ** SOAP_FMAC4 soap_get_PointerTott__H264Options(struct soap *soap, struct tt__H264Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options))
		soap_serialize_tt__Mpeg4Options(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Options(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Options ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, struct tt__Mpeg4Options **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4Options **)soap_malloc(soap, sizeof(struct tt__Mpeg4Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Options(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Options(soap, tag ? tag : "tt:Mpeg4Options", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions))
		soap_serialize_tt__JpegOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions(struct soap *soap, const char *tag, int id, struct tt__JpegOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__JpegOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__JpegOptions ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions(struct soap *soap, const char *tag, struct tt__JpegOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__JpegOptions **)soap_malloc(soap, sizeof(struct tt__JpegOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__JpegOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__JpegOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__JpegOptions(soap, tag ? tag : "tt:JpegOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateOptionsExtension(struct soap *soap, struct tt__RotateOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateOptionsExtension))
		soap_serialize_tt__RotateOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__RotateOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RotateOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RotateOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__RotateOptionsExtension(struct soap *soap, const char *tag, struct tt__RotateOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RotateOptionsExtension **)soap_malloc(soap, sizeof(struct tt__RotateOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RotateOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RotateOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(struct tt__RotateOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateOptionsExtension(struct soap *soap, struct tt__RotateOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RotateOptionsExtension(soap, tag ? tag : "tt:RotateOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RotateOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__RotateOptionsExtension(struct soap *soap, struct tt__RotateOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateMode(struct soap *soap, enum tt__RotateMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__RotateMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateMode(struct soap *soap, const char *tag, int id, enum tt__RotateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RotateMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__RotateMode ** SOAP_FMAC4 soap_in_PointerTott__RotateMode(struct soap *soap, const char *tag, enum tt__RotateMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__RotateMode **)soap_malloc(soap, sizeof(enum tt__RotateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RotateMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__RotateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateMode(struct soap *soap, enum tt__RotateMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RotateMode(soap, tag ? tag : "tt:RotateMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RotateMode ** SOAP_FMAC4 soap_get_PointerTott__RotateMode(struct soap *soap, enum tt__RotateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__SceneOrientationMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SceneOrientationMode(struct soap *soap, const char *tag, int id, enum tt__SceneOrientationMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SceneOrientationMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SceneOrientationMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__SceneOrientationMode ** SOAP_FMAC4 soap_in_PointerTott__SceneOrientationMode(struct soap *soap, const char *tag, enum tt__SceneOrientationMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__SceneOrientationMode **)soap_malloc(soap, sizeof(enum tt__SceneOrientationMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SceneOrientationMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__SceneOrientationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SceneOrientationMode, sizeof(enum tt__SceneOrientationMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SceneOrientationMode(soap, tag ? tag : "tt:SceneOrientationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SceneOrientationMode ** SOAP_FMAC4 soap_get_PointerTott__SceneOrientationMode(struct soap *soap, enum tt__SceneOrientationMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SceneOrientationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2))
		soap_serialize_tt__VideoSourceConfigurationOptionsExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationOptionsExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptionsExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationOptionsExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationOptionsExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(struct tt__VideoSourceConfigurationOptionsExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateOptions(struct soap *soap, struct tt__RotateOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateOptions))
		soap_serialize_tt__RotateOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateOptions(struct soap *soap, const char *tag, int id, struct tt__RotateOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RotateOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RotateOptions ** SOAP_FMAC4 soap_in_PointerTott__RotateOptions(struct soap *soap, const char *tag, struct tt__RotateOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RotateOptions **)soap_malloc(soap, sizeof(struct tt__RotateOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RotateOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RotateOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateOptions, sizeof(struct tt__RotateOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateOptions(struct soap *soap, struct tt__RotateOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RotateOptions(soap, tag ? tag : "tt:RotateOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RotateOptions ** SOAP_FMAC4 soap_get_PointerTott__RotateOptions(struct soap *soap, struct tt__RotateOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension))
		soap_serialize_tt__VideoSourceConfigurationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(struct tt__VideoSourceConfigurationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, tag ? tag : "tt:VideoSourceConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangleRange))
		soap_serialize_tt__IntRectangleRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangleRange(struct soap *soap, const char *tag, int id, struct tt__IntRectangleRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangleRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntRectangleRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntRectangleRange ** SOAP_FMAC4 soap_in_PointerTott__IntRectangleRange(struct soap *soap, const char *tag, struct tt__IntRectangleRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntRectangleRange **)soap_malloc(soap, sizeof(struct tt__IntRectangleRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntRectangleRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntRectangleRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangleRange, sizeof(struct tt__IntRectangleRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRectangleRange(soap, tag ? tag : "tt:IntRectangleRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangleRange ** SOAP_FMAC4 soap_get_PointerTott__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensProjection(struct soap *soap, struct tt__LensProjection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LensProjection))
		soap_serialize_tt__LensProjection(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensProjection(struct soap *soap, const char *tag, int id, struct tt__LensProjection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LensProjection, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LensProjection(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LensProjection ** SOAP_FMAC4 soap_in_PointerTott__LensProjection(struct soap *soap, const char *tag, struct tt__LensProjection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LensProjection **)soap_malloc(soap, sizeof(struct tt__LensProjection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LensProjection(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LensProjection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensProjection, sizeof(struct tt__LensProjection), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensProjection(struct soap *soap, struct tt__LensProjection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LensProjection(soap, tag ? tag : "tt:LensProjection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LensProjection ** SOAP_FMAC4 soap_get_PointerTott__LensProjection(struct soap *soap, struct tt__LensProjection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LensProjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensOffset(struct soap *soap, struct tt__LensOffset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LensOffset))
		soap_serialize_tt__LensOffset(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensOffset(struct soap *soap, const char *tag, int id, struct tt__LensOffset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LensOffset, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LensOffset(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LensOffset ** SOAP_FMAC4 soap_in_PointerTott__LensOffset(struct soap *soap, const char *tag, struct tt__LensOffset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LensOffset **)soap_malloc(soap, sizeof(struct tt__LensOffset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LensOffset(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LensOffset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensOffset, sizeof(struct tt__LensOffset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensOffset(struct soap *soap, struct tt__LensOffset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LensOffset(soap, tag ? tag : "tt:LensOffset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LensOffset ** SOAP_FMAC4 soap_get_PointerTott__LensOffset(struct soap *soap, struct tt__LensOffset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LensOffset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateExtension(struct soap *soap, struct tt__RotateExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateExtension))
		soap_serialize_tt__RotateExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateExtension(struct soap *soap, const char *tag, int id, struct tt__RotateExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RotateExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RotateExtension ** SOAP_FMAC4 soap_in_PointerTott__RotateExtension(struct soap *soap, const char *tag, struct tt__RotateExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RotateExtension **)soap_malloc(soap, sizeof(struct tt__RotateExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RotateExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RotateExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateExtension, sizeof(struct tt__RotateExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateExtension(struct soap *soap, struct tt__RotateExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RotateExtension(soap, tag ? tag : "tt:RotateExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RotateExtension ** SOAP_FMAC4 soap_get_PointerTott__RotateExtension(struct soap *soap, struct tt__RotateExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SceneOrientation(struct soap *soap, struct tt__SceneOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SceneOrientation))
		soap_serialize_tt__SceneOrientation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SceneOrientation(struct soap *soap, const char *tag, int id, struct tt__SceneOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SceneOrientation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SceneOrientation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SceneOrientation ** SOAP_FMAC4 soap_in_PointerTott__SceneOrientation(struct soap *soap, const char *tag, struct tt__SceneOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SceneOrientation **)soap_malloc(soap, sizeof(struct tt__SceneOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SceneOrientation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SceneOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SceneOrientation, sizeof(struct tt__SceneOrientation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SceneOrientation(struct soap *soap, struct tt__SceneOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SceneOrientation(soap, tag ? tag : "tt:SceneOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SceneOrientation ** SOAP_FMAC4 soap_get_PointerTott__SceneOrientation(struct soap *soap, struct tt__SceneOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SceneOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensDescription(struct soap *soap, struct tt__LensDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LensDescription))
		soap_serialize_tt__LensDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensDescription(struct soap *soap, const char *tag, int id, struct tt__LensDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LensDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LensDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LensDescription ** SOAP_FMAC4 soap_in_PointerTott__LensDescription(struct soap *soap, const char *tag, struct tt__LensDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LensDescription **)soap_malloc(soap, sizeof(struct tt__LensDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LensDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LensDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensDescription, sizeof(struct tt__LensDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensDescription(struct soap *soap, struct tt__LensDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LensDescription(soap, tag ? tag : "tt:LensDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LensDescription ** SOAP_FMAC4 soap_get_PointerTott__LensDescription(struct soap *soap, struct tt__LensDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LensDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, struct tt__VideoSourceConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2))
		soap_serialize_tt__VideoSourceConfigurationExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(struct tt__VideoSourceConfigurationExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, struct tt__VideoSourceConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, struct tt__VideoSourceConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rotate(struct soap *soap, struct tt__Rotate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rotate))
		soap_serialize_tt__Rotate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rotate(struct soap *soap, const char *tag, int id, struct tt__Rotate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rotate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Rotate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Rotate ** SOAP_FMAC4 soap_in_PointerTott__Rotate(struct soap *soap, const char *tag, struct tt__Rotate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Rotate **)soap_malloc(soap, sizeof(struct tt__Rotate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Rotate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Rotate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rotate, sizeof(struct tt__Rotate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rotate(struct soap *soap, struct tt__Rotate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Rotate(soap, tag ? tag : "tt:Rotate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rotate ** SOAP_FMAC4 soap_get_PointerTott__Rotate(struct soap *soap, struct tt__Rotate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rotate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileExtension2))
		soap_serialize_tt__ProfileExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileExtension2(struct soap *soap, const char *tag, int id, struct tt__ProfileExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ProfileExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileExtension2 ** SOAP_FMAC4 soap_in_PointerTott__ProfileExtension2(struct soap *soap, const char *tag, struct tt__ProfileExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ProfileExtension2 **)soap_malloc(soap, sizeof(struct tt__ProfileExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ProfileExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension2, sizeof(struct tt__ProfileExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileExtension2(soap, tag ? tag : "tt:ProfileExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension2 ** SOAP_FMAC4 soap_get_PointerTott__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfiguration))
		soap_serialize_tt__AudioDecoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioDecoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioDecoderConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioDecoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(struct tt__AudioDecoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, tag ? tag : "tt:AudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileExtension))
		soap_serialize_tt__ProfileExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileExtension(struct soap *soap, const char *tag, int id, struct tt__ProfileExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ProfileExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileExtension ** SOAP_FMAC4 soap_in_PointerTott__ProfileExtension(struct soap *soap, const char *tag, struct tt__ProfileExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ProfileExtension **)soap_malloc(soap, sizeof(struct tt__ProfileExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ProfileExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension, sizeof(struct tt__ProfileExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileExtension(soap, tag ? tag : "tt:ProfileExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension ** SOAP_FMAC4 soap_get_PointerTott__ProfileExtension(struct soap *soap, struct tt__ProfileExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfiguration))
		soap_serialize_tt__MetadataConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfiguration(struct soap *soap, const char *tag, int id, struct tt__MetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfiguration(struct soap *soap, const char *tag, struct tt__MetadataConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataConfiguration **)soap_malloc(soap, sizeof(struct tt__MetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(struct tt__MetadataConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfiguration(soap, tag ? tag : "tt:MetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfiguration))
		soap_serialize_tt__PTZConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, int id, struct tt__PTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfiguration ** SOAP_FMAC4 soap_in_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, struct tt__PTZConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfiguration **)soap_malloc(soap, sizeof(struct tt__PTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfiguration, sizeof(struct tt__PTZConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfiguration(soap, tag ? tag : "tt:PTZConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfiguration ** SOAP_FMAC4 soap_get_PointerTott__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAnalyticsConfiguration))
		soap_serialize_tt__VideoAnalyticsConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAnalyticsConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct tt__VideoAnalyticsConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(struct tt__VideoAnalyticsConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, tag ? tag : "tt:VideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfiguration))
		soap_serialize_tt__AudioEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(struct tt__AudioEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, tag ? tag : "tt:AudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfiguration))
		soap_serialize_tt__VideoEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, struct tt__VideoEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, tag ? tag : "tt:VideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceExtension2))
		soap_serialize_tt__VideoSourceExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoSourceExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoSourceExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(struct tt__VideoSourceExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceExtension2(soap, tag ? tag : "tt:VideoSourceExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings20))
		soap_serialize_tt__ImagingSettings20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings20(struct soap *soap, const char *tag, int id, struct tt__ImagingSettings20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettings20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettings20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings20(struct soap *soap, const char *tag, struct tt__ImagingSettings20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettings20 **)soap_malloc(soap, sizeof(struct tt__ImagingSettings20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettings20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettings20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings20, sizeof(struct tt__ImagingSettings20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettings20(soap, tag ? tag : "tt:ImagingSettings20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettings20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTofloat(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRange(struct soap *soap, struct tt__IntRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRange))
		soap_serialize_tt__IntRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRange(struct soap *soap, const char *tag, int id, struct tt__IntRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRange, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntRange ** SOAP_FMAC4 soap_in_PointerTott__IntRange(struct soap *soap, const char *tag, struct tt__IntRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntRange **)soap_malloc(soap, sizeof(struct tt__IntRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRange(struct soap *soap, struct tt__IntRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRange(soap, tag ? tag : "tt:IntRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRange ** SOAP_FMAC4 soap_get_PointerTott__IntRange(struct soap *soap, struct tt__IntRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocationEntity(struct soap *soap, struct tt__LocationEntity *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocationEntity))
		soap_serialize_tt__LocationEntity(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocationEntity(struct soap *soap, const char *tag, int id, struct tt__LocationEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocationEntity, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LocationEntity(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LocationEntity ** SOAP_FMAC4 soap_in_PointerTott__LocationEntity(struct soap *soap, const char *tag, struct tt__LocationEntity **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LocationEntity **)soap_malloc(soap, sizeof(struct tt__LocationEntity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LocationEntity(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LocationEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocationEntity, sizeof(struct tt__LocationEntity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocationEntity(struct soap *soap, struct tt__LocationEntity *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocationEntity(soap, tag ? tag : "tt:LocationEntity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LocationEntity ** SOAP_FMAC4 soap_get_PointerTott__LocationEntity(struct soap *soap, struct tt__LocationEntity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__StorageConfigurationData))
		soap_serialize_tds__StorageConfigurationData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__StorageConfigurationData(struct soap *soap, const char *tag, int id, struct tds__StorageConfigurationData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__StorageConfigurationData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__StorageConfigurationData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__StorageConfigurationData ** SOAP_FMAC4 soap_in_PointerTotds__StorageConfigurationData(struct soap *soap, const char *tag, struct tds__StorageConfigurationData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__StorageConfigurationData **)soap_malloc(soap, sizeof(struct tds__StorageConfigurationData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__StorageConfigurationData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__StorageConfigurationData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__StorageConfigurationData, sizeof(struct tds__StorageConfigurationData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__StorageConfigurationData(soap, tag ? tag : "tds:StorageConfigurationData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__StorageConfigurationData ** SOAP_FMAC4 soap_get_PointerTotds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__StorageConfigurationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__StorageConfiguration))
		soap_serialize_tds__StorageConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__StorageConfiguration(struct soap *soap, const char *tag, int id, struct tds__StorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__StorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__StorageConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__StorageConfiguration ** SOAP_FMAC4 soap_in_PointerTotds__StorageConfiguration(struct soap *soap, const char *tag, struct tds__StorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__StorageConfiguration **)soap_malloc(soap, sizeof(struct tds__StorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__StorageConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__StorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__StorageConfiguration, sizeof(struct tds__StorageConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__StorageConfiguration(soap, tag ? tag : "tds:StorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__StorageConfiguration ** SOAP_FMAC4 soap_get_PointerTotds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__StorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension))
		soap_serialize__tds__GetSystemUrisResponse_Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, int id, struct _tds__GetSystemUrisResponse_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemUrisResponse_Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemUrisResponse_Extension **)soap_malloc(soap, sizeof(struct _tds__GetSystemUrisResponse_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemUrisResponse_Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag ? tag : "tds:GetSystemUrisResponse-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLogUriList))
		soap_serialize_tt__SystemLogUriList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLogUriList(struct soap *soap, const char *tag, int id, struct tt__SystemLogUriList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLogUriList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemLogUriList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemLogUriList ** SOAP_FMAC4 soap_in_PointerTott__SystemLogUriList(struct soap *soap, const char *tag, struct tt__SystemLogUriList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemLogUriList **)soap_malloc(soap, sizeof(struct tt__SystemLogUriList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemLogUriList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLogUriList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLogUriList, sizeof(struct tt__SystemLogUriList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemLogUriList(soap, tag ? tag : "tt:SystemLogUriList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLogUriList ** SOAP_FMAC4 soap_get_PointerTott__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLogUriList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11AvailableNetworks))
		soap_serialize_tt__Dot11AvailableNetworks(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, struct tt__Dot11AvailableNetworks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11AvailableNetworks, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11AvailableNetworks(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks ** SOAP_FMAC4 soap_in_PointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, struct tt__Dot11AvailableNetworks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11AvailableNetworks **)soap_malloc(soap, sizeof(struct tt__Dot11AvailableNetworks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11AvailableNetworks(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11AvailableNetworks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(struct tt__Dot11AvailableNetworks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11AvailableNetworks(soap, tag ? tag : "tt:Dot11AvailableNetworks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks ** SOAP_FMAC4 soap_get_PointerTott__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Status(struct soap *soap, struct tt__Dot11Status *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Status))
		soap_serialize_tt__Dot11Status(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Status(struct soap *soap, const char *tag, int id, struct tt__Dot11Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Status, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Status(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11Status ** SOAP_FMAC4 soap_in_PointerTott__Dot11Status(struct soap *soap, const char *tag, struct tt__Dot11Status **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11Status **)soap_malloc(soap, sizeof(struct tt__Dot11Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Status(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Status, sizeof(struct tt__Dot11Status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Status(struct soap *soap, struct tt__Dot11Status *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Status(soap, tag ? tag : "tt:Dot11Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Status ** SOAP_FMAC4 soap_get_PointerTott__Dot11Status(struct soap *soap, struct tt__Dot11Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Capabilities))
		soap_serialize_tt__Dot11Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Capabilities(struct soap *soap, const char *tag, int id, struct tt__Dot11Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Dot11Capabilities(struct soap *soap, const char *tag, struct tt__Dot11Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11Capabilities **)soap_malloc(soap, sizeof(struct tt__Dot11Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(struct tt__Dot11Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Capabilities(soap, tag ? tag : "tt:Dot11Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutputSettings))
		soap_serialize_tt__RelayOutputSettings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, int id, struct tt__RelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutputSettings, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelayOutputSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, struct tt__RelayOutputSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelayOutputSettings **)soap_malloc(soap, sizeof(struct tt__RelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelayOutputSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelayOutputSettings(soap, tag ? tag : "tt:RelayOutputSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot1XConfiguration))
		soap_serialize_tt__Dot1XConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, int id, struct tt__Dot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot1XConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot1XConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, struct tt__Dot1XConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot1XConfiguration **)soap_malloc(soap, sizeof(struct tt__Dot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot1XConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot1XConfiguration(soap, tag ? tag : "tt:Dot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTott__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateInformation(struct soap *soap, struct tt__CertificateInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateInformation))
		soap_serialize_tt__CertificateInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateInformation(struct soap *soap, const char *tag, int id, struct tt__CertificateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateInformation ** SOAP_FMAC4 soap_in_PointerTott__CertificateInformation(struct soap *soap, const char *tag, struct tt__CertificateInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateInformation **)soap_malloc(soap, sizeof(struct tt__CertificateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateInformation, sizeof(struct tt__CertificateInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateInformation(struct soap *soap, struct tt__CertificateInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateInformation(soap, tag ? tag : "tt:CertificateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateInformation ** SOAP_FMAC4 soap_get_PointerTott__CertificateInformation(struct soap *soap, struct tt__CertificateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateWithPrivateKey))
		soap_serialize_tt__CertificateWithPrivateKey(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, struct tt__CertificateWithPrivateKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateWithPrivateKey, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateWithPrivateKey(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey ** SOAP_FMAC4 soap_in_PointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, struct tt__CertificateWithPrivateKey **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateWithPrivateKey **)soap_malloc(soap, sizeof(struct tt__CertificateWithPrivateKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateWithPrivateKey(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateWithPrivateKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateWithPrivateKey(soap, tag ? tag : "tt:CertificateWithPrivateKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey ** SOAP_FMAC4 soap_get_PointerTott__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateStatus(struct soap *soap, struct tt__CertificateStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateStatus))
		soap_serialize_tt__CertificateStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateStatus(struct soap *soap, const char *tag, int id, struct tt__CertificateStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateStatus ** SOAP_FMAC4 soap_in_PointerTott__CertificateStatus(struct soap *soap, const char *tag, struct tt__CertificateStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateStatus **)soap_malloc(soap, sizeof(struct tt__CertificateStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateStatus, sizeof(struct tt__CertificateStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateStatus(struct soap *soap, struct tt__CertificateStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateStatus(soap, tag ? tag : "tt:CertificateStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateStatus ** SOAP_FMAC4 soap_get_PointerTott__CertificateStatus(struct soap *soap, struct tt__CertificateStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Certificate(struct soap *soap, struct tt__Certificate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Certificate))
		soap_serialize_tt__Certificate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Certificate(struct soap *soap, const char *tag, int id, struct tt__Certificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Certificate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Certificate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Certificate ** SOAP_FMAC4 soap_in_PointerTott__Certificate(struct soap *soap, const char *tag, struct tt__Certificate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Certificate **)soap_malloc(soap, sizeof(struct tt__Certificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Certificate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Certificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Certificate, sizeof(struct tt__Certificate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Certificate(struct soap *soap, struct tt__Certificate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Certificate(soap, tag ? tag : "tt:Certificate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Certificate ** SOAP_FMAC4 soap_get_PointerTott__Certificate(struct soap *soap, struct tt__Certificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BinaryData(struct soap *soap, struct tt__BinaryData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BinaryData))
		soap_serialize_tt__BinaryData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BinaryData(struct soap *soap, const char *tag, int id, struct tt__BinaryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BinaryData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BinaryData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BinaryData ** SOAP_FMAC4 soap_in_PointerTott__BinaryData(struct soap *soap, const char *tag, struct tt__BinaryData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BinaryData **)soap_malloc(soap, sizeof(struct tt__BinaryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BinaryData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BinaryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BinaryData, sizeof(struct tt__BinaryData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BinaryData(struct soap *soap, struct tt__BinaryData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BinaryData(soap, tag ? tag : "tt:BinaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BinaryData ** SOAP_FMAC4 soap_get_PointerTott__BinaryData(struct soap *soap, struct tt__BinaryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddressFilter))
		soap_serialize_tt__IPAddressFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddressFilter(struct soap *soap, const char *tag, int id, struct tt__IPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddressFilter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPAddressFilter ** SOAP_FMAC4 soap_in_PointerTott__IPAddressFilter(struct soap *soap, const char *tag, struct tt__IPAddressFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPAddressFilter **)soap_malloc(soap, sizeof(struct tt__IPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddressFilter(soap, tag ? tag : "tt:IPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilter ** SOAP_FMAC4 soap_get_PointerTott__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfiguration))
		soap_serialize_tt__NetworkZeroConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, struct tt__NetworkZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkZeroConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, struct tt__NetworkZeroConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkZeroConfiguration **)soap_malloc(soap, sizeof(struct tt__NetworkZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkZeroConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(struct tt__NetworkZeroConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkZeroConfiguration(soap, tag ? tag : "tt:NetworkZeroConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Address(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Address))
		soap_serialize_tt__IPv6Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Address(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Address, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__IPv6Address(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Address, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Address(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6Address(soap, tag ? tag : "tt:IPv6Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__IPv6Address(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Address(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Address))
		soap_serialize_tt__IPv4Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Address(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Address, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__IPv4Address(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Address, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Address(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4Address(soap, tag ? tag : "tt:IPv4Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__IPv4Address(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkGateway))
		soap_serialize_tt__NetworkGateway(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkGateway(struct soap *soap, const char *tag, int id, struct tt__NetworkGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkGateway, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkGateway(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkGateway ** SOAP_FMAC4 soap_in_PointerTott__NetworkGateway(struct soap *soap, const char *tag, struct tt__NetworkGateway **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkGateway **)soap_malloc(soap, sizeof(struct tt__NetworkGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkGateway(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkGateway(soap, tag ? tag : "tt:NetworkGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkGateway ** SOAP_FMAC4 soap_get_PointerTott__NetworkGateway(struct soap *soap, struct tt__NetworkGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkProtocol))
		soap_serialize_tt__NetworkProtocol(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkProtocol(struct soap *soap, const char *tag, int id, struct tt__NetworkProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkProtocol, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkProtocol(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkProtocol ** SOAP_FMAC4 soap_in_PointerTott__NetworkProtocol(struct soap *soap, const char *tag, struct tt__NetworkProtocol **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkProtocol **)soap_malloc(soap, sizeof(struct tt__NetworkProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkProtocol(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocol, sizeof(struct tt__NetworkProtocol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkProtocol(soap, tag ? tag : "tt:NetworkProtocol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocol ** SOAP_FMAC4 soap_get_PointerTott__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration))
		soap_serialize_tt__NetworkInterfaceSetConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterface))
		soap_serialize_tt__NetworkInterface(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterface(struct soap *soap, const char *tag, struct tt__NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterface **)soap_malloc(soap, sizeof(struct tt__NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterface, sizeof(struct tt__NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterface(soap, tag ? tag : "tt:NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterface(struct soap *soap, struct tt__NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DynamicDNSInformation))
		soap_serialize_tt__DynamicDNSInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DynamicDNSInformation(struct soap *soap, const char *tag, int id, struct tt__DynamicDNSInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DynamicDNSInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DynamicDNSInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation ** SOAP_FMAC4 soap_in_PointerTott__DynamicDNSInformation(struct soap *soap, const char *tag, struct tt__DynamicDNSInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DynamicDNSInformation **)soap_malloc(soap, sizeof(struct tt__DynamicDNSInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DynamicDNSInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DynamicDNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DynamicDNSInformation(soap, tag ? tag : "tt:DynamicDNSInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation ** SOAP_FMAC4 soap_get_PointerTott__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NTPInformation(struct soap *soap, struct tt__NTPInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NTPInformation))
		soap_serialize_tt__NTPInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NTPInformation(struct soap *soap, const char *tag, int id, struct tt__NTPInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NTPInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NTPInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NTPInformation ** SOAP_FMAC4 soap_in_PointerTott__NTPInformation(struct soap *soap, const char *tag, struct tt__NTPInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NTPInformation **)soap_malloc(soap, sizeof(struct tt__NTPInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NTPInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NTPInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NTPInformation(struct soap *soap, struct tt__NTPInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NTPInformation(soap, tag ? tag : "tt:NTPInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformation ** SOAP_FMAC4 soap_get_PointerTott__NTPInformation(struct soap *soap, struct tt__NTPInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddress))
		soap_serialize_tt__IPAddress(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddress(struct soap *soap, const char *tag, int id, struct tt__IPAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddress, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPAddress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPAddress ** SOAP_FMAC4 soap_in_PointerTott__IPAddress(struct soap *soap, const char *tag, struct tt__IPAddress **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPAddress **)soap_malloc(soap, sizeof(struct tt__IPAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPAddress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddress ** SOAP_FMAC4 soap_get_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__token(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__token))
		soap_serialize_xsd__token(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__token(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__token, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__token(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__token(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__token(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__token, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__token(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__token(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSInformation(struct soap *soap, struct tt__DNSInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSInformation))
		soap_serialize_tt__DNSInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSInformation(struct soap *soap, const char *tag, int id, struct tt__DNSInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DNSInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DNSInformation ** SOAP_FMAC4 soap_in_PointerTott__DNSInformation(struct soap *soap, const char *tag, struct tt__DNSInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DNSInformation **)soap_malloc(soap, sizeof(struct tt__DNSInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DNSInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSInformation(struct soap *soap, struct tt__DNSInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DNSInformation(soap, tag ? tag : "tt:DNSInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformation ** SOAP_FMAC4 soap_get_PointerTott__DNSInformation(struct soap *soap, struct tt__DNSInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__HostnameInformation))
		soap_serialize_tt__HostnameInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__HostnameInformation(struct soap *soap, const char *tag, int id, struct tt__HostnameInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__HostnameInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__HostnameInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__HostnameInformation ** SOAP_FMAC4 soap_in_PointerTott__HostnameInformation(struct soap *soap, const char *tag, struct tt__HostnameInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__HostnameInformation **)soap_malloc(soap, sizeof(struct tt__HostnameInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__HostnameInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__HostnameInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__HostnameInformation(soap, tag ? tag : "tt:HostnameInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformation ** SOAP_FMAC4 soap_get_PointerTott__HostnameInformation(struct soap *soap, struct tt__HostnameInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Capabilities))
		soap_serialize_tt__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Capabilities(struct soap *soap, const char *tag, int id, struct tt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Capabilities(struct soap *soap, const char *tag, struct tt__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Capabilities **)soap_malloc(soap, sizeof(struct tt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Capabilities(soap, tag ? tag : "tt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__CapabilityCategory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilityCategory(struct soap *soap, const char *tag, int id, enum tt__CapabilityCategory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilityCategory, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CapabilityCategory(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__CapabilityCategory ** SOAP_FMAC4 soap_in_PointerTott__CapabilityCategory(struct soap *soap, const char *tag, enum tt__CapabilityCategory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__CapabilityCategory **)soap_malloc(soap, sizeof(enum tt__CapabilityCategory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CapabilityCategory(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__CapabilityCategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CapabilityCategory(soap, tag ? tag : "tt:CapabilityCategory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__CapabilityCategory ** SOAP_FMAC4 soap_get_PointerTott__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilityCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostring(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__User(struct soap *soap, struct tt__User *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__User))
		soap_serialize_tt__User(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__User(struct soap *soap, const char *tag, int id, struct tt__User *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__User, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__User(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__User ** SOAP_FMAC4 soap_in_PointerTott__User(struct soap *soap, const char *tag, struct tt__User **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__User **)soap_malloc(soap, sizeof(struct tt__User *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__User(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__User **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__User, sizeof(struct tt__User), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__User(struct soap *soap, struct tt__User *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__User(soap, tag ? tag : "tt:User", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__User ** SOAP_FMAC4 soap_get_PointerTott__User(struct soap *soap, struct tt__User **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RemoteUser(struct soap *soap, struct tt__RemoteUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RemoteUser))
		soap_serialize_tt__RemoteUser(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RemoteUser(struct soap *soap, const char *tag, int id, struct tt__RemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RemoteUser, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RemoteUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RemoteUser ** SOAP_FMAC4 soap_in_PointerTott__RemoteUser(struct soap *soap, const char *tag, struct tt__RemoteUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RemoteUser **)soap_malloc(soap, sizeof(struct tt__RemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RemoteUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RemoteUser(struct soap *soap, struct tt__RemoteUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RemoteUser(soap, tag ? tag : "tt:RemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RemoteUser ** SOAP_FMAC4 soap_get_PointerTott__RemoteUser(struct soap *soap, struct tt__RemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkHost(struct soap *soap, struct tt__NetworkHost *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkHost))
		soap_serialize_tt__NetworkHost(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkHost(struct soap *soap, const char *tag, int id, struct tt__NetworkHost *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkHost, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkHost(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkHost ** SOAP_FMAC4 soap_in_PointerTott__NetworkHost(struct soap *soap, const char *tag, struct tt__NetworkHost **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkHost **)soap_malloc(soap, sizeof(struct tt__NetworkHost *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkHost(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkHost **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkHost(struct soap *soap, struct tt__NetworkHost *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkHost(soap, tag ? tag : "tt:NetworkHost", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHost ** SOAP_FMAC4 soap_get_PointerTott__NetworkHost(struct soap *soap, struct tt__NetworkHost **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Scope(struct soap *soap, struct tt__Scope *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Scope))
		soap_serialize_tt__Scope(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Scope(struct soap *soap, const char *tag, int id, struct tt__Scope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Scope, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Scope(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Scope ** SOAP_FMAC4 soap_in_PointerTott__Scope(struct soap *soap, const char *tag, struct tt__Scope **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Scope **)soap_malloc(soap, sizeof(struct tt__Scope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Scope(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Scope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Scope(struct soap *soap, struct tt__Scope *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Scope(soap, tag ? tag : "tt:Scope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Scope ** SOAP_FMAC4 soap_get_PointerTott__Scope(struct soap *soap, struct tt__Scope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLog(struct soap *soap, struct tt__SystemLog *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLog))
		soap_serialize_tt__SystemLog(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLog(struct soap *soap, const char *tag, int id, struct tt__SystemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLog, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemLog ** SOAP_FMAC4 soap_in_PointerTott__SystemLog(struct soap *soap, const char *tag, struct tt__SystemLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemLog **)soap_malloc(soap, sizeof(struct tt__SystemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLog(struct soap *soap, struct tt__SystemLog *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemLog(soap, tag ? tag : "tt:SystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLog ** SOAP_FMAC4 soap_get_PointerTott__SystemLog(struct soap *soap, struct tt__SystemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportInformation(struct soap *soap, struct tt__SupportInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportInformation))
		soap_serialize_tt__SupportInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportInformation(struct soap *soap, const char *tag, int id, struct tt__SupportInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportInformation ** SOAP_FMAC4 soap_in_PointerTott__SupportInformation(struct soap *soap, const char *tag, struct tt__SupportInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportInformation **)soap_malloc(soap, sizeof(struct tt__SupportInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportInformation(struct soap *soap, struct tt__SupportInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SupportInformation(soap, tag ? tag : "tt:SupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportInformation ** SOAP_FMAC4 soap_get_PointerTott__SupportInformation(struct soap *soap, struct tt__SupportInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BackupFile(struct soap *soap, struct tt__BackupFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BackupFile))
		soap_serialize_tt__BackupFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BackupFile(struct soap *soap, const char *tag, int id, struct tt__BackupFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BackupFile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BackupFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BackupFile ** SOAP_FMAC4 soap_in_PointerTott__BackupFile(struct soap *soap, const char *tag, struct tt__BackupFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BackupFile **)soap_malloc(soap, sizeof(struct tt__BackupFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BackupFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BackupFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BackupFile, sizeof(struct tt__BackupFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BackupFile(struct soap *soap, struct tt__BackupFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BackupFile(soap, tag ? tag : "tt:BackupFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BackupFile ** SOAP_FMAC4 soap_get_PointerTott__BackupFile(struct soap *soap, struct tt__BackupFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AttachmentData(struct soap *soap, struct tt__AttachmentData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AttachmentData))
		soap_serialize_tt__AttachmentData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AttachmentData(struct soap *soap, const char *tag, int id, struct tt__AttachmentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AttachmentData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AttachmentData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AttachmentData ** SOAP_FMAC4 soap_in_PointerTott__AttachmentData(struct soap *soap, const char *tag, struct tt__AttachmentData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AttachmentData **)soap_malloc(soap, sizeof(struct tt__AttachmentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AttachmentData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AttachmentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AttachmentData, sizeof(struct tt__AttachmentData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AttachmentData(struct soap *soap, struct tt__AttachmentData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AttachmentData(soap, tag ? tag : "tt:AttachmentData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AttachmentData ** SOAP_FMAC4 soap_get_PointerTott__AttachmentData(struct soap *soap, struct tt__AttachmentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemDateTime))
		soap_serialize_tt__SystemDateTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemDateTime(struct soap *soap, const char *tag, int id, struct tt__SystemDateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemDateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemDateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemDateTime ** SOAP_FMAC4 soap_in_PointerTott__SystemDateTime(struct soap *soap, const char *tag, struct tt__SystemDateTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemDateTime **)soap_malloc(soap, sizeof(struct tt__SystemDateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemDateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemDateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemDateTime(soap, tag ? tag : "tt:SystemDateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTime ** SOAP_FMAC4 soap_get_PointerTott__SystemDateTime(struct soap *soap, struct tt__SystemDateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DateTime(struct soap *soap, struct tt__DateTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DateTime))
		soap_serialize_tt__DateTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DateTime(struct soap *soap, const char *tag, int id, struct tt__DateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DateTime ** SOAP_FMAC4 soap_in_PointerTott__DateTime(struct soap *soap, const char *tag, struct tt__DateTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DateTime **)soap_malloc(soap, sizeof(struct tt__DateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DateTime(struct soap *soap, struct tt__DateTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DateTime(soap, tag ? tag : "tt:DateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTime ** SOAP_FMAC4 soap_get_PointerTott__DateTime(struct soap *soap, struct tt__DateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TimeZone(struct soap *soap, struct tt__TimeZone *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TimeZone))
		soap_serialize_tt__TimeZone(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TimeZone(struct soap *soap, const char *tag, int id, struct tt__TimeZone *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TimeZone, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TimeZone(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TimeZone ** SOAP_FMAC4 soap_in_PointerTott__TimeZone(struct soap *soap, const char *tag, struct tt__TimeZone **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TimeZone **)soap_malloc(soap, sizeof(struct tt__TimeZone *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TimeZone(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TimeZone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TimeZone(struct soap *soap, struct tt__TimeZone *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TimeZone(soap, tag ? tag : "tt:TimeZone", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TimeZone ** SOAP_FMAC4 soap_get_PointerTott__TimeZone(struct soap *soap, struct tt__TimeZone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__DeviceServiceCapabilities))
		soap_serialize_tds__DeviceServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__DeviceServiceCapabilities(struct soap *soap, const char *tag, int id, struct tds__DeviceServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__DeviceServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__DeviceServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__DeviceServiceCapabilities(struct soap *soap, const char *tag, struct tds__DeviceServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__DeviceServiceCapabilities **)soap_malloc(soap, sizeof(struct tds__DeviceServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__DeviceServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__DeviceServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__DeviceServiceCapabilities(soap, tag ? tag : "tds:DeviceServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__DeviceServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__Service(struct soap *soap, struct tds__Service *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__Service))
		soap_serialize_tds__Service(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__Service(struct soap *soap, const char *tag, int id, struct tds__Service *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__Service, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__Service(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__Service ** SOAP_FMAC4 soap_in_PointerTotds__Service(struct soap *soap, const char *tag, struct tds__Service **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__Service **)soap_malloc(soap, sizeof(struct tds__Service *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__Service(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__Service **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__Service(struct soap *soap, struct tds__Service *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__Service(soap, tag ? tag : "tds:Service", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__Service ** SOAP_FMAC4 soap_get_PointerTotds__Service(struct soap *soap, struct tds__Service **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, struct _tds__StorageConfigurationData_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StorageConfigurationData_Extension))
		soap_serialize__tds__StorageConfigurationData_Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, int id, struct _tds__StorageConfigurationData_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StorageConfigurationData_Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__StorageConfigurationData_Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__StorageConfigurationData_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, struct _tds__StorageConfigurationData_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__StorageConfigurationData_Extension **)soap_malloc(soap, sizeof(struct _tds__StorageConfigurationData_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__StorageConfigurationData_Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__StorageConfigurationData_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(struct _tds__StorageConfigurationData_Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, struct _tds__StorageConfigurationData_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__StorageConfigurationData_Extension(soap, tag ? tag : "tds:StorageConfigurationData-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StorageConfigurationData_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, struct _tds__StorageConfigurationData_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StorageConfigurationData_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__UserCredential(struct soap *soap, struct tds__UserCredential *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__UserCredential))
		soap_serialize_tds__UserCredential(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__UserCredential(struct soap *soap, const char *tag, int id, struct tds__UserCredential *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__UserCredential, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__UserCredential(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__UserCredential ** SOAP_FMAC4 soap_in_PointerTotds__UserCredential(struct soap *soap, const char *tag, struct tds__UserCredential **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__UserCredential **)soap_malloc(soap, sizeof(struct tds__UserCredential *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__UserCredential(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__UserCredential **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__UserCredential, sizeof(struct tds__UserCredential), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__UserCredential(struct soap *soap, struct tds__UserCredential *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__UserCredential(soap, tag ? tag : "tds:UserCredential", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__UserCredential ** SOAP_FMAC4 soap_get_PointerTotds__UserCredential(struct soap *soap, struct tds__UserCredential **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__UserCredential(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UserCredential_Extension(struct soap *soap, struct _tds__UserCredential_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UserCredential_Extension))
		soap_serialize__tds__UserCredential_Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UserCredential_Extension(struct soap *soap, const char *tag, int id, struct _tds__UserCredential_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UserCredential_Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__UserCredential_Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__UserCredential_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__UserCredential_Extension(struct soap *soap, const char *tag, struct _tds__UserCredential_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__UserCredential_Extension **)soap_malloc(soap, sizeof(struct _tds__UserCredential_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__UserCredential_Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__UserCredential_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UserCredential_Extension, sizeof(struct _tds__UserCredential_Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UserCredential_Extension(struct soap *soap, struct _tds__UserCredential_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__UserCredential_Extension(soap, tag ? tag : "tds:UserCredential-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UserCredential_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__UserCredential_Extension(struct soap *soap, struct _tds__UserCredential_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UserCredential_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__MiscCapabilities))
		soap_serialize_tds__MiscCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__MiscCapabilities(struct soap *soap, const char *tag, int id, struct tds__MiscCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__MiscCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__MiscCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__MiscCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__MiscCapabilities(struct soap *soap, const char *tag, struct tds__MiscCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__MiscCapabilities **)soap_malloc(soap, sizeof(struct tds__MiscCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__MiscCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__MiscCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__MiscCapabilities, sizeof(struct tds__MiscCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__MiscCapabilities(soap, tag ? tag : "tds:MiscCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__MiscCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__MiscCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__SystemCapabilities))
		soap_serialize_tds__SystemCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__SystemCapabilities(struct soap *soap, const char *tag, int id, struct tds__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__SystemCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__SystemCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__SystemCapabilities(struct soap *soap, const char *tag, struct tds__SystemCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__SystemCapabilities **)soap_malloc(soap, sizeof(struct tds__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__SystemCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__SystemCapabilities, sizeof(struct tds__SystemCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__SystemCapabilities(soap, tag ? tag : "tds:SystemCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__SecurityCapabilities))
		soap_serialize_tds__SecurityCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__SecurityCapabilities(struct soap *soap, const char *tag, int id, struct tds__SecurityCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__SecurityCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__SecurityCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__SecurityCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__SecurityCapabilities(struct soap *soap, const char *tag, struct tds__SecurityCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__SecurityCapabilities **)soap_malloc(soap, sizeof(struct tds__SecurityCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__SecurityCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__SecurityCapabilities, sizeof(struct tds__SecurityCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__SecurityCapabilities(soap, tag ? tag : "tds:SecurityCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__SecurityCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__NetworkCapabilities))
		soap_serialize_tds__NetworkCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__NetworkCapabilities(struct soap *soap, const char *tag, int id, struct tds__NetworkCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__NetworkCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__NetworkCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__NetworkCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__NetworkCapabilities(struct soap *soap, const char *tag, struct tds__NetworkCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__NetworkCapabilities **)soap_malloc(soap, sizeof(struct tds__NetworkCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__NetworkCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__NetworkCapabilities, sizeof(struct tds__NetworkCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__NetworkCapabilities(soap, tag ? tag : "tds:NetworkCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__NetworkCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OnvifVersion))
		soap_serialize_tt__OnvifVersion(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OnvifVersion(struct soap *soap, const char *tag, int id, struct tt__OnvifVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OnvifVersion, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OnvifVersion(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OnvifVersion ** SOAP_FMAC4 soap_in_PointerTott__OnvifVersion(struct soap *soap, const char *tag, struct tt__OnvifVersion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OnvifVersion **)soap_malloc(soap, sizeof(struct tt__OnvifVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OnvifVersion(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OnvifVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OnvifVersion(soap, tag ? tag : "tt:OnvifVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OnvifVersion ** SOAP_FMAC4 soap_get_PointerTott__OnvifVersion(struct soap *soap, struct tt__OnvifVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__Service_Capabilities))
		soap_serialize__tds__Service_Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__Service_Capabilities(struct soap *soap, const char *tag, int id, struct _tds__Service_Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__Service_Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__Service_Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__Service_Capabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__Service_Capabilities(struct soap *soap, const char *tag, struct _tds__Service_Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__Service_Capabilities **)soap_malloc(soap, sizeof(struct _tds__Service_Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__Service_Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__Service_Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__Service_Capabilities(soap, tag ? tag : "tds:Service-Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__Service_Capabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__Service_Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__SerialData(struct soap *soap, struct tmd__SerialData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__SerialData))
		soap_serialize_tmd__SerialData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__SerialData(struct soap *soap, const char *tag, int id, struct tmd__SerialData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__SerialData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__SerialData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__SerialData ** SOAP_FMAC4 soap_in_PointerTotmd__SerialData(struct soap *soap, const char *tag, struct tmd__SerialData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__SerialData **)soap_malloc(soap, sizeof(struct tmd__SerialData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__SerialData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__SerialData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__SerialData, sizeof(struct tmd__SerialData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__SerialData(struct soap *soap, struct tmd__SerialData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotmd__SerialData(soap, tag ? tag : "tmd:SerialData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__SerialData ** SOAP_FMAC4 soap_get_PointerTotmd__SerialData(struct soap *soap, struct tmd__SerialData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__SerialData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__SerialPortConfigurationOptions(struct soap *soap, struct tmd__SerialPortConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__SerialPortConfigurationOptions))
		soap_serialize_tmd__SerialPortConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__SerialPortConfigurationOptions(struct soap *soap, const char *tag, int id, struct tmd__SerialPortConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__SerialPortConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__SerialPortConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__SerialPortConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTotmd__SerialPortConfigurationOptions(struct soap *soap, const char *tag, struct tmd__SerialPortConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__SerialPortConfigurationOptions **)soap_malloc(soap, sizeof(struct tmd__SerialPortConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__SerialPortConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__SerialPortConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__SerialPortConfigurationOptions, sizeof(struct tmd__SerialPortConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__SerialPortConfigurationOptions(struct soap *soap, struct tmd__SerialPortConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotmd__SerialPortConfigurationOptions(soap, tag ? tag : "tmd:SerialPortConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__SerialPortConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTotmd__SerialPortConfigurationOptions(struct soap *soap, struct tmd__SerialPortConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__SerialPortConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__SerialPortConfiguration(struct soap *soap, struct tmd__SerialPortConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__SerialPortConfiguration))
		soap_serialize_tmd__SerialPortConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__SerialPortConfiguration(struct soap *soap, const char *tag, int id, struct tmd__SerialPortConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__SerialPortConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__SerialPortConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__SerialPortConfiguration ** SOAP_FMAC4 soap_in_PointerTotmd__SerialPortConfiguration(struct soap *soap, const char *tag, struct tmd__SerialPortConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__SerialPortConfiguration **)soap_malloc(soap, sizeof(struct tmd__SerialPortConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__SerialPortConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__SerialPortConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__SerialPortConfiguration, sizeof(struct tmd__SerialPortConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__SerialPortConfiguration(struct soap *soap, struct tmd__SerialPortConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotmd__SerialPortConfiguration(soap, tag ? tag : "tmd:SerialPortConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__SerialPortConfiguration ** SOAP_FMAC4 soap_get_PointerTotmd__SerialPortConfiguration(struct soap *soap, struct tmd__SerialPortConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__SerialPortConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__SerialPort(struct soap *soap, struct tmd__SerialPort *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__SerialPort))
		soap_serialize_tmd__SerialPort(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__SerialPort(struct soap *soap, const char *tag, int id, struct tmd__SerialPort *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__SerialPort, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__SerialPort(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__SerialPort ** SOAP_FMAC4 soap_in_PointerTotmd__SerialPort(struct soap *soap, const char *tag, struct tmd__SerialPort **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__SerialPort **)soap_malloc(soap, sizeof(struct tmd__SerialPort *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__SerialPort(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__SerialPort **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__SerialPort, sizeof(struct tmd__SerialPort), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__SerialPort(struct soap *soap, struct tmd__SerialPort *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotmd__SerialPort(soap, tag ? tag : "tmd:SerialPort", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__SerialPort ** SOAP_FMAC4 soap_get_PointerTotmd__SerialPort(struct soap *soap, struct tmd__SerialPort **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__SerialPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__DigitalInputConfigurationOptions(struct soap *soap, struct tmd__DigitalInputConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__DigitalInputConfigurationOptions))
		soap_serialize_tmd__DigitalInputConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__DigitalInputConfigurationOptions(struct soap *soap, const char *tag, int id, struct tmd__DigitalInputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__DigitalInputConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__DigitalInputConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__DigitalInputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTotmd__DigitalInputConfigurationOptions(struct soap *soap, const char *tag, struct tmd__DigitalInputConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__DigitalInputConfigurationOptions **)soap_malloc(soap, sizeof(struct tmd__DigitalInputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__DigitalInputConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__DigitalInputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__DigitalInputConfigurationOptions, sizeof(struct tmd__DigitalInputConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__DigitalInputConfigurationOptions(struct soap *soap, struct tmd__DigitalInputConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotmd__DigitalInputConfigurationOptions(soap, tag ? tag : "tmd:DigitalInputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__DigitalInputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTotmd__DigitalInputConfigurationOptions(struct soap *soap, struct tmd__DigitalInputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__DigitalInputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
