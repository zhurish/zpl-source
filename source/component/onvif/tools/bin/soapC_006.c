/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:05 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *p;
	struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroySubscriptionFaultType_Description *p;
	struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *p;
	struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const struct wsnt__UnableToDestroySubscriptionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description);
			soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnableToDestroySubscriptionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToDestroySubscriptionFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToDestroySubscriptionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToDestroySubscriptionFaultType *p;
	struct wsnt__UnableToDestroySubscriptionFaultType *a = (struct wsnt__UnableToDestroySubscriptionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToDestroySubscriptionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToDestroySubscriptionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const struct wsnt__UnableToDestroySubscriptionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *p;
	struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableTerminationTimeFaultType_Description *p;
	struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *p;
	struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	soap_default_dateTime(soap, &a->MinimumTime);
	a->MaximumTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description);
			soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	soap_embedded(soap, &a->MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->MaximumTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:MinimumTime", -1, &a->MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:MaximumTime", -1, &a->MaximumTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, struct wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	size_t soap_flag_MinimumTime = 1;
	size_t soap_flag_MaximumTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnacceptableTerminationTimeFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnacceptableTerminationTimeFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:MinimumTime", &a->MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime--;
					continue;
				}
			}
			if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:MaximumTime", &a->MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || soap_flag_MinimumTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnacceptableTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_new_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, int n)
{
	struct wsnt__UnacceptableTerminationTimeFaultType *p;
	struct wsnt__UnacceptableTerminationTimeFaultType *a = (struct wsnt__UnacceptableTerminationTimeFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnacceptableTerminationTimeFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnacceptableTerminationTimeFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableTerminationTimeFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *p;
	struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToCreatePullPointFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToCreatePullPointFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToCreatePullPointFaultType_Description *p;
	struct _wsnt__UnableToCreatePullPointFaultType_Description *a = (struct _wsnt__UnableToCreatePullPointFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToCreatePullPointFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *p;
	struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const struct wsnt__UnableToCreatePullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description);
			soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnableToCreatePullPointFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToCreatePullPointFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToCreatePullPointFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToCreatePullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToCreatePullPointFaultType *p;
	struct wsnt__UnableToCreatePullPointFaultType *a = (struct wsnt__UnableToCreatePullPointFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToCreatePullPointFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToCreatePullPointFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const struct wsnt__UnableToCreatePullPointFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *p;
	struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroyPullPointFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToDestroyPullPointFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroyPullPointFaultType_Description *p;
	struct _wsnt__UnableToDestroyPullPointFaultType_Description *a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroyPullPointFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *p;
	struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, struct wsnt__UnableToDestroyPullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const struct wsnt__UnableToDestroyPullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description);
			soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToDestroyPullPointFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToDestroyPullPointFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnableToDestroyPullPointFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(struct wsnt__UnableToDestroyPullPointFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToDestroyPullPointFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToDestroyPullPointFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToDestroyPullPointFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToDestroyPullPointFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToDestroyPullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(struct wsnt__UnableToDestroyPullPointFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToDestroyPullPointFaultType *p;
	struct wsnt__UnableToDestroyPullPointFaultType *a = (struct wsnt__UnableToDestroyPullPointFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToDestroyPullPointFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToDestroyPullPointFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const struct wsnt__UnableToDestroyPullPointFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroyPullPointFaultType(struct soap *soap, struct wsnt__UnableToDestroyPullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToGetMessagesFaultType_FaultCause *p;
	struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToGetMessagesFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToGetMessagesFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToGetMessagesFaultType_Description *p;
	struct _wsnt__UnableToGetMessagesFaultType_Description *a = (struct _wsnt__UnableToGetMessagesFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToGetMessagesFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *p;
	struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToGetMessagesFaultType(struct soap *soap, struct wsnt__UnableToGetMessagesFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const struct wsnt__UnableToGetMessagesFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description);
			soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToGetMessagesFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToGetMessagesFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnableToGetMessagesFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(struct wsnt__UnableToGetMessagesFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToGetMessagesFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToGetMessagesFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToGetMessagesFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToGetMessagesFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToGetMessagesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(struct wsnt__UnableToGetMessagesFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToGetMessagesFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToGetMessagesFaultType *p;
	struct wsnt__UnableToGetMessagesFaultType *a = (struct wsnt__UnableToGetMessagesFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToGetMessagesFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToGetMessagesFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToGetMessagesFaultType(struct soap *soap, const struct wsnt__UnableToGetMessagesFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag ? tag : "wsnt:UnableToGetMessagesFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToGetMessagesFaultType(struct soap *soap, struct wsnt__UnableToGetMessagesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *p;
	struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description * SOAP_FMAC4 soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description * SOAP_FMAC4 soap_new__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *p;
	struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description * SOAP_FMAC4 soap_get__wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *p;
	struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct wsnt__NoCurrentMessageOnTopicFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const struct wsnt__NoCurrentMessageOnTopicFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description);
			soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_in_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, struct wsnt__NoCurrentMessageOnTopicFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__NoCurrentMessageOnTopicFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__NoCurrentMessageOnTopicFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__NoCurrentMessageOnTopicFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_new_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, int n)
{
	struct wsnt__NoCurrentMessageOnTopicFaultType *p;
	struct wsnt__NoCurrentMessageOnTopicFaultType *a = (struct wsnt__NoCurrentMessageOnTopicFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__NoCurrentMessageOnTopicFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const struct wsnt__NoCurrentMessageOnTopicFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag ? tag : "wsnt:NoCurrentMessageOnTopicFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC4 soap_get_wsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct wsnt__NoCurrentMessageOnTopicFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *p;
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *p;
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *p;
	struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableInitialTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	soap_default_dateTime(soap, &a->MinimumTime);
	a->MaximumTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableInitialTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description);
			soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	soap_embedded(soap, &a->MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->MaximumTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:MinimumTime", -1, &a->MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:MaximumTime", -1, &a->MaximumTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, struct wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	size_t soap_flag_MinimumTime = 1;
	size_t soap_flag_MaximumTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:MinimumTime", &a->MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime--;
					continue;
				}
			}
			if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:MaximumTime", &a->MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || soap_flag_MinimumTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_new_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, int n)
{
	struct wsnt__UnacceptableInitialTerminationTimeFaultType *p;
	struct wsnt__UnacceptableInitialTerminationTimeFaultType *a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableInitialTerminationTimeFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableInitialTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableInitialTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *p;
	struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__NotifyMessageNotSupportedFaultType_Description *p;
	struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *p;
	struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const struct wsnt__NotifyMessageNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description);
			soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, struct wsnt__NotifyMessageNotSupportedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__NotifyMessageNotSupportedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__NotifyMessageNotSupportedFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__NotifyMessageNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_new_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, int n)
{
	struct wsnt__NotifyMessageNotSupportedFaultType *p;
	struct wsnt__NotifyMessageNotSupportedFaultType *a = (struct wsnt__NotifyMessageNotSupportedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__NotifyMessageNotSupportedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__NotifyMessageNotSupportedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const struct wsnt__NotifyMessageNotSupportedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag ? tag : "wsnt:NotifyMessageNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *p;
	struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnsupportedPolicyRequestFaultType_Description *p;
	struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *p;
	struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	a->__sizeUnsupportedPolicy = 0;
	a->UnsupportedPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnsupportedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description);
			soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnsupportedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnsupportedPolicy; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnsupportedPolicy + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnsupportedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnsupportedPolicy; i++)
		{	const char *soap_tmp_UnsupportedPolicy = soap_QName2s(soap, a->UnsupportedPolicy[i]);
			if (soap_out__QName(soap, "wsnt:UnsupportedPolicy", -1, (char*const*)(void*)&soap_tmp_UnsupportedPolicy, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, struct wsnt__UnsupportedPolicyRequestFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnsupportedPolicy = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnsupportedPolicyRequestFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnsupportedPolicyRequestFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnsupportedPolicy", 1, NULL))
			{	if (a->UnsupportedPolicy == NULL)
				{	if (soap_blist_UnsupportedPolicy == NULL)
						soap_blist_UnsupportedPolicy = soap_alloc_block(soap);
					a->UnsupportedPolicy = (char **)soap_push_block_max(soap, soap_blist_UnsupportedPolicy, sizeof(char *));
					if (a->UnsupportedPolicy == NULL)
						return NULL;
					*a->UnsupportedPolicy = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnsupportedPolicy", (char**)a->UnsupportedPolicy, "xsd:QName"))
				{	a->__sizeUnsupportedPolicy++;
					a->UnsupportedPolicy = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnsupportedPolicy)
			soap_pop_block(soap, soap_blist_UnsupportedPolicy);
		if (a->__sizeUnsupportedPolicy)
		{	a->UnsupportedPolicy = (char **)soap_save_block(soap, soap_blist_UnsupportedPolicy, NULL, 1);
		}
		else
		{	a->UnsupportedPolicy = NULL;
			if (soap_blist_UnsupportedPolicy)
				soap_end_block(soap, soap_blist_UnsupportedPolicy);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnsupportedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_new_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, int n)
{
	struct wsnt__UnsupportedPolicyRequestFaultType *p;
	struct wsnt__UnsupportedPolicyRequestFaultType *a = (struct wsnt__UnsupportedPolicyRequestFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnsupportedPolicyRequestFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnsupportedPolicyRequestFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnsupportedPolicyRequestFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnsupportedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *p;
	struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *p;
	struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *p;
	struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	a->__sizeUnrecognizedPolicy = 0;
	a->UnrecognizedPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnrecognizedPolicyRequestFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description);
			soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnrecognizedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnrecognizedPolicy; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnrecognizedPolicy + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnrecognizedPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnrecognizedPolicy; i++)
		{	const char *soap_tmp_UnrecognizedPolicy = soap_QName2s(soap, a->UnrecognizedPolicy[i]);
			if (soap_out__QName(soap, "wsnt:UnrecognizedPolicy", -1, (char*const*)(void*)&soap_tmp_UnrecognizedPolicy, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_in_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, struct wsnt__UnrecognizedPolicyRequestFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnrecognizedPolicy = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__UnrecognizedPolicyRequestFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnrecognizedPolicyRequestFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnrecognizedPolicy", 1, NULL))
			{	if (a->UnrecognizedPolicy == NULL)
				{	if (soap_blist_UnrecognizedPolicy == NULL)
						soap_blist_UnrecognizedPolicy = soap_alloc_block(soap);
					a->UnrecognizedPolicy = (char **)soap_push_block_max(soap, soap_blist_UnrecognizedPolicy, sizeof(char *));
					if (a->UnrecognizedPolicy == NULL)
						return NULL;
					*a->UnrecognizedPolicy = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnrecognizedPolicy", (char**)a->UnrecognizedPolicy, "xsd:QName"))
				{	a->__sizeUnrecognizedPolicy++;
					a->UnrecognizedPolicy = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnrecognizedPolicy)
			soap_pop_block(soap, soap_blist_UnrecognizedPolicy);
		if (a->__sizeUnrecognizedPolicy)
		{	a->UnrecognizedPolicy = (char **)soap_save_block(soap, soap_blist_UnrecognizedPolicy, NULL, 1);
		}
		else
		{	a->UnrecognizedPolicy = NULL;
			if (soap_blist_UnrecognizedPolicy)
				soap_end_block(soap, soap_blist_UnrecognizedPolicy);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnrecognizedPolicyRequestFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_new_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, int n)
{
	struct wsnt__UnrecognizedPolicyRequestFaultType *p;
	struct wsnt__UnrecognizedPolicyRequestFaultType *a = (struct wsnt__UnrecognizedPolicyRequestFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnrecognizedPolicyRequestFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const struct wsnt__UnrecognizedPolicyRequestFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag ? tag : "wsnt:UnrecognizedPolicyRequestFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC4 soap_get_wsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *p;
	struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidMessageContentExpressionFaultType_Description *p;
	struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *p;
	struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const struct wsnt__InvalidMessageContentExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidMessageContentExpressionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidMessageContentExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidMessageContentExpressionFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidMessageContentExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidMessageContentExpressionFaultType *p;
	struct wsnt__InvalidMessageContentExpressionFaultType *a = (struct wsnt__InvalidMessageContentExpressionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidMessageContentExpressionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidMessageContentExpressionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const struct wsnt__InvalidMessageContentExpressionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag ? tag : "wsnt:InvalidMessageContentExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *p;
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *p;
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *p;
	struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const struct wsnt__InvalidProducerPropertiesExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidProducerPropertiesExpressionFaultType *p;
	struct wsnt__InvalidProducerPropertiesExpressionFaultType *a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const struct wsnt__InvalidProducerPropertiesExpressionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag ? tag : "wsnt:InvalidProducerPropertiesExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *p;
	struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *p;
	struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *p;
	struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const struct wsnt__MultipleTopicsSpecifiedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description);
			soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_in_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, struct wsnt__MultipleTopicsSpecifiedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__MultipleTopicsSpecifiedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__MultipleTopicsSpecifiedFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__MultipleTopicsSpecifiedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_new_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, int n)
{
	struct wsnt__MultipleTopicsSpecifiedFaultType *p;
	struct wsnt__MultipleTopicsSpecifiedFaultType *a = (struct wsnt__MultipleTopicsSpecifiedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__MultipleTopicsSpecifiedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const struct wsnt__MultipleTopicsSpecifiedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag ? tag : "wsnt:MultipleTopicsSpecifiedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC4 soap_get_wsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicNotSupportedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicNotSupportedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__TopicNotSupportedFaultType_FaultCause *p;
	struct _wsnt__TopicNotSupportedFaultType_FaultCause *a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicNotSupportedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicNotSupportedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__TopicNotSupportedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__TopicNotSupportedFaultType_Description *p;
	struct _wsnt__TopicNotSupportedFaultType_Description *a = (struct _wsnt__TopicNotSupportedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicNotSupportedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicNotSupportedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__TopicNotSupportedFaultType_ErrorCode *p;
	struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicNotSupportedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicNotSupportedFaultType(struct soap *soap, const struct wsnt__TopicNotSupportedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description);
			soap_serialize__wsnt__TopicNotSupportedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_in_wsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, struct wsnt__TopicNotSupportedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__TopicNotSupportedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicNotSupportedFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__TopicNotSupportedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__TopicNotSupportedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__TopicNotSupportedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_new_wsnt__TopicNotSupportedFaultType(struct soap *soap, int n)
{
	struct wsnt__TopicNotSupportedFaultType *p;
	struct wsnt__TopicNotSupportedFaultType *a = (struct wsnt__TopicNotSupportedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicNotSupportedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicNotSupportedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicNotSupportedFaultType(struct soap *soap, const struct wsnt__TopicNotSupportedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicNotSupportedFaultType(soap, tag ? tag : "wsnt:TopicNotSupportedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType * SOAP_FMAC4 soap_get_wsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *p;
	struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidTopicExpressionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidTopicExpressionFaultType_Description *p;
	struct _wsnt__InvalidTopicExpressionFaultType_Description *a = (struct _wsnt__InvalidTopicExpressionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *p;
	struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const struct wsnt__InvalidTopicExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidTopicExpressionFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidTopicExpressionFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidTopicExpressionFaultType *p;
	struct wsnt__InvalidTopicExpressionFaultType *a = (struct wsnt__InvalidTopicExpressionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidTopicExpressionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidTopicExpressionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const struct wsnt__InvalidTopicExpressionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag ? tag : "wsnt:InvalidTopicExpressionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *p;
	struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_new__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *p;
	struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *p;
	struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct wsnt__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description);
			soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__TopicExpressionDialectUnknownFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicExpressionDialectUnknownFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_new_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, int n)
{
	struct wsnt__TopicExpressionDialectUnknownFaultType *p;
	struct wsnt__TopicExpressionDialectUnknownFaultType *a = (struct wsnt__TopicExpressionDialectUnknownFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicExpressionDialectUnknownFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidFilterFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidFilterFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_FaultCause *p;
	struct _wsnt__InvalidFilterFaultType_FaultCause *a = (struct _wsnt__InvalidFilterFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidFilterFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__InvalidFilterFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidFilterFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_Description *p;
	struct _wsnt__InvalidFilterFaultType_Description *a = (struct _wsnt__InvalidFilterFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_Description(soap, tag ? tag : "wsnt:InvalidFilterFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidFilterFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_ErrorCode *p;
	struct _wsnt__InvalidFilterFaultType_ErrorCode *a = (struct _wsnt__InvalidFilterFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidFilterFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	a->__sizeUnknownFilter = 0;
	a->UnknownFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidFilterFaultType(struct soap *soap, const struct wsnt__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description);
			soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnknownFilter; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnknownFilter + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidFilterFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidFilterFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnknownFilter; i++)
		{	const char *soap_tmp_UnknownFilter = soap_QName2s(soap, a->UnknownFilter[i]);
			if (soap_out__QName(soap, "wsnt:UnknownFilter", -1, (char*const*)(void*)&soap_tmp_UnknownFilter, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidFilterFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnknownFilter = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__InvalidFilterFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidFilterFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidFilterFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidFilterFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidFilterFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnknownFilter", 1, NULL))
			{	if (a->UnknownFilter == NULL)
				{	if (soap_blist_UnknownFilter == NULL)
						soap_blist_UnknownFilter = soap_alloc_block(soap);
					a->UnknownFilter = (char **)soap_push_block_max(soap, soap_blist_UnknownFilter, sizeof(char *));
					if (a->UnknownFilter == NULL)
						return NULL;
					*a->UnknownFilter = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnknownFilter", (char**)a->UnknownFilter, "xsd:QName"))
				{	a->__sizeUnknownFilter++;
					a->UnknownFilter = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidFilterFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnknownFilter)
			soap_pop_block(soap, soap_blist_UnknownFilter);
		if (a->__sizeUnknownFilter)
		{	a->UnknownFilter = (char **)soap_save_block(soap, soap_blist_UnknownFilter, NULL, 1);
		}
		else
		{	a->UnknownFilter = NULL;
			if (soap_blist_UnknownFilter)
				soap_end_block(soap, soap_blist_UnknownFilter);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || a->__sizeUnknownFilter < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidFilterFaultType, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidFilterFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidFilterFaultType *p;
	struct wsnt__InvalidFilterFaultType *a = (struct wsnt__InvalidFilterFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidFilterFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidFilterFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidFilterFaultType(struct soap *soap, const struct wsnt__InvalidFilterFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidFilterFaultType(soap, tag ? tag : "wsnt:InvalidFilterFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *p;
	struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_Description *p;
	struct _wsnt__SubscribeCreationFailedFaultType_Description *a = (struct _wsnt__SubscribeCreationFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *p;
	struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const struct wsnt__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description);
			soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, struct wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__SubscribeCreationFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__SubscribeCreationFailedFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_new_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__SubscribeCreationFailedFaultType *p;
	struct wsnt__SubscribeCreationFailedFaultType *a = (struct wsnt__SubscribeCreationFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__SubscribeCreationFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__SubscribeCreationFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const struct wsnt__SubscribeCreationFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDReference(struct soap *soap, struct tt__OSDReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->__item);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDReference(struct soap *soap, const struct tt__OSDReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDReference(struct soap *soap, const char *tag, int id, const struct tt__OSDReference *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ReferenceToken(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct tt__OSDReference * SOAP_FMAC4 soap_in_tt__OSDReference(struct soap *soap, const char *tag, struct tt__OSDReference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct tt__OSDReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDReference, sizeof(struct tt__OSDReference), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_tt__OSDReference(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (!soap_in_tt__ReferenceToken(soap, tag, (char**)&a->__item, "tt:OSDReference"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct tt__OSDReference * SOAP_FMAC4 soap_new_tt__OSDReference(struct soap *soap, int n)
{
	struct tt__OSDReference *p;
	struct tt__OSDReference *a = (struct tt__OSDReference*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDReference));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDReference(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDReference(struct soap *soap, const struct tt__OSDReference *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDReference(soap, tag ? tag : "tt:OSDReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDReference * SOAP_FMAC4 soap_get_tt__OSDReference(struct soap *soap, struct tt__OSDReference *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoder2Configuration(struct soap *soap, struct tt__AudioEncoder2Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_string(soap, &a->Encoding);
	a->Multicast = NULL;
	soap_default_int(soap, &a->Bitrate);
	soap_default_int(soap, &a->SampleRate);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioEncoder2Configuration(struct soap *soap, const struct tt__AudioEncoder2Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_string(soap, (char*const*)&a->Encoding);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_embedded(soap, &a->Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &a->SampleRate, SOAP_TYPE_int);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoder2Configuration(struct soap *soap, const char *tag, int id, const struct tt__AudioEncoder2Configuration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoder2Configuration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->Encoding)
	{	if (soap_element_empty(soap, "tt:Encoding", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Encoding", -1, (char*const*)&a->Encoding, ""))
		return soap->error;
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SampleRate", -1, &a->SampleRate, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioEncoder2Configuration * SOAP_FMAC4 soap_in_tt__AudioEncoder2Configuration(struct soap *soap, const char *tag, struct tt__AudioEncoder2Configuration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRate = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioEncoder2Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoder2Configuration, sizeof(struct tt__AudioEncoder2Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioEncoder2Configuration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Encoding", (char**)&a->Encoding, "xsd:string"))
				{	soap_flag_Encoding--;
					continue;
				}
			}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			}
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Bitrate", &a->Bitrate, "xsd:int"))
				{	soap_flag_Bitrate--;
					continue;
				}
			}
			if (soap_flag_SampleRate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:SampleRate", &a->SampleRate, "xsd:int"))
				{	soap_flag_SampleRate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->Encoding || soap_flag_Bitrate > 0 || soap_flag_SampleRate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioEncoder2Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoder2Configuration, SOAP_TYPE_tt__AudioEncoder2Configuration, sizeof(struct tt__AudioEncoder2Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioEncoder2Configuration * SOAP_FMAC4 soap_new_tt__AudioEncoder2Configuration(struct soap *soap, int n)
{
	struct tt__AudioEncoder2Configuration *p;
	struct tt__AudioEncoder2Configuration *a = (struct tt__AudioEncoder2Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioEncoder2Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncoder2Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoder2Configuration(struct soap *soap, const struct tt__AudioEncoder2Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncoder2Configuration(soap, tag ? tag : "tt:AudioEncoder2Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoder2Configuration * SOAP_FMAC4 soap_get_tt__AudioEncoder2Configuration(struct soap *soap, struct tt__AudioEncoder2Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoder2Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoder2Configuration(struct soap *soap, struct tt__VideoEncoder2Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_string(soap, &a->Encoding);
	a->Resolution = NULL;
	a->RateControl = NULL;
	a->Multicast = NULL;
	soap_default_float(soap, &a->Quality);
	a->__size = 0;
	a->__any = NULL;
	a->GovLength = NULL;
	soap_default_string(soap, &a->Profile);
	a->GuaranteedFrameRate = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoder2Configuration(struct soap *soap, const struct tt__VideoEncoder2Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_string(soap, (char*const*)&a->Encoding);
	soap_serialize_PointerTott__VideoResolution2(soap, &a->Resolution);
	soap_serialize_PointerTott__VideoRateControl2(soap, &a->RateControl);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_embedded(soap, &a->Quality, SOAP_TYPE_float);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoder2Configuration(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoder2Configuration *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (a->GovLength)
	{	soap_set_attr(soap, "GovLength", soap_int2s(soap, *a->GovLength), 1);
	}
	if (a->Profile)
		soap_set_attr(soap, "Profile", soap_string2s(soap, a->Profile), 1);
	if (a->GuaranteedFrameRate)
	{	soap_set_attr(soap, "GuaranteedFrameRate", soap_xsd__boolean2s(soap, *a->GuaranteedFrameRate), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoder2Configuration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->Encoding)
	{	if (soap_element_empty(soap, "tt:Encoding", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tt:Encoding", -1, (char*const*)&a->Encoding, ""))
		return soap->error;
	if (!a->Resolution)
	{	if (soap_element_empty(soap, "tt:Resolution", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoResolution2(soap, "tt:Resolution", -1, &a->Resolution, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoRateControl2(soap, "tt:RateControl", -1, &a->RateControl, ""))
		return soap->error;
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Quality", -1, &a->Quality, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoder2Configuration * SOAP_FMAC4 soap_in_tt__VideoEncoder2Configuration(struct soap *soap, const char *tag, struct tt__VideoEncoder2Configuration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_RateControl = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_Quality = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoEncoder2Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoder2Configuration, sizeof(struct tt__VideoEncoder2Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoder2Configuration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "GovLength", 5, 0);
		if (t)
		{
			if (!(a->GovLength = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->GovLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "Profile", 1, 0), &a->Profile))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "GuaranteedFrameRate", 5, 0);
		if (t)
		{
			if (!(a->GuaranteedFrameRate = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->GuaranteedFrameRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tt:Encoding", (char**)&a->Encoding, "xsd:string"))
				{	soap_flag_Encoding--;
					continue;
				}
			}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution2(soap, "tt:Resolution", &a->Resolution, "tt:VideoResolution2"))
				{	soap_flag_Resolution--;
					continue;
				}
			}
			if (soap_flag_RateControl && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoRateControl2(soap, "tt:RateControl", &a->RateControl, "tt:VideoRateControl2"))
				{	soap_flag_RateControl--;
					continue;
				}
			}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			}
			if (soap_flag_Quality && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Quality", &a->Quality, "xsd:float"))
				{	soap_flag_Quality--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->Encoding || !a->Resolution || soap_flag_Quality > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoEncoder2Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoder2Configuration, SOAP_TYPE_tt__VideoEncoder2Configuration, sizeof(struct tt__VideoEncoder2Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoEncoder2Configuration * SOAP_FMAC4 soap_new_tt__VideoEncoder2Configuration(struct soap *soap, int n)
{
	struct tt__VideoEncoder2Configuration *p;
	struct tt__VideoEncoder2Configuration *a = (struct tt__VideoEncoder2Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoEncoder2Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoder2Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoder2Configuration(struct soap *soap, const struct tt__VideoEncoder2Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoder2Configuration(soap, tag ? tag : "tt:VideoEncoder2Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoder2Configuration * SOAP_FMAC4 soap_get_tt__VideoEncoder2Configuration(struct soap *soap, struct tt__VideoEncoder2Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoder2Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__MoveAndStartTrackingResponse(struct soap *soap, struct _tptz__MoveAndStartTrackingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__MoveAndStartTrackingResponse(struct soap *soap, const struct _tptz__MoveAndStartTrackingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__MoveAndStartTrackingResponse(struct soap *soap, const char *tag, int id, const struct _tptz__MoveAndStartTrackingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__MoveAndStartTrackingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__MoveAndStartTrackingResponse * SOAP_FMAC4 soap_in__tptz__MoveAndStartTrackingResponse(struct soap *soap, const char *tag, struct _tptz__MoveAndStartTrackingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__MoveAndStartTrackingResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__MoveAndStartTrackingResponse, sizeof(struct _tptz__MoveAndStartTrackingResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__MoveAndStartTrackingResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__MoveAndStartTrackingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__MoveAndStartTrackingResponse, SOAP_TYPE__tptz__MoveAndStartTrackingResponse, sizeof(struct _tptz__MoveAndStartTrackingResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__MoveAndStartTrackingResponse * SOAP_FMAC4 soap_new__tptz__MoveAndStartTrackingResponse(struct soap *soap, int n)
{
	struct _tptz__MoveAndStartTrackingResponse *p;
	struct _tptz__MoveAndStartTrackingResponse *a = (struct _tptz__MoveAndStartTrackingResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__MoveAndStartTrackingResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__MoveAndStartTrackingResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__MoveAndStartTrackingResponse(struct soap *soap, const struct _tptz__MoveAndStartTrackingResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__MoveAndStartTrackingResponse(soap, tag ? tag : "tptz:MoveAndStartTrackingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__MoveAndStartTrackingResponse * SOAP_FMAC4 soap_get__tptz__MoveAndStartTrackingResponse(struct soap *soap, struct _tptz__MoveAndStartTrackingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__MoveAndStartTrackingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__MoveAndStartTracking(struct soap *soap, struct _tptz__MoveAndStartTracking *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
	a->GeoLocation = NULL;
	a->TargetPosition = NULL;
	a->Speed = NULL;
	soap_default_xsd__integer(soap, &a->ObjectID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__MoveAndStartTracking(struct soap *soap, const struct _tptz__MoveAndStartTracking *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetToken);
	soap_serialize_PointerTott__GeoLocation(soap, &a->GeoLocation);
	soap_serialize_PointerTott__PTZVector(soap, &a->TargetPosition);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
	soap_serialize_xsd__integer(soap, (char*const*)&a->ObjectID);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__MoveAndStartTracking(struct soap *soap, const char *tag, int id, const struct _tptz__MoveAndStartTracking *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__MoveAndStartTracking), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, (char*const*)&a->PresetToken, ""))
		return soap->error;
	if (soap_out_PointerTott__GeoLocation(soap, "tptz:GeoLocation", -1, &a->GeoLocation, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tptz:TargetPosition", -1, &a->TargetPosition, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "tptz:ObjectID", -1, (char*const*)&a->ObjectID, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__MoveAndStartTracking * SOAP_FMAC4 soap_in__tptz__MoveAndStartTracking(struct soap *soap, const char *tag, struct _tptz__MoveAndStartTracking *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetToken = 1;
	size_t soap_flag_GeoLocation = 1;
	size_t soap_flag_TargetPosition = 1;
	size_t soap_flag_Speed = 1;
	size_t soap_flag_ObjectID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__MoveAndStartTracking*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__MoveAndStartTracking, sizeof(struct _tptz__MoveAndStartTracking), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__MoveAndStartTracking(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", (char**)&a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			}
			if (soap_flag_GeoLocation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoLocation(soap, "tptz:GeoLocation", &a->GeoLocation, "tt:GeoLocation"))
				{	soap_flag_GeoLocation--;
					continue;
				}
			}
			if (soap_flag_TargetPosition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tptz:TargetPosition", &a->TargetPosition, "tt:PTZVector"))
				{	soap_flag_TargetPosition--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap_flag_ObjectID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "tptz:ObjectID", (char**)&a->ObjectID, "xsd:integer"))
				{	soap_flag_ObjectID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__MoveAndStartTracking *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__MoveAndStartTracking, SOAP_TYPE__tptz__MoveAndStartTracking, sizeof(struct _tptz__MoveAndStartTracking), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__MoveAndStartTracking * SOAP_FMAC4 soap_new__tptz__MoveAndStartTracking(struct soap *soap, int n)
{
	struct _tptz__MoveAndStartTracking *p;
	struct _tptz__MoveAndStartTracking *a = (struct _tptz__MoveAndStartTracking*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__MoveAndStartTracking));
	for (p = a; p && n--; p++)
		soap_default__tptz__MoveAndStartTracking(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__MoveAndStartTracking(struct soap *soap, const struct _tptz__MoveAndStartTracking *a, const char *tag, const char *type)
{
	if (soap_out__tptz__MoveAndStartTracking(soap, tag ? tag : "tptz:MoveAndStartTracking", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__MoveAndStartTracking * SOAP_FMAC4 soap_get__tptz__MoveAndStartTracking(struct soap *soap, struct _tptz__MoveAndStartTracking *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__MoveAndStartTracking(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, struct _tptz__GetCompatibleConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePTZConfiguration = 0;
	a->PTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, const struct _tptz__GetCompatibleConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PTZConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZConfiguration; i++)
		{
			soap_embedded(soap, a->PTZConfiguration + i, SOAP_TYPE_tt__PTZConfiguration);
			soap_serialize_tt__PTZConfiguration(soap, a->PTZConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetCompatibleConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePTZConfiguration");
	if (a->PTZConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZConfiguration; i++)
			if (soap_out_tt__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, a->PTZConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurationsResponse * SOAP_FMAC4 soap_in__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, const char *tag, struct _tptz__GetCompatibleConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PTZConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetCompatibleConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, sizeof(struct _tptz__GetCompatibleConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetCompatibleConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PTZConfiguration", 1, NULL))
			{	if (a->PTZConfiguration == NULL)
				{	if (soap_blist_PTZConfiguration == NULL)
						soap_blist_PTZConfiguration = soap_alloc_block(soap);
					a->PTZConfiguration = (struct tt__PTZConfiguration *)soap_push_block_max(soap, soap_blist_PTZConfiguration, sizeof(struct tt__PTZConfiguration));
					if (a->PTZConfiguration == NULL)
						return NULL;
					soap_default_tt__PTZConfiguration(soap, a->PTZConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZConfiguration(soap, "tptz:PTZConfiguration", a->PTZConfiguration, "tt:PTZConfiguration"))
				{	a->__sizePTZConfiguration++;
					a->PTZConfiguration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePTZConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PTZConfiguration)
			soap_pop_block(soap, soap_blist_PTZConfiguration);
		if (a->__sizePTZConfiguration)
		{	a->PTZConfiguration = (struct tt__PTZConfiguration *)soap_save_block(soap, soap_blist_PTZConfiguration, NULL, 1);
		}
		else
		{	a->PTZConfiguration = NULL;
			if (soap_blist_PTZConfiguration)
				soap_end_block(soap, soap_blist_PTZConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetCompatibleConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, sizeof(struct _tptz__GetCompatibleConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurationsResponse * SOAP_FMAC4 soap_new__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, int n)
{
	struct _tptz__GetCompatibleConfigurationsResponse *p;
	struct _tptz__GetCompatibleConfigurationsResponse *a = (struct _tptz__GetCompatibleConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetCompatibleConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetCompatibleConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, const struct _tptz__GetCompatibleConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetCompatibleConfigurationsResponse(soap, tag ? tag : "tptz:GetCompatibleConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurationsResponse * SOAP_FMAC4 soap_get__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, struct _tptz__GetCompatibleConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetCompatibleConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetCompatibleConfigurations(struct soap *soap, struct _tptz__GetCompatibleConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetCompatibleConfigurations(struct soap *soap, const struct _tptz__GetCompatibleConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetCompatibleConfigurations(struct soap *soap, const char *tag, int id, const struct _tptz__GetCompatibleConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetCompatibleConfigurations), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurations * SOAP_FMAC4 soap_in__tptz__GetCompatibleConfigurations(struct soap *soap, const char *tag, struct _tptz__GetCompatibleConfigurations *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetCompatibleConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetCompatibleConfigurations, sizeof(struct _tptz__GetCompatibleConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetCompatibleConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetCompatibleConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetCompatibleConfigurations, SOAP_TYPE__tptz__GetCompatibleConfigurations, sizeof(struct _tptz__GetCompatibleConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurations * SOAP_FMAC4 soap_new__tptz__GetCompatibleConfigurations(struct soap *soap, int n)
{
	struct _tptz__GetCompatibleConfigurations *p;
	struct _tptz__GetCompatibleConfigurations *a = (struct _tptz__GetCompatibleConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetCompatibleConfigurations));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetCompatibleConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetCompatibleConfigurations(struct soap *soap, const struct _tptz__GetCompatibleConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetCompatibleConfigurations(soap, tag ? tag : "tptz:GetCompatibleConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurations * SOAP_FMAC4 soap_get__tptz__GetCompatibleConfigurations(struct soap *soap, struct _tptz__GetCompatibleConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetCompatibleConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RemovePresetTourResponse(struct soap *soap, struct _tptz__RemovePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RemovePresetTourResponse(struct soap *soap, const struct _tptz__RemovePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__RemovePresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePresetTourResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RemovePresetTourResponse * SOAP_FMAC4 soap_in__tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__RemovePresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__RemovePresetTourResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(struct _tptz__RemovePresetTourResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RemovePresetTourResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetTourResponse, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(struct _tptz__RemovePresetTourResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__RemovePresetTourResponse * SOAP_FMAC4 soap_new__tptz__RemovePresetTourResponse(struct soap *soap, int n)
{
	struct _tptz__RemovePresetTourResponse *p;
	struct _tptz__RemovePresetTourResponse *a = (struct _tptz__RemovePresetTourResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__RemovePresetTourResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__RemovePresetTourResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RemovePresetTourResponse(struct soap *soap, const struct _tptz__RemovePresetTourResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__RemovePresetTourResponse(soap, tag ? tag : "tptz:RemovePresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetTourResponse * SOAP_FMAC4 soap_get__tptz__RemovePresetTourResponse(struct soap *soap, struct _tptz__RemovePresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RemovePresetTour(struct soap *soap, struct _tptz__RemovePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RemovePresetTour(struct soap *soap, const struct _tptz__RemovePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetTourToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__RemovePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePresetTour), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->PresetTourToken)
	{	if (soap_element_empty(soap, "tptz:PresetTourToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, (char*const*)&a->PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RemovePresetTour * SOAP_FMAC4 soap_in__tptz__RemovePresetTour(struct soap *soap, const char *tag, struct _tptz__RemovePresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTourToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__RemovePresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetTour, sizeof(struct _tptz__RemovePresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RemovePresetTour(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", (char**)&a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->PresetTourToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetTour, SOAP_TYPE__tptz__RemovePresetTour, sizeof(struct _tptz__RemovePresetTour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__RemovePresetTour * SOAP_FMAC4 soap_new__tptz__RemovePresetTour(struct soap *soap, int n)
{
	struct _tptz__RemovePresetTour *p;
	struct _tptz__RemovePresetTour *a = (struct _tptz__RemovePresetTour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__RemovePresetTour));
	for (p = a; p && n--; p++)
		soap_default__tptz__RemovePresetTour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RemovePresetTour(struct soap *soap, const struct _tptz__RemovePresetTour *a, const char *tag, const char *type)
{
	if (soap_out__tptz__RemovePresetTour(soap, tag ? tag : "tptz:RemovePresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetTour * SOAP_FMAC4 soap_get__tptz__RemovePresetTour(struct soap *soap, struct _tptz__RemovePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__OperatePresetTourResponse(struct soap *soap, struct _tptz__OperatePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__OperatePresetTourResponse(struct soap *soap, const struct _tptz__OperatePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__OperatePresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__OperatePresetTourResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__OperatePresetTourResponse * SOAP_FMAC4 soap_in__tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__OperatePresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__OperatePresetTourResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(struct _tptz__OperatePresetTourResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__OperatePresetTourResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__OperatePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__OperatePresetTourResponse, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(struct _tptz__OperatePresetTourResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__OperatePresetTourResponse * SOAP_FMAC4 soap_new__tptz__OperatePresetTourResponse(struct soap *soap, int n)
{
	struct _tptz__OperatePresetTourResponse *p;
	struct _tptz__OperatePresetTourResponse *a = (struct _tptz__OperatePresetTourResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__OperatePresetTourResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__OperatePresetTourResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__OperatePresetTourResponse(struct soap *soap, const struct _tptz__OperatePresetTourResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__OperatePresetTourResponse(soap, tag ? tag : "tptz:OperatePresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__OperatePresetTourResponse * SOAP_FMAC4 soap_get__tptz__OperatePresetTourResponse(struct soap *soap, struct _tptz__OperatePresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__OperatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__OperatePresetTour(struct soap *soap, struct _tptz__OperatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
	soap_default_tt__PTZPresetTourOperation(soap, &a->Operation);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__OperatePresetTour(struct soap *soap, const struct _tptz__OperatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetTourToken);
	soap_embedded(soap, &a->Operation, SOAP_TYPE_tt__PTZPresetTourOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__OperatePresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__OperatePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__OperatePresetTour), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->PresetTourToken)
	{	if (soap_element_empty(soap, "tptz:PresetTourToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, (char*const*)&a->PresetTourToken, ""))
		return soap->error;
	if (soap_out_tt__PTZPresetTourOperation(soap, "tptz:Operation", -1, &a->Operation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__OperatePresetTour * SOAP_FMAC4 soap_in__tptz__OperatePresetTour(struct soap *soap, const char *tag, struct _tptz__OperatePresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTourToken = 1;
	size_t soap_flag_Operation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__OperatePresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__OperatePresetTour, sizeof(struct _tptz__OperatePresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__OperatePresetTour(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", (char**)&a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			}
			if (soap_flag_Operation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__PTZPresetTourOperation(soap, "tptz:Operation", &a->Operation, "tt:PTZPresetTourOperation"))
				{	soap_flag_Operation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->PresetTourToken || soap_flag_Operation > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__OperatePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__OperatePresetTour, SOAP_TYPE__tptz__OperatePresetTour, sizeof(struct _tptz__OperatePresetTour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__OperatePresetTour * SOAP_FMAC4 soap_new__tptz__OperatePresetTour(struct soap *soap, int n)
{
	struct _tptz__OperatePresetTour *p;
	struct _tptz__OperatePresetTour *a = (struct _tptz__OperatePresetTour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__OperatePresetTour));
	for (p = a; p && n--; p++)
		soap_default__tptz__OperatePresetTour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__OperatePresetTour(struct soap *soap, const struct _tptz__OperatePresetTour *a, const char *tag, const char *type)
{
	if (soap_out__tptz__OperatePresetTour(soap, tag ? tag : "tptz:OperatePresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__OperatePresetTour * SOAP_FMAC4 soap_get__tptz__OperatePresetTour(struct soap *soap, struct _tptz__OperatePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__OperatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__ModifyPresetTourResponse(struct soap *soap, struct _tptz__ModifyPresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__ModifyPresetTourResponse(struct soap *soap, const struct _tptz__ModifyPresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__ModifyPresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ModifyPresetTourResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTourResponse * SOAP_FMAC4 soap_in__tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, struct _tptz__ModifyPresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__ModifyPresetTourResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(struct _tptz__ModifyPresetTourResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__ModifyPresetTourResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__ModifyPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ModifyPresetTourResponse, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(struct _tptz__ModifyPresetTourResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__ModifyPresetTourResponse * SOAP_FMAC4 soap_new__tptz__ModifyPresetTourResponse(struct soap *soap, int n)
{
	struct _tptz__ModifyPresetTourResponse *p;
	struct _tptz__ModifyPresetTourResponse *a = (struct _tptz__ModifyPresetTourResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__ModifyPresetTourResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__ModifyPresetTourResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__ModifyPresetTourResponse(struct soap *soap, const struct _tptz__ModifyPresetTourResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__ModifyPresetTourResponse(soap, tag ? tag : "tptz:ModifyPresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTourResponse * SOAP_FMAC4 soap_get__tptz__ModifyPresetTourResponse(struct soap *soap, struct _tptz__ModifyPresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ModifyPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__ModifyPresetTour(struct soap *soap, struct _tptz__ModifyPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->PresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__ModifyPresetTour(struct soap *soap, const struct _tptz__ModifyPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerTott__PresetTour(soap, &a->PresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ModifyPresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__ModifyPresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ModifyPresetTour), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->PresetTour)
	{	if (soap_element_empty(soap, "tptz:PresetTour", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PresetTour(soap, "tptz:PresetTour", -1, &a->PresetTour, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTour * SOAP_FMAC4 soap_in__tptz__ModifyPresetTour(struct soap *soap, const char *tag, struct _tptz__ModifyPresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTour = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__ModifyPresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(struct _tptz__ModifyPresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__ModifyPresetTour(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_PresetTour && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PresetTour(soap, "tptz:PresetTour", &a->PresetTour, "tt:PresetTour"))
				{	soap_flag_PresetTour--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->PresetTour))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__ModifyPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ModifyPresetTour, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(struct _tptz__ModifyPresetTour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__ModifyPresetTour * SOAP_FMAC4 soap_new__tptz__ModifyPresetTour(struct soap *soap, int n)
{
	struct _tptz__ModifyPresetTour *p;
	struct _tptz__ModifyPresetTour *a = (struct _tptz__ModifyPresetTour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__ModifyPresetTour));
	for (p = a; p && n--; p++)
		soap_default__tptz__ModifyPresetTour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__ModifyPresetTour(struct soap *soap, const struct _tptz__ModifyPresetTour *a, const char *tag, const char *type)
{
	if (soap_out__tptz__ModifyPresetTour(soap, tag ? tag : "tptz:ModifyPresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTour * SOAP_FMAC4 soap_get__tptz__ModifyPresetTour(struct soap *soap, struct _tptz__ModifyPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ModifyPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__CreatePresetTourResponse(struct soap *soap, struct _tptz__CreatePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__CreatePresetTourResponse(struct soap *soap, const struct _tptz__CreatePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetTourToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__CreatePresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__CreatePresetTourResponse), type))
		return soap->error;
	if (a->PresetTourToken)
		soap_element_result(soap, "tptz:PresetTourToken");
	if (!a->PresetTourToken)
	{	if (soap_element_empty(soap, "tptz:PresetTourToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, (char*const*)&a->PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__CreatePresetTourResponse * SOAP_FMAC4 soap_in__tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__CreatePresetTourResponse *a, const char *type)
{
	size_t soap_flag_PresetTourToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__CreatePresetTourResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(struct _tptz__CreatePresetTourResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__CreatePresetTourResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", (char**)&a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PresetTourToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PresetTourToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__CreatePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__CreatePresetTourResponse, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(struct _tptz__CreatePresetTourResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__CreatePresetTourResponse * SOAP_FMAC4 soap_new__tptz__CreatePresetTourResponse(struct soap *soap, int n)
{
	struct _tptz__CreatePresetTourResponse *p;
	struct _tptz__CreatePresetTourResponse *a = (struct _tptz__CreatePresetTourResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__CreatePresetTourResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__CreatePresetTourResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__CreatePresetTourResponse(struct soap *soap, const struct _tptz__CreatePresetTourResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__CreatePresetTourResponse(soap, tag ? tag : "tptz:CreatePresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__CreatePresetTourResponse * SOAP_FMAC4 soap_get__tptz__CreatePresetTourResponse(struct soap *soap, struct _tptz__CreatePresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__CreatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__CreatePresetTour(struct soap *soap, struct _tptz__CreatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__CreatePresetTour(struct soap *soap, const struct _tptz__CreatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__CreatePresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__CreatePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__CreatePresetTour), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__CreatePresetTour * SOAP_FMAC4 soap_in__tptz__CreatePresetTour(struct soap *soap, const char *tag, struct _tptz__CreatePresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__CreatePresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__CreatePresetTour, sizeof(struct _tptz__CreatePresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__CreatePresetTour(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__CreatePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__CreatePresetTour, SOAP_TYPE__tptz__CreatePresetTour, sizeof(struct _tptz__CreatePresetTour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__CreatePresetTour * SOAP_FMAC4 soap_new__tptz__CreatePresetTour(struct soap *soap, int n)
{
	struct _tptz__CreatePresetTour *p;
	struct _tptz__CreatePresetTour *a = (struct _tptz__CreatePresetTour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__CreatePresetTour));
	for (p = a; p && n--; p++)
		soap_default__tptz__CreatePresetTour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__CreatePresetTour(struct soap *soap, const struct _tptz__CreatePresetTour *a, const char *tag, const char *type)
{
	if (soap_out__tptz__CreatePresetTour(soap, tag ? tag : "tptz:CreatePresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__CreatePresetTour * SOAP_FMAC4 soap_get__tptz__CreatePresetTour(struct soap *soap, struct _tptz__CreatePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__CreatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTourOptionsResponse(struct soap *soap, struct _tptz__GetPresetTourOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTourOptionsResponse(struct soap *soap, const struct _tptz__GetPresetTourOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTourOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "tptz:Options");
	if (!a->Options)
	{	if (soap_element_empty(soap, "tptz:Options", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourOptions(soap, "tptz:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptionsResponse * SOAP_FMAC4 soap_in__tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetTourOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetPresetTourOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(struct _tptz__GetPresetTourOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTourOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourOptions(soap, "tptz:Options", &a->Options, "tt:PTZPresetTourOptions"))
				{	soap_flag_Options--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Options))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(struct _tptz__GetPresetTourOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptionsResponse * SOAP_FMAC4 soap_new__tptz__GetPresetTourOptionsResponse(struct soap *soap, int n)
{
	struct _tptz__GetPresetTourOptionsResponse *p;
	struct _tptz__GetPresetTourOptionsResponse *a = (struct _tptz__GetPresetTourOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetTourOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetTourOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTourOptionsResponse(struct soap *soap, const struct _tptz__GetPresetTourOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetTourOptionsResponse(soap, tag ? tag : "tptz:GetPresetTourOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptionsResponse * SOAP_FMAC4 soap_get__tptz__GetPresetTourOptionsResponse(struct soap *soap, struct _tptz__GetPresetTourOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTourOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTourOptions(struct soap *soap, struct _tptz__GetPresetTourOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTourOptions(struct soap *soap, const struct _tptz__GetPresetTourOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetTourToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTourOptions(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTourOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTourOptions), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, (char*const*)&a->PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptions * SOAP_FMAC4 soap_in__tptz__GetPresetTourOptions(struct soap *soap, const char *tag, struct _tptz__GetPresetTourOptions *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTourToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetPresetTourOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(struct _tptz__GetPresetTourOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTourOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", (char**)&a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourOptions, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(struct _tptz__GetPresetTourOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptions * SOAP_FMAC4 soap_new__tptz__GetPresetTourOptions(struct soap *soap, int n)
{
	struct _tptz__GetPresetTourOptions *p;
	struct _tptz__GetPresetTourOptions *a = (struct _tptz__GetPresetTourOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetTourOptions));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetTourOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTourOptions(struct soap *soap, const struct _tptz__GetPresetTourOptions *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetTourOptions(soap, tag ? tag : "tptz:GetPresetTourOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptions * SOAP_FMAC4 soap_get__tptz__GetPresetTourOptions(struct soap *soap, struct _tptz__GetPresetTourOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTourResponse(struct soap *soap, struct _tptz__GetPresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTourResponse(struct soap *soap, const struct _tptz__GetPresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PresetTour(soap, &a->PresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTourResponse), type))
		return soap->error;
	if (a->PresetTour)
		soap_element_result(soap, "tptz:PresetTour");
	if (!a->PresetTour)
	{	if (soap_element_empty(soap, "tptz:PresetTour", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PresetTour(soap, "tptz:PresetTour", -1, &a->PresetTour, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTourResponse * SOAP_FMAC4 soap_in__tptz__GetPresetTourResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetTourResponse *a, const char *type)
{
	size_t soap_flag_PresetTour = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetPresetTourResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(struct _tptz__GetPresetTourResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTourResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetTour && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PresetTour(soap, "tptz:PresetTour", &a->PresetTour, "tt:PresetTour"))
				{	soap_flag_PresetTour--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PresetTour");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PresetTour))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourResponse, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(struct _tptz__GetPresetTourResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetTourResponse * SOAP_FMAC4 soap_new__tptz__GetPresetTourResponse(struct soap *soap, int n)
{
	struct _tptz__GetPresetTourResponse *p;
	struct _tptz__GetPresetTourResponse *a = (struct _tptz__GetPresetTourResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetTourResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetTourResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTourResponse(struct soap *soap, const struct _tptz__GetPresetTourResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetTourResponse(soap, tag ? tag : "tptz:GetPresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourResponse * SOAP_FMAC4 soap_get__tptz__GetPresetTourResponse(struct soap *soap, struct _tptz__GetPresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTour(struct soap *soap, struct _tptz__GetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTour(struct soap *soap, const struct _tptz__GetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetTourToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTour), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->PresetTourToken)
	{	if (soap_element_empty(soap, "tptz:PresetTourToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, (char*const*)&a->PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTour * SOAP_FMAC4 soap_in__tptz__GetPresetTour(struct soap *soap, const char *tag, struct _tptz__GetPresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTourToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetPresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTour, sizeof(struct _tptz__GetPresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTour(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", (char**)&a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->PresetTourToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTour, SOAP_TYPE__tptz__GetPresetTour, sizeof(struct _tptz__GetPresetTour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetTour * SOAP_FMAC4 soap_new__tptz__GetPresetTour(struct soap *soap, int n)
{
	struct _tptz__GetPresetTour *p;
	struct _tptz__GetPresetTour *a = (struct _tptz__GetPresetTour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetTour));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetTour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTour(struct soap *soap, const struct _tptz__GetPresetTour *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetTour(soap, tag ? tag : "tptz:GetPresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTour * SOAP_FMAC4 soap_get__tptz__GetPresetTour(struct soap *soap, struct _tptz__GetPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetToursResponse(struct soap *soap, struct _tptz__GetPresetToursResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePresetTour = 0;
	a->PresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetToursResponse(struct soap *soap, const struct _tptz__GetPresetToursResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PresetTour)
	{	int i;
		for (i = 0; i < (int)a->__sizePresetTour; i++)
		{
			soap_embedded(soap, a->PresetTour + i, SOAP_TYPE_tt__PresetTour);
			soap_serialize_tt__PresetTour(soap, a->PresetTour + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetToursResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetToursResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetToursResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePresetTour");
	if (a->PresetTour)
	{	int i;
		for (i = 0; i < (int)a->__sizePresetTour; i++)
			if (soap_out_tt__PresetTour(soap, "tptz:PresetTour", -1, a->PresetTour + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetToursResponse * SOAP_FMAC4 soap_in__tptz__GetPresetToursResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetToursResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PresetTour = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetPresetToursResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(struct _tptz__GetPresetToursResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetToursResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PresetTour", 1, NULL))
			{	if (a->PresetTour == NULL)
				{	if (soap_blist_PresetTour == NULL)
						soap_blist_PresetTour = soap_alloc_block(soap);
					a->PresetTour = (struct tt__PresetTour *)soap_push_block_max(soap, soap_blist_PresetTour, sizeof(struct tt__PresetTour));
					if (a->PresetTour == NULL)
						return NULL;
					soap_default_tt__PresetTour(soap, a->PresetTour);
				}
				soap_revert(soap);
				if (soap_in_tt__PresetTour(soap, "tptz:PresetTour", a->PresetTour, "tt:PresetTour"))
				{	a->__sizePresetTour++;
					a->PresetTour = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePresetTour");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PresetTour)
			soap_pop_block(soap, soap_blist_PresetTour);
		if (a->__sizePresetTour)
		{	a->PresetTour = (struct tt__PresetTour *)soap_save_block(soap, soap_blist_PresetTour, NULL, 1);
		}
		else
		{	a->PresetTour = NULL;
			if (soap_blist_PresetTour)
				soap_end_block(soap, soap_blist_PresetTour);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetToursResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetToursResponse, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(struct _tptz__GetPresetToursResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetToursResponse * SOAP_FMAC4 soap_new__tptz__GetPresetToursResponse(struct soap *soap, int n)
{
	struct _tptz__GetPresetToursResponse *p;
	struct _tptz__GetPresetToursResponse *a = (struct _tptz__GetPresetToursResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetToursResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetToursResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetToursResponse(struct soap *soap, const struct _tptz__GetPresetToursResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetToursResponse(soap, tag ? tag : "tptz:GetPresetToursResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetToursResponse * SOAP_FMAC4 soap_get__tptz__GetPresetToursResponse(struct soap *soap, struct _tptz__GetPresetToursResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetToursResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTours(struct soap *soap, struct _tptz__GetPresetTours *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTours(struct soap *soap, const struct _tptz__GetPresetTours *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTours(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTours *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTours), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTours * SOAP_FMAC4 soap_in__tptz__GetPresetTours(struct soap *soap, const char *tag, struct _tptz__GetPresetTours *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GetPresetTours*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTours, sizeof(struct _tptz__GetPresetTours), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTours(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTours *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTours, SOAP_TYPE__tptz__GetPresetTours, sizeof(struct _tptz__GetPresetTours), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetTours * SOAP_FMAC4 soap_new__tptz__GetPresetTours(struct soap *soap, int n)
{
	struct _tptz__GetPresetTours *p;
	struct _tptz__GetPresetTours *a = (struct _tptz__GetPresetTours*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetTours));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetTours(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTours(struct soap *soap, const struct _tptz__GetPresetTours *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetTours(soap, tag ? tag : "tptz:GetPresetTours", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTours * SOAP_FMAC4 soap_get__tptz__GetPresetTours(struct soap *soap, struct _tptz__GetPresetTours *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTours(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__StopResponse(struct soap *soap, const struct _tptz__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__StopResponse(struct soap *soap, const char *tag, int id, const struct _tptz__StopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__StopResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__StopResponse * SOAP_FMAC4 soap_in__tptz__StopResponse(struct soap *soap, const char *tag, struct _tptz__StopResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__StopResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__StopResponse, sizeof(struct _tptz__StopResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__StopResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__StopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__StopResponse, SOAP_TYPE__tptz__StopResponse, sizeof(struct _tptz__StopResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__StopResponse * SOAP_FMAC4 soap_new__tptz__StopResponse(struct soap *soap, int n)
{
	struct _tptz__StopResponse *p;
	struct _tptz__StopResponse *a = (struct _tptz__StopResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__StopResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__StopResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__StopResponse(struct soap *soap, const struct _tptz__StopResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__StopResponse(soap, tag ? tag : "tptz:StopResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__StopResponse * SOAP_FMAC4 soap_get__tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__Stop(struct soap *soap, struct _tptz__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__Stop(struct soap *soap, const struct _tptz__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerToxsd__boolean(soap, &a->PanTilt);
	soap_serialize_PointerToxsd__boolean(soap, &a->Zoom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__Stop(struct soap *soap, const char *tag, int id, const struct _tptz__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__Stop), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tptz:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tptz:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__Stop * SOAP_FMAC4 soap_in__tptz__Stop(struct soap *soap, const char *tag, struct _tptz__Stop *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__Stop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__Stop, sizeof(struct _tptz__Stop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__Stop(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tptz:PanTilt", &a->PanTilt, "xsd:boolean"))
				{	soap_flag_PanTilt--;
					continue;
				}
			}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tptz:Zoom", &a->Zoom, "xsd:boolean"))
				{	soap_flag_Zoom--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__Stop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__Stop, SOAP_TYPE__tptz__Stop, sizeof(struct _tptz__Stop), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__Stop * SOAP_FMAC4 soap_new__tptz__Stop(struct soap *soap, int n)
{
	struct _tptz__Stop *p;
	struct _tptz__Stop *a = (struct _tptz__Stop*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__Stop));
	for (p = a; p && n--; p++)
		soap_default__tptz__Stop(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__Stop(struct soap *soap, const struct _tptz__Stop *a, const char *tag, const char *type)
{
	if (soap_out__tptz__Stop(soap, tag ? tag : "tptz:Stop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__Stop * SOAP_FMAC4 soap_get__tptz__Stop(struct soap *soap, struct _tptz__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GeoMoveResponse(struct soap *soap, struct _tptz__GeoMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GeoMoveResponse(struct soap *soap, const struct _tptz__GeoMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GeoMoveResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GeoMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GeoMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GeoMoveResponse * SOAP_FMAC4 soap_in__tptz__GeoMoveResponse(struct soap *soap, const char *tag, struct _tptz__GeoMoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GeoMoveResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GeoMoveResponse, sizeof(struct _tptz__GeoMoveResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GeoMoveResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GeoMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GeoMoveResponse, SOAP_TYPE__tptz__GeoMoveResponse, sizeof(struct _tptz__GeoMoveResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GeoMoveResponse * SOAP_FMAC4 soap_new__tptz__GeoMoveResponse(struct soap *soap, int n)
{
	struct _tptz__GeoMoveResponse *p;
	struct _tptz__GeoMoveResponse *a = (struct _tptz__GeoMoveResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GeoMoveResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GeoMoveResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GeoMoveResponse(struct soap *soap, const struct _tptz__GeoMoveResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GeoMoveResponse(soap, tag ? tag : "tptz:GeoMoveResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GeoMoveResponse * SOAP_FMAC4 soap_get__tptz__GeoMoveResponse(struct soap *soap, struct _tptz__GeoMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GeoMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GeoMove(struct soap *soap, struct _tptz__GeoMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Target = NULL;
	a->Speed = NULL;
	a->AreaHeight = NULL;
	a->AreaWidth = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GeoMove(struct soap *soap, const struct _tptz__GeoMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerTott__GeoLocation(soap, &a->Target);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
	soap_serialize_PointerTofloat(soap, &a->AreaHeight);
	soap_serialize_PointerTofloat(soap, &a->AreaWidth);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GeoMove(struct soap *soap, const char *tag, int id, const struct _tptz__GeoMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GeoMove), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->Target)
	{	if (soap_element_empty(soap, "tptz:Target", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__GeoLocation(soap, "tptz:Target", -1, &a->Target, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tptz:AreaHeight", -1, &a->AreaHeight, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tptz:AreaWidth", -1, &a->AreaWidth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GeoMove * SOAP_FMAC4 soap_in__tptz__GeoMove(struct soap *soap, const char *tag, struct _tptz__GeoMove *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Target = 1;
	size_t soap_flag_Speed = 1;
	size_t soap_flag_AreaHeight = 1;
	size_t soap_flag_AreaWidth = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__GeoMove*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GeoMove, sizeof(struct _tptz__GeoMove), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GeoMove(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_Target && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoLocation(soap, "tptz:Target", &a->Target, "tt:GeoLocation"))
				{	soap_flag_Target--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap_flag_AreaHeight && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tptz:AreaHeight", &a->AreaHeight, "xsd:float"))
				{	soap_flag_AreaHeight--;
					continue;
				}
			}
			if (soap_flag_AreaWidth && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tptz:AreaWidth", &a->AreaWidth, "xsd:float"))
				{	soap_flag_AreaWidth--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->Target))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GeoMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GeoMove, SOAP_TYPE__tptz__GeoMove, sizeof(struct _tptz__GeoMove), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GeoMove * SOAP_FMAC4 soap_new__tptz__GeoMove(struct soap *soap, int n)
{
	struct _tptz__GeoMove *p;
	struct _tptz__GeoMove *a = (struct _tptz__GeoMove*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GeoMove));
	for (p = a; p && n--; p++)
		soap_default__tptz__GeoMove(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GeoMove(struct soap *soap, const struct _tptz__GeoMove *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GeoMove(soap, tag ? tag : "tptz:GeoMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GeoMove * SOAP_FMAC4 soap_get__tptz__GeoMove(struct soap *soap, struct _tptz__GeoMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GeoMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__AbsoluteMoveResponse(struct soap *soap, const struct _tptz__AbsoluteMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, int id, const struct _tptz__AbsoluteMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__AbsoluteMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse * SOAP_FMAC4 soap_in__tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, struct _tptz__AbsoluteMoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__AbsoluteMoveResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(struct _tptz__AbsoluteMoveResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__AbsoluteMoveResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__AbsoluteMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__AbsoluteMoveResponse, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(struct _tptz__AbsoluteMoveResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse * SOAP_FMAC4 soap_new__tptz__AbsoluteMoveResponse(struct soap *soap, int n)
{
	struct _tptz__AbsoluteMoveResponse *p;
	struct _tptz__AbsoluteMoveResponse *a = (struct _tptz__AbsoluteMoveResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__AbsoluteMoveResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__AbsoluteMoveResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__AbsoluteMoveResponse(struct soap *soap, const struct _tptz__AbsoluteMoveResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__AbsoluteMoveResponse(soap, tag ? tag : "tptz:AbsoluteMoveResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse * SOAP_FMAC4 soap_get__tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__AbsoluteMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Position = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__AbsoluteMove(struct soap *soap, const struct _tptz__AbsoluteMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerTott__PTZVector(soap, &a->Position);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__AbsoluteMove(struct soap *soap, const char *tag, int id, const struct _tptz__AbsoluteMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__AbsoluteMove), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "tptz:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->Position)
	{	if (soap_element_empty(soap, "tptz:Position", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZVector(soap, "tptz:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__AbsoluteMove * SOAP_FMAC4 soap_in__tptz__AbsoluteMove(struct soap *soap, const char *tag, struct _tptz__AbsoluteMove *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Position = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__AbsoluteMove*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__AbsoluteMove, sizeof(struct _tptz__AbsoluteMove), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__AbsoluteMove(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tptz:Position", &a->Position, "tt:PTZVector"))
				{	soap_flag_Position--;
					continue;
				}
			}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->Position))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__AbsoluteMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__AbsoluteMove, SOAP_TYPE__tptz__AbsoluteMove, sizeof(struct _tptz__AbsoluteMove), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__AbsoluteMove * SOAP_FMAC4 soap_new__tptz__AbsoluteMove(struct soap *soap, int n)
{
	struct _tptz__AbsoluteMove *p;
	struct _tptz__AbsoluteMove *a = (struct _tptz__AbsoluteMove*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__AbsoluteMove));
	for (p = a; p && n--; p++)
		soap_default__tptz__AbsoluteMove(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__AbsoluteMove(struct soap *soap, const struct _tptz__AbsoluteMove *a, const char *tag, const char *type)
{
	if (soap_out__tptz__AbsoluteMove(soap, tag ? tag : "tptz:AbsoluteMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__AbsoluteMove * SOAP_FMAC4 soap_get__tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__AbsoluteMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RelativeMoveResponse(struct soap *soap, const struct _tptz__RelativeMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RelativeMoveResponse(struct soap *soap, const char *tag, int id, const struct _tptz__RelativeMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RelativeMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse * SOAP_FMAC4 soap_in__tptz__RelativeMoveResponse(struct soap *soap, const char *tag, struct _tptz__RelativeMoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tptz__RelativeMoveResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(struct _tptz__RelativeMoveResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RelativeMoveResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__RelativeMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RelativeMoveResponse, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(struct _tptz__RelativeMoveResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse * SOAP_FMAC4 soap_new__tptz__RelativeMoveResponse(struct soap *soap, int n)
{
	struct _tptz__RelativeMoveResponse *p;
	struct _tptz__RelativeMoveResponse *a = (struct _tptz__RelativeMoveResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__RelativeMoveResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__RelativeMoveResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RelativeMoveResponse(struct soap *soap, const struct _tptz__RelativeMoveResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__RelativeMoveResponse(soap, tag ? tag : "tptz:RelativeMoveResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse * SOAP_FMAC4 soap_get__tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RelativeMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
