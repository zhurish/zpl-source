/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:05 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__CreateAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_tt__AnalyticsEngineInput);
			soap_serialize_tt__AnalyticsEngineInput(soap, a->Configuration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, const char *tag, int id, const struct _tad__CreateAnalyticsEngineControlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfiguration");
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_tt__AnalyticsEngineInput(soap, "tad:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControlResponse * SOAP_FMAC4 soap_in__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineControlResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configuration = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__CreateAnalyticsEngineControlResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse, sizeof(struct _tad__CreateAnalyticsEngineControlResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__CreateAnalyticsEngineControlResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct tt__AnalyticsEngineInput *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct tt__AnalyticsEngineInput));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_tt__AnalyticsEngineInput(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_tt__AnalyticsEngineInput(soap, "tad:Configuration", a->Configuration, "tt:AnalyticsEngineInput"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct tt__AnalyticsEngineInput *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse, sizeof(struct _tad__CreateAnalyticsEngineControlResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControlResponse * SOAP_FMAC4 soap_new__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, int n)
{
	struct _tad__CreateAnalyticsEngineControlResponse *p;
	struct _tad__CreateAnalyticsEngineControlResponse *a = (struct _tad__CreateAnalyticsEngineControlResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__CreateAnalyticsEngineControlResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__CreateAnalyticsEngineControlResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__CreateAnalyticsEngineControlResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__CreateAnalyticsEngineControlResponse(soap, tag ? tag : "tad:CreateAnalyticsEngineControlResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControlResponse * SOAP_FMAC4 soap_get__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__CreateAnalyticsEngineControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineControl(struct soap *soap, struct tt__AnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->EngineToken);
	soap_default_tt__ReferenceToken(soap, &a->EngineConfigToken);
	a->__sizeInputToken = 0;
	a->InputToken = NULL;
	a->__sizeReceiverToken = 0;
	a->ReceiverToken = NULL;
	a->Multicast = NULL;
	a->Subscription = NULL;
	soap_default_tt__ModeOfOperation(soap, &a->Mode);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineControl(struct soap *soap, const struct tt__AnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->EngineToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->EngineConfigToken);
	if (a->InputToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeInputToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->InputToken + i));
		}
	}
	if (a->ReceiverToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeReceiverToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->ReceiverToken + i));
		}
	}
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_serialize_PointerTott__Config(soap, &a->Subscription);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineControl *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineControl), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->EngineToken)
	{	if (soap_element_empty(soap, "tt:EngineToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:EngineToken", -1, (char*const*)&a->EngineToken, ""))
		return soap->error;
	if (!a->EngineConfigToken)
	{	if (soap_element_empty(soap, "tt:EngineConfigToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tt:EngineConfigToken", -1, (char*const*)&a->EngineConfigToken, ""))
		return soap->error;
	if (a->InputToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeInputToken; i++)
			if (soap_out_string(soap, "tt:InputToken", -1, (char*const*)(a->InputToken + i), ""))
				return soap->error;
	}
	if (a->ReceiverToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeReceiverToken; i++)
			if (soap_out_string(soap, "tt:ReceiverToken", -1, (char*const*)(a->ReceiverToken + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (!a->Subscription)
	{	if (soap_element_empty(soap, "tt:Subscription", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Config(soap, "tt:Subscription", -1, &a->Subscription, ""))
		return soap->error;
	if (soap_out_tt__ModeOfOperation(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl * SOAP_FMAC4 soap_in_tt__AnalyticsEngineControl(struct soap *soap, const char *tag, struct tt__AnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_EngineToken = 1;
	size_t soap_flag_EngineConfigToken = 1;
	struct soap_blist *soap_blist_InputToken = NULL;
	struct soap_blist *soap_blist_ReceiverToken = NULL;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_Subscription = 1;
	size_t soap_flag_Mode = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsEngineControl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(struct tt__AnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineControl(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_EngineToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:EngineToken", (char**)&a->EngineToken, "tt:ReferenceToken"))
				{	soap_flag_EngineToken--;
					continue;
				}
			}
			if (soap_flag_EngineConfigToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:EngineConfigToken", (char**)&a->EngineConfigToken, "tt:ReferenceToken"))
				{	soap_flag_EngineConfigToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:InputToken", 1, NULL))
			{	if (a->InputToken == NULL)
				{	if (soap_blist_InputToken == NULL)
						soap_blist_InputToken = soap_alloc_block(soap);
					a->InputToken = (char **)soap_push_block_max(soap, soap_blist_InputToken, sizeof(char *));
					if (a->InputToken == NULL)
						return NULL;
					*a->InputToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:InputToken", (char**)a->InputToken, "tt:ReferenceToken"))
				{	a->__sizeInputToken++;
					a->InputToken = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ReceiverToken", 1, NULL))
			{	if (a->ReceiverToken == NULL)
				{	if (soap_blist_ReceiverToken == NULL)
						soap_blist_ReceiverToken = soap_alloc_block(soap);
					a->ReceiverToken = (char **)soap_push_block_max(soap, soap_blist_ReceiverToken, sizeof(char *));
					if (a->ReceiverToken == NULL)
						return NULL;
					*a->ReceiverToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:ReceiverToken", (char**)a->ReceiverToken, "tt:ReferenceToken"))
				{	a->__sizeReceiverToken++;
					a->ReceiverToken = NULL;
					continue;
				}
			}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			}
			if (soap_flag_Subscription && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Config(soap, "tt:Subscription", &a->Subscription, "tt:Config"))
				{	soap_flag_Subscription--;
					continue;
				}
			}
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ModeOfOperation(soap, "tt:Mode", &a->Mode, "tt:ModeOfOperation"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->InputToken)
			soap_pop_block(soap, soap_blist_InputToken);
		if (a->__sizeInputToken)
		{	a->InputToken = (char **)soap_save_block(soap, soap_blist_InputToken, NULL, 1);
		}
		else
		{	a->InputToken = NULL;
			if (soap_blist_InputToken)
				soap_end_block(soap, soap_blist_InputToken);
		}
		if (a->ReceiverToken)
			soap_pop_block(soap, soap_blist_ReceiverToken);
		if (a->__sizeReceiverToken)
		{	a->ReceiverToken = (char **)soap_save_block(soap, soap_blist_ReceiverToken, NULL, 1);
		}
		else
		{	a->ReceiverToken = NULL;
			if (soap_blist_ReceiverToken)
				soap_end_block(soap, soap_blist_ReceiverToken);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->EngineToken || !a->EngineConfigToken || a->__sizeInputToken < 1 || a->__sizeReceiverToken < 1 || !a->Subscription || soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineControl, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(struct tt__AnalyticsEngineControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl * SOAP_FMAC4 soap_new_tt__AnalyticsEngineControl(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineControl *p;
	struct tt__AnalyticsEngineControl *a = (struct tt__AnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineControl(struct soap *soap, const struct tt__AnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineControl(soap, tag ? tag : "tt:AnalyticsEngineControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl * SOAP_FMAC4 soap_get_tt__AnalyticsEngineControl(struct soap *soap, struct tt__AnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__CreateAnalyticsEngineControl(struct soap *soap, struct _tad__CreateAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__CreateAnalyticsEngineControl(struct soap *soap, const struct _tad__CreateAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineControl(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__CreateAnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct _tad__CreateAnalyticsEngineControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__CreateAnalyticsEngineControl), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tad:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsEngineControl(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControl * SOAP_FMAC4 soap_in__tad__CreateAnalyticsEngineControl(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__CreateAnalyticsEngineControl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__CreateAnalyticsEngineControl, sizeof(struct _tad__CreateAnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__CreateAnalyticsEngineControl(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineControl(soap, "tad:Configuration", &a->Configuration, "tt:AnalyticsEngineControl"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__CreateAnalyticsEngineControl, SOAP_TYPE__tad__CreateAnalyticsEngineControl, sizeof(struct _tad__CreateAnalyticsEngineControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControl * SOAP_FMAC4 soap_new__tad__CreateAnalyticsEngineControl(struct soap *soap, int n)
{
	struct _tad__CreateAnalyticsEngineControl *p;
	struct _tad__CreateAnalyticsEngineControl *a = (struct _tad__CreateAnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__CreateAnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default__tad__CreateAnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__CreateAnalyticsEngineControl(struct soap *soap, const struct _tad__CreateAnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out__tad__CreateAnalyticsEngineControl(soap, tag ? tag : "tad:CreateAnalyticsEngineControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControl * SOAP_FMAC4 soap_get__tad__CreateAnalyticsEngineControl(struct soap *soap, struct _tad__CreateAnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__CreateAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, const struct _tad__CreateAnalyticsEngineInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_tt__AnalyticsEngineInput);
			soap_serialize_tt__AnalyticsEngineInput(soap, a->Configuration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, int id, const struct _tad__CreateAnalyticsEngineInputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfiguration");
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_tt__AnalyticsEngineInput(soap, "tad:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_in__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineInputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configuration = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__CreateAnalyticsEngineInputsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, sizeof(struct _tad__CreateAnalyticsEngineInputsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__CreateAnalyticsEngineInputsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct tt__AnalyticsEngineInput *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct tt__AnalyticsEngineInput));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_tt__AnalyticsEngineInput(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_tt__AnalyticsEngineInput(soap, "tad:Configuration", a->Configuration, "tt:AnalyticsEngineInput"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct tt__AnalyticsEngineInput *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineInputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, sizeof(struct _tad__CreateAnalyticsEngineInputsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_new__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, int n)
{
	struct _tad__CreateAnalyticsEngineInputsResponse *p;
	struct _tad__CreateAnalyticsEngineInputsResponse *a = (struct _tad__CreateAnalyticsEngineInputsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__CreateAnalyticsEngineInputsResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__CreateAnalyticsEngineInputsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, const struct _tad__CreateAnalyticsEngineInputsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__CreateAnalyticsEngineInputsResponse(soap, tag ? tag : "tad:CreateAnalyticsEngineInputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_get__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineInputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__CreateAnalyticsEngineInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineInput(struct soap *soap, struct tt__AnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->SourceIdentification = NULL;
	a->VideoInput = NULL;
	a->MetadataInput = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineInput(struct soap *soap, const struct tt__AnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__SourceIdentification(soap, &a->SourceIdentification);
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &a->VideoInput);
	soap_serialize_PointerTott__MetadataInput(soap, &a->MetadataInput);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInput(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineInput *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInput), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->SourceIdentification)
	{	if (soap_element_empty(soap, "tt:SourceIdentification", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SourceIdentification(soap, "tt:SourceIdentification", -1, &a->SourceIdentification, ""))
		return soap->error;
	if (!a->VideoInput)
	{	if (soap_element_empty(soap, "tt:VideoInput", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoInput", -1, &a->VideoInput, ""))
		return soap->error;
	if (!a->MetadataInput)
	{	if (soap_element_empty(soap, "tt:MetadataInput", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MetadataInput(soap, "tt:MetadataInput", -1, &a->MetadataInput, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInput(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInput *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceIdentification = 1;
	size_t soap_flag_VideoInput = 1;
	size_t soap_flag_MetadataInput = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsEngineInput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(struct tt__AnalyticsEngineInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineInput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_SourceIdentification && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SourceIdentification(soap, "tt:SourceIdentification", &a->SourceIdentification, "tt:SourceIdentification"))
				{	soap_flag_SourceIdentification--;
					continue;
				}
			}
			if (soap_flag_VideoInput && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoInput", &a->VideoInput, "tt:VideoEncoderConfiguration"))
				{	soap_flag_VideoInput--;
					continue;
				}
			}
			if (soap_flag_MetadataInput && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataInput(soap, "tt:MetadataInput", &a->MetadataInput, "tt:MetadataInput"))
				{	soap_flag_MetadataInput--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->SourceIdentification || !a->VideoInput || !a->MetadataInput))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInput, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(struct tt__AnalyticsEngineInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput * SOAP_FMAC4 soap_new_tt__AnalyticsEngineInput(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineInput *p;
	struct tt__AnalyticsEngineInput *a = (struct tt__AnalyticsEngineInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineInput));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineInput(struct soap *soap, const struct tt__AnalyticsEngineInput *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineInput(soap, tag ? tag : "tt:AnalyticsEngineInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInput(struct soap *soap, struct tt__AnalyticsEngineInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__CreateAnalyticsEngineInputs(struct soap *soap, struct _tad__CreateAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
	a->__sizeForcePersistence = 0;
	a->ForcePersistence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__CreateAnalyticsEngineInputs(struct soap *soap, const struct _tad__CreateAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_tt__AnalyticsEngineInput);
			soap_serialize_tt__AnalyticsEngineInput(soap, a->Configuration + i);
		}
	}
	if (a->ForcePersistence)
	{	int i;
		for (i = 0; i < (int)a->__sizeForcePersistence; i++)
		{
			soap_embedded(soap, a->ForcePersistence + i, SOAP_TYPE_xsd__boolean);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__CreateAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, const struct _tad__CreateAnalyticsEngineInputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__CreateAnalyticsEngineInputs), type))
		return soap->error;
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_tt__AnalyticsEngineInput(soap, "tad:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	if (a->ForcePersistence)
	{	int i;
		for (i = 0; i < (int)a->__sizeForcePersistence; i++)
			if (soap_out_xsd__boolean(soap, "tad:ForcePersistence", -1, a->ForcePersistence + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputs * SOAP_FMAC4 soap_in__tad__CreateAnalyticsEngineInputs(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineInputs *a, const char *type)
{
	struct soap_blist *soap_blist_Configuration = NULL;
	struct soap_blist *soap_blist_ForcePersistence = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__CreateAnalyticsEngineInputs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, sizeof(struct _tad__CreateAnalyticsEngineInputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__CreateAnalyticsEngineInputs(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct tt__AnalyticsEngineInput *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct tt__AnalyticsEngineInput));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_tt__AnalyticsEngineInput(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_tt__AnalyticsEngineInput(soap, "tad:Configuration", a->Configuration, "tt:AnalyticsEngineInput"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:ForcePersistence", 1, NULL))
			{	if (a->ForcePersistence == NULL)
				{	if (soap_blist_ForcePersistence == NULL)
						soap_blist_ForcePersistence = soap_alloc_block(soap);
					a->ForcePersistence = (enum xsd__boolean *)soap_push_block_max(soap, soap_blist_ForcePersistence, sizeof(enum xsd__boolean));
					if (a->ForcePersistence == NULL)
						return NULL;
					soap_default_xsd__boolean(soap, a->ForcePersistence);
				}
				soap_revert(soap);
				if (soap_in_xsd__boolean(soap, "tad:ForcePersistence", a->ForcePersistence, "xsd:boolean"))
				{	a->__sizeForcePersistence++;
					a->ForcePersistence = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct tt__AnalyticsEngineInput *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (a->ForcePersistence)
			soap_pop_block(soap, soap_blist_ForcePersistence);
		if (a->__sizeForcePersistence)
		{	a->ForcePersistence = (enum xsd__boolean *)soap_save_block(soap, soap_blist_ForcePersistence, NULL, 1);
		}
		else
		{	a->ForcePersistence = NULL;
			if (soap_blist_ForcePersistence)
				soap_end_block(soap, soap_blist_ForcePersistence);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1 || a->__sizeForcePersistence < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineInputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, sizeof(struct _tad__CreateAnalyticsEngineInputs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputs * SOAP_FMAC4 soap_new__tad__CreateAnalyticsEngineInputs(struct soap *soap, int n)
{
	struct _tad__CreateAnalyticsEngineInputs *p;
	struct _tad__CreateAnalyticsEngineInputs *a = (struct _tad__CreateAnalyticsEngineInputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__CreateAnalyticsEngineInputs));
	for (p = a; p && n--; p++)
		soap_default__tad__CreateAnalyticsEngineInputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__CreateAnalyticsEngineInputs(struct soap *soap, const struct _tad__CreateAnalyticsEngineInputs *a, const char *tag, const char *type)
{
	if (soap_out__tad__CreateAnalyticsEngineInputs(soap, tag ? tag : "tad:CreateAnalyticsEngineInputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputs * SOAP_FMAC4 soap_get__tad__CreateAnalyticsEngineInputs(struct soap *soap, struct _tad__CreateAnalyticsEngineInputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__CreateAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__DeleteAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, const char *tag, int id, const struct _tad__DeleteAnalyticsEngineControlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControlResponse * SOAP_FMAC4 soap_in__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineControlResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__DeleteAnalyticsEngineControlResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse, sizeof(struct _tad__DeleteAnalyticsEngineControlResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__DeleteAnalyticsEngineControlResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse, sizeof(struct _tad__DeleteAnalyticsEngineControlResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControlResponse * SOAP_FMAC4 soap_new__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, int n)
{
	struct _tad__DeleteAnalyticsEngineControlResponse *p;
	struct _tad__DeleteAnalyticsEngineControlResponse *a = (struct _tad__DeleteAnalyticsEngineControlResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__DeleteAnalyticsEngineControlResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__DeleteAnalyticsEngineControlResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__DeleteAnalyticsEngineControlResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__DeleteAnalyticsEngineControlResponse(soap, tag ? tag : "tad:DeleteAnalyticsEngineControlResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControlResponse * SOAP_FMAC4 soap_get__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__DeleteAnalyticsEngineControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__DeleteAnalyticsEngineControl(struct soap *soap, struct _tad__DeleteAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__DeleteAnalyticsEngineControl(struct soap *soap, const struct _tad__DeleteAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__DeleteAnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct _tad__DeleteAnalyticsEngineControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineControl), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tad:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tad:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControl * SOAP_FMAC4 soap_in__tad__DeleteAnalyticsEngineControl(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__DeleteAnalyticsEngineControl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineControl, sizeof(struct _tad__DeleteAnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__DeleteAnalyticsEngineControl(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tad:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__DeleteAnalyticsEngineControl, SOAP_TYPE__tad__DeleteAnalyticsEngineControl, sizeof(struct _tad__DeleteAnalyticsEngineControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControl * SOAP_FMAC4 soap_new__tad__DeleteAnalyticsEngineControl(struct soap *soap, int n)
{
	struct _tad__DeleteAnalyticsEngineControl *p;
	struct _tad__DeleteAnalyticsEngineControl *a = (struct _tad__DeleteAnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__DeleteAnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default__tad__DeleteAnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__DeleteAnalyticsEngineControl(struct soap *soap, const struct _tad__DeleteAnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out__tad__DeleteAnalyticsEngineControl(soap, tag ? tag : "tad:DeleteAnalyticsEngineControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControl * SOAP_FMAC4 soap_get__tad__DeleteAnalyticsEngineControl(struct soap *soap, struct _tad__DeleteAnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__DeleteAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetServiceCapabilitiesResponse(struct soap *soap, struct _tad__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tad__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotad__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tad:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tad:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotad__Capabilities(soap, "tad:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tad__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tad__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetServiceCapabilitiesResponse, sizeof(struct _tad__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotad__Capabilities(soap, "tad:Capabilities", &a->Capabilities, "tad:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tad:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetServiceCapabilitiesResponse, SOAP_TYPE__tad__GetServiceCapabilitiesResponse, sizeof(struct _tad__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tad__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tad__GetServiceCapabilitiesResponse *p;
	struct _tad__GetServiceCapabilitiesResponse *a = (struct _tad__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tad__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetServiceCapabilitiesResponse(soap, tag ? tag : "tad:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tad__GetServiceCapabilitiesResponse(struct soap *soap, struct _tad__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetServiceCapabilities(struct soap *soap, struct _tad__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetServiceCapabilities(struct soap *soap, const struct _tad__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tad__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetServiceCapabilities * SOAP_FMAC4 soap_in__tad__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tad__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetServiceCapabilities, sizeof(struct _tad__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetServiceCapabilities, SOAP_TYPE__tad__GetServiceCapabilities, sizeof(struct _tad__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetServiceCapabilities * SOAP_FMAC4 soap_new__tad__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tad__GetServiceCapabilities *p;
	struct _tad__GetServiceCapabilities *a = (struct _tad__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tad__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetServiceCapabilities(struct soap *soap, const struct _tad__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetServiceCapabilities(soap, tag ? tag : "tad:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetServiceCapabilities * SOAP_FMAC4 soap_get__tad__GetServiceCapabilities(struct soap *soap, struct _tad__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tad__Capabilities(struct soap *soap, struct tad__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tad__Capabilities(struct soap *soap, const struct tad__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tad__Capabilities(struct soap *soap, const char *tag, int id, const struct tad__Capabilities *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tad__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tad__Capabilities * SOAP_FMAC4 soap_in_tad__Capabilities(struct soap *soap, const char *tag, struct tad__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tad__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tad__Capabilities, sizeof(struct tad__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tad__Capabilities(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tad__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tad__Capabilities, SOAP_TYPE_tad__Capabilities, sizeof(struct tad__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tad__Capabilities * SOAP_FMAC4 soap_new_tad__Capabilities(struct soap *soap, int n)
{
	struct tad__Capabilities *p;
	struct tad__Capabilities *a = (struct tad__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tad__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tad__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tad__Capabilities(struct soap *soap, const struct tad__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tad__Capabilities(soap, tag ? tag : "tad:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tad__Capabilities * SOAP_FMAC4 soap_get_tad__Capabilities(struct soap *soap, struct tad__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tad__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetSupportedMetadataResponse(struct soap *soap, struct _tan__GetSupportedMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsModule = 0;
	a->AnalyticsModule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetSupportedMetadataResponse(struct soap *soap, const struct _tan__GetSupportedMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
		{
			soap_embedded(soap, a->AnalyticsModule + i, SOAP_TYPE_tan__MetadataInfo);
			soap_serialize_tan__MetadataInfo(soap, a->AnalyticsModule + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetSupportedMetadataResponse(struct soap *soap, const char *tag, int id, const struct _tan__GetSupportedMetadataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetSupportedMetadataResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAnalyticsModule");
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
			if (soap_out_tan__MetadataInfo(soap, "tan:AnalyticsModule", -1, a->AnalyticsModule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetSupportedMetadataResponse * SOAP_FMAC4 soap_in__tan__GetSupportedMetadataResponse(struct soap *soap, const char *tag, struct _tan__GetSupportedMetadataResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsModule = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetSupportedMetadataResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedMetadataResponse, sizeof(struct _tan__GetSupportedMetadataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetSupportedMetadataResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModule", 1, NULL))
			{	if (a->AnalyticsModule == NULL)
				{	if (soap_blist_AnalyticsModule == NULL)
						soap_blist_AnalyticsModule = soap_alloc_block(soap);
					a->AnalyticsModule = (struct tan__MetadataInfo *)soap_push_block_max(soap, soap_blist_AnalyticsModule, sizeof(struct tan__MetadataInfo));
					if (a->AnalyticsModule == NULL)
						return NULL;
					soap_default_tan__MetadataInfo(soap, a->AnalyticsModule);
				}
				soap_revert(soap);
				if (soap_in_tan__MetadataInfo(soap, "tan:AnalyticsModule", a->AnalyticsModule, "tan:MetadataInfo"))
				{	a->__sizeAnalyticsModule++;
					a->AnalyticsModule = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAnalyticsModule");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModule)
			soap_pop_block(soap, soap_blist_AnalyticsModule);
		if (a->__sizeAnalyticsModule)
		{	a->AnalyticsModule = (struct tan__MetadataInfo *)soap_save_block(soap, soap_blist_AnalyticsModule, NULL, 1);
		}
		else
		{	a->AnalyticsModule = NULL;
			if (soap_blist_AnalyticsModule)
				soap_end_block(soap, soap_blist_AnalyticsModule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedMetadataResponse, SOAP_TYPE__tan__GetSupportedMetadataResponse, sizeof(struct _tan__GetSupportedMetadataResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetSupportedMetadataResponse * SOAP_FMAC4 soap_new__tan__GetSupportedMetadataResponse(struct soap *soap, int n)
{
	struct _tan__GetSupportedMetadataResponse *p;
	struct _tan__GetSupportedMetadataResponse *a = (struct _tan__GetSupportedMetadataResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetSupportedMetadataResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__GetSupportedMetadataResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetSupportedMetadataResponse(struct soap *soap, const struct _tan__GetSupportedMetadataResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetSupportedMetadataResponse(soap, tag ? tag : "tan:GetSupportedMetadataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedMetadataResponse * SOAP_FMAC4 soap_get__tan__GetSupportedMetadataResponse(struct soap *soap, struct _tan__GetSupportedMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetSupportedMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetSupportedMetadata(struct soap *soap, struct _tan__GetSupportedMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetSupportedMetadata(struct soap *soap, const struct _tan__GetSupportedMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->Type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetSupportedMetadata(struct soap *soap, const char *tag, int id, const struct _tan__GetSupportedMetadata *a, const char *type)
{
	const char *soap_tmp_Type;
	soap_tmp_Type = soap_QName2s(soap, a->Type);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetSupportedMetadata), type))
		return soap->error;
	if (soap_out__QName(soap, "tan:Type", -1, (char*const*)(void*)&soap_tmp_Type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetSupportedMetadata * SOAP_FMAC4 soap_in__tan__GetSupportedMetadata(struct soap *soap, const char *tag, struct _tan__GetSupportedMetadata *a, const char *type)
{
	size_t soap_flag_Type = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetSupportedMetadata*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedMetadata, sizeof(struct _tan__GetSupportedMetadata), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetSupportedMetadata(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "tan:Type", (char**)&a->Type, "xsd:QName"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedMetadata, SOAP_TYPE__tan__GetSupportedMetadata, sizeof(struct _tan__GetSupportedMetadata), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetSupportedMetadata * SOAP_FMAC4 soap_new__tan__GetSupportedMetadata(struct soap *soap, int n)
{
	struct _tan__GetSupportedMetadata *p;
	struct _tan__GetSupportedMetadata *a = (struct _tan__GetSupportedMetadata*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetSupportedMetadata));
	for (p = a; p && n--; p++)
		soap_default__tan__GetSupportedMetadata(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetSupportedMetadata(struct soap *soap, const struct _tan__GetSupportedMetadata *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetSupportedMetadata(soap, tag ? tag : "tan:GetSupportedMetadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedMetadata * SOAP_FMAC4 soap_get__tan__GetSupportedMetadata(struct soap *soap, struct _tan__GetSupportedMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetSupportedMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetAnalyticsModuleOptionsResponse(struct soap *soap, struct _tan__GetAnalyticsModuleOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOptions = 0;
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetAnalyticsModuleOptionsResponse(struct soap *soap, const struct _tan__GetAnalyticsModuleOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Options)
	{	int i;
		for (i = 0; i < (int)a->__sizeOptions; i++)
		{
			soap_embedded(soap, a->Options + i, SOAP_TYPE_tan__ConfigOptions);
			soap_serialize_tan__ConfigOptions(soap, a->Options + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetAnalyticsModuleOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tan__GetAnalyticsModuleOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetAnalyticsModuleOptionsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeOptions");
	if (a->Options)
	{	int i;
		for (i = 0; i < (int)a->__sizeOptions; i++)
			if (soap_out_tan__ConfigOptions(soap, "tan:Options", -1, a->Options + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModuleOptionsResponse * SOAP_FMAC4 soap_in__tan__GetAnalyticsModuleOptionsResponse(struct soap *soap, const char *tag, struct _tan__GetAnalyticsModuleOptionsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Options = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetAnalyticsModuleOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetAnalyticsModuleOptionsResponse, sizeof(struct _tan__GetAnalyticsModuleOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetAnalyticsModuleOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:Options", 1, NULL))
			{	if (a->Options == NULL)
				{	if (soap_blist_Options == NULL)
						soap_blist_Options = soap_alloc_block(soap);
					a->Options = (struct tan__ConfigOptions *)soap_push_block_max(soap, soap_blist_Options, sizeof(struct tan__ConfigOptions));
					if (a->Options == NULL)
						return NULL;
					soap_default_tan__ConfigOptions(soap, a->Options);
				}
				soap_revert(soap);
				if (soap_in_tan__ConfigOptions(soap, "tan:Options", a->Options, "tan:ConfigOptions"))
				{	a->__sizeOptions++;
					a->Options = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Options)
			soap_pop_block(soap, soap_blist_Options);
		if (a->__sizeOptions)
		{	a->Options = (struct tan__ConfigOptions *)soap_save_block(soap, soap_blist_Options, NULL, 1);
		}
		else
		{	a->Options = NULL;
			if (soap_blist_Options)
				soap_end_block(soap, soap_blist_Options);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__GetAnalyticsModuleOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetAnalyticsModuleOptionsResponse, SOAP_TYPE__tan__GetAnalyticsModuleOptionsResponse, sizeof(struct _tan__GetAnalyticsModuleOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetAnalyticsModuleOptionsResponse * SOAP_FMAC4 soap_new__tan__GetAnalyticsModuleOptionsResponse(struct soap *soap, int n)
{
	struct _tan__GetAnalyticsModuleOptionsResponse *p;
	struct _tan__GetAnalyticsModuleOptionsResponse *a = (struct _tan__GetAnalyticsModuleOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetAnalyticsModuleOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__GetAnalyticsModuleOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetAnalyticsModuleOptionsResponse(struct soap *soap, const struct _tan__GetAnalyticsModuleOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetAnalyticsModuleOptionsResponse(soap, tag ? tag : "tan:GetAnalyticsModuleOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModuleOptionsResponse * SOAP_FMAC4 soap_get__tan__GetAnalyticsModuleOptionsResponse(struct soap *soap, struct _tan__GetAnalyticsModuleOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetAnalyticsModuleOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetAnalyticsModuleOptions(struct soap *soap, struct _tan__GetAnalyticsModuleOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->Type);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetAnalyticsModuleOptions(struct soap *soap, const struct _tan__GetAnalyticsModuleOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->Type);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetAnalyticsModuleOptions(struct soap *soap, const char *tag, int id, const struct _tan__GetAnalyticsModuleOptions *a, const char *type)
{
	const char *soap_tmp_Type;
	soap_tmp_Type = soap_QName2s(soap, a->Type);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetAnalyticsModuleOptions), type))
		return soap->error;
	if (soap_out__QName(soap, "tan:Type", -1, (char*const*)(void*)&soap_tmp_Type, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tan:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModuleOptions * SOAP_FMAC4 soap_in__tan__GetAnalyticsModuleOptions(struct soap *soap, const char *tag, struct _tan__GetAnalyticsModuleOptions *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetAnalyticsModuleOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetAnalyticsModuleOptions, sizeof(struct _tan__GetAnalyticsModuleOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetAnalyticsModuleOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "tan:Type", (char**)&a->Type, "xsd:QName"))
				{	soap_flag_Type--;
					continue;
				}
			}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__GetAnalyticsModuleOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetAnalyticsModuleOptions, SOAP_TYPE__tan__GetAnalyticsModuleOptions, sizeof(struct _tan__GetAnalyticsModuleOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetAnalyticsModuleOptions * SOAP_FMAC4 soap_new__tan__GetAnalyticsModuleOptions(struct soap *soap, int n)
{
	struct _tan__GetAnalyticsModuleOptions *p;
	struct _tan__GetAnalyticsModuleOptions *a = (struct _tan__GetAnalyticsModuleOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetAnalyticsModuleOptions));
	for (p = a; p && n--; p++)
		soap_default__tan__GetAnalyticsModuleOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetAnalyticsModuleOptions(struct soap *soap, const struct _tan__GetAnalyticsModuleOptions *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetAnalyticsModuleOptions(soap, tag ? tag : "tan:GetAnalyticsModuleOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModuleOptions * SOAP_FMAC4 soap_get__tan__GetAnalyticsModuleOptions(struct soap *soap, struct _tan__GetAnalyticsModuleOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetAnalyticsModuleOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetAnalyticsModulesResponse(struct soap *soap, struct _tan__GetAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsModule = 0;
	a->AnalyticsModule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetAnalyticsModulesResponse(struct soap *soap, const struct _tan__GetAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
		{
			soap_embedded(soap, a->AnalyticsModule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->AnalyticsModule + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__GetAnalyticsModulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetAnalyticsModulesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAnalyticsModule");
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
			if (soap_out_tt__Config(soap, "tan:AnalyticsModule", -1, a->AnalyticsModule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__GetAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__GetAnalyticsModulesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsModule = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetAnalyticsModulesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetAnalyticsModulesResponse, sizeof(struct _tan__GetAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetAnalyticsModulesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModule", 1, NULL))
			{	if (a->AnalyticsModule == NULL)
				{	if (soap_blist_AnalyticsModule == NULL)
						soap_blist_AnalyticsModule = soap_alloc_block(soap);
					a->AnalyticsModule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_AnalyticsModule, sizeof(struct tt__Config));
					if (a->AnalyticsModule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->AnalyticsModule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tan:AnalyticsModule", a->AnalyticsModule, "tt:Config"))
				{	a->__sizeAnalyticsModule++;
					a->AnalyticsModule = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAnalyticsModule");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModule)
			soap_pop_block(soap, soap_blist_AnalyticsModule);
		if (a->__sizeAnalyticsModule)
		{	a->AnalyticsModule = (struct tt__Config *)soap_save_block(soap, soap_blist_AnalyticsModule, NULL, 1);
		}
		else
		{	a->AnalyticsModule = NULL;
			if (soap_blist_AnalyticsModule)
				soap_end_block(soap, soap_blist_AnalyticsModule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__GetAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetAnalyticsModulesResponse, SOAP_TYPE__tan__GetAnalyticsModulesResponse, sizeof(struct _tan__GetAnalyticsModulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetAnalyticsModulesResponse * SOAP_FMAC4 soap_new__tan__GetAnalyticsModulesResponse(struct soap *soap, int n)
{
	struct _tan__GetAnalyticsModulesResponse *p;
	struct _tan__GetAnalyticsModulesResponse *a = (struct _tan__GetAnalyticsModulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetAnalyticsModulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__GetAnalyticsModulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetAnalyticsModulesResponse(struct soap *soap, const struct _tan__GetAnalyticsModulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetAnalyticsModulesResponse(soap, tag ? tag : "tan:GetAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__GetAnalyticsModulesResponse(struct soap *soap, struct _tan__GetAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetAnalyticsModules(struct soap *soap, struct _tan__GetAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetAnalyticsModules(struct soap *soap, const struct _tan__GetAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetAnalyticsModules(struct soap *soap, const char *tag, int id, const struct _tan__GetAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetAnalyticsModules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tan:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModules * SOAP_FMAC4 soap_in__tan__GetAnalyticsModules(struct soap *soap, const char *tag, struct _tan__GetAnalyticsModules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetAnalyticsModules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetAnalyticsModules, sizeof(struct _tan__GetAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetAnalyticsModules(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__GetAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetAnalyticsModules, SOAP_TYPE__tan__GetAnalyticsModules, sizeof(struct _tan__GetAnalyticsModules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetAnalyticsModules * SOAP_FMAC4 soap_new__tan__GetAnalyticsModules(struct soap *soap, int n)
{
	struct _tan__GetAnalyticsModules *p;
	struct _tan__GetAnalyticsModules *a = (struct _tan__GetAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default__tan__GetAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetAnalyticsModules(struct soap *soap, const struct _tan__GetAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetAnalyticsModules(soap, tag ? tag : "tan:GetAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModules * SOAP_FMAC4 soap_get__tan__GetAnalyticsModules(struct soap *soap, struct _tan__GetAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__ModifyAnalyticsModulesResponse(struct soap *soap, struct _tan__ModifyAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__ModifyAnalyticsModulesResponse(struct soap *soap, const struct _tan__ModifyAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__ModifyAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__ModifyAnalyticsModulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__ModifyAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__ModifyAnalyticsModulesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__ModifyAnalyticsModulesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, sizeof(struct _tan__ModifyAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__ModifyAnalyticsModulesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__ModifyAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, sizeof(struct _tan__ModifyAnalyticsModulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModulesResponse * SOAP_FMAC4 soap_new__tan__ModifyAnalyticsModulesResponse(struct soap *soap, int n)
{
	struct _tan__ModifyAnalyticsModulesResponse *p;
	struct _tan__ModifyAnalyticsModulesResponse *a = (struct _tan__ModifyAnalyticsModulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__ModifyAnalyticsModulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__ModifyAnalyticsModulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__ModifyAnalyticsModulesResponse(struct soap *soap, const struct _tan__ModifyAnalyticsModulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__ModifyAnalyticsModulesResponse(soap, tag ? tag : "tan:ModifyAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__ModifyAnalyticsModulesResponse(struct soap *soap, struct _tan__ModifyAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__ModifyAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__ModifyAnalyticsModules(struct soap *soap, struct _tan__ModifyAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	a->__sizeAnalyticsModule = 0;
	a->AnalyticsModule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__ModifyAnalyticsModules(struct soap *soap, const struct _tan__ModifyAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
		{
			soap_embedded(soap, a->AnalyticsModule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->AnalyticsModule + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, int id, const struct _tan__ModifyAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__ModifyAnalyticsModules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tan:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
			if (soap_out_tt__Config(soap, "tan:AnalyticsModule", -1, a->AnalyticsModule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_in__tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, struct _tan__ModifyAnalyticsModules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	struct soap_blist *soap_blist_AnalyticsModule = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__ModifyAnalyticsModules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyAnalyticsModules, sizeof(struct _tan__ModifyAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__ModifyAnalyticsModules(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModule", 1, NULL))
			{	if (a->AnalyticsModule == NULL)
				{	if (soap_blist_AnalyticsModule == NULL)
						soap_blist_AnalyticsModule = soap_alloc_block(soap);
					a->AnalyticsModule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_AnalyticsModule, sizeof(struct tt__Config));
					if (a->AnalyticsModule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->AnalyticsModule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tan:AnalyticsModule", a->AnalyticsModule, "tt:Config"))
				{	a->__sizeAnalyticsModule++;
					a->AnalyticsModule = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModule)
			soap_pop_block(soap, soap_blist_AnalyticsModule);
		if (a->__sizeAnalyticsModule)
		{	a->AnalyticsModule = (struct tt__Config *)soap_save_block(soap, soap_blist_AnalyticsModule, NULL, 1);
		}
		else
		{	a->AnalyticsModule = NULL;
			if (soap_blist_AnalyticsModule)
				soap_end_block(soap, soap_blist_AnalyticsModule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken || a->__sizeAnalyticsModule < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__ModifyAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyAnalyticsModules, SOAP_TYPE__tan__ModifyAnalyticsModules, sizeof(struct _tan__ModifyAnalyticsModules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_new__tan__ModifyAnalyticsModules(struct soap *soap, int n)
{
	struct _tan__ModifyAnalyticsModules *p;
	struct _tan__ModifyAnalyticsModules *a = (struct _tan__ModifyAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__ModifyAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default__tan__ModifyAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__ModifyAnalyticsModules(struct soap *soap, const struct _tan__ModifyAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out__tan__ModifyAnalyticsModules(soap, tag ? tag : "tan:ModifyAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_get__tan__ModifyAnalyticsModules(struct soap *soap, struct _tan__ModifyAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__ModifyAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__DeleteAnalyticsModulesResponse(struct soap *soap, struct _tan__DeleteAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__DeleteAnalyticsModulesResponse(struct soap *soap, const struct _tan__DeleteAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__DeleteAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__DeleteAnalyticsModulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__DeleteAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__DeleteAnalyticsModulesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__DeleteAnalyticsModulesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, sizeof(struct _tan__DeleteAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__DeleteAnalyticsModulesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__DeleteAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, sizeof(struct _tan__DeleteAnalyticsModulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModulesResponse * SOAP_FMAC4 soap_new__tan__DeleteAnalyticsModulesResponse(struct soap *soap, int n)
{
	struct _tan__DeleteAnalyticsModulesResponse *p;
	struct _tan__DeleteAnalyticsModulesResponse *a = (struct _tan__DeleteAnalyticsModulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__DeleteAnalyticsModulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__DeleteAnalyticsModulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__DeleteAnalyticsModulesResponse(struct soap *soap, const struct _tan__DeleteAnalyticsModulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__DeleteAnalyticsModulesResponse(soap, tag ? tag : "tan:DeleteAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__DeleteAnalyticsModulesResponse(struct soap *soap, struct _tan__DeleteAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__DeleteAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__DeleteAnalyticsModules(struct soap *soap, struct _tan__DeleteAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	a->__sizeAnalyticsModuleName = 0;
	a->AnalyticsModuleName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__DeleteAnalyticsModules(struct soap *soap, const struct _tan__DeleteAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	if (a->AnalyticsModuleName)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModuleName; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->AnalyticsModuleName + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, int id, const struct _tan__DeleteAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__DeleteAnalyticsModules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tan:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (a->AnalyticsModuleName)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModuleName; i++)
			if (soap_out_string(soap, "tan:AnalyticsModuleName", -1, (char*const*)(a->AnalyticsModuleName + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_in__tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, struct _tan__DeleteAnalyticsModules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	struct soap_blist *soap_blist_AnalyticsModuleName = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__DeleteAnalyticsModules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteAnalyticsModules, sizeof(struct _tan__DeleteAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__DeleteAnalyticsModules(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModuleName", 1, NULL))
			{	if (a->AnalyticsModuleName == NULL)
				{	if (soap_blist_AnalyticsModuleName == NULL)
						soap_blist_AnalyticsModuleName = soap_alloc_block(soap);
					a->AnalyticsModuleName = (char **)soap_push_block_max(soap, soap_blist_AnalyticsModuleName, sizeof(char *));
					if (a->AnalyticsModuleName == NULL)
						return NULL;
					*a->AnalyticsModuleName = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tan:AnalyticsModuleName", (char**)a->AnalyticsModuleName, "xsd:string"))
				{	a->__sizeAnalyticsModuleName++;
					a->AnalyticsModuleName = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModuleName)
			soap_pop_block(soap, soap_blist_AnalyticsModuleName);
		if (a->__sizeAnalyticsModuleName)
		{	a->AnalyticsModuleName = (char **)soap_save_block(soap, soap_blist_AnalyticsModuleName, NULL, 1);
		}
		else
		{	a->AnalyticsModuleName = NULL;
			if (soap_blist_AnalyticsModuleName)
				soap_end_block(soap, soap_blist_AnalyticsModuleName);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken || a->__sizeAnalyticsModuleName < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__DeleteAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteAnalyticsModules, SOAP_TYPE__tan__DeleteAnalyticsModules, sizeof(struct _tan__DeleteAnalyticsModules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_new__tan__DeleteAnalyticsModules(struct soap *soap, int n)
{
	struct _tan__DeleteAnalyticsModules *p;
	struct _tan__DeleteAnalyticsModules *a = (struct _tan__DeleteAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__DeleteAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default__tan__DeleteAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__DeleteAnalyticsModules(struct soap *soap, const struct _tan__DeleteAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out__tan__DeleteAnalyticsModules(soap, tag ? tag : "tan:DeleteAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_get__tan__DeleteAnalyticsModules(struct soap *soap, struct _tan__DeleteAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__DeleteAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__CreateAnalyticsModulesResponse(struct soap *soap, struct _tan__CreateAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__CreateAnalyticsModulesResponse(struct soap *soap, const struct _tan__CreateAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__CreateAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__CreateAnalyticsModulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__CreateAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__CreateAnalyticsModulesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__CreateAnalyticsModulesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, sizeof(struct _tan__CreateAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__CreateAnalyticsModulesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__CreateAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, sizeof(struct _tan__CreateAnalyticsModulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModulesResponse * SOAP_FMAC4 soap_new__tan__CreateAnalyticsModulesResponse(struct soap *soap, int n)
{
	struct _tan__CreateAnalyticsModulesResponse *p;
	struct _tan__CreateAnalyticsModulesResponse *a = (struct _tan__CreateAnalyticsModulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__CreateAnalyticsModulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__CreateAnalyticsModulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__CreateAnalyticsModulesResponse(struct soap *soap, const struct _tan__CreateAnalyticsModulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__CreateAnalyticsModulesResponse(soap, tag ? tag : "tan:CreateAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__CreateAnalyticsModulesResponse(struct soap *soap, struct _tan__CreateAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__CreateAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__CreateAnalyticsModules(struct soap *soap, struct _tan__CreateAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	a->__sizeAnalyticsModule = 0;
	a->AnalyticsModule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__CreateAnalyticsModules(struct soap *soap, const struct _tan__CreateAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
		{
			soap_embedded(soap, a->AnalyticsModule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->AnalyticsModule + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__CreateAnalyticsModules(struct soap *soap, const char *tag, int id, const struct _tan__CreateAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__CreateAnalyticsModules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tan:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
			if (soap_out_tt__Config(soap, "tan:AnalyticsModule", -1, a->AnalyticsModule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModules * SOAP_FMAC4 soap_in__tan__CreateAnalyticsModules(struct soap *soap, const char *tag, struct _tan__CreateAnalyticsModules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	struct soap_blist *soap_blist_AnalyticsModule = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__CreateAnalyticsModules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateAnalyticsModules, sizeof(struct _tan__CreateAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__CreateAnalyticsModules(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModule", 1, NULL))
			{	if (a->AnalyticsModule == NULL)
				{	if (soap_blist_AnalyticsModule == NULL)
						soap_blist_AnalyticsModule = soap_alloc_block(soap);
					a->AnalyticsModule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_AnalyticsModule, sizeof(struct tt__Config));
					if (a->AnalyticsModule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->AnalyticsModule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tan:AnalyticsModule", a->AnalyticsModule, "tt:Config"))
				{	a->__sizeAnalyticsModule++;
					a->AnalyticsModule = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModule)
			soap_pop_block(soap, soap_blist_AnalyticsModule);
		if (a->__sizeAnalyticsModule)
		{	a->AnalyticsModule = (struct tt__Config *)soap_save_block(soap, soap_blist_AnalyticsModule, NULL, 1);
		}
		else
		{	a->AnalyticsModule = NULL;
			if (soap_blist_AnalyticsModule)
				soap_end_block(soap, soap_blist_AnalyticsModule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken || a->__sizeAnalyticsModule < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__CreateAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateAnalyticsModules, SOAP_TYPE__tan__CreateAnalyticsModules, sizeof(struct _tan__CreateAnalyticsModules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModules * SOAP_FMAC4 soap_new__tan__CreateAnalyticsModules(struct soap *soap, int n)
{
	struct _tan__CreateAnalyticsModules *p;
	struct _tan__CreateAnalyticsModules *a = (struct _tan__CreateAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__CreateAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default__tan__CreateAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__CreateAnalyticsModules(struct soap *soap, const struct _tan__CreateAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out__tan__CreateAnalyticsModules(soap, tag ? tag : "tan:CreateAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModules * SOAP_FMAC4 soap_get__tan__CreateAnalyticsModules(struct soap *soap, struct _tan__CreateAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__CreateAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, struct _tan__GetSupportedAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SupportedAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, const struct _tan__GetSupportedAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SupportedAnalyticsModules(soap, &a->SupportedAnalyticsModules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__GetSupportedAnalyticsModulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse), type))
		return soap->error;
	if (a->SupportedAnalyticsModules)
		soap_element_result(soap, "tan:SupportedAnalyticsModules");
	if (!a->SupportedAnalyticsModules)
	{	if (soap_element_empty(soap, "tan:SupportedAnalyticsModules", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SupportedAnalyticsModules(soap, "tan:SupportedAnalyticsModules", -1, &a->SupportedAnalyticsModules, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__GetSupportedAnalyticsModulesResponse *a, const char *type)
{
	size_t soap_flag_SupportedAnalyticsModules = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetSupportedAnalyticsModulesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, sizeof(struct _tan__GetSupportedAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetSupportedAnalyticsModulesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportedAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SupportedAnalyticsModules(soap, "tan:SupportedAnalyticsModules", &a->SupportedAnalyticsModules, "tt:SupportedAnalyticsModules"))
				{	soap_flag_SupportedAnalyticsModules--;
					continue;
				}
			}
			soap_check_result(soap, "tan:SupportedAnalyticsModules");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SupportedAnalyticsModules))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, sizeof(struct _tan__GetSupportedAnalyticsModulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModulesResponse * SOAP_FMAC4 soap_new__tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, int n)
{
	struct _tan__GetSupportedAnalyticsModulesResponse *p;
	struct _tan__GetSupportedAnalyticsModulesResponse *a = (struct _tan__GetSupportedAnalyticsModulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetSupportedAnalyticsModulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__GetSupportedAnalyticsModulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, const struct _tan__GetSupportedAnalyticsModulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetSupportedAnalyticsModulesResponse(soap, tag ? tag : "tan:GetSupportedAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, struct _tan__GetSupportedAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetSupportedAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetSupportedAnalyticsModules(struct soap *soap, struct _tan__GetSupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetSupportedAnalyticsModules(struct soap *soap, const struct _tan__GetSupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, int id, const struct _tan__GetSupportedAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetSupportedAnalyticsModules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tan:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_in__tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, struct _tan__GetSupportedAnalyticsModules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetSupportedAnalyticsModules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedAnalyticsModules, sizeof(struct _tan__GetSupportedAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetSupportedAnalyticsModules(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedAnalyticsModules, SOAP_TYPE__tan__GetSupportedAnalyticsModules, sizeof(struct _tan__GetSupportedAnalyticsModules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_new__tan__GetSupportedAnalyticsModules(struct soap *soap, int n)
{
	struct _tan__GetSupportedAnalyticsModules *p;
	struct _tan__GetSupportedAnalyticsModules *a = (struct _tan__GetSupportedAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetSupportedAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default__tan__GetSupportedAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetSupportedAnalyticsModules(struct soap *soap, const struct _tan__GetSupportedAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetSupportedAnalyticsModules(soap, tag ? tag : "tan:GetSupportedAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_get__tan__GetSupportedAnalyticsModules(struct soap *soap, struct _tan__GetSupportedAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetSupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetRuleOptionsResponse(struct soap *soap, struct _tan__GetRuleOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRuleOptions = 0;
	a->RuleOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetRuleOptionsResponse(struct soap *soap, const struct _tan__GetRuleOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RuleOptions)
	{	int i;
		for (i = 0; i < (int)a->__sizeRuleOptions; i++)
		{
			soap_embedded(soap, a->RuleOptions + i, SOAP_TYPE_tan__ConfigOptions);
			soap_serialize_tan__ConfigOptions(soap, a->RuleOptions + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetRuleOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tan__GetRuleOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetRuleOptionsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeRuleOptions");
	if (a->RuleOptions)
	{	int i;
		for (i = 0; i < (int)a->__sizeRuleOptions; i++)
			if (soap_out_tan__ConfigOptions(soap, "tan:RuleOptions", -1, a->RuleOptions + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetRuleOptionsResponse * SOAP_FMAC4 soap_in__tan__GetRuleOptionsResponse(struct soap *soap, const char *tag, struct _tan__GetRuleOptionsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_RuleOptions = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetRuleOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetRuleOptionsResponse, sizeof(struct _tan__GetRuleOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetRuleOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:RuleOptions", 1, NULL))
			{	if (a->RuleOptions == NULL)
				{	if (soap_blist_RuleOptions == NULL)
						soap_blist_RuleOptions = soap_alloc_block(soap);
					a->RuleOptions = (struct tan__ConfigOptions *)soap_push_block_max(soap, soap_blist_RuleOptions, sizeof(struct tan__ConfigOptions));
					if (a->RuleOptions == NULL)
						return NULL;
					soap_default_tan__ConfigOptions(soap, a->RuleOptions);
				}
				soap_revert(soap);
				if (soap_in_tan__ConfigOptions(soap, "tan:RuleOptions", a->RuleOptions, "tan:ConfigOptions"))
				{	a->__sizeRuleOptions++;
					a->RuleOptions = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRuleOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RuleOptions)
			soap_pop_block(soap, soap_blist_RuleOptions);
		if (a->__sizeRuleOptions)
		{	a->RuleOptions = (struct tan__ConfigOptions *)soap_save_block(soap, soap_blist_RuleOptions, NULL, 1);
		}
		else
		{	a->RuleOptions = NULL;
			if (soap_blist_RuleOptions)
				soap_end_block(soap, soap_blist_RuleOptions);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__GetRuleOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetRuleOptionsResponse, SOAP_TYPE__tan__GetRuleOptionsResponse, sizeof(struct _tan__GetRuleOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetRuleOptionsResponse * SOAP_FMAC4 soap_new__tan__GetRuleOptionsResponse(struct soap *soap, int n)
{
	struct _tan__GetRuleOptionsResponse *p;
	struct _tan__GetRuleOptionsResponse *a = (struct _tan__GetRuleOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetRuleOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__GetRuleOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetRuleOptionsResponse(struct soap *soap, const struct _tan__GetRuleOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetRuleOptionsResponse(soap, tag ? tag : "tan:GetRuleOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetRuleOptionsResponse * SOAP_FMAC4 soap_get__tan__GetRuleOptionsResponse(struct soap *soap, struct _tan__GetRuleOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetRuleOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetRuleOptions(struct soap *soap, struct _tan__GetRuleOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->RuleType);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetRuleOptions(struct soap *soap, const struct _tan__GetRuleOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->RuleType);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetRuleOptions(struct soap *soap, const char *tag, int id, const struct _tan__GetRuleOptions *a, const char *type)
{
	const char *soap_tmp_RuleType;
	soap_tmp_RuleType = soap_QName2s(soap, a->RuleType);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetRuleOptions), type))
		return soap->error;
	if (soap_out__QName(soap, "tan:RuleType", -1, (char*const*)(void*)&soap_tmp_RuleType, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tan:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetRuleOptions * SOAP_FMAC4 soap_in__tan__GetRuleOptions(struct soap *soap, const char *tag, struct _tan__GetRuleOptions *a, const char *type)
{
	size_t soap_flag_RuleType = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetRuleOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetRuleOptions, sizeof(struct _tan__GetRuleOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetRuleOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RuleType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "tan:RuleType", (char**)&a->RuleType, "xsd:QName"))
				{	soap_flag_RuleType--;
					continue;
				}
			}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__GetRuleOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetRuleOptions, SOAP_TYPE__tan__GetRuleOptions, sizeof(struct _tan__GetRuleOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetRuleOptions * SOAP_FMAC4 soap_new__tan__GetRuleOptions(struct soap *soap, int n)
{
	struct _tan__GetRuleOptions *p;
	struct _tan__GetRuleOptions *a = (struct _tan__GetRuleOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetRuleOptions));
	for (p = a; p && n--; p++)
		soap_default__tan__GetRuleOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetRuleOptions(struct soap *soap, const struct _tan__GetRuleOptions *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetRuleOptions(soap, tag ? tag : "tan:GetRuleOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetRuleOptions * SOAP_FMAC4 soap_get__tan__GetRuleOptions(struct soap *soap, struct _tan__GetRuleOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetRuleOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetRulesResponse(struct soap *soap, struct _tan__GetRulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRule = 0;
	a->Rule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetRulesResponse(struct soap *soap, const struct _tan__GetRulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Rule)
	{	int i;
		for (i = 0; i < (int)a->__sizeRule; i++)
		{
			soap_embedded(soap, a->Rule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->Rule + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetRulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__GetRulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetRulesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeRule");
	if (a->Rule)
	{	int i;
		for (i = 0; i < (int)a->__sizeRule; i++)
			if (soap_out_tt__Config(soap, "tan:Rule", -1, a->Rule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetRulesResponse * SOAP_FMAC4 soap_in__tan__GetRulesResponse(struct soap *soap, const char *tag, struct _tan__GetRulesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Rule = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetRulesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetRulesResponse, sizeof(struct _tan__GetRulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetRulesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:Rule", 1, NULL))
			{	if (a->Rule == NULL)
				{	if (soap_blist_Rule == NULL)
						soap_blist_Rule = soap_alloc_block(soap);
					a->Rule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_Rule, sizeof(struct tt__Config));
					if (a->Rule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->Rule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tan:Rule", a->Rule, "tt:Config"))
				{	a->__sizeRule++;
					a->Rule = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRule");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Rule)
			soap_pop_block(soap, soap_blist_Rule);
		if (a->__sizeRule)
		{	a->Rule = (struct tt__Config *)soap_save_block(soap, soap_blist_Rule, NULL, 1);
		}
		else
		{	a->Rule = NULL;
			if (soap_blist_Rule)
				soap_end_block(soap, soap_blist_Rule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__GetRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetRulesResponse, SOAP_TYPE__tan__GetRulesResponse, sizeof(struct _tan__GetRulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetRulesResponse * SOAP_FMAC4 soap_new__tan__GetRulesResponse(struct soap *soap, int n)
{
	struct _tan__GetRulesResponse *p;
	struct _tan__GetRulesResponse *a = (struct _tan__GetRulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetRulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__GetRulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetRulesResponse(struct soap *soap, const struct _tan__GetRulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetRulesResponse(soap, tag ? tag : "tan:GetRulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetRulesResponse * SOAP_FMAC4 soap_get__tan__GetRulesResponse(struct soap *soap, struct _tan__GetRulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetRules(struct soap *soap, struct _tan__GetRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetRules(struct soap *soap, const struct _tan__GetRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetRules(struct soap *soap, const char *tag, int id, const struct _tan__GetRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetRules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tan:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetRules * SOAP_FMAC4 soap_in__tan__GetRules(struct soap *soap, const char *tag, struct _tan__GetRules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetRules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetRules, sizeof(struct _tan__GetRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetRules(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__GetRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetRules, SOAP_TYPE__tan__GetRules, sizeof(struct _tan__GetRules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetRules * SOAP_FMAC4 soap_new__tan__GetRules(struct soap *soap, int n)
{
	struct _tan__GetRules *p;
	struct _tan__GetRules *a = (struct _tan__GetRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetRules));
	for (p = a; p && n--; p++)
		soap_default__tan__GetRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetRules(struct soap *soap, const struct _tan__GetRules *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetRules(soap, tag ? tag : "tan:GetRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetRules * SOAP_FMAC4 soap_get__tan__GetRules(struct soap *soap, struct _tan__GetRules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__ModifyRulesResponse(struct soap *soap, struct _tan__ModifyRulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__ModifyRulesResponse(struct soap *soap, const struct _tan__ModifyRulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__ModifyRulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__ModifyRulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__ModifyRulesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__ModifyRulesResponse * SOAP_FMAC4 soap_in__tan__ModifyRulesResponse(struct soap *soap, const char *tag, struct _tan__ModifyRulesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__ModifyRulesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyRulesResponse, sizeof(struct _tan__ModifyRulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__ModifyRulesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__ModifyRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyRulesResponse, SOAP_TYPE__tan__ModifyRulesResponse, sizeof(struct _tan__ModifyRulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__ModifyRulesResponse * SOAP_FMAC4 soap_new__tan__ModifyRulesResponse(struct soap *soap, int n)
{
	struct _tan__ModifyRulesResponse *p;
	struct _tan__ModifyRulesResponse *a = (struct _tan__ModifyRulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__ModifyRulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__ModifyRulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__ModifyRulesResponse(struct soap *soap, const struct _tan__ModifyRulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__ModifyRulesResponse(soap, tag ? tag : "tan:ModifyRulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyRulesResponse * SOAP_FMAC4 soap_get__tan__ModifyRulesResponse(struct soap *soap, struct _tan__ModifyRulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__ModifyRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__ModifyRules(struct soap *soap, struct _tan__ModifyRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	a->__sizeRule = 0;
	a->Rule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__ModifyRules(struct soap *soap, const struct _tan__ModifyRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	if (a->Rule)
	{	int i;
		for (i = 0; i < (int)a->__sizeRule; i++)
		{
			soap_embedded(soap, a->Rule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->Rule + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__ModifyRules(struct soap *soap, const char *tag, int id, const struct _tan__ModifyRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__ModifyRules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tan:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (a->Rule)
	{	int i;
		for (i = 0; i < (int)a->__sizeRule; i++)
			if (soap_out_tt__Config(soap, "tan:Rule", -1, a->Rule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__ModifyRules * SOAP_FMAC4 soap_in__tan__ModifyRules(struct soap *soap, const char *tag, struct _tan__ModifyRules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	struct soap_blist *soap_blist_Rule = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__ModifyRules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyRules, sizeof(struct _tan__ModifyRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__ModifyRules(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:Rule", 1, NULL))
			{	if (a->Rule == NULL)
				{	if (soap_blist_Rule == NULL)
						soap_blist_Rule = soap_alloc_block(soap);
					a->Rule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_Rule, sizeof(struct tt__Config));
					if (a->Rule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->Rule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tan:Rule", a->Rule, "tt:Config"))
				{	a->__sizeRule++;
					a->Rule = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Rule)
			soap_pop_block(soap, soap_blist_Rule);
		if (a->__sizeRule)
		{	a->Rule = (struct tt__Config *)soap_save_block(soap, soap_blist_Rule, NULL, 1);
		}
		else
		{	a->Rule = NULL;
			if (soap_blist_Rule)
				soap_end_block(soap, soap_blist_Rule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken || a->__sizeRule < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__ModifyRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyRules, SOAP_TYPE__tan__ModifyRules, sizeof(struct _tan__ModifyRules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__ModifyRules * SOAP_FMAC4 soap_new__tan__ModifyRules(struct soap *soap, int n)
{
	struct _tan__ModifyRules *p;
	struct _tan__ModifyRules *a = (struct _tan__ModifyRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__ModifyRules));
	for (p = a; p && n--; p++)
		soap_default__tan__ModifyRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__ModifyRules(struct soap *soap, const struct _tan__ModifyRules *a, const char *tag, const char *type)
{
	if (soap_out__tan__ModifyRules(soap, tag ? tag : "tan:ModifyRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyRules * SOAP_FMAC4 soap_get__tan__ModifyRules(struct soap *soap, struct _tan__ModifyRules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__ModifyRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__DeleteRulesResponse(struct soap *soap, struct _tan__DeleteRulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__DeleteRulesResponse(struct soap *soap, const struct _tan__DeleteRulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__DeleteRulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__DeleteRulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__DeleteRulesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__DeleteRulesResponse * SOAP_FMAC4 soap_in__tan__DeleteRulesResponse(struct soap *soap, const char *tag, struct _tan__DeleteRulesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__DeleteRulesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteRulesResponse, sizeof(struct _tan__DeleteRulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__DeleteRulesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__DeleteRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteRulesResponse, SOAP_TYPE__tan__DeleteRulesResponse, sizeof(struct _tan__DeleteRulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__DeleteRulesResponse * SOAP_FMAC4 soap_new__tan__DeleteRulesResponse(struct soap *soap, int n)
{
	struct _tan__DeleteRulesResponse *p;
	struct _tan__DeleteRulesResponse *a = (struct _tan__DeleteRulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__DeleteRulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__DeleteRulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__DeleteRulesResponse(struct soap *soap, const struct _tan__DeleteRulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__DeleteRulesResponse(soap, tag ? tag : "tan:DeleteRulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteRulesResponse * SOAP_FMAC4 soap_get__tan__DeleteRulesResponse(struct soap *soap, struct _tan__DeleteRulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__DeleteRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__DeleteRules(struct soap *soap, struct _tan__DeleteRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	a->__sizeRuleName = 0;
	a->RuleName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__DeleteRules(struct soap *soap, const struct _tan__DeleteRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	if (a->RuleName)
	{	int i;
		for (i = 0; i < (int)a->__sizeRuleName; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->RuleName + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__DeleteRules(struct soap *soap, const char *tag, int id, const struct _tan__DeleteRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__DeleteRules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tan:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (a->RuleName)
	{	int i;
		for (i = 0; i < (int)a->__sizeRuleName; i++)
			if (soap_out_string(soap, "tan:RuleName", -1, (char*const*)(a->RuleName + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__DeleteRules * SOAP_FMAC4 soap_in__tan__DeleteRules(struct soap *soap, const char *tag, struct _tan__DeleteRules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	struct soap_blist *soap_blist_RuleName = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__DeleteRules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteRules, sizeof(struct _tan__DeleteRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__DeleteRules(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:RuleName", 1, NULL))
			{	if (a->RuleName == NULL)
				{	if (soap_blist_RuleName == NULL)
						soap_blist_RuleName = soap_alloc_block(soap);
					a->RuleName = (char **)soap_push_block_max(soap, soap_blist_RuleName, sizeof(char *));
					if (a->RuleName == NULL)
						return NULL;
					*a->RuleName = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tan:RuleName", (char**)a->RuleName, "xsd:string"))
				{	a->__sizeRuleName++;
					a->RuleName = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RuleName)
			soap_pop_block(soap, soap_blist_RuleName);
		if (a->__sizeRuleName)
		{	a->RuleName = (char **)soap_save_block(soap, soap_blist_RuleName, NULL, 1);
		}
		else
		{	a->RuleName = NULL;
			if (soap_blist_RuleName)
				soap_end_block(soap, soap_blist_RuleName);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken || a->__sizeRuleName < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__DeleteRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteRules, SOAP_TYPE__tan__DeleteRules, sizeof(struct _tan__DeleteRules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__DeleteRules * SOAP_FMAC4 soap_new__tan__DeleteRules(struct soap *soap, int n)
{
	struct _tan__DeleteRules *p;
	struct _tan__DeleteRules *a = (struct _tan__DeleteRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__DeleteRules));
	for (p = a; p && n--; p++)
		soap_default__tan__DeleteRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__DeleteRules(struct soap *soap, const struct _tan__DeleteRules *a, const char *tag, const char *type)
{
	if (soap_out__tan__DeleteRules(soap, tag ? tag : "tan:DeleteRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteRules * SOAP_FMAC4 soap_get__tan__DeleteRules(struct soap *soap, struct _tan__DeleteRules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__DeleteRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__CreateRulesResponse(struct soap *soap, struct _tan__CreateRulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__CreateRulesResponse(struct soap *soap, const struct _tan__CreateRulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__CreateRulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__CreateRulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__CreateRulesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__CreateRulesResponse * SOAP_FMAC4 soap_in__tan__CreateRulesResponse(struct soap *soap, const char *tag, struct _tan__CreateRulesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__CreateRulesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateRulesResponse, sizeof(struct _tan__CreateRulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__CreateRulesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__CreateRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateRulesResponse, SOAP_TYPE__tan__CreateRulesResponse, sizeof(struct _tan__CreateRulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__CreateRulesResponse * SOAP_FMAC4 soap_new__tan__CreateRulesResponse(struct soap *soap, int n)
{
	struct _tan__CreateRulesResponse *p;
	struct _tan__CreateRulesResponse *a = (struct _tan__CreateRulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__CreateRulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__CreateRulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__CreateRulesResponse(struct soap *soap, const struct _tan__CreateRulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__CreateRulesResponse(soap, tag ? tag : "tan:CreateRulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateRulesResponse * SOAP_FMAC4 soap_get__tan__CreateRulesResponse(struct soap *soap, struct _tan__CreateRulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__CreateRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__CreateRules(struct soap *soap, struct _tan__CreateRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	a->__sizeRule = 0;
	a->Rule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__CreateRules(struct soap *soap, const struct _tan__CreateRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	if (a->Rule)
	{	int i;
		for (i = 0; i < (int)a->__sizeRule; i++)
		{
			soap_embedded(soap, a->Rule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->Rule + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__CreateRules(struct soap *soap, const char *tag, int id, const struct _tan__CreateRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__CreateRules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tan:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (a->Rule)
	{	int i;
		for (i = 0; i < (int)a->__sizeRule; i++)
			if (soap_out_tt__Config(soap, "tan:Rule", -1, a->Rule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__CreateRules * SOAP_FMAC4 soap_in__tan__CreateRules(struct soap *soap, const char *tag, struct _tan__CreateRules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	struct soap_blist *soap_blist_Rule = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__CreateRules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateRules, sizeof(struct _tan__CreateRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__CreateRules(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:Rule", 1, NULL))
			{	if (a->Rule == NULL)
				{	if (soap_blist_Rule == NULL)
						soap_blist_Rule = soap_alloc_block(soap);
					a->Rule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_Rule, sizeof(struct tt__Config));
					if (a->Rule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->Rule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tan:Rule", a->Rule, "tt:Config"))
				{	a->__sizeRule++;
					a->Rule = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Rule)
			soap_pop_block(soap, soap_blist_Rule);
		if (a->__sizeRule)
		{	a->Rule = (struct tt__Config *)soap_save_block(soap, soap_blist_Rule, NULL, 1);
		}
		else
		{	a->Rule = NULL;
			if (soap_blist_Rule)
				soap_end_block(soap, soap_blist_Rule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken || a->__sizeRule < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__CreateRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateRules, SOAP_TYPE__tan__CreateRules, sizeof(struct _tan__CreateRules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__CreateRules * SOAP_FMAC4 soap_new__tan__CreateRules(struct soap *soap, int n)
{
	struct _tan__CreateRules *p;
	struct _tan__CreateRules *a = (struct _tan__CreateRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__CreateRules));
	for (p = a; p && n--; p++)
		soap_default__tan__CreateRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__CreateRules(struct soap *soap, const struct _tan__CreateRules *a, const char *tag, const char *type)
{
	if (soap_out__tan__CreateRules(soap, tag ? tag : "tan:CreateRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateRules * SOAP_FMAC4 soap_get__tan__CreateRules(struct soap *soap, struct _tan__CreateRules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__CreateRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetSupportedRulesResponse(struct soap *soap, struct _tan__GetSupportedRulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SupportedRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetSupportedRulesResponse(struct soap *soap, const struct _tan__GetSupportedRulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SupportedRules(soap, &a->SupportedRules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetSupportedRulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__GetSupportedRulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetSupportedRulesResponse), type))
		return soap->error;
	if (a->SupportedRules)
		soap_element_result(soap, "tan:SupportedRules");
	if (!a->SupportedRules)
	{	if (soap_element_empty(soap, "tan:SupportedRules", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SupportedRules(soap, "tan:SupportedRules", -1, &a->SupportedRules, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetSupportedRulesResponse * SOAP_FMAC4 soap_in__tan__GetSupportedRulesResponse(struct soap *soap, const char *tag, struct _tan__GetSupportedRulesResponse *a, const char *type)
{
	size_t soap_flag_SupportedRules = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetSupportedRulesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedRulesResponse, sizeof(struct _tan__GetSupportedRulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetSupportedRulesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportedRules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SupportedRules(soap, "tan:SupportedRules", &a->SupportedRules, "tt:SupportedRules"))
				{	soap_flag_SupportedRules--;
					continue;
				}
			}
			soap_check_result(soap, "tan:SupportedRules");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SupportedRules))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedRulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedRulesResponse, SOAP_TYPE__tan__GetSupportedRulesResponse, sizeof(struct _tan__GetSupportedRulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetSupportedRulesResponse * SOAP_FMAC4 soap_new__tan__GetSupportedRulesResponse(struct soap *soap, int n)
{
	struct _tan__GetSupportedRulesResponse *p;
	struct _tan__GetSupportedRulesResponse *a = (struct _tan__GetSupportedRulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetSupportedRulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__GetSupportedRulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetSupportedRulesResponse(struct soap *soap, const struct _tan__GetSupportedRulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetSupportedRulesResponse(soap, tag ? tag : "tan:GetSupportedRulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedRulesResponse * SOAP_FMAC4 soap_get__tan__GetSupportedRulesResponse(struct soap *soap, struct _tan__GetSupportedRulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetSupportedRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetSupportedRules(struct soap *soap, struct _tan__GetSupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetSupportedRules(struct soap *soap, const struct _tan__GetSupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetSupportedRules(struct soap *soap, const char *tag, int id, const struct _tan__GetSupportedRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetSupportedRules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tan:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetSupportedRules * SOAP_FMAC4 soap_in__tan__GetSupportedRules(struct soap *soap, const char *tag, struct _tan__GetSupportedRules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetSupportedRules*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetSupportedRules, sizeof(struct _tan__GetSupportedRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetSupportedRules(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetSupportedRules, SOAP_TYPE__tan__GetSupportedRules, sizeof(struct _tan__GetSupportedRules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetSupportedRules * SOAP_FMAC4 soap_new__tan__GetSupportedRules(struct soap *soap, int n)
{
	struct _tan__GetSupportedRules *p;
	struct _tan__GetSupportedRules *a = (struct _tan__GetSupportedRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetSupportedRules));
	for (p = a; p && n--; p++)
		soap_default__tan__GetSupportedRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetSupportedRules(struct soap *soap, const struct _tan__GetSupportedRules *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetSupportedRules(soap, tag ? tag : "tan:GetSupportedRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedRules * SOAP_FMAC4 soap_get__tan__GetSupportedRules(struct soap *soap, struct _tan__GetSupportedRules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetSupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetServiceCapabilitiesResponse(struct soap *soap, struct _tan__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tan__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotan__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tan__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tan:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tan:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotan__Capabilities(soap, "tan:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tan__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tan__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetServiceCapabilitiesResponse, sizeof(struct _tan__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotan__Capabilities(soap, "tan:Capabilities", &a->Capabilities, "tan:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tan:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetServiceCapabilitiesResponse, SOAP_TYPE__tan__GetServiceCapabilitiesResponse, sizeof(struct _tan__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tan__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tan__GetServiceCapabilitiesResponse *p;
	struct _tan__GetServiceCapabilitiesResponse *a = (struct _tan__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tan__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetServiceCapabilitiesResponse(soap, tag ? tag : "tan:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tan__GetServiceCapabilitiesResponse(struct soap *soap, struct _tan__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetServiceCapabilities(struct soap *soap, struct _tan__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetServiceCapabilities(struct soap *soap, const struct _tan__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tan__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetServiceCapabilities * SOAP_FMAC4 soap_in__tan__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tan__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tan__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetServiceCapabilities, sizeof(struct _tan__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetServiceCapabilities, SOAP_TYPE__tan__GetServiceCapabilities, sizeof(struct _tan__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetServiceCapabilities * SOAP_FMAC4 soap_new__tan__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tan__GetServiceCapabilities *p;
	struct _tan__GetServiceCapabilities *a = (struct _tan__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tan__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetServiceCapabilities(struct soap *soap, const struct _tan__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetServiceCapabilities(soap, tag ? tag : "tan:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetServiceCapabilities * SOAP_FMAC4 soap_get__tan__GetServiceCapabilities(struct soap *soap, struct _tan__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tan__MetadataInfo(struct soap *soap, struct tan__MetadataInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SampleFrame = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default__QName(soap, &a->Type);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tan__MetadataInfo(struct soap *soap, const struct tan__MetadataInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Frame(soap, &a->SampleFrame);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tan__MetadataInfo(struct soap *soap, const char *tag, int id, const struct tan__MetadataInfo *a, const char *type)
{
	soap_set_attr(soap, "Type", a->Type ? soap__QName2s(soap, a->Type) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tan__MetadataInfo), type))
		return soap->error;
	if (!a->SampleFrame)
	{	if (soap_element_empty(soap, "tan:SampleFrame", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Frame(soap, "tan:SampleFrame", -1, &a->SampleFrame, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tan__MetadataInfo * SOAP_FMAC4 soap_in_tan__MetadataInfo(struct soap *soap, const char *tag, struct tan__MetadataInfo *a, const char *type)
{
	size_t soap_flag_SampleFrame = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tan__MetadataInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tan__MetadataInfo, sizeof(struct tan__MetadataInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tan__MetadataInfo(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "Type", 2, 1), &a->Type))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SampleFrame && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Frame(soap, "tan:SampleFrame", &a->SampleFrame, "tt:Frame"))
				{	soap_flag_SampleFrame--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->SampleFrame))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tan__MetadataInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tan__MetadataInfo, SOAP_TYPE_tan__MetadataInfo, sizeof(struct tan__MetadataInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tan__MetadataInfo * SOAP_FMAC4 soap_new_tan__MetadataInfo(struct soap *soap, int n)
{
	struct tan__MetadataInfo *p;
	struct tan__MetadataInfo *a = (struct tan__MetadataInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tan__MetadataInfo));
	for (p = a; p && n--; p++)
		soap_default_tan__MetadataInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tan__MetadataInfo(struct soap *soap, const struct tan__MetadataInfo *a, const char *tag, const char *type)
{
	if (soap_out_tan__MetadataInfo(soap, tag ? tag : "tan:MetadataInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tan__MetadataInfo * SOAP_FMAC4 soap_get_tan__MetadataInfo(struct soap *soap, struct tan__MetadataInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tan__MetadataInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tan__ConfigOptions(struct soap *soap, struct tan__ConfigOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default__QName(soap, &a->RuleType);
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
	soap_default__QName(soap, &a->AnalyticsModule);
	a->minOccurs = NULL;
	a->maxOccurs = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tan__ConfigOptions(struct soap *soap, const struct tan__ConfigOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tan__ConfigOptions(struct soap *soap, const char *tag, int id, const struct tan__ConfigOptions *a, const char *type)
{
	if (a->RuleType)
		soap_set_attr(soap, "RuleType", soap__QName2s(soap, a->RuleType), 1);
	soap_set_attr(soap, "Name", a->Name ? soap_string2s(soap, a->Name) : "", 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap__QName2s(soap, a->Type), 1);
	if (a->AnalyticsModule)
		soap_set_attr(soap, "AnalyticsModule", soap__QName2s(soap, a->AnalyticsModule), 1);
	if (a->minOccurs)
	{	soap_set_attr(soap, "minOccurs", soap_int2s(soap, *a->minOccurs), 1);
	}
	if (a->maxOccurs)
	{	soap_set_attr(soap, "maxOccurs", soap_int2s(soap, *a->maxOccurs), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tan__ConfigOptions), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tan__ConfigOptions * SOAP_FMAC4 soap_in_tan__ConfigOptions(struct soap *soap, const char *tag, struct tan__ConfigOptions *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tan__ConfigOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tan__ConfigOptions, sizeof(struct tan__ConfigOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tan__ConfigOptions(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "RuleType", 2, 0), &a->RuleType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1, 1), &a->Name))
		return NULL;
	if (soap_s2_QName(soap, soap_attr_value(soap, "Type", 2, 0), &a->Type))
		return NULL;
	if (soap_s2_QName(soap, soap_attr_value(soap, "AnalyticsModule", 2, 0), &a->AnalyticsModule))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "minOccurs", 5, 0);
		if (t)
		{
			if (!(a->minOccurs = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->minOccurs))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "maxOccurs", 5, 0);
		if (t)
		{
			if (!(a->maxOccurs = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->maxOccurs))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tan__ConfigOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tan__ConfigOptions, SOAP_TYPE_tan__ConfigOptions, sizeof(struct tan__ConfigOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tan__ConfigOptions * SOAP_FMAC4 soap_new_tan__ConfigOptions(struct soap *soap, int n)
{
	struct tan__ConfigOptions *p;
	struct tan__ConfigOptions *a = (struct tan__ConfigOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tan__ConfigOptions));
	for (p = a; p && n--; p++)
		soap_default_tan__ConfigOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tan__ConfigOptions(struct soap *soap, const struct tan__ConfigOptions *a, const char *tag, const char *type)
{
	if (soap_out_tan__ConfigOptions(soap, tag ? tag : "tan:ConfigOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tan__ConfigOptions * SOAP_FMAC4 soap_get_tan__ConfigOptions(struct soap *soap, struct tan__ConfigOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tan__ConfigOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tan__Capabilities(struct soap *soap, struct tan__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->RuleSupport = NULL;
	a->AnalyticsModuleSupport = NULL;
	a->CellBasedSceneDescriptionSupported = NULL;
	a->RuleOptionsSupported = NULL;
	a->AnalyticsModuleOptionsSupported = NULL;
	a->SupportedMetadata = NULL;
	soap_default_tt__StringList(soap, &a->ImageSendingType);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tan__Capabilities(struct soap *soap, const struct tan__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tan__Capabilities(struct soap *soap, const char *tag, int id, const struct tan__Capabilities *a, const char *type)
{
	if (a->RuleSupport)
	{	soap_set_attr(soap, "RuleSupport", soap_xsd__boolean2s(soap, *a->RuleSupport), 1);
	}
	if (a->AnalyticsModuleSupport)
	{	soap_set_attr(soap, "AnalyticsModuleSupport", soap_xsd__boolean2s(soap, *a->AnalyticsModuleSupport), 1);
	}
	if (a->CellBasedSceneDescriptionSupported)
	{	soap_set_attr(soap, "CellBasedSceneDescriptionSupported", soap_xsd__boolean2s(soap, *a->CellBasedSceneDescriptionSupported), 1);
	}
	if (a->RuleOptionsSupported)
	{	soap_set_attr(soap, "RuleOptionsSupported", soap_xsd__boolean2s(soap, *a->RuleOptionsSupported), 1);
	}
	if (a->AnalyticsModuleOptionsSupported)
	{	soap_set_attr(soap, "AnalyticsModuleOptionsSupported", soap_xsd__boolean2s(soap, *a->AnalyticsModuleOptionsSupported), 1);
	}
	if (a->SupportedMetadata)
	{	soap_set_attr(soap, "SupportedMetadata", soap_xsd__boolean2s(soap, *a->SupportedMetadata), 1);
	}
	if (a->ImageSendingType)
		soap_set_attr(soap, "ImageSendingType", soap_tt__StringList2s(soap, a->ImageSendingType), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tan__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tan__Capabilities * SOAP_FMAC4 soap_in_tan__Capabilities(struct soap *soap, const char *tag, struct tan__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tan__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tan__Capabilities, sizeof(struct tan__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tan__Capabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "RuleSupport", 5, 0);
		if (t)
		{
			if (!(a->RuleSupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RuleSupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "AnalyticsModuleSupport", 5, 0);
		if (t)
		{
			if (!(a->AnalyticsModuleSupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->AnalyticsModuleSupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "CellBasedSceneDescriptionSupported", 5, 0);
		if (t)
		{
			if (!(a->CellBasedSceneDescriptionSupported = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->CellBasedSceneDescriptionSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RuleOptionsSupported", 5, 0);
		if (t)
		{
			if (!(a->RuleOptionsSupported = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RuleOptionsSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "AnalyticsModuleOptionsSupported", 5, 0);
		if (t)
		{
			if (!(a->AnalyticsModuleOptionsSupported = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->AnalyticsModuleOptionsSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SupportedMetadata", 5, 0);
		if (t)
		{
			if (!(a->SupportedMetadata = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->SupportedMetadata))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__StringList(soap, soap_attr_value(soap, "ImageSendingType", 1, 0), &a->ImageSendingType))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tan__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tan__Capabilities, SOAP_TYPE_tan__Capabilities, sizeof(struct tan__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tan__Capabilities * SOAP_FMAC4 soap_new_tan__Capabilities(struct soap *soap, int n)
{
	struct tan__Capabilities *p;
	struct tan__Capabilities *a = (struct tan__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tan__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tan__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tan__Capabilities(struct soap *soap, const struct tan__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tan__Capabilities(soap, tag ? tag : "tan:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tan__Capabilities * SOAP_FMAC4 soap_get_tan__Capabilities(struct soap *soap, struct tan__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tan__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Behaviour(struct soap *soap, struct ns2__Behaviour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Smoking = NULL;
	a->UsingMobile = NULL;
	soap_default_string(soap, &a->Activity);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Behaviour(struct soap *soap, const struct ns2__Behaviour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Smoking(soap, &a->Smoking);
	soap_serialize_PointerTons2__UsingMobile(soap, &a->UsingMobile);
	soap_serialize_string(soap, (char*const*)&a->Activity);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Behaviour(struct soap *soap, const char *tag, int id, const struct ns2__Behaviour *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Behaviour), type))
		return soap->error;
	if (soap_out_PointerTons2__Smoking(soap, "ns2:Smoking", -1, &a->Smoking, ""))
		return soap->error;
	if (soap_out_PointerTons2__UsingMobile(soap, "ns2:UsingMobile", -1, &a->UsingMobile, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:Activity", -1, (char*const*)&a->Activity, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Behaviour * SOAP_FMAC4 soap_in_ns2__Behaviour(struct soap *soap, const char *tag, struct ns2__Behaviour *a, const char *type)
{
	size_t soap_flag_Smoking = 1;
	size_t soap_flag_UsingMobile = 1;
	size_t soap_flag_Activity = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__Behaviour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Behaviour, sizeof(struct ns2__Behaviour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Behaviour(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Smoking && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Smoking(soap, "ns2:Smoking", &a->Smoking, "ns2:Smoking"))
				{	soap_flag_Smoking--;
					continue;
				}
			}
			if (soap_flag_UsingMobile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__UsingMobile(soap, "ns2:UsingMobile", &a->UsingMobile, "ns2:UsingMobile"))
				{	soap_flag_UsingMobile--;
					continue;
				}
			}
			if (soap_flag_Activity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:Activity", (char**)&a->Activity, "xsd:string"))
				{	soap_flag_Activity--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Behaviour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Behaviour, SOAP_TYPE_ns2__Behaviour, sizeof(struct ns2__Behaviour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Behaviour * SOAP_FMAC4 soap_new_ns2__Behaviour(struct soap *soap, int n)
{
	struct ns2__Behaviour *p;
	struct ns2__Behaviour *a = (struct ns2__Behaviour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Behaviour));
	for (p = a; p && n--; p++)
		soap_default_ns2__Behaviour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Behaviour(struct soap *soap, const struct ns2__Behaviour *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Behaviour(soap, tag ? tag : "ns2:Behaviour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Behaviour * SOAP_FMAC4 soap_get_ns2__Behaviour(struct soap *soap, struct ns2__Behaviour *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Belonging(struct soap *soap, struct ns2__Belonging *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bag = NULL;
	a->Umbrella = NULL;
	a->LiftSomething = NULL;
	a->Box = NULL;
	a->Cart = NULL;
	a->Weapon = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Belonging(struct soap *soap, const struct ns2__Belonging *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Bag(soap, &a->Bag);
	soap_serialize_PointerTons2__Umbrella(soap, &a->Umbrella);
	soap_serialize_PointerToxsd__boolean(soap, &a->LiftSomething);
	soap_serialize_PointerTons2__Box(soap, &a->Box);
	soap_serialize_PointerTons2__Cart(soap, &a->Cart);
	soap_serialize_PointerToxsd__boolean(soap, &a->Weapon);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Belonging(struct soap *soap, const char *tag, int id, const struct ns2__Belonging *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Belonging), type))
		return soap->error;
	if (soap_out_PointerTons2__Bag(soap, "ns2:Bag", -1, &a->Bag, ""))
		return soap->error;
	if (soap_out_PointerTons2__Umbrella(soap, "ns2:Umbrella", -1, &a->Umbrella, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:LiftSomething", -1, &a->LiftSomething, ""))
		return soap->error;
	if (soap_out_PointerTons2__Box(soap, "ns2:Box", -1, &a->Box, ""))
		return soap->error;
	if (soap_out_PointerTons2__Cart(soap, "ns2:Cart", -1, &a->Cart, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:Weapon", -1, &a->Weapon, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Belonging * SOAP_FMAC4 soap_in_ns2__Belonging(struct soap *soap, const char *tag, struct ns2__Belonging *a, const char *type)
{
	size_t soap_flag_Bag = 1;
	size_t soap_flag_Umbrella = 1;
	size_t soap_flag_LiftSomething = 1;
	size_t soap_flag_Box = 1;
	size_t soap_flag_Cart = 1;
	size_t soap_flag_Weapon = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__Belonging*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Belonging, sizeof(struct ns2__Belonging), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Belonging(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bag && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Bag(soap, "ns2:Bag", &a->Bag, "ns2:Bag"))
				{	soap_flag_Bag--;
					continue;
				}
			}
			if (soap_flag_Umbrella && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Umbrella(soap, "ns2:Umbrella", &a->Umbrella, "ns2:Umbrella"))
				{	soap_flag_Umbrella--;
					continue;
				}
			}
			if (soap_flag_LiftSomething && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns2:LiftSomething", &a->LiftSomething, "xsd:boolean"))
				{	soap_flag_LiftSomething--;
					continue;
				}
			}
			if (soap_flag_Box && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Box(soap, "ns2:Box", &a->Box, "ns2:Box"))
				{	soap_flag_Box--;
					continue;
				}
			}
			if (soap_flag_Cart && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Cart(soap, "ns2:Cart", &a->Cart, "ns2:Cart"))
				{	soap_flag_Cart--;
					continue;
				}
			}
			if (soap_flag_Weapon && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns2:Weapon", &a->Weapon, "xsd:boolean"))
				{	soap_flag_Weapon--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Belonging *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Belonging, SOAP_TYPE_ns2__Belonging, sizeof(struct ns2__Belonging), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Belonging * SOAP_FMAC4 soap_new_ns2__Belonging(struct soap *soap, int n)
{
	struct ns2__Belonging *p;
	struct ns2__Belonging *a = (struct ns2__Belonging*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Belonging));
	for (p = a; p && n--; p++)
		soap_default_ns2__Belonging(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Belonging(struct soap *soap, const struct ns2__Belonging *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Belonging(soap, tag ? tag : "ns2:Belonging", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Belonging * SOAP_FMAC4 soap_get_ns2__Belonging(struct soap *soap, struct ns2__Belonging *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Belonging(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Cart(struct soap *soap, struct ns2__Cart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Category);
	a->Color = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Cart(struct soap *soap, const struct ns2__Cart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Category);
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Cart(struct soap *soap, const char *tag, int id, const struct ns2__Cart *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Cart), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:Category", -1, (char*const*)&a->Category, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "ns2:Color", -1, &a->Color, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Cart * SOAP_FMAC4 soap_in_ns2__Cart(struct soap *soap, const char *tag, struct ns2__Cart *a, const char *type)
{
	size_t soap_flag_Category = 1;
	size_t soap_flag_Color = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__Cart*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Cart, sizeof(struct ns2__Cart), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Cart(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Category && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:Category", (char**)&a->Category, "xsd:string"))
				{	soap_flag_Category--;
					continue;
				}
			}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "ns2:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Cart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Cart, SOAP_TYPE_ns2__Cart, sizeof(struct ns2__Cart), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Cart * SOAP_FMAC4 soap_new_ns2__Cart(struct soap *soap, int n)
{
	struct ns2__Cart *p;
	struct ns2__Cart *a = (struct ns2__Cart*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Cart));
	for (p = a; p && n--; p++)
		soap_default_ns2__Cart(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Cart(struct soap *soap, const struct ns2__Cart *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Cart(soap, tag ? tag : "ns2:Cart", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Cart * SOAP_FMAC4 soap_get_ns2__Cart(struct soap *soap, struct ns2__Cart *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Cart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Box(struct soap *soap, struct ns2__Box *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Lug = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Box(struct soap *soap, const struct ns2__Box *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	soap_serialize_PointerToxsd__boolean(soap, &a->Lug);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Box(struct soap *soap, const char *tag, int id, const struct ns2__Box *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Box), type))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "ns2:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:Lug", -1, &a->Lug, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Box * SOAP_FMAC4 soap_in_ns2__Box(struct soap *soap, const char *tag, struct ns2__Box *a, const char *type)
{
	size_t soap_flag_Color = 1;
	size_t soap_flag_Lug = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__Box*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Box, sizeof(struct ns2__Box), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Box(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "ns2:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap_flag_Lug && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns2:Lug", &a->Lug, "xsd:boolean"))
				{	soap_flag_Lug--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Box *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Box, SOAP_TYPE_ns2__Box, sizeof(struct ns2__Box), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Box * SOAP_FMAC4 soap_new_ns2__Box(struct soap *soap, int n)
{
	struct ns2__Box *p;
	struct ns2__Box *a = (struct ns2__Box*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Box));
	for (p = a; p && n--; p++)
		soap_default_ns2__Box(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Box(struct soap *soap, const struct ns2__Box *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Box(soap, tag ? tag : "ns2:Box", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Box * SOAP_FMAC4 soap_get_ns2__Box(struct soap *soap, struct ns2__Box *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Box(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Umbrella(struct soap *soap, struct ns2__Umbrella *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Open = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Umbrella(struct soap *soap, const struct ns2__Umbrella *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	soap_serialize_PointerToxsd__boolean(soap, &a->Open);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Umbrella(struct soap *soap, const char *tag, int id, const struct ns2__Umbrella *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Umbrella), type))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "ns2:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:Open", -1, &a->Open, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Umbrella * SOAP_FMAC4 soap_in_ns2__Umbrella(struct soap *soap, const char *tag, struct ns2__Umbrella *a, const char *type)
{
	size_t soap_flag_Color = 1;
	size_t soap_flag_Open = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__Umbrella*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Umbrella, sizeof(struct ns2__Umbrella), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Umbrella(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "ns2:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap_flag_Open && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns2:Open", &a->Open, "xsd:boolean"))
				{	soap_flag_Open--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Umbrella *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Umbrella, SOAP_TYPE_ns2__Umbrella, sizeof(struct ns2__Umbrella), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Umbrella * SOAP_FMAC4 soap_new_ns2__Umbrella(struct soap *soap, int n)
{
	struct ns2__Umbrella *p;
	struct ns2__Umbrella *a = (struct ns2__Umbrella*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Umbrella));
	for (p = a; p && n--; p++)
		soap_default_ns2__Umbrella(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Umbrella(struct soap *soap, const struct ns2__Umbrella *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Umbrella(soap, tag ? tag : "ns2:Umbrella", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Umbrella * SOAP_FMAC4 soap_get_ns2__Umbrella(struct soap *soap, struct ns2__Umbrella *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Umbrella(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Bag(struct soap *soap, struct ns2__Bag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Category);
	a->Color = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Bag(struct soap *soap, const struct ns2__Bag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Category);
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Bag(struct soap *soap, const char *tag, int id, const struct ns2__Bag *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Bag), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:Category", -1, (char*const*)&a->Category, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "ns2:Color", -1, &a->Color, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Bag * SOAP_FMAC4 soap_in_ns2__Bag(struct soap *soap, const char *tag, struct ns2__Bag *a, const char *type)
{
	size_t soap_flag_Category = 1;
	size_t soap_flag_Color = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__Bag*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Bag, sizeof(struct ns2__Bag), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Bag(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Category && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:Category", (char**)&a->Category, "xsd:string"))
				{	soap_flag_Category--;
					continue;
				}
			}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "ns2:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Bag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Bag, SOAP_TYPE_ns2__Bag, sizeof(struct ns2__Bag), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Bag * SOAP_FMAC4 soap_new_ns2__Bag(struct soap *soap, int n)
{
	struct ns2__Bag *p;
	struct ns2__Bag *a = (struct ns2__Bag*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Bag));
	for (p = a; p && n--; p++)
		soap_default_ns2__Bag(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Bag(struct soap *soap, const struct ns2__Bag *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Bag(soap, tag ? tag : "ns2:Bag", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Bag * SOAP_FMAC4 soap_get_ns2__Bag(struct soap *soap, struct ns2__Bag *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Bag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Clothing(struct soap *soap, struct ns2__Clothing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Scarf = NULL;
	a->Gloves = NULL;
	a->Tops = NULL;
	a->Bottoms = NULL;
	a->Shoes = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Clothing(struct soap *soap, const struct ns2__Clothing *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Scarf(soap, &a->Scarf);
	soap_serialize_PointerTons2__Gloves(soap, &a->Gloves);
	soap_serialize_PointerTons2__Tops(soap, &a->Tops);
	soap_serialize_PointerTons2__Bottoms(soap, &a->Bottoms);
	soap_serialize_PointerTons2__Shoes(soap, &a->Shoes);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Clothing(struct soap *soap, const char *tag, int id, const struct ns2__Clothing *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Clothing), type))
		return soap->error;
	if (soap_out_PointerTons2__Scarf(soap, "ns2:Scarf", -1, &a->Scarf, ""))
		return soap->error;
	if (soap_out_PointerTons2__Gloves(soap, "ns2:Gloves", -1, &a->Gloves, ""))
		return soap->error;
	if (soap_out_PointerTons2__Tops(soap, "ns2:Tops", -1, &a->Tops, ""))
		return soap->error;
	if (soap_out_PointerTons2__Bottoms(soap, "ns2:Bottoms", -1, &a->Bottoms, ""))
		return soap->error;
	if (soap_out_PointerTons2__Shoes(soap, "ns2:Shoes", -1, &a->Shoes, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Clothing * SOAP_FMAC4 soap_in_ns2__Clothing(struct soap *soap, const char *tag, struct ns2__Clothing *a, const char *type)
{
	size_t soap_flag_Scarf = 1;
	size_t soap_flag_Gloves = 1;
	size_t soap_flag_Tops = 1;
	size_t soap_flag_Bottoms = 1;
	size_t soap_flag_Shoes = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__Clothing*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Clothing, sizeof(struct ns2__Clothing), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Clothing(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Scarf && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Scarf(soap, "ns2:Scarf", &a->Scarf, "ns2:Scarf"))
				{	soap_flag_Scarf--;
					continue;
				}
			}
			if (soap_flag_Gloves && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Gloves(soap, "ns2:Gloves", &a->Gloves, "ns2:Gloves"))
				{	soap_flag_Gloves--;
					continue;
				}
			}
			if (soap_flag_Tops && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Tops(soap, "ns2:Tops", &a->Tops, "ns2:Tops"))
				{	soap_flag_Tops--;
					continue;
				}
			}
			if (soap_flag_Bottoms && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Bottoms(soap, "ns2:Bottoms", &a->Bottoms, "ns2:Bottoms"))
				{	soap_flag_Bottoms--;
					continue;
				}
			}
			if (soap_flag_Shoes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons2__Shoes(soap, "ns2:Shoes", &a->Shoes, "ns2:Shoes"))
				{	soap_flag_Shoes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Clothing *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Clothing, SOAP_TYPE_ns2__Clothing, sizeof(struct ns2__Clothing), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Clothing * SOAP_FMAC4 soap_new_ns2__Clothing(struct soap *soap, int n)
{
	struct ns2__Clothing *p;
	struct ns2__Clothing *a = (struct ns2__Clothing*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Clothing));
	for (p = a; p && n--; p++)
		soap_default_ns2__Clothing(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Clothing(struct soap *soap, const struct ns2__Clothing *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Clothing(soap, tag ? tag : "ns2:Clothing", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Clothing * SOAP_FMAC4 soap_get_ns2__Clothing(struct soap *soap, struct ns2__Clothing *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Clothing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Shoes(struct soap *soap, struct ns2__Shoes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Category);
	a->Color = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Shoes(struct soap *soap, const struct ns2__Shoes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Category);
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Shoes(struct soap *soap, const char *tag, int id, const struct ns2__Shoes *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Shoes), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:Category", -1, (char*const*)&a->Category, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "ns2:Color", -1, &a->Color, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Shoes * SOAP_FMAC4 soap_in_ns2__Shoes(struct soap *soap, const char *tag, struct ns2__Shoes *a, const char *type)
{
	size_t soap_flag_Category = 1;
	size_t soap_flag_Color = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__Shoes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Shoes, sizeof(struct ns2__Shoes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Shoes(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Category && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:Category", (char**)&a->Category, "xsd:string"))
				{	soap_flag_Category--;
					continue;
				}
			}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "ns2:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Shoes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Shoes, SOAP_TYPE_ns2__Shoes, sizeof(struct ns2__Shoes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Shoes * SOAP_FMAC4 soap_new_ns2__Shoes(struct soap *soap, int n)
{
	struct ns2__Shoes *p;
	struct ns2__Shoes *a = (struct ns2__Shoes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Shoes));
	for (p = a; p && n--; p++)
		soap_default_ns2__Shoes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Shoes(struct soap *soap, const struct ns2__Shoes *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Shoes(soap, tag ? tag : "ns2:Shoes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Shoes * SOAP_FMAC4 soap_get_ns2__Shoes(struct soap *soap, struct ns2__Shoes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Shoes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Bottoms(struct soap *soap, struct ns2__Bottoms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Category);
	a->Color = NULL;
	soap_default_string(soap, &a->Grain);
	soap_default_string(soap, &a->Style);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Bottoms(struct soap *soap, const struct ns2__Bottoms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Category);
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	soap_serialize_string(soap, (char*const*)&a->Grain);
	soap_serialize_string(soap, (char*const*)&a->Style);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Bottoms(struct soap *soap, const char *tag, int id, const struct ns2__Bottoms *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Bottoms), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:Category", -1, (char*const*)&a->Category, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "ns2:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:Grain", -1, (char*const*)&a->Grain, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:Style", -1, (char*const*)&a->Style, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Bottoms * SOAP_FMAC4 soap_in_ns2__Bottoms(struct soap *soap, const char *tag, struct ns2__Bottoms *a, const char *type)
{
	size_t soap_flag_Category = 1;
	size_t soap_flag_Color = 1;
	size_t soap_flag_Grain = 1;
	size_t soap_flag_Style = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__Bottoms*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Bottoms, sizeof(struct ns2__Bottoms), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Bottoms(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Category && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:Category", (char**)&a->Category, "xsd:string"))
				{	soap_flag_Category--;
					continue;
				}
			}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "ns2:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap_flag_Grain && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:Grain", (char**)&a->Grain, "xsd:string"))
				{	soap_flag_Grain--;
					continue;
				}
			}
			if (soap_flag_Style && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:Style", (char**)&a->Style, "xsd:string"))
				{	soap_flag_Style--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Bottoms *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Bottoms, SOAP_TYPE_ns2__Bottoms, sizeof(struct ns2__Bottoms), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Bottoms * SOAP_FMAC4 soap_new_ns2__Bottoms(struct soap *soap, int n)
{
	struct ns2__Bottoms *p;
	struct ns2__Bottoms *a = (struct ns2__Bottoms*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Bottoms));
	for (p = a; p && n--; p++)
		soap_default_ns2__Bottoms(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Bottoms(struct soap *soap, const struct ns2__Bottoms *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Bottoms(soap, tag ? tag : "ns2:Bottoms", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Bottoms * SOAP_FMAC4 soap_get_ns2__Bottoms(struct soap *soap, struct ns2__Bottoms *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Bottoms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Tops(struct soap *soap, struct ns2__Tops *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Category);
	a->Color = NULL;
	soap_default_string(soap, &a->Grain);
	soap_default_string(soap, &a->Style);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Tops(struct soap *soap, const struct ns2__Tops *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Category);
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	soap_serialize_string(soap, (char*const*)&a->Grain);
	soap_serialize_string(soap, (char*const*)&a->Style);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Tops(struct soap *soap, const char *tag, int id, const struct ns2__Tops *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Tops), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:Category", -1, (char*const*)&a->Category, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "ns2:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:Grain", -1, (char*const*)&a->Grain, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:Style", -1, (char*const*)&a->Style, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Tops * SOAP_FMAC4 soap_in_ns2__Tops(struct soap *soap, const char *tag, struct ns2__Tops *a, const char *type)
{
	size_t soap_flag_Category = 1;
	size_t soap_flag_Color = 1;
	size_t soap_flag_Grain = 1;
	size_t soap_flag_Style = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__Tops*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Tops, sizeof(struct ns2__Tops), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Tops(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Category && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:Category", (char**)&a->Category, "xsd:string"))
				{	soap_flag_Category--;
					continue;
				}
			}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "ns2:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap_flag_Grain && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:Grain", (char**)&a->Grain, "xsd:string"))
				{	soap_flag_Grain--;
					continue;
				}
			}
			if (soap_flag_Style && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:Style", (char**)&a->Style, "xsd:string"))
				{	soap_flag_Style--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Tops *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Tops, SOAP_TYPE_ns2__Tops, sizeof(struct ns2__Tops), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Tops * SOAP_FMAC4 soap_new_ns2__Tops(struct soap *soap, int n)
{
	struct ns2__Tops *p;
	struct ns2__Tops *a = (struct ns2__Tops*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Tops));
	for (p = a; p && n--; p++)
		soap_default_ns2__Tops(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Tops(struct soap *soap, const struct ns2__Tops *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Tops(soap, tag ? tag : "ns2:Tops", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Tops * SOAP_FMAC4 soap_get_ns2__Tops(struct soap *soap, struct ns2__Tops *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Tops(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Gloves(struct soap *soap, struct ns2__Gloves *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Wear = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Gloves(struct soap *soap, const struct ns2__Gloves *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	soap_serialize_PointerToxsd__boolean(soap, &a->Wear);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Gloves(struct soap *soap, const char *tag, int id, const struct ns2__Gloves *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Gloves), type))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "ns2:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:Wear", -1, &a->Wear, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Gloves * SOAP_FMAC4 soap_in_ns2__Gloves(struct soap *soap, const char *tag, struct ns2__Gloves *a, const char *type)
{
	size_t soap_flag_Color = 1;
	size_t soap_flag_Wear = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__Gloves*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Gloves, sizeof(struct ns2__Gloves), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Gloves(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "ns2:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap_flag_Wear && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns2:Wear", &a->Wear, "xsd:boolean"))
				{	soap_flag_Wear--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Gloves *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Gloves, SOAP_TYPE_ns2__Gloves, sizeof(struct ns2__Gloves), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Gloves * SOAP_FMAC4 soap_new_ns2__Gloves(struct soap *soap, int n)
{
	struct ns2__Gloves *p;
	struct ns2__Gloves *a = (struct ns2__Gloves*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Gloves));
	for (p = a; p && n--; p++)
		soap_default_ns2__Gloves(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Gloves(struct soap *soap, const struct ns2__Gloves *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Gloves(soap, tag ? tag : "ns2:Gloves", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Gloves * SOAP_FMAC4 soap_get_ns2__Gloves(struct soap *soap, struct ns2__Gloves *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Gloves(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Scarf(struct soap *soap, struct ns2__Scarf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Wear = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Scarf(struct soap *soap, const struct ns2__Scarf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	soap_serialize_PointerToxsd__boolean(soap, &a->Wear);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Scarf(struct soap *soap, const char *tag, int id, const struct ns2__Scarf *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Scarf), type))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "ns2:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns2:Wear", -1, &a->Wear, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Scarf * SOAP_FMAC4 soap_in_ns2__Scarf(struct soap *soap, const char *tag, struct ns2__Scarf *a, const char *type)
{
	size_t soap_flag_Color = 1;
	size_t soap_flag_Wear = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__Scarf*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Scarf, sizeof(struct ns2__Scarf), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Scarf(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "ns2:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap_flag_Wear && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns2:Wear", &a->Wear, "xsd:boolean"))
				{	soap_flag_Wear--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Scarf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Scarf, SOAP_TYPE_ns2__Scarf, sizeof(struct ns2__Scarf), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Scarf * SOAP_FMAC4 soap_new_ns2__Scarf(struct soap *soap, int n)
{
	struct ns2__Scarf *p;
	struct ns2__Scarf *a = (struct ns2__Scarf*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Scarf));
	for (p = a; p && n--; p++)
		soap_default_ns2__Scarf(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Scarf(struct soap *soap, const struct ns2__Scarf *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Scarf(soap, tag ? tag : "ns2:Scarf", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Scarf * SOAP_FMAC4 soap_get_ns2__Scarf(struct soap *soap, struct ns2__Scarf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Scarf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__BodyMetric(struct soap *soap, struct ns2__BodyMetric *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Height = NULL;
	soap_default_string(soap, &a->BodyShape);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__BodyMetric(struct soap *soap, const struct ns2__BodyMetric *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Height);
	soap_serialize_string(soap, (char*const*)&a->BodyShape);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BodyMetric(struct soap *soap, const char *tag, int id, const struct ns2__BodyMetric *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BodyMetric), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:Height", -1, &a->Height, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:BodyShape", -1, (char*const*)&a->BodyShape, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__BodyMetric * SOAP_FMAC4 soap_in_ns2__BodyMetric(struct soap *soap, const char *tag, struct ns2__BodyMetric *a, const char *type)
{
	size_t soap_flag_Height = 1;
	size_t soap_flag_BodyShape = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns2__BodyMetric*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BodyMetric, sizeof(struct ns2__BodyMetric), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__BodyMetric(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "ns2:Height", &a->Height, "xsd:int"))
				{	soap_flag_Height--;
					continue;
				}
			}
			if (soap_flag_BodyShape && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns2:BodyShape", (char**)&a->BodyShape, "xsd:string"))
				{	soap_flag_BodyShape--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__BodyMetric *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BodyMetric, SOAP_TYPE_ns2__BodyMetric, sizeof(struct ns2__BodyMetric), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__BodyMetric * SOAP_FMAC4 soap_new_ns2__BodyMetric(struct soap *soap, int n)
{
	struct ns2__BodyMetric *p;
	struct ns2__BodyMetric *a = (struct ns2__BodyMetric*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__BodyMetric));
	for (p = a; p && n--; p++)
		soap_default_ns2__BodyMetric(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__BodyMetric(struct soap *soap, const struct ns2__BodyMetric *a, const char *tag, const char *type)
{
	if (soap_out_ns2__BodyMetric(soap, tag ? tag : "ns2:BodyMetric", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BodyMetric * SOAP_FMAC4 soap_get_ns2__BodyMetric(struct soap *soap, struct ns2__BodyMetric *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BodyMetric(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AdditionalFeatures(struct soap *soap, struct ns1__AdditionalFeatures *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Scar = NULL;
	a->Mole = NULL;
	a->Tattoo = NULL;
	soap_default_string(soap, &a->Freckles);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AdditionalFeatures(struct soap *soap, const struct ns1__AdditionalFeatures *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->Scar);
	soap_serialize_PointerToxsd__boolean(soap, &a->Mole);
	soap_serialize_PointerToxsd__boolean(soap, &a->Tattoo);
	soap_serialize_string(soap, (char*const*)&a->Freckles);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AdditionalFeatures(struct soap *soap, const char *tag, int id, const struct ns1__AdditionalFeatures *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AdditionalFeatures), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Scar", -1, &a->Scar, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Mole", -1, &a->Mole, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Tattoo", -1, &a->Tattoo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Freckles", -1, (char*const*)&a->Freckles, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AdditionalFeatures * SOAP_FMAC4 soap_in_ns1__AdditionalFeatures(struct soap *soap, const char *tag, struct ns1__AdditionalFeatures *a, const char *type)
{
	size_t soap_flag_Scar = 1;
	size_t soap_flag_Mole = 1;
	size_t soap_flag_Tattoo = 1;
	size_t soap_flag_Freckles = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__AdditionalFeatures*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AdditionalFeatures, sizeof(struct ns1__AdditionalFeatures), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AdditionalFeatures(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Scar && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns1:Scar", &a->Scar, "xsd:boolean"))
				{	soap_flag_Scar--;
					continue;
				}
			}
			if (soap_flag_Mole && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns1:Mole", &a->Mole, "xsd:boolean"))
				{	soap_flag_Mole--;
					continue;
				}
			}
			if (soap_flag_Tattoo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns1:Tattoo", &a->Tattoo, "xsd:boolean"))
				{	soap_flag_Tattoo--;
					continue;
				}
			}
			if (soap_flag_Freckles && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Freckles", (char**)&a->Freckles, "xsd:string"))
				{	soap_flag_Freckles--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AdditionalFeatures *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AdditionalFeatures, SOAP_TYPE_ns1__AdditionalFeatures, sizeof(struct ns1__AdditionalFeatures), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__AdditionalFeatures * SOAP_FMAC4 soap_new_ns1__AdditionalFeatures(struct soap *soap, int n)
{
	struct ns1__AdditionalFeatures *p;
	struct ns1__AdditionalFeatures *a = (struct ns1__AdditionalFeatures*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__AdditionalFeatures));
	for (p = a; p && n--; p++)
		soap_default_ns1__AdditionalFeatures(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AdditionalFeatures(struct soap *soap, const struct ns1__AdditionalFeatures *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AdditionalFeatures(soap, tag ? tag : "ns1:AdditionalFeatures", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AdditionalFeatures * SOAP_FMAC4 soap_get_ns1__AdditionalFeatures(struct soap *soap, struct ns1__AdditionalFeatures *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AdditionalFeatures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Accessory(struct soap *soap, struct ns1__Accessory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Opticals = NULL;
	a->Hat = NULL;
	a->Mask = NULL;
	a->Hijab = NULL;
	a->Helmet = NULL;
	a->Kerchief = NULL;
	a->RightEyePatch = NULL;
	a->LeftEyePatch = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Accessory(struct soap *soap, const struct ns1__Accessory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__AccessoryDescription(soap, &a->Opticals);
	soap_serialize_PointerTons1__AccessoryDescription(soap, &a->Hat);
	soap_serialize_PointerTons1__AccessoryDescription(soap, &a->Mask);
	soap_serialize_PointerTons1__AccessoryDescription(soap, &a->Hijab);
	soap_serialize_PointerTons1__AccessoryDescription(soap, &a->Helmet);
	soap_serialize_PointerTons1__AccessoryDescription(soap, &a->Kerchief);
	soap_serialize_PointerTons1__AccessoryDescription(soap, &a->RightEyePatch);
	soap_serialize_PointerTons1__AccessoryDescription(soap, &a->LeftEyePatch);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Accessory(struct soap *soap, const char *tag, int id, const struct ns1__Accessory *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Accessory), type))
		return soap->error;
	if (soap_out_PointerTons1__AccessoryDescription(soap, "ns1:Opticals", -1, &a->Opticals, ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessoryDescription(soap, "ns1:Hat", -1, &a->Hat, ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessoryDescription(soap, "ns1:Mask", -1, &a->Mask, ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessoryDescription(soap, "ns1:Hijab", -1, &a->Hijab, ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessoryDescription(soap, "ns1:Helmet", -1, &a->Helmet, ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessoryDescription(soap, "ns1:Kerchief", -1, &a->Kerchief, ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessoryDescription(soap, "ns1:RightEyePatch", -1, &a->RightEyePatch, ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessoryDescription(soap, "ns1:LeftEyePatch", -1, &a->LeftEyePatch, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Accessory * SOAP_FMAC4 soap_in_ns1__Accessory(struct soap *soap, const char *tag, struct ns1__Accessory *a, const char *type)
{
	size_t soap_flag_Opticals = 1;
	size_t soap_flag_Hat = 1;
	size_t soap_flag_Mask = 1;
	size_t soap_flag_Hijab = 1;
	size_t soap_flag_Helmet = 1;
	size_t soap_flag_Kerchief = 1;
	size_t soap_flag_RightEyePatch = 1;
	size_t soap_flag_LeftEyePatch = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__Accessory*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Accessory, sizeof(struct ns1__Accessory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Accessory(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Opticals && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AccessoryDescription(soap, "ns1:Opticals", &a->Opticals, "ns1:AccessoryDescription"))
				{	soap_flag_Opticals--;
					continue;
				}
			}
			if (soap_flag_Hat && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AccessoryDescription(soap, "ns1:Hat", &a->Hat, "ns1:AccessoryDescription"))
				{	soap_flag_Hat--;
					continue;
				}
			}
			if (soap_flag_Mask && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AccessoryDescription(soap, "ns1:Mask", &a->Mask, "ns1:AccessoryDescription"))
				{	soap_flag_Mask--;
					continue;
				}
			}
			if (soap_flag_Hijab && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AccessoryDescription(soap, "ns1:Hijab", &a->Hijab, "ns1:AccessoryDescription"))
				{	soap_flag_Hijab--;
					continue;
				}
			}
			if (soap_flag_Helmet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AccessoryDescription(soap, "ns1:Helmet", &a->Helmet, "ns1:AccessoryDescription"))
				{	soap_flag_Helmet--;
					continue;
				}
			}
			if (soap_flag_Kerchief && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AccessoryDescription(soap, "ns1:Kerchief", &a->Kerchief, "ns1:AccessoryDescription"))
				{	soap_flag_Kerchief--;
					continue;
				}
			}
			if (soap_flag_RightEyePatch && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AccessoryDescription(soap, "ns1:RightEyePatch", &a->RightEyePatch, "ns1:AccessoryDescription"))
				{	soap_flag_RightEyePatch--;
					continue;
				}
			}
			if (soap_flag_LeftEyePatch && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AccessoryDescription(soap, "ns1:LeftEyePatch", &a->LeftEyePatch, "ns1:AccessoryDescription"))
				{	soap_flag_LeftEyePatch--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Accessory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Accessory, SOAP_TYPE_ns1__Accessory, sizeof(struct ns1__Accessory), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__Accessory * SOAP_FMAC4 soap_new_ns1__Accessory(struct soap *soap, int n)
{
	struct ns1__Accessory *p;
	struct ns1__Accessory *a = (struct ns1__Accessory*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__Accessory));
	for (p = a; p && n--; p++)
		soap_default_ns1__Accessory(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Accessory(struct soap *soap, const struct ns1__Accessory *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Accessory(soap, tag ? tag : "ns1:Accessory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Accessory * SOAP_FMAC4 soap_get_ns1__Accessory(struct soap *soap, struct ns1__Accessory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Accessory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AccessoryDescription(struct soap *soap, struct ns1__AccessoryDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Wear = NULL;
	a->Color = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AccessoryDescription(struct soap *soap, const struct ns1__AccessoryDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->Wear);
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessoryDescription(struct soap *soap, const char *tag, int id, const struct ns1__AccessoryDescription *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessoryDescription), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Wear", -1, &a->Wear, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "ns1:Color", -1, &a->Color, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AccessoryDescription * SOAP_FMAC4 soap_in_ns1__AccessoryDescription(struct soap *soap, const char *tag, struct ns1__AccessoryDescription *a, const char *type)
{
	size_t soap_flag_Wear = 1;
	size_t soap_flag_Color = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__AccessoryDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessoryDescription, sizeof(struct ns1__AccessoryDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AccessoryDescription(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Wear && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns1:Wear", &a->Wear, "xsd:boolean"))
				{	soap_flag_Wear--;
					continue;
				}
			}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "ns1:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AccessoryDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccessoryDescription, SOAP_TYPE_ns1__AccessoryDescription, sizeof(struct ns1__AccessoryDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__AccessoryDescription * SOAP_FMAC4 soap_new_ns1__AccessoryDescription(struct soap *soap, int n)
{
	struct ns1__AccessoryDescription *p;
	struct ns1__AccessoryDescription *a = (struct ns1__AccessoryDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__AccessoryDescription));
	for (p = a; p && n--; p++)
		soap_default_ns1__AccessoryDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AccessoryDescription(struct soap *soap, const struct ns1__AccessoryDescription *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AccessoryDescription(soap, tag ? tag : "ns1:AccessoryDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AccessoryDescription * SOAP_FMAC4 soap_get_ns1__AccessoryDescription(struct soap *soap, struct ns1__AccessoryDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessoryDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PoseAngle(struct soap *soap, struct ns1__PoseAngle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PoseAngles = NULL;
	a->Uncertainty = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PoseAngle(struct soap *soap, const struct ns1__PoseAngle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__GeoOrientation(soap, &a->PoseAngles);
	soap_serialize_PointerTott__GeoOrientation(soap, &a->Uncertainty);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PoseAngle(struct soap *soap, const char *tag, int id, const struct ns1__PoseAngle *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PoseAngle), type))
		return soap->error;
	if (soap_out_PointerTott__GeoOrientation(soap, "ns1:PoseAngles", -1, &a->PoseAngles, ""))
		return soap->error;
	if (soap_out_PointerTott__GeoOrientation(soap, "ns1:Uncertainty", -1, &a->Uncertainty, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__PoseAngle * SOAP_FMAC4 soap_in_ns1__PoseAngle(struct soap *soap, const char *tag, struct ns1__PoseAngle *a, const char *type)
{
	size_t soap_flag_PoseAngles = 1;
	size_t soap_flag_Uncertainty = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__PoseAngle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PoseAngle, sizeof(struct ns1__PoseAngle), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__PoseAngle(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PoseAngles && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoOrientation(soap, "ns1:PoseAngles", &a->PoseAngles, "tt:GeoOrientation"))
				{	soap_flag_PoseAngles--;
					continue;
				}
			}
			if (soap_flag_Uncertainty && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoOrientation(soap, "ns1:Uncertainty", &a->Uncertainty, "tt:GeoOrientation"))
				{	soap_flag_Uncertainty--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__PoseAngle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PoseAngle, SOAP_TYPE_ns1__PoseAngle, sizeof(struct ns1__PoseAngle), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__PoseAngle * SOAP_FMAC4 soap_new_ns1__PoseAngle(struct soap *soap, int n)
{
	struct ns1__PoseAngle *p;
	struct ns1__PoseAngle *a = (struct ns1__PoseAngle*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__PoseAngle));
	for (p = a; p && n--; p++)
		soap_default_ns1__PoseAngle(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PoseAngle(struct soap *soap, const struct ns1__PoseAngle *a, const char *tag, const char *type)
{
	if (soap_out_ns1__PoseAngle(soap, tag ? tag : "ns1:PoseAngle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PoseAngle * SOAP_FMAC4 soap_get_ns1__PoseAngle(struct soap *soap, struct ns1__PoseAngle *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PoseAngle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__FacialHair(struct soap *soap, struct ns1__FacialHair *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Mustache = NULL;
	a->Beard = NULL;
	a->Sideburn = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__FacialHair(struct soap *soap, const struct ns1__FacialHair *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->Mustache);
	soap_serialize_PointerToxsd__boolean(soap, &a->Beard);
	soap_serialize_PointerToxsd__boolean(soap, &a->Sideburn);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FacialHair(struct soap *soap, const char *tag, int id, const struct ns1__FacialHair *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FacialHair), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Mustache", -1, &a->Mustache, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Beard", -1, &a->Beard, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Sideburn", -1, &a->Sideburn, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__FacialHair * SOAP_FMAC4 soap_in_ns1__FacialHair(struct soap *soap, const char *tag, struct ns1__FacialHair *a, const char *type)
{
	size_t soap_flag_Mustache = 1;
	size_t soap_flag_Beard = 1;
	size_t soap_flag_Sideburn = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__FacialHair*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FacialHair, sizeof(struct ns1__FacialHair), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__FacialHair(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mustache && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns1:Mustache", &a->Mustache, "xsd:boolean"))
				{	soap_flag_Mustache--;
					continue;
				}
			}
			if (soap_flag_Beard && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns1:Beard", &a->Beard, "xsd:boolean"))
				{	soap_flag_Beard--;
					continue;
				}
			}
			if (soap_flag_Sideburn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns1:Sideburn", &a->Sideburn, "xsd:boolean"))
				{	soap_flag_Sideburn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__FacialHair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FacialHair, SOAP_TYPE_ns1__FacialHair, sizeof(struct ns1__FacialHair), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__FacialHair * SOAP_FMAC4 soap_new_ns1__FacialHair(struct soap *soap, int n)
{
	struct ns1__FacialHair *p;
	struct ns1__FacialHair *a = (struct ns1__FacialHair*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__FacialHair));
	for (p = a; p && n--; p++)
		soap_default_ns1__FacialHair(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__FacialHair(struct soap *soap, const struct ns1__FacialHair *a, const char *tag, const char *type)
{
	if (soap_out_ns1__FacialHair(soap, tag ? tag : "ns1:FacialHair", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FacialHair * SOAP_FMAC4 soap_get_ns1__FacialHair(struct soap *soap, struct ns1__FacialHair *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FacialHair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Nose(struct soap *soap, struct ns1__Nose *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Length);
	soap_default_string(soap, &a->NoseBridge);
	soap_default_string(soap, &a->NoseWing);
	soap_default_string(soap, &a->NoseEnd);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Nose(struct soap *soap, const struct ns1__Nose *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Length);
	soap_serialize_string(soap, (char*const*)&a->NoseBridge);
	soap_serialize_string(soap, (char*const*)&a->NoseWing);
	soap_serialize_string(soap, (char*const*)&a->NoseEnd);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Nose(struct soap *soap, const char *tag, int id, const struct ns1__Nose *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Nose), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Length", -1, (char*const*)&a->Length, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:NoseBridge", -1, (char*const*)&a->NoseBridge, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:NoseWing", -1, (char*const*)&a->NoseWing, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:NoseEnd", -1, (char*const*)&a->NoseEnd, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Nose * SOAP_FMAC4 soap_in_ns1__Nose(struct soap *soap, const char *tag, struct ns1__Nose *a, const char *type)
{
	size_t soap_flag_Length = 1;
	size_t soap_flag_NoseBridge = 1;
	size_t soap_flag_NoseWing = 1;
	size_t soap_flag_NoseEnd = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__Nose*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Nose, sizeof(struct ns1__Nose), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Nose(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Length && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Length", (char**)&a->Length, "xsd:string"))
				{	soap_flag_Length--;
					continue;
				}
			}
			if (soap_flag_NoseBridge && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:NoseBridge", (char**)&a->NoseBridge, "xsd:string"))
				{	soap_flag_NoseBridge--;
					continue;
				}
			}
			if (soap_flag_NoseWing && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:NoseWing", (char**)&a->NoseWing, "xsd:string"))
				{	soap_flag_NoseWing--;
					continue;
				}
			}
			if (soap_flag_NoseEnd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:NoseEnd", (char**)&a->NoseEnd, "xsd:string"))
				{	soap_flag_NoseEnd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Nose *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Nose, SOAP_TYPE_ns1__Nose, sizeof(struct ns1__Nose), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__Nose * SOAP_FMAC4 soap_new_ns1__Nose(struct soap *soap, int n)
{
	struct ns1__Nose *p;
	struct ns1__Nose *a = (struct ns1__Nose*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__Nose));
	for (p = a; p && n--; p++)
		soap_default_ns1__Nose(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Nose(struct soap *soap, const struct ns1__Nose *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Nose(soap, tag ? tag : "ns1:Nose", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Nose * SOAP_FMAC4 soap_get_ns1__Nose(struct soap *soap, struct ns1__Nose *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Nose(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Eye(struct soap *soap, struct ns1__Eye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Shape);
	soap_default_string(soap, &a->Eyelid);
	soap_default_string(soap, &a->Eyeball);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Eye(struct soap *soap, const struct ns1__Eye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Shape);
	soap_serialize_string(soap, (char*const*)&a->Eyelid);
	soap_serialize_string(soap, (char*const*)&a->Eyeball);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Eye(struct soap *soap, const char *tag, int id, const struct ns1__Eye *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Eye), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Shape", -1, (char*const*)&a->Shape, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Eyelid", -1, (char*const*)&a->Eyelid, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Eyeball", -1, (char*const*)&a->Eyeball, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Eye * SOAP_FMAC4 soap_in_ns1__Eye(struct soap *soap, const char *tag, struct ns1__Eye *a, const char *type)
{
	size_t soap_flag_Shape = 1;
	size_t soap_flag_Eyelid = 1;
	size_t soap_flag_Eyeball = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__Eye*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Eye, sizeof(struct ns1__Eye), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Eye(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Shape && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Shape", (char**)&a->Shape, "xsd:string"))
				{	soap_flag_Shape--;
					continue;
				}
			}
			if (soap_flag_Eyelid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Eyelid", (char**)&a->Eyelid, "xsd:string"))
				{	soap_flag_Eyelid--;
					continue;
				}
			}
			if (soap_flag_Eyeball && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Eyeball", (char**)&a->Eyeball, "xsd:string"))
				{	soap_flag_Eyeball--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Eye *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Eye, SOAP_TYPE_ns1__Eye, sizeof(struct ns1__Eye), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__Eye * SOAP_FMAC4 soap_new_ns1__Eye(struct soap *soap, int n)
{
	struct ns1__Eye *p;
	struct ns1__Eye *a = (struct ns1__Eye*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__Eye));
	for (p = a; p && n--; p++)
		soap_default_ns1__Eye(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Eye(struct soap *soap, const struct ns1__Eye *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Eye(soap, tag ? tag : "ns1:Eye", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Eye * SOAP_FMAC4 soap_get_ns1__Eye(struct soap *soap, struct ns1__Eye *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Eye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Eyebrow(struct soap *soap, struct ns1__Eyebrow *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Width);
	a->Color = NULL;
	soap_default_string(soap, &a->Space);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Eyebrow(struct soap *soap, const struct ns1__Eyebrow *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Width);
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	soap_serialize_string(soap, (char*const*)&a->Space);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Eyebrow(struct soap *soap, const char *tag, int id, const struct ns1__Eyebrow *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Eyebrow), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Width", -1, (char*const*)&a->Width, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "ns1:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Space", -1, (char*const*)&a->Space, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Eyebrow * SOAP_FMAC4 soap_in_ns1__Eyebrow(struct soap *soap, const char *tag, struct ns1__Eyebrow *a, const char *type)
{
	size_t soap_flag_Width = 1;
	size_t soap_flag_Color = 1;
	size_t soap_flag_Space = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__Eyebrow*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Eyebrow, sizeof(struct ns1__Eyebrow), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Eyebrow(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Width", (char**)&a->Width, "xsd:string"))
				{	soap_flag_Width--;
					continue;
				}
			}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "ns1:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap_flag_Space && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Space", (char**)&a->Space, "xsd:string"))
				{	soap_flag_Space--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Eyebrow *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Eyebrow, SOAP_TYPE_ns1__Eyebrow, sizeof(struct ns1__Eyebrow), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__Eyebrow * SOAP_FMAC4 soap_new_ns1__Eyebrow(struct soap *soap, int n)
{
	struct ns1__Eyebrow *p;
	struct ns1__Eyebrow *a = (struct ns1__Eyebrow*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__Eyebrow));
	for (p = a; p && n--; p++)
		soap_default_ns1__Eyebrow(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Eyebrow(struct soap *soap, const struct ns1__Eyebrow *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Eyebrow(soap, tag ? tag : "ns1:Eyebrow", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Eyebrow * SOAP_FMAC4 soap_get_ns1__Eyebrow(struct soap *soap, struct ns1__Eyebrow *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Eyebrow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Hair(struct soap *soap, struct ns1__Hair *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Length);
	soap_default_string(soap, &a->Style);
	a->Color = NULL;
	a->Bangs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Hair(struct soap *soap, const struct ns1__Hair *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Length);
	soap_serialize_string(soap, (char*const*)&a->Style);
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	soap_serialize_PointerToxsd__boolean(soap, &a->Bangs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Hair(struct soap *soap, const char *tag, int id, const struct ns1__Hair *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Hair), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Length", -1, (char*const*)&a->Length, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Style", -1, (char*const*)&a->Style, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "ns1:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Bangs", -1, &a->Bangs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Hair * SOAP_FMAC4 soap_in_ns1__Hair(struct soap *soap, const char *tag, struct ns1__Hair *a, const char *type)
{
	size_t soap_flag_Length = 1;
	size_t soap_flag_Style = 1;
	size_t soap_flag_Color = 1;
	size_t soap_flag_Bangs = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__Hair*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Hair, sizeof(struct ns1__Hair), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Hair(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Length && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Length", (char**)&a->Length, "xsd:string"))
				{	soap_flag_Length--;
					continue;
				}
			}
			if (soap_flag_Style && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "ns1:Style", (char**)&a->Style, "xsd:string"))
				{	soap_flag_Style--;
					continue;
				}
			}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorDescriptor(soap, "ns1:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			}
			if (soap_flag_Bangs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "ns1:Bangs", &a->Bangs, "xsd:boolean"))
				{	soap_flag_Bangs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Hair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Hair, SOAP_TYPE_ns1__Hair, sizeof(struct ns1__Hair), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__Hair * SOAP_FMAC4 soap_new_ns1__Hair(struct soap *soap, int n)
{
	struct ns1__Hair *p;
	struct ns1__Hair *a = (struct ns1__Hair*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__Hair));
	for (p = a; p && n--; p++)
		soap_default_ns1__Hair(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Hair(struct soap *soap, const struct ns1__Hair *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Hair(soap, tag ? tag : "ns1:Hair", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Hair * SOAP_FMAC4 soap_get_ns1__Hair(struct soap *soap, struct ns1__Hair *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Hair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyURI(soap, &a->Dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__QueryExpressionType(struct soap *soap, const struct wstop__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__QueryExpressionType(struct soap *soap, const char *tag, int id, const struct wstop__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", a->Dialect ? soap_xsd__anyURI2s(soap, a->Dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__QueryExpressionType), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__QueryExpressionType * SOAP_FMAC4 soap_in_wstop__QueryExpressionType(struct soap *soap, const char *tag, struct wstop__QueryExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__QueryExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__QueryExpressionType(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &a->Dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__QueryExpressionType, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__QueryExpressionType * SOAP_FMAC4 soap_new_wstop__QueryExpressionType(struct soap *soap, int n)
{
	struct wstop__QueryExpressionType *p;
	struct wstop__QueryExpressionType *a = (struct wstop__QueryExpressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__QueryExpressionType));
	for (p = a; p && n--; p++)
		soap_default_wstop__QueryExpressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__QueryExpressionType(struct soap *soap, const struct wstop__QueryExpressionType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__QueryExpressionType(soap, tag ? tag : "wstop:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__QueryExpressionType * SOAP_FMAC4 soap_get_wstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__ExtensibleDocumented(struct soap *soap, struct wstop__ExtensibleDocumented *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__ExtensibleDocumented(struct soap *soap, const struct wstop__ExtensibleDocumented *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, int id, const struct wstop__ExtensibleDocumented *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__ExtensibleDocumented), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__ExtensibleDocumented * SOAP_FMAC4 soap_in_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, struct wstop__ExtensibleDocumented *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__ExtensibleDocumented*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(struct wstop__ExtensibleDocumented), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__ExtensibleDocumented(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__ExtensibleDocumented *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__ExtensibleDocumented, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(struct wstop__ExtensibleDocumented), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__ExtensibleDocumented * SOAP_FMAC4 soap_new_wstop__ExtensibleDocumented(struct soap *soap, int n)
{
	struct wstop__ExtensibleDocumented *p;
	struct wstop__ExtensibleDocumented *a = (struct wstop__ExtensibleDocumented*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__ExtensibleDocumented));
	for (p = a; p && n--; p++)
		soap_default_wstop__ExtensibleDocumented(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ExtensibleDocumented(struct soap *soap, const struct wstop__ExtensibleDocumented *a, const char *tag, const char *type)
{
	if (soap_out_wstop__ExtensibleDocumented(soap, tag ? tag : "wstop:ExtensibleDocumented", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__ExtensibleDocumented * SOAP_FMAC4 soap_get_wstop__ExtensibleDocumented(struct soap *soap, struct wstop__ExtensibleDocumented *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ExtensibleDocumented(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__Documentation(struct soap *soap, struct wstop__Documentation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__Documentation(struct soap *soap, const struct wstop__Documentation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__Documentation(struct soap *soap, const char *tag, int id, const struct wstop__Documentation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__Documentation), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__Documentation * SOAP_FMAC4 soap_in_wstop__Documentation(struct soap *soap, const char *tag, struct wstop__Documentation *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__Documentation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__Documentation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__Documentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__Documentation, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__Documentation * SOAP_FMAC4 soap_new_wstop__Documentation(struct soap *soap, int n)
{
	struct wstop__Documentation *p;
	struct wstop__Documentation *a = (struct wstop__Documentation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__Documentation));
	for (p = a; p && n--; p++)
		soap_default_wstop__Documentation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__Documentation(struct soap *soap, const struct wstop__Documentation *a, const char *tag, const char *type)
{
	if (soap_out_wstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__Documentation * SOAP_FMAC4 soap_get_wstop__Documentation(struct soap *soap, struct wstop__Documentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const struct _wsrfbf__BaseFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsrfbf__BaseFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfbf__BaseFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfbf__BaseFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_new__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsrfbf__BaseFaultType_FaultCause *p;
	struct _wsrfbf__BaseFaultType_FaultCause *a = (struct _wsrfbf__BaseFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfbf__BaseFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsrfbf__BaseFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const struct _wsrfbf__BaseFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfbf__BaseFaultType_Description(struct soap *soap, const struct _wsrfbf__BaseFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsrfbf__BaseFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsrfbf__BaseFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(struct _wsrfbf__BaseFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsrfbf__BaseFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_new__wsrfbf__BaseFaultType_Description(struct soap *soap, int n)
{
	struct _wsrfbf__BaseFaultType_Description *p;
	struct _wsrfbf__BaseFaultType_Description *a = (struct _wsrfbf__BaseFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfbf__BaseFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsrfbf__BaseFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfbf__BaseFaultType_Description(struct soap *soap, const struct _wsrfbf__BaseFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsrfbf__BaseFaultType_Description(soap, tag ? tag : "wsrfbf:BaseFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const struct _wsrfbf__BaseFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsrfbf__BaseFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfbf__BaseFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfbf__BaseFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsrfbf__BaseFaultType_ErrorCode *p;
	struct _wsrfbf__BaseFaultType_ErrorCode *a = (struct _wsrfbf__BaseFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfbf__BaseFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsrfbf__BaseFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const struct _wsrfbf__BaseFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrfbf__BaseFaultType(struct soap *soap, struct wsrfbf__BaseFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->Timestamp);
	a->Originator = NULL;
	a->ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->Description = NULL;
	a->FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrfbf__BaseFaultType(struct soap *soap, const struct wsrfbf__BaseFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->Originator);
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, &a->ErrorCode);
	if (a->Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->Description + i, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
			soap_serialize__wsrfbf__BaseFaultType_Description(soap, a->Description + i);
		}
	}
	soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, &a->FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, int id, const struct wsrfbf__BaseFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfbf__BaseFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->ErrorCode, ""))
		return soap->error;
	if (a->Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", -1, a->Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrfbf__BaseFaultType * SOAP_FMAC4 soap_in_wsrfbf__BaseFaultType(struct soap *soap, const char *tag, struct wsrfbf__BaseFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Timestamp = 1;
	size_t soap_flag_Originator = 1;
	size_t soap_flag_ErrorCode = 1;
	struct soap_blist *soap_blist_Description = NULL;
	size_t soap_flag_FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrfbf__BaseFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(struct wsrfbf__BaseFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrfbf__BaseFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp--;
					continue;
				}
			}
			if (soap_flag_Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator--;
					continue;
				}
			}
			if (soap_flag_ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->ErrorCode, ""))
				{	soap_flag_ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->Description == NULL)
				{	if (soap_blist_Description == NULL)
						soap_blist_Description = soap_alloc_block(soap);
					a->Description = (struct _wsrfbf__BaseFaultType_Description *)soap_push_block_max(soap, soap_blist_Description, sizeof(struct _wsrfbf__BaseFaultType_Description));
					if (a->Description == NULL)
						return NULL;
					soap_default__wsrfbf__BaseFaultType_Description(soap, a->Description);
				}
				soap_revert(soap);
				if (soap_in__wsrfbf__BaseFaultType_Description(soap, "wsrfbf:Description", a->Description, ""))
				{	a->__sizeDescription++;
					a->Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->FaultCause, ""))
				{	soap_flag_FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Description)
			soap_pop_block(soap, soap_blist_Description);
		if (a->__sizeDescription)
		{	a->Description = (struct _wsrfbf__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description, NULL, 1);
		}
		else
		{	a->Description = NULL;
			if (soap_blist_Description)
				soap_end_block(soap, soap_blist_Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrfbf__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfbf__BaseFaultType, SOAP_TYPE_wsrfbf__BaseFaultType, sizeof(struct wsrfbf__BaseFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrfbf__BaseFaultType * SOAP_FMAC4 soap_new_wsrfbf__BaseFaultType(struct soap *soap, int n)
{
	struct wsrfbf__BaseFaultType *p;
	struct wsrfbf__BaseFaultType *a = (struct wsrfbf__BaseFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsrfbf__BaseFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsrfbf__BaseFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrfbf__BaseFaultType(struct soap *soap, const struct wsrfbf__BaseFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsrfbf__BaseFaultType(soap, tag ? tag : "wsrfbf:BaseFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrfbf__BaseFaultType * SOAP_FMAC4 soap_get_wsrfbf__BaseFaultType(struct soap *soap, struct wsrfbf__BaseFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfbf__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeSubscriptionResponse(struct soap *soap, const struct _wsnt__ResumeSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, struct _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__ResumeSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(struct _wsnt__ResumeSubscriptionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeSubscriptionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(struct _wsnt__ResumeSubscriptionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_new__wsnt__ResumeSubscriptionResponse(struct soap *soap, int n)
{
	struct _wsnt__ResumeSubscriptionResponse *p;
	struct _wsnt__ResumeSubscriptionResponse *a = (struct _wsnt__ResumeSubscriptionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeSubscriptionResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeSubscriptionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeSubscriptionResponse(struct soap *soap, const struct _wsnt__ResumeSubscriptionResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeSubscriptionResponse(soap, tag ? tag : "wsnt:ResumeSubscriptionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeSubscription(struct soap *soap, const struct _wsnt__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscription(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscription), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription * SOAP_FMAC4 soap_in__wsnt__ResumeSubscription(struct soap *soap, const char *tag, struct _wsnt__ResumeSubscription *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__ResumeSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(struct _wsnt__ResumeSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeSubscription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscription, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(struct _wsnt__ResumeSubscription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription * SOAP_FMAC4 soap_new__wsnt__ResumeSubscription(struct soap *soap, int n)
{
	struct _wsnt__ResumeSubscription *p;
	struct _wsnt__ResumeSubscription *a = (struct _wsnt__ResumeSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeSubscription));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeSubscription(struct soap *soap, const struct _wsnt__ResumeSubscription *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeSubscription(soap, tag ? tag : "wsnt:ResumeSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription * SOAP_FMAC4 soap_get__wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseSubscriptionResponse(struct soap *soap, const struct _wsnt__PauseSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, struct _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__PauseSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(struct _wsnt__PauseSubscriptionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseSubscriptionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscriptionResponse, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(struct _wsnt__PauseSubscriptionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_new__wsnt__PauseSubscriptionResponse(struct soap *soap, int n)
{
	struct _wsnt__PauseSubscriptionResponse *p;
	struct _wsnt__PauseSubscriptionResponse *a = (struct _wsnt__PauseSubscriptionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseSubscriptionResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseSubscriptionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseSubscriptionResponse(struct soap *soap, const struct _wsnt__PauseSubscriptionResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseSubscriptionResponse(soap, tag ? tag : "wsnt:PauseSubscriptionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseSubscription(struct soap *soap, const struct _wsnt__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscription(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscription), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseSubscription * SOAP_FMAC4 soap_in__wsnt__PauseSubscription(struct soap *soap, const char *tag, struct _wsnt__PauseSubscription *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__PauseSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscription, sizeof(struct _wsnt__PauseSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseSubscription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscription, SOAP_TYPE__wsnt__PauseSubscription, sizeof(struct _wsnt__PauseSubscription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseSubscription * SOAP_FMAC4 soap_new__wsnt__PauseSubscription(struct soap *soap, int n)
{
	struct _wsnt__PauseSubscription *p;
	struct _wsnt__PauseSubscription *a = (struct _wsnt__PauseSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseSubscription));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseSubscription(struct soap *soap, const struct _wsnt__PauseSubscription *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseSubscription(soap, tag ? tag : "wsnt:PauseSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseSubscription * SOAP_FMAC4 soap_get__wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsubscribeResponse(struct soap *soap, const struct _wsnt__UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsubscribeResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_in__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, struct _wsnt__UnsubscribeResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UnsubscribeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(struct _wsnt__UnsubscribeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnsubscribeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsubscribeResponse, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(struct _wsnt__UnsubscribeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_new__wsnt__UnsubscribeResponse(struct soap *soap, int n)
{
	struct _wsnt__UnsubscribeResponse *p;
	struct _wsnt__UnsubscribeResponse *a = (struct _wsnt__UnsubscribeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnsubscribeResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnsubscribeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsubscribeResponse(struct soap *soap, const struct _wsnt__UnsubscribeResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnsubscribeResponse(soap, tag ? tag : "wsnt:UnsubscribeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_get__wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Unsubscribe(struct soap *soap, const struct _wsnt__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Unsubscribe(struct soap *soap, const char *tag, int id, const struct _wsnt__Unsubscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Unsubscribe), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Unsubscribe * SOAP_FMAC4 soap_in__wsnt__Unsubscribe(struct soap *soap, const char *tag, struct _wsnt__Unsubscribe *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Unsubscribe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Unsubscribe, sizeof(struct _wsnt__Unsubscribe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Unsubscribe(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Unsubscribe, SOAP_TYPE__wsnt__Unsubscribe, sizeof(struct _wsnt__Unsubscribe), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Unsubscribe * SOAP_FMAC4 soap_new__wsnt__Unsubscribe(struct soap *soap, int n)
{
	struct _wsnt__Unsubscribe *p;
	struct _wsnt__Unsubscribe *a = (struct _wsnt__Unsubscribe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Unsubscribe));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Unsubscribe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Unsubscribe(struct soap *soap, const struct _wsnt__Unsubscribe *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Unsubscribe(soap, tag ? tag : "wsnt:Unsubscribe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Unsubscribe * SOAP_FMAC4 soap_get__wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->TerminationTime);
	a->CurrentTime = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__RenewResponse(struct soap *soap, const struct _wsnt__RenewResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->TerminationTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->CurrentTime);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__RenewResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__RenewResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__RenewResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:TerminationTime");
	if (soap_out_dateTime(soap, "wsnt:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__RenewResponse * SOAP_FMAC4 soap_in__wsnt__RenewResponse(struct soap *soap, const char *tag, struct _wsnt__RenewResponse *a, const char *type)
{
	size_t soap_flag_TerminationTime = 1;
	size_t soap_flag_CurrentTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__RenewResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__RenewResponse, sizeof(struct _wsnt__RenewResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__RenewResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			}
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "wsnt:TerminationTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__RenewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__RenewResponse, SOAP_TYPE__wsnt__RenewResponse, sizeof(struct _wsnt__RenewResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__RenewResponse * SOAP_FMAC4 soap_new__wsnt__RenewResponse(struct soap *soap, int n)
{
	struct _wsnt__RenewResponse *p;
	struct _wsnt__RenewResponse *a = (struct _wsnt__RenewResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__RenewResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__RenewResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__RenewResponse(struct soap *soap, const struct _wsnt__RenewResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__RenewResponse(soap, tag ? tag : "wsnt:RenewResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__RenewResponse * SOAP_FMAC4 soap_get__wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__RenewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Renew(struct soap *soap, struct _wsnt__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsnt__AbsoluteOrRelativeTimeType(soap, &a->TerminationTime);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Renew(struct soap *soap, const struct _wsnt__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, (char*const*)&a->TerminationTime);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Renew(struct soap *soap, const char *tag, int id, const struct _wsnt__Renew *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Renew), type))
		return soap->error;
	if (!a->TerminationTime)
	{	if (soap_element_nil(soap, "wsnt:TerminationTime"))
			return soap->error;
	}
	else if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", -1, (char*const*)&a->TerminationTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Renew * SOAP_FMAC4 soap_in__wsnt__Renew(struct soap *soap, const char *tag, struct _wsnt__Renew *a, const char *type)
{
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Renew*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Renew, sizeof(struct _wsnt__Renew), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Renew(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", (char**)&a->TerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__Renew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Renew, SOAP_TYPE__wsnt__Renew, sizeof(struct _wsnt__Renew), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Renew * SOAP_FMAC4 soap_new__wsnt__Renew(struct soap *soap, int n)
{
	struct _wsnt__Renew *p;
	struct _wsnt__Renew *a = (struct _wsnt__Renew*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Renew));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Renew(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Renew(struct soap *soap, const struct _wsnt__Renew *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Renew(soap, tag ? tag : "wsnt:Renew", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Renew * SOAP_FMAC4 soap_get__wsnt__Renew(struct soap *soap, struct _wsnt__Renew *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->PullPoint);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__CreatePullPointResponse(struct soap *soap, const struct _wsnt__CreatePullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->PullPoint, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->PullPoint);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__CreatePullPointResponse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPointResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:PullPoint");
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", -1, &a->PullPoint, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_in__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, struct _wsnt__CreatePullPointResponse *a, const char *type)
{
	size_t soap_flag_PullPoint = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__CreatePullPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(struct _wsnt__CreatePullPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__CreatePullPointResponse(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PullPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", &a->PullPoint, "wsa5:EndpointReferenceType"))
				{	soap_flag_PullPoint--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "wsnt:PullPoint");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PullPoint > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__CreatePullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPointResponse, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(struct _wsnt__CreatePullPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_new__wsnt__CreatePullPointResponse(struct soap *soap, int n)
{
	struct _wsnt__CreatePullPointResponse *p;
	struct _wsnt__CreatePullPointResponse *a = (struct _wsnt__CreatePullPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__CreatePullPointResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__CreatePullPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__CreatePullPointResponse(struct soap *soap, const struct _wsnt__CreatePullPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__CreatePullPointResponse(soap, tag ? tag : "wsnt:CreatePullPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_get__wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__CreatePullPoint(struct soap *soap, const struct _wsnt__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPoint(struct soap *soap, const char *tag, int id, const struct _wsnt__CreatePullPoint *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPoint), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint * SOAP_FMAC4 soap_in__wsnt__CreatePullPoint(struct soap *soap, const char *tag, struct _wsnt__CreatePullPoint *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__CreatePullPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(struct _wsnt__CreatePullPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__CreatePullPoint(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__CreatePullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPoint, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(struct _wsnt__CreatePullPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint * SOAP_FMAC4 soap_new__wsnt__CreatePullPoint(struct soap *soap, int n)
{
	struct _wsnt__CreatePullPoint *p;
	struct _wsnt__CreatePullPoint *a = (struct _wsnt__CreatePullPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__CreatePullPoint));
	for (p = a; p && n--; p++)
		soap_default__wsnt__CreatePullPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__CreatePullPoint(struct soap *soap, const struct _wsnt__CreatePullPoint *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__CreatePullPoint(soap, tag ? tag : "wsnt:CreatePullPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint * SOAP_FMAC4 soap_get__wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__DestroyPullPointResponse(struct soap *soap, const struct _wsnt__DestroyPullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__DestroyPullPointResponse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_in__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, struct _wsnt__DestroyPullPointResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__DestroyPullPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(struct _wsnt__DestroyPullPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__DestroyPullPointResponse(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__DestroyPullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPointResponse, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(struct _wsnt__DestroyPullPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_new__wsnt__DestroyPullPointResponse(struct soap *soap, int n)
{
	struct _wsnt__DestroyPullPointResponse *p;
	struct _wsnt__DestroyPullPointResponse *a = (struct _wsnt__DestroyPullPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__DestroyPullPointResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__DestroyPullPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__DestroyPullPointResponse(struct soap *soap, const struct _wsnt__DestroyPullPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__DestroyPullPointResponse(soap, tag ? tag : "wsnt:DestroyPullPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_get__wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__DestroyPullPoint(struct soap *soap, const struct _wsnt__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, int id, const struct _wsnt__DestroyPullPoint *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPoint), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_in__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, struct _wsnt__DestroyPullPoint *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__DestroyPullPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(struct _wsnt__DestroyPullPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__DestroyPullPoint(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__DestroyPullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPoint, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(struct _wsnt__DestroyPullPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_new__wsnt__DestroyPullPoint(struct soap *soap, int n)
{
	struct _wsnt__DestroyPullPoint *p;
	struct _wsnt__DestroyPullPoint *a = (struct _wsnt__DestroyPullPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__DestroyPullPoint));
	for (p = a; p && n--; p++)
		soap_default__wsnt__DestroyPullPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__DestroyPullPoint(struct soap *soap, const struct _wsnt__DestroyPullPoint *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__DestroyPullPoint(soap, tag ? tag : "wsnt:DestroyPullPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_get__wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNotificationMessage = 0;
	a->NotificationMessage_ = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetMessagesResponse(struct soap *soap, const struct _wsnt__GetMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NotificationMessage_)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
		{
			soap_embedded(soap, a->NotificationMessage_ + i, SOAP_TYPE_wsnt__NotificationMessageHolderType);
			soap_serialize_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage_ + i);
		}
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__GetMessagesResponse *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessagesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNotificationMessage");
	if (a->NotificationMessage_)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
			if (soap_out_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, a->NotificationMessage_ + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_in__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, struct _wsnt__GetMessagesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NotificationMessage_ = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__GetMessagesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(struct _wsnt__GetMessagesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetMessagesResponse(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
			{	if (a->NotificationMessage_ == NULL)
				{	if (soap_blist_NotificationMessage_ == NULL)
						soap_blist_NotificationMessage_ = soap_alloc_block(soap);
					a->NotificationMessage_ = (struct wsnt__NotificationMessageHolderType *)soap_push_block_max(soap, soap_blist_NotificationMessage_, sizeof(struct wsnt__NotificationMessageHolderType));
					if (a->NotificationMessage_ == NULL)
						return NULL;
					soap_default_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage_);
				}
				soap_revert(soap);
				if (soap_in_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", a->NotificationMessage_, "wsnt:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->NotificationMessage_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNotificationMessage");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NotificationMessage_)
			soap_pop_block(soap, soap_blist_NotificationMessage_);
		if (a->__sizeNotificationMessage)
		{	a->NotificationMessage_ = (struct wsnt__NotificationMessageHolderType *)soap_save_block(soap, soap_blist_NotificationMessage_, NULL, 1);
		}
		else
		{	a->NotificationMessage_ = NULL;
			if (soap_blist_NotificationMessage_)
				soap_end_block(soap, soap_blist_NotificationMessage_);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessagesResponse, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(struct _wsnt__GetMessagesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_new__wsnt__GetMessagesResponse(struct soap *soap, int n)
{
	struct _wsnt__GetMessagesResponse *p;
	struct _wsnt__GetMessagesResponse *a = (struct _wsnt__GetMessagesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__GetMessagesResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__GetMessagesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetMessagesResponse(struct soap *soap, const struct _wsnt__GetMessagesResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__GetMessagesResponse(soap, tag ? tag : "wsnt:GetMessagesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_get__wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__nonNegativeInteger(soap, &a->MaximumNumber);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetMessages(struct soap *soap, const struct _wsnt__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__nonNegativeInteger(soap, (char*const*)&a->MaximumNumber);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessages(struct soap *soap, const char *tag, int id, const struct _wsnt__GetMessages *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessages), type))
		return soap->error;
	if (soap_out_xsd__nonNegativeInteger(soap, "wsnt:MaximumNumber", -1, (char*const*)&a->MaximumNumber, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetMessages * SOAP_FMAC4 soap_in__wsnt__GetMessages(struct soap *soap, const char *tag, struct _wsnt__GetMessages *a, const char *type)
{
	size_t soap_flag_MaximumNumber = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__GetMessages*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessages, sizeof(struct _wsnt__GetMessages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetMessages(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__nonNegativeInteger(soap, "wsnt:MaximumNumber", (char**)&a->MaximumNumber, "xsd:nonNegativeInteger"))
				{	soap_flag_MaximumNumber--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessages, SOAP_TYPE__wsnt__GetMessages, sizeof(struct _wsnt__GetMessages), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__GetMessages * SOAP_FMAC4 soap_new__wsnt__GetMessages(struct soap *soap, int n)
{
	struct _wsnt__GetMessages *p;
	struct _wsnt__GetMessages *a = (struct _wsnt__GetMessages*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__GetMessages));
	for (p = a; p && n--; p++)
		soap_default__wsnt__GetMessages(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetMessages(struct soap *soap, const struct _wsnt__GetMessages *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__GetMessages(soap, tag ? tag : "wsnt:GetMessages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetMessages * SOAP_FMAC4 soap_get__wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetCurrentMessageResponse(struct soap *soap, const struct _wsnt__GetCurrentMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, struct _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__GetCurrentMessageResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(struct _wsnt__GetCurrentMessageResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetCurrentMessageResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetCurrentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessageResponse, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(struct _wsnt__GetCurrentMessageResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_new__wsnt__GetCurrentMessageResponse(struct soap *soap, int n)
{
	struct _wsnt__GetCurrentMessageResponse *p;
	struct _wsnt__GetCurrentMessageResponse *a = (struct _wsnt__GetCurrentMessageResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__GetCurrentMessageResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__GetCurrentMessageResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetCurrentMessageResponse(struct soap *soap, const struct _wsnt__GetCurrentMessageResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__GetCurrentMessageResponse(soap, tag ? tag : "wsnt:GetCurrentMessageResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetCurrentMessage(struct soap *soap, const struct _wsnt__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &a->Topic);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, int id, const struct _wsnt__GetCurrentMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessage), type))
		return soap->error;
	if (!a->Topic)
	{	if (soap_element_empty(soap, "wsnt:Topic", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->Topic, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, struct _wsnt__GetCurrentMessage *a, const char *type)
{
	size_t soap_flag_Topic = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__GetCurrentMessage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(struct _wsnt__GetCurrentMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetCurrentMessage(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Topic))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__GetCurrentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessage, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(struct _wsnt__GetCurrentMessage), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_new__wsnt__GetCurrentMessage(struct soap *soap, int n)
{
	struct _wsnt__GetCurrentMessage *p;
	struct _wsnt__GetCurrentMessage *a = (struct _wsnt__GetCurrentMessage*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__GetCurrentMessage));
	for (p = a; p && n--; p++)
		soap_default__wsnt__GetCurrentMessage(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetCurrentMessage(struct soap *soap, const struct _wsnt__GetCurrentMessage *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__GetCurrentMessage(soap, tag ? tag : "wsnt:GetCurrentMessage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	a->CurrentTime = NULL;
	a->TerminationTime = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeResponse(struct soap *soap, const struct _wsnt__SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_serialize_PointerTodateTime(soap, &a->CurrentTime);
	soap_serialize_PointerTodateTime(soap, &a->TerminationTime);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeResponse), type))
		return soap->error;
	soap_element_result(soap, "wsnt:SubscriptionReference");
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse * SOAP_FMAC4 soap_in__wsnt__SubscribeResponse(struct soap *soap, const char *tag, struct _wsnt__SubscribeResponse *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_CurrentTime = 1;
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscribeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(struct _wsnt__SubscribeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			}
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			}
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "wsnt:SubscriptionReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeResponse, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(struct _wsnt__SubscribeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse * SOAP_FMAC4 soap_new__wsnt__SubscribeResponse(struct soap *soap, int n)
{
	struct _wsnt__SubscribeResponse *p;
	struct _wsnt__SubscribeResponse *a = (struct _wsnt__SubscribeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeResponse));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeResponse(struct soap *soap, const struct _wsnt__SubscribeResponse *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeResponse(soap, tag ? tag : "wsnt:SubscribeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse * SOAP_FMAC4 soap_get__wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const struct _wsnt__Subscribe_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _wsnt__Subscribe_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_in__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _wsnt__Subscribe_SubscriptionPolicy *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Subscribe_SubscriptionPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Subscribe_SubscriptionPolicy(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_new__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, int n)
{
	struct _wsnt__Subscribe_SubscriptionPolicy *p;
	struct _wsnt__Subscribe_SubscriptionPolicy *a = (struct _wsnt__Subscribe_SubscriptionPolicy*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Subscribe_SubscriptionPolicy));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Subscribe_SubscriptionPolicy(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const struct _wsnt__Subscribe_SubscriptionPolicy *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_get__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	a->Filter = NULL;
	soap_default_wsnt__AbsoluteOrRelativeTimeType(soap, &a->InitialTerminationTime);
	a->SubscriptionPolicy = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Subscribe(struct soap *soap, const struct _wsnt__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, (char*const*)&a->InitialTerminationTime);
	soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe(struct soap *soap, const char *tag, int id, const struct _wsnt__Subscribe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", -1, (char*const*)&a->InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Subscribe * SOAP_FMAC4 soap_in__wsnt__Subscribe(struct soap *soap, const char *tag, struct _wsnt__Subscribe *a, const char *type)
{
	size_t soap_flag_ConsumerReference = 1;
	size_t soap_flag_Filter = 1;
	size_t soap_flag_InitialTerminationTime = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Subscribe*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe, sizeof(struct _wsnt__Subscribe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Subscribe(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference--;
					continue;
				}
			}
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			}
			if (soap_flag_InitialTerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", (char**)&a->InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", &a->SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe, SOAP_TYPE__wsnt__Subscribe, sizeof(struct _wsnt__Subscribe), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Subscribe * SOAP_FMAC4 soap_new__wsnt__Subscribe(struct soap *soap, int n)
{
	struct _wsnt__Subscribe *p;
	struct _wsnt__Subscribe *a = (struct _wsnt__Subscribe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Subscribe));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Subscribe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Subscribe(struct soap *soap, const struct _wsnt__Subscribe *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Subscribe(soap, tag ? tag : "wsnt:Subscribe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe * SOAP_FMAC4 soap_get__wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UseRaw(struct soap *soap, struct _wsnt__UseRaw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UseRaw(struct soap *soap, const struct _wsnt__UseRaw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UseRaw(struct soap *soap, const char *tag, int id, const struct _wsnt__UseRaw *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UseRaw), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UseRaw * SOAP_FMAC4 soap_in__wsnt__UseRaw(struct soap *soap, const char *tag, struct _wsnt__UseRaw *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__UseRaw*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UseRaw, sizeof(struct _wsnt__UseRaw), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UseRaw(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UseRaw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UseRaw, SOAP_TYPE__wsnt__UseRaw, sizeof(struct _wsnt__UseRaw), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UseRaw * SOAP_FMAC4 soap_new__wsnt__UseRaw(struct soap *soap, int n)
{
	struct _wsnt__UseRaw *p;
	struct _wsnt__UseRaw *a = (struct _wsnt__UseRaw*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UseRaw));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UseRaw(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UseRaw(struct soap *soap, const struct _wsnt__UseRaw *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UseRaw(soap, tag ? tag : "wsnt:UseRaw", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UseRaw * SOAP_FMAC4 soap_get__wsnt__UseRaw(struct soap *soap, struct _wsnt__UseRaw *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UseRaw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Notify(struct soap *soap, struct _wsnt__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNotificationMessage = 0;
	a->NotificationMessage_ = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Notify(struct soap *soap, const struct _wsnt__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NotificationMessage_)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
		{
			soap_embedded(soap, a->NotificationMessage_ + i, SOAP_TYPE_wsnt__NotificationMessageHolderType);
			soap_serialize_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage_ + i);
		}
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Notify(struct soap *soap, const char *tag, int id, const struct _wsnt__Notify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Notify), type))
		return soap->error;
	if (a->NotificationMessage_)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
			if (soap_out_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, a->NotificationMessage_ + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Notify * SOAP_FMAC4 soap_in__wsnt__Notify(struct soap *soap, const char *tag, struct _wsnt__Notify *a, const char *type)
{
	struct soap_blist *soap_blist_NotificationMessage_ = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__Notify*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Notify, sizeof(struct _wsnt__Notify), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Notify(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
			{	if (a->NotificationMessage_ == NULL)
				{	if (soap_blist_NotificationMessage_ == NULL)
						soap_blist_NotificationMessage_ = soap_alloc_block(soap);
					a->NotificationMessage_ = (struct wsnt__NotificationMessageHolderType *)soap_push_block_max(soap, soap_blist_NotificationMessage_, sizeof(struct wsnt__NotificationMessageHolderType));
					if (a->NotificationMessage_ == NULL)
						return NULL;
					soap_default_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage_);
				}
				soap_revert(soap);
				if (soap_in_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", a->NotificationMessage_, "wsnt:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->NotificationMessage_ = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NotificationMessage_)
			soap_pop_block(soap, soap_blist_NotificationMessage_);
		if (a->__sizeNotificationMessage)
		{	a->NotificationMessage_ = (struct wsnt__NotificationMessageHolderType *)soap_save_block(soap, soap_blist_NotificationMessage_, NULL, 1);
		}
		else
		{	a->NotificationMessage_ = NULL;
			if (soap_blist_NotificationMessage_)
				soap_end_block(soap, soap_blist_NotificationMessage_);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNotificationMessage < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__Notify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Notify, SOAP_TYPE__wsnt__Notify, sizeof(struct _wsnt__Notify), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__Notify * SOAP_FMAC4 soap_new__wsnt__Notify(struct soap *soap, int n)
{
	struct _wsnt__Notify *p;
	struct _wsnt__Notify *a = (struct _wsnt__Notify*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__Notify));
	for (p = a; p && n--; p++)
		soap_default__wsnt__Notify(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Notify(struct soap *soap, const struct _wsnt__Notify *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__Notify(soap, tag ? tag : "wsnt:Notify", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Notify * SOAP_FMAC4 soap_get__wsnt__Notify(struct soap *soap, struct _wsnt__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscriptionManagerRP(struct soap *soap, struct _wsnt__SubscriptionManagerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	a->Filter = NULL;
	a->SubscriptionPolicy = NULL;
	a->CreationTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscriptionManagerRP(struct soap *soap, const struct _wsnt__SubscriptionManagerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_PointerTowsnt__SubscriptionPolicyType(soap, &a->SubscriptionPolicy);
	soap_serialize_PointerTodateTime(soap, &a->CreationTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscriptionManagerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:CreationTime", -1, &a->CreationTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_in__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, struct _wsnt__SubscriptionManagerRP *a, const char *type)
{
	size_t soap_flag_ConsumerReference = 1;
	size_t soap_flag_Filter = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	size_t soap_flag_CreationTime = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__SubscriptionManagerRP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(struct _wsnt__SubscriptionManagerRP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscriptionManagerRP(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference--;
					continue;
				}
			}
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", &a->SubscriptionPolicy, "wsnt:SubscriptionPolicyType"))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			}
			if (soap_flag_CreationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "wsnt:CreationTime", &a->CreationTime, "xsd:dateTime"))
				{	soap_flag_CreationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _wsnt__SubscriptionManagerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscriptionManagerRP, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(struct _wsnt__SubscriptionManagerRP), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_new__wsnt__SubscriptionManagerRP(struct soap *soap, int n)
{
	struct _wsnt__SubscriptionManagerRP *p;
	struct _wsnt__SubscriptionManagerRP *a = (struct _wsnt__SubscriptionManagerRP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscriptionManagerRP));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscriptionManagerRP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscriptionManagerRP(struct soap *soap, const struct _wsnt__SubscriptionManagerRP *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscriptionManagerRP(soap, tag ? tag : "wsnt:SubscriptionManagerRP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_get__wsnt__SubscriptionManagerRP(struct soap *soap, struct _wsnt__SubscriptionManagerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscriptionManagerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__TopicSetType(struct soap *soap, const struct wstop__TopicSetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicSetType(struct soap *soap, const char *tag, int id, const struct wstop__TopicSetType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicSetType), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__TopicSetType * SOAP_FMAC4 soap_in_wstop__TopicSetType(struct soap *soap, const char *tag, struct wstop__TopicSetType *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__TopicSetType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__TopicSetType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicSetType, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__TopicSetType * SOAP_FMAC4 soap_new_wstop__TopicSetType(struct soap *soap, int n)
{
	struct wstop__TopicSetType *p;
	struct wstop__TopicSetType *a = (struct wstop__TopicSetType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__TopicSetType));
	for (p = a; p && n--; p++)
		soap_default_wstop__TopicSetType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__TopicSetType(struct soap *soap, const struct wstop__TopicSetType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicSetType * SOAP_FMAC4 soap_get_wstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotificationProducerRP(struct soap *soap, struct _wsnt__NotificationProducerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTopicExpression = 0;
	a->TopicExpression_ = NULL;
	a->FixedTopicSet = NULL;
	a->__sizeTopicExpressionDialect = 0;
	a->TopicExpressionDialect_ = NULL;
	a->wstop__TopicSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotificationProducerRP(struct soap *soap, const struct _wsnt__NotificationProducerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->TopicExpression_)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpression; i++)
		{
			soap_embedded(soap, a->TopicExpression_ + i, SOAP_TYPE_wsnt__TopicExpressionType);
			soap_serialize_wsnt__TopicExpressionType(soap, a->TopicExpression_ + i);
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->FixedTopicSet);
	if (a->TopicExpressionDialect_)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpressionDialect; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->TopicExpressionDialect_ + i));
		}
	}
	soap_serialize_PointerTowstop__TopicSetType(soap, &a->wstop__TopicSet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, int id, const struct _wsnt__NotificationProducerRP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationProducerRP), type))
		return soap->error;
	if (a->TopicExpression_)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpression; i++)
			if (soap_out_wsnt__TopicExpressionType(soap, "wsnt:TopicExpression", -1, a->TopicExpression_ + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "wsnt:FixedTopicSet", -1, &a->FixedTopicSet, ""))
		return soap->error;
	if (a->TopicExpressionDialect_)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpressionDialect; i++)
			if (soap_out_string(soap, "wsnt:TopicExpressionDialect", -1, (char*const*)(a->TopicExpressionDialect_ + i), ""))
				return soap->error;
	}
	if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &a->wstop__TopicSet, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_in__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, struct _wsnt__NotificationProducerRP *a, const char *type)
{
	struct soap_blist *soap_blist_TopicExpression_ = NULL;
	size_t soap_flag_FixedTopicSet = 1;
	struct soap_blist *soap_blist_TopicExpressionDialect_ = NULL;
	size_t soap_flag_wstop__TopicSet = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NotificationProducerRP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(struct _wsnt__NotificationProducerRP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotificationProducerRP(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpression", 1, NULL))
			{	if (a->TopicExpression_ == NULL)
				{	if (soap_blist_TopicExpression_ == NULL)
						soap_blist_TopicExpression_ = soap_alloc_block(soap);
					a->TopicExpression_ = (struct wsnt__TopicExpressionType *)soap_push_block_max(soap, soap_blist_TopicExpression_, sizeof(struct wsnt__TopicExpressionType));
					if (a->TopicExpression_ == NULL)
						return NULL;
					soap_default_wsnt__TopicExpressionType(soap, a->TopicExpression_);
				}
				soap_revert(soap);
				if (soap_in_wsnt__TopicExpressionType(soap, "wsnt:TopicExpression", a->TopicExpression_, "wsnt:TopicExpressionType"))
				{	a->__sizeTopicExpression++;
					a->TopicExpression_ = NULL;
					continue;
				}
			}
			if (soap_flag_FixedTopicSet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "wsnt:FixedTopicSet", &a->FixedTopicSet, "xsd:boolean"))
				{	soap_flag_FixedTopicSet--;
					continue;
				}
				if (soap->error == SOAP_EMPTY)
				{	if (!(a->FixedTopicSet = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
						return NULL;
					*a->FixedTopicSet = (enum xsd__boolean)1;
					soap->error = SOAP_OK;
					soap_flag_FixedTopicSet--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpressionDialect", 1, NULL))
			{	if (a->TopicExpressionDialect_ == NULL)
				{	if (soap_blist_TopicExpressionDialect_ == NULL)
						soap_blist_TopicExpressionDialect_ = soap_alloc_block(soap);
					a->TopicExpressionDialect_ = (char **)soap_push_block_max(soap, soap_blist_TopicExpressionDialect_, sizeof(char *));
					if (a->TopicExpressionDialect_ == NULL)
						return NULL;
					*a->TopicExpressionDialect_ = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "wsnt:TopicExpressionDialect", (char**)a->TopicExpressionDialect_, "xsd:anyURI"))
				{	a->__sizeTopicExpressionDialect++;
					a->TopicExpressionDialect_ = NULL;
					continue;
				}
			}
			if (soap_flag_wstop__TopicSet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &a->wstop__TopicSet, "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TopicExpression_)
			soap_pop_block(soap, soap_blist_TopicExpression_);
		if (a->__sizeTopicExpression)
		{	a->TopicExpression_ = (struct wsnt__TopicExpressionType *)soap_save_block(soap, soap_blist_TopicExpression_, NULL, 1);
		}
		else
		{	a->TopicExpression_ = NULL;
			if (soap_blist_TopicExpression_)
				soap_end_block(soap, soap_blist_TopicExpression_);
		}
		if (a->TopicExpressionDialect_)
			soap_pop_block(soap, soap_blist_TopicExpressionDialect_);
		if (a->__sizeTopicExpressionDialect)
		{	a->TopicExpressionDialect_ = (char **)soap_save_block(soap, soap_blist_TopicExpressionDialect_, NULL, 1);
		}
		else
		{	a->TopicExpressionDialect_ = NULL;
			if (soap_blist_TopicExpressionDialect_)
				soap_end_block(soap, soap_blist_TopicExpressionDialect_);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotificationProducerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationProducerRP, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(struct _wsnt__NotificationProducerRP), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_new__wsnt__NotificationProducerRP(struct soap *soap, int n)
{
	struct _wsnt__NotificationProducerRP *p;
	struct _wsnt__NotificationProducerRP *a = (struct _wsnt__NotificationProducerRP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotificationProducerRP));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotificationProducerRP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotificationProducerRP(struct soap *soap, const struct _wsnt__NotificationProducerRP *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotificationProducerRP(soap, tag ? tag : "wsnt:NotificationProducerRP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_get__wsnt__NotificationProducerRP(struct soap *soap, struct _wsnt__NotificationProducerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationProducerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotificationMessageHolderType_Message(struct soap *soap, struct _wsnt__NotificationMessageHolderType_Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const struct _wsnt__NotificationMessageHolderType_Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, int id, const struct _wsnt__NotificationMessageHolderType_Message *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_in__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, struct _wsnt__NotificationMessageHolderType_Message *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__NotificationMessageHolderType_Message*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(struct _wsnt__NotificationMessageHolderType_Message), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotificationMessageHolderType_Message(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotificationMessageHolderType_Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(struct _wsnt__NotificationMessageHolderType_Message), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_new__wsnt__NotificationMessageHolderType_Message(struct soap *soap, int n)
{
	struct _wsnt__NotificationMessageHolderType_Message *p;
	struct _wsnt__NotificationMessageHolderType_Message *a = (struct _wsnt__NotificationMessageHolderType_Message*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__NotificationMessageHolderType_Message));
	for (p = a; p && n--; p++)
		soap_default__wsnt__NotificationMessageHolderType_Message(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const struct _wsnt__NotificationMessageHolderType_Message *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__NotificationMessageHolderType_Message(soap, tag ? tag : "wsnt:NotificationMessageHolderType-Message", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_get__wsnt__NotificationMessageHolderType_Message(struct soap *soap, struct _wsnt__NotificationMessageHolderType_Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationMessageHolderType_Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__SubscriptionPolicyType(struct soap *soap, const struct wsnt__SubscriptionPolicyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, const struct wsnt__SubscriptionPolicyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_in_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, struct wsnt__SubscriptionPolicyType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__SubscriptionPolicyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__SubscriptionPolicyType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__SubscriptionPolicyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscriptionPolicyType, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_new_wsnt__SubscriptionPolicyType(struct soap *soap, int n)
{
	struct wsnt__SubscriptionPolicyType *p;
	struct wsnt__SubscriptionPolicyType *a = (struct wsnt__SubscriptionPolicyType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__SubscriptionPolicyType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__SubscriptionPolicyType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__SubscriptionPolicyType(struct soap *soap, const struct wsnt__SubscriptionPolicyType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_get_wsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyURI(soap, &a->Dialect);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicExpressionType(struct soap *soap, const struct wsnt__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", a->Dialect ? soap_xsd__anyURI2s(soap, a->Dialect) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionType), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__TopicExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicExpressionType(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &a->Dialect))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionType, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_new_wsnt__TopicExpressionType(struct soap *soap, int n)
{
	struct wsnt__TopicExpressionType *p;
	struct wsnt__TopicExpressionType *a = (struct wsnt__TopicExpressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicExpressionType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicExpressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicExpressionType(struct soap *soap, const struct wsnt__TopicExpressionType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
	soap_default_xsd__anyURI(soap, &a->Dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__QueryExpressionType(struct soap *soap, const struct wsnt__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__QueryExpressionType(struct soap *soap, const char *tag, int id, const struct wsnt__QueryExpressionType *a, const char *type)
{
	soap_set_attr(soap, "Dialect", a->Dialect ? soap_xsd__anyURI2s(soap, a->Dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__QueryExpressionType), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_in_wsnt__QueryExpressionType(struct soap *soap, const char *tag, struct wsnt__QueryExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__QueryExpressionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__QueryExpressionType(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 4, 1), &a->Dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__QueryExpressionType, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_new_wsnt__QueryExpressionType(struct soap *soap, int n)
{
	struct wsnt__QueryExpressionType *p;
	struct wsnt__QueryExpressionType *a = (struct wsnt__QueryExpressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__QueryExpressionType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__QueryExpressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__QueryExpressionType(struct soap *soap, const struct wsnt__QueryExpressionType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__QueryExpressionType(soap, tag ? tag : "wsnt:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_get_wsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__Message(struct soap *soap, struct _tt__Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	soap_default_dateTime(soap, &a->UtcTime);
	a->PropertyOperation = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__Message(struct soap *soap, const struct _tt__Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemList(soap, &a->Source);
	soap_serialize_PointerTott__ItemList(soap, &a->Key);
	soap_serialize_PointerTott__ItemList(soap, &a->Data);
	soap_serialize_PointerTott__MessageExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Message(struct soap *soap, const char *tag, int id, const struct _tt__Message *a, const char *type)
{
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, a->UtcTime), 1);
	if (a->PropertyOperation)
	{	soap_set_attr(soap, "PropertyOperation", soap_tt__PropertyOperation2s(soap, *a->PropertyOperation), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Message), type))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__Message * SOAP_FMAC4 soap_in__tt__Message(struct soap *soap, const char *tag, struct _tt__Message *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tt__Message*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Message, sizeof(struct _tt__Message), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__Message(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 5, 1), &a->UtcTime))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "PropertyOperation", 5, 0);
		if (t)
		{
			if (!(a->PropertyOperation = (enum tt__PropertyOperation *)soap_malloc(soap, sizeof(enum tt__PropertyOperation))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__PropertyOperation(soap, t, a->PropertyOperation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Source", &a->Source, "tt:ItemList"))
				{	soap_flag_Source--;
					continue;
				}
			}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Key", &a->Key, "tt:ItemList"))
				{	soap_flag_Key--;
					continue;
				}
			}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Data", &a->Data, "tt:ItemList"))
				{	soap_flag_Data--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MessageExtension(soap, "tt:Extension", &a->Extension, "tt:MessageExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Message, SOAP_TYPE__tt__Message, sizeof(struct _tt__Message), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__Message * SOAP_FMAC4 soap_new__tt__Message(struct soap *soap, int n)
{
	struct _tt__Message *p;
	struct _tt__Message *a = (struct _tt__Message*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__Message));
	for (p = a; p && n--; p++)
		soap_default__tt__Message(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__Message(struct soap *soap, const struct _tt__Message *a, const char *tag, const char *type)
{
	if (soap_out__tt__Message(soap, tag ? tag : "tt:Message", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Message * SOAP_FMAC4 soap_get__tt__Message(struct soap *soap, struct _tt__Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
