/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:06 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngine(struct soap *soap, struct tt__AnalyticsEngine *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngine))
		soap_serialize_tt__AnalyticsEngine(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngine(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngine, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngine(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngine ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngine(struct soap *soap, const char *tag, struct tt__AnalyticsEngine **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngine **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngine(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngine, sizeof(struct tt__AnalyticsEngine), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngine(struct soap *soap, struct tt__AnalyticsEngine *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngine(soap, tag ? tag : "tt:AnalyticsEngine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngine ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngine(struct soap *soap, struct tt__AnalyticsEngine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineControl(struct soap *soap, struct tt__AnalyticsEngineControl *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineControl))
		soap_serialize_tt__AnalyticsEngineControl(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineControl(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineControl, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineControl(struct soap *soap, const char *tag, struct tt__AnalyticsEngineControl **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineControl **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineControl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(struct tt__AnalyticsEngineControl), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineControl(struct soap *soap, struct tt__AnalyticsEngineControl *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineControl(soap, tag ? tag : "tt:AnalyticsEngineControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineControl(struct soap *soap, struct tt__AnalyticsEngineControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineInput(struct soap *soap, struct tt__AnalyticsEngineInput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineInput))
		soap_serialize_tt__AnalyticsEngineInput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineInput(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineInput, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineInput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineInput(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineInput **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineInput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(struct tt__AnalyticsEngineInput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineInput(struct soap *soap, struct tt__AnalyticsEngineInput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineInput(soap, tag ? tag : "tt:AnalyticsEngineInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineInput(struct soap *soap, struct tt__AnalyticsEngineInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotad__Capabilities(struct soap *soap, struct tad__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tad__Capabilities))
		soap_serialize_tad__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotad__Capabilities(struct soap *soap, const char *tag, int id, struct tad__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tad__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tad__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tad__Capabilities ** SOAP_FMAC4 soap_in_PointerTotad__Capabilities(struct soap *soap, const char *tag, struct tad__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tad__Capabilities **)soap_malloc(soap, sizeof(struct tad__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tad__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tad__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tad__Capabilities, sizeof(struct tad__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotad__Capabilities(struct soap *soap, struct tad__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotad__Capabilities(soap, tag ? tag : "tad:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tad__Capabilities ** SOAP_FMAC4 soap_get_PointerTotad__Capabilities(struct soap *soap, struct tad__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotad__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotan__MetadataInfo(struct soap *soap, struct tan__MetadataInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tan__MetadataInfo))
		soap_serialize_tan__MetadataInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotan__MetadataInfo(struct soap *soap, const char *tag, int id, struct tan__MetadataInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tan__MetadataInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tan__MetadataInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tan__MetadataInfo ** SOAP_FMAC4 soap_in_PointerTotan__MetadataInfo(struct soap *soap, const char *tag, struct tan__MetadataInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tan__MetadataInfo **)soap_malloc(soap, sizeof(struct tan__MetadataInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tan__MetadataInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tan__MetadataInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tan__MetadataInfo, sizeof(struct tan__MetadataInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotan__MetadataInfo(struct soap *soap, struct tan__MetadataInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotan__MetadataInfo(soap, tag ? tag : "tan:MetadataInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tan__MetadataInfo ** SOAP_FMAC4 soap_get_PointerTotan__MetadataInfo(struct soap *soap, struct tan__MetadataInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotan__MetadataInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedAnalyticsModules(struct soap *soap, struct tt__SupportedAnalyticsModules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedAnalyticsModules))
		soap_serialize_tt__SupportedAnalyticsModules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedAnalyticsModules(struct soap *soap, const char *tag, int id, struct tt__SupportedAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedAnalyticsModules, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportedAnalyticsModules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTott__SupportedAnalyticsModules(struct soap *soap, const char *tag, struct tt__SupportedAnalyticsModules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportedAnalyticsModules **)soap_malloc(soap, sizeof(struct tt__SupportedAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportedAnalyticsModules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(struct tt__SupportedAnalyticsModules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedAnalyticsModules(struct soap *soap, struct tt__SupportedAnalyticsModules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SupportedAnalyticsModules(soap, tag ? tag : "tt:SupportedAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTott__SupportedAnalyticsModules(struct soap *soap, struct tt__SupportedAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotan__ConfigOptions(struct soap *soap, struct tan__ConfigOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tan__ConfigOptions))
		soap_serialize_tan__ConfigOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotan__ConfigOptions(struct soap *soap, const char *tag, int id, struct tan__ConfigOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tan__ConfigOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tan__ConfigOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tan__ConfigOptions ** SOAP_FMAC4 soap_in_PointerTotan__ConfigOptions(struct soap *soap, const char *tag, struct tan__ConfigOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tan__ConfigOptions **)soap_malloc(soap, sizeof(struct tan__ConfigOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tan__ConfigOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tan__ConfigOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tan__ConfigOptions, sizeof(struct tan__ConfigOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotan__ConfigOptions(struct soap *soap, struct tan__ConfigOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotan__ConfigOptions(soap, tag ? tag : "tan:ConfigOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tan__ConfigOptions ** SOAP_FMAC4 soap_get_PointerTotan__ConfigOptions(struct soap *soap, struct tan__ConfigOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotan__ConfigOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedRules(struct soap *soap, struct tt__SupportedRules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedRules))
		soap_serialize_tt__SupportedRules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedRules(struct soap *soap, const char *tag, int id, struct tt__SupportedRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedRules, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportedRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportedRules ** SOAP_FMAC4 soap_in_PointerTott__SupportedRules(struct soap *soap, const char *tag, struct tt__SupportedRules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportedRules **)soap_malloc(soap, sizeof(struct tt__SupportedRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportedRules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedRules, sizeof(struct tt__SupportedRules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedRules(struct soap *soap, struct tt__SupportedRules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SupportedRules(soap, tag ? tag : "tt:SupportedRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedRules ** SOAP_FMAC4 soap_get_PointerTott__SupportedRules(struct soap *soap, struct tt__SupportedRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotan__Capabilities(struct soap *soap, struct tan__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tan__Capabilities))
		soap_serialize_tan__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotan__Capabilities(struct soap *soap, const char *tag, int id, struct tan__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tan__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tan__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tan__Capabilities ** SOAP_FMAC4 soap_in_PointerTotan__Capabilities(struct soap *soap, const char *tag, struct tan__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tan__Capabilities **)soap_malloc(soap, sizeof(struct tan__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tan__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tan__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tan__Capabilities, sizeof(struct tan__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotan__Capabilities(struct soap *soap, struct tan__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotan__Capabilities(soap, tag ? tag : "tan:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tan__Capabilities ** SOAP_FMAC4 soap_get_PointerTotan__Capabilities(struct soap *soap, struct tan__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotan__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Behaviour(struct soap *soap, struct ns2__Behaviour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Behaviour))
		soap_serialize_ns2__Behaviour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Behaviour(struct soap *soap, const char *tag, int id, struct ns2__Behaviour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Behaviour, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Behaviour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Behaviour ** SOAP_FMAC4 soap_in_PointerTons2__Behaviour(struct soap *soap, const char *tag, struct ns2__Behaviour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Behaviour **)soap_malloc(soap, sizeof(struct ns2__Behaviour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Behaviour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Behaviour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Behaviour, sizeof(struct ns2__Behaviour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Behaviour(struct soap *soap, struct ns2__Behaviour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Behaviour(soap, tag ? tag : "ns2:Behaviour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Behaviour ** SOAP_FMAC4 soap_get_PointerTons2__Behaviour(struct soap *soap, struct ns2__Behaviour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Belonging(struct soap *soap, struct ns2__Belonging *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Belonging))
		soap_serialize_ns2__Belonging(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Belonging(struct soap *soap, const char *tag, int id, struct ns2__Belonging *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Belonging, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Belonging(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Belonging ** SOAP_FMAC4 soap_in_PointerTons2__Belonging(struct soap *soap, const char *tag, struct ns2__Belonging **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Belonging **)soap_malloc(soap, sizeof(struct ns2__Belonging *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Belonging(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Belonging **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Belonging, sizeof(struct ns2__Belonging), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Belonging(struct soap *soap, struct ns2__Belonging *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Belonging(soap, tag ? tag : "ns2:Belonging", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Belonging ** SOAP_FMAC4 soap_get_PointerTons2__Belonging(struct soap *soap, struct ns2__Belonging **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Belonging(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Clothing(struct soap *soap, struct ns2__Clothing *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Clothing))
		soap_serialize_ns2__Clothing(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Clothing(struct soap *soap, const char *tag, int id, struct ns2__Clothing *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Clothing, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Clothing(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Clothing ** SOAP_FMAC4 soap_in_PointerTons2__Clothing(struct soap *soap, const char *tag, struct ns2__Clothing **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Clothing **)soap_malloc(soap, sizeof(struct ns2__Clothing *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Clothing(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Clothing **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Clothing, sizeof(struct ns2__Clothing), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Clothing(struct soap *soap, struct ns2__Clothing *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Clothing(soap, tag ? tag : "ns2:Clothing", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Clothing ** SOAP_FMAC4 soap_get_PointerTons2__Clothing(struct soap *soap, struct ns2__Clothing **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Clothing(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BodyMetric(struct soap *soap, struct ns2__BodyMetric *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BodyMetric))
		soap_serialize_ns2__BodyMetric(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BodyMetric(struct soap *soap, const char *tag, int id, struct ns2__BodyMetric *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BodyMetric, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__BodyMetric(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__BodyMetric ** SOAP_FMAC4 soap_in_PointerTons2__BodyMetric(struct soap *soap, const char *tag, struct ns2__BodyMetric **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__BodyMetric **)soap_malloc(soap, sizeof(struct ns2__BodyMetric *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__BodyMetric(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__BodyMetric **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BodyMetric, sizeof(struct ns2__BodyMetric), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BodyMetric(struct soap *soap, struct ns2__BodyMetric *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BodyMetric(soap, tag ? tag : "ns2:BodyMetric", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__BodyMetric ** SOAP_FMAC4 soap_get_PointerTons2__BodyMetric(struct soap *soap, struct ns2__BodyMetric **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BodyMetric(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UsingMobile(struct soap *soap, enum ns2__UsingMobile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns2__UsingMobile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UsingMobile(struct soap *soap, const char *tag, int id, enum ns2__UsingMobile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UsingMobile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__UsingMobile(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__UsingMobile ** SOAP_FMAC4 soap_in_PointerTons2__UsingMobile(struct soap *soap, const char *tag, enum ns2__UsingMobile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__UsingMobile **)soap_malloc(soap, sizeof(enum ns2__UsingMobile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__UsingMobile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__UsingMobile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UsingMobile, sizeof(enum ns2__UsingMobile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UsingMobile(struct soap *soap, enum ns2__UsingMobile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__UsingMobile(soap, tag ? tag : "ns2:UsingMobile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__UsingMobile ** SOAP_FMAC4 soap_get_PointerTons2__UsingMobile(struct soap *soap, enum ns2__UsingMobile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UsingMobile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Smoking(struct soap *soap, enum ns2__Smoking *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns2__Smoking);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Smoking(struct soap *soap, const char *tag, int id, enum ns2__Smoking *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Smoking, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Smoking(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__Smoking ** SOAP_FMAC4 soap_in_PointerTons2__Smoking(struct soap *soap, const char *tag, enum ns2__Smoking **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__Smoking **)soap_malloc(soap, sizeof(enum ns2__Smoking *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Smoking(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__Smoking **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Smoking, sizeof(enum ns2__Smoking), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Smoking(struct soap *soap, enum ns2__Smoking *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Smoking(soap, tag ? tag : "ns2:Smoking", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__Smoking ** SOAP_FMAC4 soap_get_PointerTons2__Smoking(struct soap *soap, enum ns2__Smoking **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Smoking(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Cart(struct soap *soap, struct ns2__Cart *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Cart))
		soap_serialize_ns2__Cart(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Cart(struct soap *soap, const char *tag, int id, struct ns2__Cart *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Cart, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Cart(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Cart ** SOAP_FMAC4 soap_in_PointerTons2__Cart(struct soap *soap, const char *tag, struct ns2__Cart **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Cart **)soap_malloc(soap, sizeof(struct ns2__Cart *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Cart(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Cart **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Cart, sizeof(struct ns2__Cart), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Cart(struct soap *soap, struct ns2__Cart *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Cart(soap, tag ? tag : "ns2:Cart", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Cart ** SOAP_FMAC4 soap_get_PointerTons2__Cart(struct soap *soap, struct ns2__Cart **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Cart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Box(struct soap *soap, struct ns2__Box *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Box))
		soap_serialize_ns2__Box(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Box(struct soap *soap, const char *tag, int id, struct ns2__Box *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Box, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Box(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Box ** SOAP_FMAC4 soap_in_PointerTons2__Box(struct soap *soap, const char *tag, struct ns2__Box **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Box **)soap_malloc(soap, sizeof(struct ns2__Box *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Box(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Box **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Box, sizeof(struct ns2__Box), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Box(struct soap *soap, struct ns2__Box *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Box(soap, tag ? tag : "ns2:Box", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Box ** SOAP_FMAC4 soap_get_PointerTons2__Box(struct soap *soap, struct ns2__Box **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Box(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Umbrella(struct soap *soap, struct ns2__Umbrella *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Umbrella))
		soap_serialize_ns2__Umbrella(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Umbrella(struct soap *soap, const char *tag, int id, struct ns2__Umbrella *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Umbrella, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Umbrella(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Umbrella ** SOAP_FMAC4 soap_in_PointerTons2__Umbrella(struct soap *soap, const char *tag, struct ns2__Umbrella **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Umbrella **)soap_malloc(soap, sizeof(struct ns2__Umbrella *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Umbrella(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Umbrella **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Umbrella, sizeof(struct ns2__Umbrella), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Umbrella(struct soap *soap, struct ns2__Umbrella *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Umbrella(soap, tag ? tag : "ns2:Umbrella", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Umbrella ** SOAP_FMAC4 soap_get_PointerTons2__Umbrella(struct soap *soap, struct ns2__Umbrella **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Umbrella(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Bag(struct soap *soap, struct ns2__Bag *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Bag))
		soap_serialize_ns2__Bag(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Bag(struct soap *soap, const char *tag, int id, struct ns2__Bag *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Bag, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Bag(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Bag ** SOAP_FMAC4 soap_in_PointerTons2__Bag(struct soap *soap, const char *tag, struct ns2__Bag **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Bag **)soap_malloc(soap, sizeof(struct ns2__Bag *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Bag(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Bag **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Bag, sizeof(struct ns2__Bag), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Bag(struct soap *soap, struct ns2__Bag *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Bag(soap, tag ? tag : "ns2:Bag", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Bag ** SOAP_FMAC4 soap_get_PointerTons2__Bag(struct soap *soap, struct ns2__Bag **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Bag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Shoes(struct soap *soap, struct ns2__Shoes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Shoes))
		soap_serialize_ns2__Shoes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Shoes(struct soap *soap, const char *tag, int id, struct ns2__Shoes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Shoes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Shoes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Shoes ** SOAP_FMAC4 soap_in_PointerTons2__Shoes(struct soap *soap, const char *tag, struct ns2__Shoes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Shoes **)soap_malloc(soap, sizeof(struct ns2__Shoes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Shoes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Shoes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Shoes, sizeof(struct ns2__Shoes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Shoes(struct soap *soap, struct ns2__Shoes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Shoes(soap, tag ? tag : "ns2:Shoes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Shoes ** SOAP_FMAC4 soap_get_PointerTons2__Shoes(struct soap *soap, struct ns2__Shoes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Shoes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Bottoms(struct soap *soap, struct ns2__Bottoms *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Bottoms))
		soap_serialize_ns2__Bottoms(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Bottoms(struct soap *soap, const char *tag, int id, struct ns2__Bottoms *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Bottoms, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Bottoms(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Bottoms ** SOAP_FMAC4 soap_in_PointerTons2__Bottoms(struct soap *soap, const char *tag, struct ns2__Bottoms **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Bottoms **)soap_malloc(soap, sizeof(struct ns2__Bottoms *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Bottoms(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Bottoms **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Bottoms, sizeof(struct ns2__Bottoms), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Bottoms(struct soap *soap, struct ns2__Bottoms *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Bottoms(soap, tag ? tag : "ns2:Bottoms", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Bottoms ** SOAP_FMAC4 soap_get_PointerTons2__Bottoms(struct soap *soap, struct ns2__Bottoms **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Bottoms(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Tops(struct soap *soap, struct ns2__Tops *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Tops))
		soap_serialize_ns2__Tops(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Tops(struct soap *soap, const char *tag, int id, struct ns2__Tops *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Tops, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Tops(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Tops ** SOAP_FMAC4 soap_in_PointerTons2__Tops(struct soap *soap, const char *tag, struct ns2__Tops **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Tops **)soap_malloc(soap, sizeof(struct ns2__Tops *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Tops(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Tops **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Tops, sizeof(struct ns2__Tops), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Tops(struct soap *soap, struct ns2__Tops *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Tops(soap, tag ? tag : "ns2:Tops", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Tops ** SOAP_FMAC4 soap_get_PointerTons2__Tops(struct soap *soap, struct ns2__Tops **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Tops(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Gloves(struct soap *soap, struct ns2__Gloves *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Gloves))
		soap_serialize_ns2__Gloves(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Gloves(struct soap *soap, const char *tag, int id, struct ns2__Gloves *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Gloves, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Gloves(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Gloves ** SOAP_FMAC4 soap_in_PointerTons2__Gloves(struct soap *soap, const char *tag, struct ns2__Gloves **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Gloves **)soap_malloc(soap, sizeof(struct ns2__Gloves *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Gloves(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Gloves **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Gloves, sizeof(struct ns2__Gloves), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Gloves(struct soap *soap, struct ns2__Gloves *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Gloves(soap, tag ? tag : "ns2:Gloves", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Gloves ** SOAP_FMAC4 soap_get_PointerTons2__Gloves(struct soap *soap, struct ns2__Gloves **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Gloves(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Scarf(struct soap *soap, struct ns2__Scarf *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Scarf))
		soap_serialize_ns2__Scarf(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Scarf(struct soap *soap, const char *tag, int id, struct ns2__Scarf *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Scarf, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Scarf(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Scarf ** SOAP_FMAC4 soap_in_PointerTons2__Scarf(struct soap *soap, const char *tag, struct ns2__Scarf **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Scarf **)soap_malloc(soap, sizeof(struct ns2__Scarf *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Scarf(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Scarf **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Scarf, sizeof(struct ns2__Scarf), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Scarf(struct soap *soap, struct ns2__Scarf *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Scarf(soap, tag ? tag : "ns2:Scarf", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Scarf ** SOAP_FMAC4 soap_get_PointerTons2__Scarf(struct soap *soap, struct ns2__Scarf **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Scarf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AdditionalFeatures(struct soap *soap, struct ns1__AdditionalFeatures *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AdditionalFeatures))
		soap_serialize_ns1__AdditionalFeatures(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AdditionalFeatures(struct soap *soap, const char *tag, int id, struct ns1__AdditionalFeatures *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AdditionalFeatures, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AdditionalFeatures(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__AdditionalFeatures ** SOAP_FMAC4 soap_in_PointerTons1__AdditionalFeatures(struct soap *soap, const char *tag, struct ns1__AdditionalFeatures **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__AdditionalFeatures **)soap_malloc(soap, sizeof(struct ns1__AdditionalFeatures *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AdditionalFeatures(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__AdditionalFeatures **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AdditionalFeatures, sizeof(struct ns1__AdditionalFeatures), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AdditionalFeatures(struct soap *soap, struct ns1__AdditionalFeatures *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AdditionalFeatures(soap, tag ? tag : "ns1:AdditionalFeatures", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AdditionalFeatures ** SOAP_FMAC4 soap_get_PointerTons1__AdditionalFeatures(struct soap *soap, struct ns1__AdditionalFeatures **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AdditionalFeatures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Accessory(struct soap *soap, struct ns1__Accessory *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Accessory))
		soap_serialize_ns1__Accessory(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Accessory(struct soap *soap, const char *tag, int id, struct ns1__Accessory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Accessory, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Accessory(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Accessory ** SOAP_FMAC4 soap_in_PointerTons1__Accessory(struct soap *soap, const char *tag, struct ns1__Accessory **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Accessory **)soap_malloc(soap, sizeof(struct ns1__Accessory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Accessory(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Accessory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Accessory, sizeof(struct ns1__Accessory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Accessory(struct soap *soap, struct ns1__Accessory *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Accessory(soap, tag ? tag : "ns1:Accessory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Accessory ** SOAP_FMAC4 soap_get_PointerTons1__Accessory(struct soap *soap, struct ns1__Accessory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Accessory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PoseAngle(struct soap *soap, struct ns1__PoseAngle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PoseAngle))
		soap_serialize_ns1__PoseAngle(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PoseAngle(struct soap *soap, const char *tag, int id, struct ns1__PoseAngle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PoseAngle, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PoseAngle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__PoseAngle ** SOAP_FMAC4 soap_in_PointerTons1__PoseAngle(struct soap *soap, const char *tag, struct ns1__PoseAngle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__PoseAngle **)soap_malloc(soap, sizeof(struct ns1__PoseAngle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__PoseAngle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__PoseAngle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PoseAngle, sizeof(struct ns1__PoseAngle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PoseAngle(struct soap *soap, struct ns1__PoseAngle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__PoseAngle(soap, tag ? tag : "ns1:PoseAngle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PoseAngle ** SOAP_FMAC4 soap_get_PointerTons1__PoseAngle(struct soap *soap, struct ns1__PoseAngle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PoseAngle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FacialHair(struct soap *soap, struct ns1__FacialHair *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FacialHair))
		soap_serialize_ns1__FacialHair(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FacialHair(struct soap *soap, const char *tag, int id, struct ns1__FacialHair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FacialHair, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FacialHair(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FacialHair ** SOAP_FMAC4 soap_in_PointerTons1__FacialHair(struct soap *soap, const char *tag, struct ns1__FacialHair **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FacialHair **)soap_malloc(soap, sizeof(struct ns1__FacialHair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FacialHair(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FacialHair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FacialHair, sizeof(struct ns1__FacialHair), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FacialHair(struct soap *soap, struct ns1__FacialHair *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FacialHair(soap, tag ? tag : "ns1:FacialHair", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FacialHair ** SOAP_FMAC4 soap_get_PointerTons1__FacialHair(struct soap *soap, struct ns1__FacialHair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FacialHair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Nose(struct soap *soap, struct ns1__Nose *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Nose))
		soap_serialize_ns1__Nose(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Nose(struct soap *soap, const char *tag, int id, struct ns1__Nose *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Nose, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Nose(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Nose ** SOAP_FMAC4 soap_in_PointerTons1__Nose(struct soap *soap, const char *tag, struct ns1__Nose **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Nose **)soap_malloc(soap, sizeof(struct ns1__Nose *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Nose(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Nose **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Nose, sizeof(struct ns1__Nose), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Nose(struct soap *soap, struct ns1__Nose *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Nose(soap, tag ? tag : "ns1:Nose", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Nose ** SOAP_FMAC4 soap_get_PointerTons1__Nose(struct soap *soap, struct ns1__Nose **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Nose(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Ear(struct soap *soap, enum ns1__Ear *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns1__Ear);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Ear(struct soap *soap, const char *tag, int id, enum ns1__Ear *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Ear, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Ear(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__Ear ** SOAP_FMAC4 soap_in_PointerTons1__Ear(struct soap *soap, const char *tag, enum ns1__Ear **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__Ear **)soap_malloc(soap, sizeof(enum ns1__Ear *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Ear(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__Ear **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Ear, sizeof(enum ns1__Ear), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Ear(struct soap *soap, enum ns1__Ear *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Ear(soap, tag ? tag : "ns1:Ear", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Ear ** SOAP_FMAC4 soap_get_PointerTons1__Ear(struct soap *soap, enum ns1__Ear **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Ear(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Eye(struct soap *soap, struct ns1__Eye *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Eye))
		soap_serialize_ns1__Eye(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Eye(struct soap *soap, const char *tag, int id, struct ns1__Eye *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Eye, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Eye(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Eye ** SOAP_FMAC4 soap_in_PointerTons1__Eye(struct soap *soap, const char *tag, struct ns1__Eye **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Eye **)soap_malloc(soap, sizeof(struct ns1__Eye *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Eye(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Eye **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Eye, sizeof(struct ns1__Eye), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Eye(struct soap *soap, struct ns1__Eye *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Eye(soap, tag ? tag : "ns1:Eye", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Eye ** SOAP_FMAC4 soap_get_PointerTons1__Eye(struct soap *soap, struct ns1__Eye **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Eye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Eyebrow(struct soap *soap, struct ns1__Eyebrow *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Eyebrow))
		soap_serialize_ns1__Eyebrow(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Eyebrow(struct soap *soap, const char *tag, int id, struct ns1__Eyebrow *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Eyebrow, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Eyebrow(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Eyebrow ** SOAP_FMAC4 soap_in_PointerTons1__Eyebrow(struct soap *soap, const char *tag, struct ns1__Eyebrow **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Eyebrow **)soap_malloc(soap, sizeof(struct ns1__Eyebrow *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Eyebrow(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Eyebrow **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Eyebrow, sizeof(struct ns1__Eyebrow), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Eyebrow(struct soap *soap, struct ns1__Eyebrow *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Eyebrow(soap, tag ? tag : "ns1:Eyebrow", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Eyebrow ** SOAP_FMAC4 soap_get_PointerTons1__Eyebrow(struct soap *soap, struct ns1__Eyebrow **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Eyebrow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Hair(struct soap *soap, struct ns1__Hair *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Hair))
		soap_serialize_ns1__Hair(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Hair(struct soap *soap, const char *tag, int id, struct ns1__Hair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Hair, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Hair(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Hair ** SOAP_FMAC4 soap_in_PointerTons1__Hair(struct soap *soap, const char *tag, struct ns1__Hair **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Hair **)soap_malloc(soap, sizeof(struct ns1__Hair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Hair(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Hair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Hair, sizeof(struct ns1__Hair), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Hair(struct soap *soap, struct ns1__Hair *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Hair(soap, tag ? tag : "ns1:Hair", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Hair ** SOAP_FMAC4 soap_get_PointerTons1__Hair(struct soap *soap, struct ns1__Hair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Hair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccessoryDescription(struct soap *soap, struct ns1__AccessoryDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccessoryDescription))
		soap_serialize_ns1__AccessoryDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccessoryDescription(struct soap *soap, const char *tag, int id, struct ns1__AccessoryDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AccessoryDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AccessoryDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__AccessoryDescription ** SOAP_FMAC4 soap_in_PointerTons1__AccessoryDescription(struct soap *soap, const char *tag, struct ns1__AccessoryDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__AccessoryDescription **)soap_malloc(soap, sizeof(struct ns1__AccessoryDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AccessoryDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__AccessoryDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AccessoryDescription, sizeof(struct ns1__AccessoryDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccessoryDescription(struct soap *soap, struct ns1__AccessoryDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AccessoryDescription(soap, tag ? tag : "ns1:AccessoryDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AccessoryDescription ** SOAP_FMAC4 soap_get_PointerTons1__AccessoryDescription(struct soap *soap, struct ns1__AccessoryDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccessoryDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__Documentation))
		soap_serialize_wstop__Documentation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__Documentation(struct soap *soap, const char *tag, int id, struct wstop__Documentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__Documentation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__Documentation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__Documentation ** SOAP_FMAC4 soap_in_PointerTowstop__Documentation(struct soap *soap, const char *tag, struct wstop__Documentation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__Documentation **)soap_malloc(soap, sizeof(struct wstop__Documentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__Documentation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__Documentation ** SOAP_FMAC4 soap_get_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause))
		soap_serialize__wsrfbf__BaseFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_Description))
		soap_serialize__wsrfbf__BaseFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_Description **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(struct _wsrfbf__BaseFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag ? tag : "wsrfbf:BaseFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode))
		soap_serialize__wsrfbf__BaseFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy))
		soap_serialize__wsnt__Subscribe_SubscriptionPolicy(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _wsnt__Subscribe_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscriptionPolicyType))
		soap_serialize_wsnt__SubscriptionPolicyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, struct wsnt__SubscriptionPolicyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscriptionPolicyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__SubscriptionPolicyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, struct wsnt__SubscriptionPolicyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__SubscriptionPolicyType **)soap_malloc(soap, sizeof(struct wsnt__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__SubscriptionPolicyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicSetType))
		soap_serialize_wstop__TopicSetType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, int id, struct wstop__TopicSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicSetType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__TopicSetType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__TopicSetType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, struct wstop__TopicSetType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__TopicSetType **)soap_malloc(soap, sizeof(struct wstop__TopicSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__TopicSetType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicSetType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionType))
		soap_serialize_wsnt__TopicExpressionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, struct wsnt__TopicExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__TopicExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__TopicExpressionType **)soap_malloc(soap, sizeof(struct wsnt__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__TopicExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__PropertyOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PropertyOperation(struct soap *soap, const char *tag, int id, enum tt__PropertyOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PropertyOperation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PropertyOperation(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_in_PointerTott__PropertyOperation(struct soap *soap, const char *tag, enum tt__PropertyOperation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__PropertyOperation **)soap_malloc(soap, sizeof(enum tt__PropertyOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PropertyOperation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__PropertyOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PropertyOperation(soap, tag ? tag : "tt:PropertyOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_get_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageExtension(struct soap *soap, struct tt__MessageExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageExtension))
		soap_serialize_tt__MessageExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageExtension(struct soap *soap, const char *tag, int id, struct tt__MessageExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MessageExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MessageExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageExtension(struct soap *soap, const char *tag, struct tt__MessageExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MessageExtension **)soap_malloc(soap, sizeof(struct tt__MessageExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MessageExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MessageExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageExtension(struct soap *soap, struct tt__MessageExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MessageExtension(soap, tag ? tag : "tt:MessageExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageExtension(struct soap *soap, struct tt__MessageExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tt__union_EventStream(struct soap *soap, struct __tt__union_EventStream *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___tt__union_EventStream))
		soap_serialize___tt__union_EventStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tt__union_EventStream(struct soap *soap, const char *tag, int id, struct __tt__union_EventStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tt__union_EventStream, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___tt__union_EventStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __tt__union_EventStream ** SOAP_FMAC4 soap_in_PointerTo__tt__union_EventStream(struct soap *soap, const char *tag, struct __tt__union_EventStream **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __tt__union_EventStream **)soap_malloc(soap, sizeof(struct __tt__union_EventStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___tt__union_EventStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __tt__union_EventStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tt__union_EventStream, sizeof(struct __tt__union_EventStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tt__union_EventStream(struct soap *soap, struct __tt__union_EventStream *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__tt__union_EventStream(soap, tag ? tag : "-tt:union-EventStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __tt__union_EventStream ** SOAP_FMAC4 soap_get_PointerTo__tt__union_EventStream(struct soap *soap, struct __tt__union_EventStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tt__union_EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventStreamExtension(struct soap *soap, struct tt__EventStreamExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventStreamExtension))
		soap_serialize_tt__EventStreamExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventStreamExtension(struct soap *soap, const char *tag, int id, struct tt__EventStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventStreamExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__EventStreamExtension(struct soap *soap, const char *tag, struct tt__EventStreamExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EventStreamExtension **)soap_malloc(soap, sizeof(struct tt__EventStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EventStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EventStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventStreamExtension, sizeof(struct tt__EventStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventStreamExtension(struct soap *soap, struct tt__EventStreamExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventStreamExtension(soap, tag ? tag : "tt:EventStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__EventStreamExtension(struct soap *soap, struct tt__EventStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tt__union_PTZStream(struct soap *soap, struct __tt__union_PTZStream *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___tt__union_PTZStream))
		soap_serialize___tt__union_PTZStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tt__union_PTZStream(struct soap *soap, const char *tag, int id, struct __tt__union_PTZStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tt__union_PTZStream, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___tt__union_PTZStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __tt__union_PTZStream ** SOAP_FMAC4 soap_in_PointerTo__tt__union_PTZStream(struct soap *soap, const char *tag, struct __tt__union_PTZStream **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __tt__union_PTZStream **)soap_malloc(soap, sizeof(struct __tt__union_PTZStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___tt__union_PTZStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __tt__union_PTZStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tt__union_PTZStream, sizeof(struct __tt__union_PTZStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tt__union_PTZStream(struct soap *soap, struct __tt__union_PTZStream *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__tt__union_PTZStream(soap, tag ? tag : "-tt:union-PTZStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __tt__union_PTZStream ** SOAP_FMAC4 soap_get_PointerTo__tt__union_PTZStream(struct soap *soap, struct __tt__union_PTZStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tt__union_PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStreamExtension(struct soap *soap, struct tt__PTZStreamExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStreamExtension))
		soap_serialize_tt__PTZStreamExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStreamExtension(struct soap *soap, const char *tag, int id, struct tt__PTZStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStreamExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZStreamExtension(struct soap *soap, const char *tag, struct tt__PTZStreamExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZStreamExtension **)soap_malloc(soap, sizeof(struct tt__PTZStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStreamExtension, sizeof(struct tt__PTZStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStreamExtension(struct soap *soap, struct tt__PTZStreamExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZStreamExtension(soap, tag ? tag : "tt:PTZStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZStreamExtension(struct soap *soap, struct tt__PTZStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, struct __tt__union_VideoAnalyticsStream *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___tt__union_VideoAnalyticsStream))
		soap_serialize___tt__union_VideoAnalyticsStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, int id, struct __tt__union_VideoAnalyticsStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tt__union_VideoAnalyticsStream, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___tt__union_VideoAnalyticsStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __tt__union_VideoAnalyticsStream ** SOAP_FMAC4 soap_in_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, struct __tt__union_VideoAnalyticsStream **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __tt__union_VideoAnalyticsStream **)soap_malloc(soap, sizeof(struct __tt__union_VideoAnalyticsStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___tt__union_VideoAnalyticsStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __tt__union_VideoAnalyticsStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tt__union_VideoAnalyticsStream, sizeof(struct __tt__union_VideoAnalyticsStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, struct __tt__union_VideoAnalyticsStream *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__tt__union_VideoAnalyticsStream(soap, tag ? tag : "-tt:union-VideoAnalyticsStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __tt__union_VideoAnalyticsStream ** SOAP_FMAC4 soap_get_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, struct __tt__union_VideoAnalyticsStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tt__union_VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, struct tt__VideoAnalyticsStreamExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension))
		soap_serialize_tt__VideoAnalyticsStreamExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, int id, struct tt__VideoAnalyticsStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoAnalyticsStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, struct tt__VideoAnalyticsStreamExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoAnalyticsStreamExtension **)soap_malloc(soap, sizeof(struct tt__VideoAnalyticsStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoAnalyticsStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, sizeof(struct tt__VideoAnalyticsStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, struct tt__VideoAnalyticsStreamExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoAnalyticsStreamExtension(soap, tag ? tag : "tt:VideoAnalyticsStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, struct tt__VideoAnalyticsStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAnalyticsStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Frame(struct soap *soap, struct tt__Frame *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Frame))
		soap_serialize_tt__Frame(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Frame(struct soap *soap, const char *tag, int id, struct tt__Frame *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Frame, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Frame(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Frame ** SOAP_FMAC4 soap_in_PointerTott__Frame(struct soap *soap, const char *tag, struct tt__Frame **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Frame **)soap_malloc(soap, sizeof(struct tt__Frame *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Frame(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Frame **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Frame, sizeof(struct tt__Frame), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Frame(struct soap *soap, struct tt__Frame *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Frame(soap, tag ? tag : "tt:Frame", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Frame ** SOAP_FMAC4 soap_get_PointerTott__Frame(struct soap *soap, struct tt__Frame **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Frame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioAnalyticsStreamExtension(struct soap *soap, struct tt__AudioAnalyticsStreamExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioAnalyticsStreamExtension))
		soap_serialize_tt__AudioAnalyticsStreamExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioAnalyticsStreamExtension(struct soap *soap, const char *tag, int id, struct tt__AudioAnalyticsStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioAnalyticsStreamExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioAnalyticsStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioAnalyticsStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__AudioAnalyticsStreamExtension(struct soap *soap, const char *tag, struct tt__AudioAnalyticsStreamExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioAnalyticsStreamExtension **)soap_malloc(soap, sizeof(struct tt__AudioAnalyticsStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioAnalyticsStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioAnalyticsStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioAnalyticsStreamExtension, sizeof(struct tt__AudioAnalyticsStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioAnalyticsStreamExtension(struct soap *soap, struct tt__AudioAnalyticsStreamExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioAnalyticsStreamExtension(soap, tag ? tag : "tt:AudioAnalyticsStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioAnalyticsStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__AudioAnalyticsStreamExtension(struct soap *soap, struct tt__AudioAnalyticsStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioAnalyticsStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDescriptor(struct soap *soap, struct tt__AudioDescriptor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDescriptor))
		soap_serialize_tt__AudioDescriptor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDescriptor(struct soap *soap, const char *tag, int id, struct tt__AudioDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDescriptor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioDescriptor ** SOAP_FMAC4 soap_in_PointerTott__AudioDescriptor(struct soap *soap, const char *tag, struct tt__AudioDescriptor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioDescriptor **)soap_malloc(soap, sizeof(struct tt__AudioDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDescriptor, sizeof(struct tt__AudioDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDescriptor(struct soap *soap, struct tt__AudioDescriptor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioDescriptor(soap, tag ? tag : "tt:AudioDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDescriptor ** SOAP_FMAC4 soap_get_PointerTott__AudioDescriptor(struct soap *soap, struct tt__AudioDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataStreamExtension2(struct soap *soap, struct tt__MetadataStreamExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataStreamExtension2))
		soap_serialize_tt__MetadataStreamExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataStreamExtension2(struct soap *soap, const char *tag, int id, struct tt__MetadataStreamExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataStreamExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataStreamExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension2 ** SOAP_FMAC4 soap_in_PointerTott__MetadataStreamExtension2(struct soap *soap, const char *tag, struct tt__MetadataStreamExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataStreamExtension2 **)soap_malloc(soap, sizeof(struct tt__MetadataStreamExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataStreamExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataStreamExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataStreamExtension2, sizeof(struct tt__MetadataStreamExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataStreamExtension2(struct soap *soap, struct tt__MetadataStreamExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataStreamExtension2(soap, tag ? tag : "tt:MetadataStreamExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension2 ** SOAP_FMAC4 soap_get_PointerTott__MetadataStreamExtension2(struct soap *soap, struct tt__MetadataStreamExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataStreamExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioAnalyticsStream(struct soap *soap, struct tt__AudioAnalyticsStream *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioAnalyticsStream))
		soap_serialize_tt__AudioAnalyticsStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioAnalyticsStream(struct soap *soap, const char *tag, int id, struct tt__AudioAnalyticsStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioAnalyticsStream, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioAnalyticsStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioAnalyticsStream ** SOAP_FMAC4 soap_in_PointerTott__AudioAnalyticsStream(struct soap *soap, const char *tag, struct tt__AudioAnalyticsStream **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioAnalyticsStream **)soap_malloc(soap, sizeof(struct tt__AudioAnalyticsStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioAnalyticsStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioAnalyticsStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioAnalyticsStream, sizeof(struct tt__AudioAnalyticsStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioAnalyticsStream(struct soap *soap, struct tt__AudioAnalyticsStream *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioAnalyticsStream(soap, tag ? tag : "tt:AudioAnalyticsStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioAnalyticsStream ** SOAP_FMAC4 soap_get_PointerTott__AudioAnalyticsStream(struct soap *soap, struct tt__AudioAnalyticsStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tt__union_MetadataStream(struct soap *soap, struct __tt__union_MetadataStream *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___tt__union_MetadataStream))
		soap_serialize___tt__union_MetadataStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tt__union_MetadataStream(struct soap *soap, const char *tag, int id, struct __tt__union_MetadataStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tt__union_MetadataStream, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___tt__union_MetadataStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __tt__union_MetadataStream ** SOAP_FMAC4 soap_in_PointerTo__tt__union_MetadataStream(struct soap *soap, const char *tag, struct __tt__union_MetadataStream **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __tt__union_MetadataStream **)soap_malloc(soap, sizeof(struct __tt__union_MetadataStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___tt__union_MetadataStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __tt__union_MetadataStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tt__union_MetadataStream, sizeof(struct __tt__union_MetadataStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tt__union_MetadataStream(struct soap *soap, struct __tt__union_MetadataStream *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__tt__union_MetadataStream(soap, tag ? tag : "-tt:union-MetadataStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __tt__union_MetadataStream ** SOAP_FMAC4 soap_get_PointerTo__tt__union_MetadataStream(struct soap *soap, struct __tt__union_MetadataStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tt__union_MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataStreamExtension(struct soap *soap, struct tt__MetadataStreamExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataStreamExtension))
		soap_serialize_tt__MetadataStreamExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataStreamExtension(struct soap *soap, const char *tag, int id, struct tt__MetadataStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataStreamExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataStreamExtension(struct soap *soap, const char *tag, struct tt__MetadataStreamExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataStreamExtension **)soap_malloc(soap, sizeof(struct tt__MetadataStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataStreamExtension, sizeof(struct tt__MetadataStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataStreamExtension(struct soap *soap, struct tt__MetadataStreamExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataStreamExtension(soap, tag ? tag : "tt:MetadataStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataStreamExtension(struct soap *soap, struct tt__MetadataStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventStream(struct soap *soap, struct tt__EventStream *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventStream))
		soap_serialize_tt__EventStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventStream(struct soap *soap, const char *tag, int id, struct tt__EventStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventStream, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventStream ** SOAP_FMAC4 soap_in_PointerTott__EventStream(struct soap *soap, const char *tag, struct tt__EventStream **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EventStream **)soap_malloc(soap, sizeof(struct tt__EventStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EventStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EventStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventStream, sizeof(struct tt__EventStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventStream(struct soap *soap, struct tt__EventStream *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventStream(soap, tag ? tag : "tt:EventStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventStream ** SOAP_FMAC4 soap_get_PointerTott__EventStream(struct soap *soap, struct tt__EventStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStream(struct soap *soap, struct tt__PTZStream *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStream))
		soap_serialize_tt__PTZStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStream(struct soap *soap, const char *tag, int id, struct tt__PTZStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStream, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZStream ** SOAP_FMAC4 soap_in_PointerTott__PTZStream(struct soap *soap, const char *tag, struct tt__PTZStream **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZStream **)soap_malloc(soap, sizeof(struct tt__PTZStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStream, sizeof(struct tt__PTZStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStream(struct soap *soap, struct tt__PTZStream *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZStream(soap, tag ? tag : "tt:PTZStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStream ** SOAP_FMAC4 soap_get_PointerTott__PTZStream(struct soap *soap, struct tt__PTZStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAnalyticsStream(struct soap *soap, struct tt__VideoAnalyticsStream *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAnalyticsStream))
		soap_serialize_tt__VideoAnalyticsStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAnalyticsStream(struct soap *soap, const char *tag, int id, struct tt__VideoAnalyticsStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAnalyticsStream, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoAnalyticsStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStream ** SOAP_FMAC4 soap_in_PointerTott__VideoAnalyticsStream(struct soap *soap, const char *tag, struct tt__VideoAnalyticsStream **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoAnalyticsStream **)soap_malloc(soap, sizeof(struct tt__VideoAnalyticsStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoAnalyticsStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsStream, sizeof(struct tt__VideoAnalyticsStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAnalyticsStream(struct soap *soap, struct tt__VideoAnalyticsStream *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoAnalyticsStream(soap, tag ? tag : "tt:VideoAnalyticsStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStream ** SOAP_FMAC4 soap_get_PointerTott__VideoAnalyticsStream(struct soap *soap, struct tt__VideoAnalyticsStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectTreeExtension))
		soap_serialize_tt__ObjectTreeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectTreeExtension(struct soap *soap, const char *tag, int id, struct tt__ObjectTreeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectTreeExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ObjectTreeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ObjectTreeExtension ** SOAP_FMAC4 soap_in_PointerTott__ObjectTreeExtension(struct soap *soap, const char *tag, struct tt__ObjectTreeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ObjectTreeExtension **)soap_malloc(soap, sizeof(struct tt__ObjectTreeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ObjectTreeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectTreeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectTreeExtension, sizeof(struct tt__ObjectTreeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ObjectTreeExtension(soap, tag ? tag : "tt:ObjectTreeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectTreeExtension ** SOAP_FMAC4 soap_get_PointerTott__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectTreeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Merge(struct soap *soap, struct tt__Merge *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Merge))
		soap_serialize_tt__Merge(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Merge(struct soap *soap, const char *tag, int id, struct tt__Merge *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Merge, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Merge(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Merge ** SOAP_FMAC4 soap_in_PointerTott__Merge(struct soap *soap, const char *tag, struct tt__Merge **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Merge **)soap_malloc(soap, sizeof(struct tt__Merge *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Merge(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Merge **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Merge, sizeof(struct tt__Merge), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Merge(struct soap *soap, struct tt__Merge *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Merge(soap, tag ? tag : "tt:Merge", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Merge ** SOAP_FMAC4 soap_get_PointerTott__Merge(struct soap *soap, struct tt__Merge **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Merge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Split(struct soap *soap, struct tt__Split *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Split))
		soap_serialize_tt__Split(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Split(struct soap *soap, const char *tag, int id, struct tt__Split *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Split, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Split(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Split ** SOAP_FMAC4 soap_in_PointerTott__Split(struct soap *soap, const char *tag, struct tt__Split **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Split **)soap_malloc(soap, sizeof(struct tt__Split *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Split(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Split **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Split, sizeof(struct tt__Split), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Split(struct soap *soap, struct tt__Split *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Split(soap, tag ? tag : "tt:Split", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Split ** SOAP_FMAC4 soap_get_PointerTott__Split(struct soap *soap, struct tt__Split **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Split(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rename(struct soap *soap, struct tt__Rename *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rename))
		soap_serialize_tt__Rename(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rename(struct soap *soap, const char *tag, int id, struct tt__Rename *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rename, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Rename(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Rename ** SOAP_FMAC4 soap_in_PointerTott__Rename(struct soap *soap, const char *tag, struct tt__Rename **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Rename **)soap_malloc(soap, sizeof(struct tt__Rename *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Rename(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Rename **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rename, sizeof(struct tt__Rename), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rename(struct soap *soap, struct tt__Rename *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Rename(soap, tag ? tag : "tt:Rename", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rename ** SOAP_FMAC4 soap_get_PointerTott__Rename(struct soap *soap, struct tt__Rename **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rename(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BehaviourExtension))
		soap_serialize_tt__BehaviourExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BehaviourExtension(struct soap *soap, const char *tag, int id, struct tt__BehaviourExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BehaviourExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BehaviourExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BehaviourExtension ** SOAP_FMAC4 soap_in_PointerTott__BehaviourExtension(struct soap *soap, const char *tag, struct tt__BehaviourExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BehaviourExtension **)soap_malloc(soap, sizeof(struct tt__BehaviourExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BehaviourExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BehaviourExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BehaviourExtension, sizeof(struct tt__BehaviourExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BehaviourExtension(soap, tag ? tag : "tt:BehaviourExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BehaviourExtension ** SOAP_FMAC4 soap_get_PointerTott__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BehaviourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__Behaviour_Idle))
		soap_serialize__tt__Behaviour_Idle(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__Behaviour_Idle(struct soap *soap, const char *tag, int id, struct _tt__Behaviour_Idle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__Behaviour_Idle, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__Behaviour_Idle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__Behaviour_Idle ** SOAP_FMAC4 soap_in_PointerTo_tt__Behaviour_Idle(struct soap *soap, const char *tag, struct _tt__Behaviour_Idle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__Behaviour_Idle **)soap_malloc(soap, sizeof(struct _tt__Behaviour_Idle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__Behaviour_Idle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__Behaviour_Idle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__Behaviour_Idle, sizeof(struct _tt__Behaviour_Idle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__Behaviour_Idle(soap, tag ? tag : "tt:Behaviour-Idle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Behaviour_Idle ** SOAP_FMAC4 soap_get_PointerTo_tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__Behaviour_Idle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__Behaviour_Removed))
		soap_serialize__tt__Behaviour_Removed(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__Behaviour_Removed(struct soap *soap, const char *tag, int id, struct _tt__Behaviour_Removed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__Behaviour_Removed, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__Behaviour_Removed(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__Behaviour_Removed ** SOAP_FMAC4 soap_in_PointerTo_tt__Behaviour_Removed(struct soap *soap, const char *tag, struct _tt__Behaviour_Removed **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__Behaviour_Removed **)soap_malloc(soap, sizeof(struct _tt__Behaviour_Removed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__Behaviour_Removed(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__Behaviour_Removed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__Behaviour_Removed, sizeof(struct _tt__Behaviour_Removed), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__Behaviour_Removed(soap, tag ? tag : "tt:Behaviour-Removed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Behaviour_Removed ** SOAP_FMAC4 soap_get_PointerTo_tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__Behaviour_Removed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectId(struct soap *soap, struct tt__ObjectId *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectId))
		soap_serialize_tt__ObjectId(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectId(struct soap *soap, const char *tag, int id, struct tt__ObjectId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectId, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ObjectId(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ObjectId ** SOAP_FMAC4 soap_in_PointerTott__ObjectId(struct soap *soap, const char *tag, struct tt__ObjectId **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ObjectId **)soap_malloc(soap, sizeof(struct tt__ObjectId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ObjectId(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectId, sizeof(struct tt__ObjectId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectId(struct soap *soap, struct tt__ObjectId *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ObjectId(soap, tag ? tag : "tt:ObjectId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectId ** SOAP_FMAC4 soap_get_PointerTott__ObjectId(struct soap *soap, struct tt__ObjectId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FrameExtension2))
		soap_serialize_tt__FrameExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FrameExtension2(struct soap *soap, const char *tag, int id, struct tt__FrameExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FrameExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FrameExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FrameExtension2 ** SOAP_FMAC4 soap_in_PointerTott__FrameExtension2(struct soap *soap, const char *tag, struct tt__FrameExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FrameExtension2 **)soap_malloc(soap, sizeof(struct tt__FrameExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FrameExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FrameExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FrameExtension2, sizeof(struct tt__FrameExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FrameExtension2(soap, tag ? tag : "tt:FrameExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FrameExtension2 ** SOAP_FMAC4 soap_get_PointerTott__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FrameExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MotionInCells(struct soap *soap, struct tt__MotionInCells *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MotionInCells))
		soap_serialize_tt__MotionInCells(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MotionInCells(struct soap *soap, const char *tag, int id, struct tt__MotionInCells *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MotionInCells, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MotionInCells(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MotionInCells ** SOAP_FMAC4 soap_in_PointerTott__MotionInCells(struct soap *soap, const char *tag, struct tt__MotionInCells **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MotionInCells **)soap_malloc(soap, sizeof(struct tt__MotionInCells *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MotionInCells(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MotionInCells **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MotionInCells, sizeof(struct tt__MotionInCells), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MotionInCells(struct soap *soap, struct tt__MotionInCells *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MotionInCells(soap, tag ? tag : "tt:MotionInCells", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MotionInCells ** SOAP_FMAC4 soap_get_PointerTott__MotionInCells(struct soap *soap, struct tt__MotionInCells **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MotionInCells(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FrameExtension(struct soap *soap, struct tt__FrameExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FrameExtension))
		soap_serialize_tt__FrameExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FrameExtension(struct soap *soap, const char *tag, int id, struct tt__FrameExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FrameExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FrameExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FrameExtension ** SOAP_FMAC4 soap_in_PointerTott__FrameExtension(struct soap *soap, const char *tag, struct tt__FrameExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FrameExtension **)soap_malloc(soap, sizeof(struct tt__FrameExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FrameExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FrameExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FrameExtension, sizeof(struct tt__FrameExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FrameExtension(struct soap *soap, struct tt__FrameExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FrameExtension(soap, tag ? tag : "tt:FrameExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FrameExtension ** SOAP_FMAC4 soap_get_PointerTott__FrameExtension(struct soap *soap, struct tt__FrameExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FrameExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectTree(struct soap *soap, struct tt__ObjectTree *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectTree))
		soap_serialize_tt__ObjectTree(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectTree(struct soap *soap, const char *tag, int id, struct tt__ObjectTree *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectTree, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ObjectTree(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ObjectTree ** SOAP_FMAC4 soap_in_PointerTott__ObjectTree(struct soap *soap, const char *tag, struct tt__ObjectTree **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ObjectTree **)soap_malloc(soap, sizeof(struct tt__ObjectTree *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ObjectTree(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectTree **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectTree, sizeof(struct tt__ObjectTree), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectTree(struct soap *soap, struct tt__ObjectTree *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ObjectTree(soap, tag ? tag : "tt:ObjectTree", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectTree ** SOAP_FMAC4 soap_get_PointerTott__ObjectTree(struct soap *soap, struct tt__ObjectTree **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Object(struct soap *soap, struct tt__Object *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Object))
		soap_serialize_tt__Object(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Object(struct soap *soap, const char *tag, int id, struct tt__Object *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Object, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Object(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Object ** SOAP_FMAC4 soap_in_PointerTott__Object(struct soap *soap, const char *tag, struct tt__Object **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Object **)soap_malloc(soap, sizeof(struct tt__Object *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Object(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Object **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Object, sizeof(struct tt__Object), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Object(struct soap *soap, struct tt__Object *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Object(soap, tag ? tag : "tt:Object", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Object ** SOAP_FMAC4 soap_get_PointerTott__Object(struct soap *soap, struct tt__Object **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStatus(struct soap *soap, struct tt__PTZStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStatus))
		soap_serialize_tt__PTZStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStatus(struct soap *soap, const char *tag, int id, struct tt__PTZStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZStatus(struct soap *soap, const char *tag, struct tt__PTZStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZStatus **)soap_malloc(soap, sizeof(struct tt__PTZStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatus, sizeof(struct tt__PTZStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStatus(struct soap *soap, struct tt__PTZStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZStatus(soap, tag ? tag : "tt:PTZStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZStatus(struct soap *soap, struct tt__PTZStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ClassDescriptorExtension2))
		soap_serialize_tt__ClassDescriptorExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ClassDescriptorExtension2(struct soap *soap, const char *tag, int id, struct tt__ClassDescriptorExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ClassDescriptorExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ClassDescriptorExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension2 ** SOAP_FMAC4 soap_in_PointerTott__ClassDescriptorExtension2(struct soap *soap, const char *tag, struct tt__ClassDescriptorExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ClassDescriptorExtension2 **)soap_malloc(soap, sizeof(struct tt__ClassDescriptorExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ClassDescriptorExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptorExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ClassDescriptorExtension2, sizeof(struct tt__ClassDescriptorExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ClassDescriptorExtension2(soap, tag ? tag : "tt:ClassDescriptorExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension2 ** SOAP_FMAC4 soap_get_PointerTott__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ClassDescriptorExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OtherType(struct soap *soap, struct tt__OtherType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OtherType))
		soap_serialize_tt__OtherType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OtherType(struct soap *soap, const char *tag, int id, struct tt__OtherType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OtherType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OtherType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OtherType ** SOAP_FMAC4 soap_in_PointerTott__OtherType(struct soap *soap, const char *tag, struct tt__OtherType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OtherType **)soap_malloc(soap, sizeof(struct tt__OtherType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OtherType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OtherType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OtherType, sizeof(struct tt__OtherType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OtherType(struct soap *soap, struct tt__OtherType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OtherType(soap, tag ? tag : "tt:OtherType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OtherType ** SOAP_FMAC4 soap_get_PointerTott__OtherType(struct soap *soap, struct tt__OtherType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OtherType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ClassDescriptorExtension))
		soap_serialize_tt__ClassDescriptorExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ClassDescriptorExtension(struct soap *soap, const char *tag, int id, struct tt__ClassDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ClassDescriptorExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ClassDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__ClassDescriptorExtension(struct soap *soap, const char *tag, struct tt__ClassDescriptorExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ClassDescriptorExtension **)soap_malloc(soap, sizeof(struct tt__ClassDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ClassDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ClassDescriptorExtension, sizeof(struct tt__ClassDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ClassDescriptorExtension(soap, tag ? tag : "tt:ClassDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate))
		soap_serialize__tt__ClassDescriptor_ClassCandidate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, int id, struct _tt__ClassDescriptor_ClassCandidate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ClassDescriptor_ClassCandidate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate ** SOAP_FMAC4 soap_in_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, struct _tt__ClassDescriptor_ClassCandidate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ClassDescriptor_ClassCandidate **)soap_malloc(soap, sizeof(struct _tt__ClassDescriptor_ClassCandidate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ClassDescriptor_ClassCandidate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ClassDescriptor_ClassCandidate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, sizeof(struct _tt__ClassDescriptor_ClassCandidate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ClassDescriptor_ClassCandidate(soap, tag ? tag : "tt:ClassDescriptor-ClassCandidate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate ** SOAP_FMAC4 soap_get_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ClassDescriptor_ClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ShapeDescriptorExtension))
		soap_serialize_tt__ShapeDescriptorExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ShapeDescriptorExtension(struct soap *soap, const char *tag, int id, struct tt__ShapeDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ShapeDescriptorExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ShapeDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__ShapeDescriptorExtension(struct soap *soap, const char *tag, struct tt__ShapeDescriptorExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ShapeDescriptorExtension **)soap_malloc(soap, sizeof(struct tt__ShapeDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ShapeDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ShapeDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ShapeDescriptorExtension, sizeof(struct tt__ShapeDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ShapeDescriptorExtension(soap, tag ? tag : "tt:ShapeDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ShapeDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Polygon(struct soap *soap, struct tt__Polygon *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Polygon))
		soap_serialize_tt__Polygon(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Polygon(struct soap *soap, const char *tag, int id, struct tt__Polygon *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Polygon, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Polygon(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Polygon ** SOAP_FMAC4 soap_in_PointerTott__Polygon(struct soap *soap, const char *tag, struct tt__Polygon **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Polygon **)soap_malloc(soap, sizeof(struct tt__Polygon *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Polygon(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Polygon **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Polygon, sizeof(struct tt__Polygon), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Polygon(struct soap *soap, struct tt__Polygon *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Polygon(soap, tag ? tag : "tt:Polygon", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Polygon ** SOAP_FMAC4 soap_get_PointerTott__Polygon(struct soap *soap, struct tt__Polygon **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StringLikelihood(struct soap *soap, struct tt__StringLikelihood *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StringLikelihood))
		soap_serialize_tt__StringLikelihood(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StringLikelihood(struct soap *soap, const char *tag, int id, struct tt__StringLikelihood *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StringLikelihood, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StringLikelihood(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__StringLikelihood ** SOAP_FMAC4 soap_in_PointerTott__StringLikelihood(struct soap *soap, const char *tag, struct tt__StringLikelihood **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__StringLikelihood **)soap_malloc(soap, sizeof(struct tt__StringLikelihood *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StringLikelihood(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__StringLikelihood **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StringLikelihood, sizeof(struct tt__StringLikelihood), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StringLikelihood(struct soap *soap, struct tt__StringLikelihood *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StringLikelihood(soap, tag ? tag : "tt:StringLikelihood", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StringLikelihood ** SOAP_FMAC4 soap_get_PointerTott__StringLikelihood(struct soap *soap, struct tt__StringLikelihood **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StringLikelihood(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HumanBody(struct soap *soap, struct ns2__HumanBody *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HumanBody))
		soap_serialize_ns2__HumanBody(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HumanBody(struct soap *soap, const char *tag, int id, struct ns2__HumanBody *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HumanBody, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__HumanBody(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__HumanBody ** SOAP_FMAC4 soap_in_PointerTons2__HumanBody(struct soap *soap, const char *tag, struct ns2__HumanBody **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__HumanBody **)soap_malloc(soap, sizeof(struct ns2__HumanBody *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__HumanBody(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__HumanBody **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HumanBody, sizeof(struct ns2__HumanBody), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HumanBody(struct soap *soap, struct ns2__HumanBody *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__HumanBody(soap, tag ? tag : "ns2:HumanBody", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__HumanBody ** SOAP_FMAC4 soap_get_PointerTons2__HumanBody(struct soap *soap, struct ns2__HumanBody **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HumanBody(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HumanFace(struct soap *soap, struct ns1__HumanFace *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HumanFace))
		soap_serialize_ns1__HumanFace(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HumanFace(struct soap *soap, const char *tag, int id, struct ns1__HumanFace *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HumanFace, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__HumanFace(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__HumanFace ** SOAP_FMAC4 soap_in_PointerTons1__HumanFace(struct soap *soap, const char *tag, struct ns1__HumanFace **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__HumanFace **)soap_malloc(soap, sizeof(struct ns1__HumanFace *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__HumanFace(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__HumanFace **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HumanFace, sizeof(struct ns1__HumanFace), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HumanFace(struct soap *soap, struct ns1__HumanFace *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__HumanFace(soap, tag ? tag : "ns1:HumanFace", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__HumanFace ** SOAP_FMAC4 soap_get_PointerTons1__HumanFace(struct soap *soap, struct ns1__HumanFace **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HumanFace(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LicensePlateInfo(struct soap *soap, struct tt__LicensePlateInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LicensePlateInfo))
		soap_serialize_tt__LicensePlateInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LicensePlateInfo(struct soap *soap, const char *tag, int id, struct tt__LicensePlateInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LicensePlateInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LicensePlateInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LicensePlateInfo ** SOAP_FMAC4 soap_in_PointerTott__LicensePlateInfo(struct soap *soap, const char *tag, struct tt__LicensePlateInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LicensePlateInfo **)soap_malloc(soap, sizeof(struct tt__LicensePlateInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LicensePlateInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LicensePlateInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LicensePlateInfo, sizeof(struct tt__LicensePlateInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LicensePlateInfo(struct soap *soap, struct tt__LicensePlateInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LicensePlateInfo(soap, tag ? tag : "tt:LicensePlateInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LicensePlateInfo ** SOAP_FMAC4 soap_get_PointerTott__LicensePlateInfo(struct soap *soap, struct tt__LicensePlateInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LicensePlateInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VehicleInfo(struct soap *soap, struct tt__VehicleInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VehicleInfo))
		soap_serialize_tt__VehicleInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VehicleInfo(struct soap *soap, const char *tag, int id, struct tt__VehicleInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VehicleInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VehicleInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VehicleInfo ** SOAP_FMAC4 soap_in_PointerTott__VehicleInfo(struct soap *soap, const char *tag, struct tt__VehicleInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VehicleInfo **)soap_malloc(soap, sizeof(struct tt__VehicleInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VehicleInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VehicleInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VehicleInfo, sizeof(struct tt__VehicleInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VehicleInfo(struct soap *soap, struct tt__VehicleInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VehicleInfo(soap, tag ? tag : "tt:VehicleInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VehicleInfo ** SOAP_FMAC4 soap_get_PointerTott__VehicleInfo(struct soap *soap, struct tt__VehicleInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VehicleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AppearanceExtension))
		soap_serialize_tt__AppearanceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AppearanceExtension(struct soap *soap, const char *tag, int id, struct tt__AppearanceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AppearanceExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AppearanceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AppearanceExtension ** SOAP_FMAC4 soap_in_PointerTott__AppearanceExtension(struct soap *soap, const char *tag, struct tt__AppearanceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AppearanceExtension **)soap_malloc(soap, sizeof(struct tt__AppearanceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AppearanceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AppearanceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AppearanceExtension, sizeof(struct tt__AppearanceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AppearanceExtension(soap, tag ? tag : "tt:AppearanceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AppearanceExtension ** SOAP_FMAC4 soap_get_PointerTott__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AppearanceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ClassDescriptor))
		soap_serialize_tt__ClassDescriptor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ClassDescriptor(struct soap *soap, const char *tag, int id, struct tt__ClassDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ClassDescriptor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ClassDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ClassDescriptor ** SOAP_FMAC4 soap_in_PointerTott__ClassDescriptor(struct soap *soap, const char *tag, struct tt__ClassDescriptor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ClassDescriptor **)soap_malloc(soap, sizeof(struct tt__ClassDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ClassDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ClassDescriptor, sizeof(struct tt__ClassDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ClassDescriptor(soap, tag ? tag : "tt:ClassDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptor ** SOAP_FMAC4 soap_get_PointerTott__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorDescriptor))
		soap_serialize_tt__ColorDescriptor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorDescriptor(struct soap *soap, const char *tag, int id, struct tt__ColorDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorDescriptor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorDescriptor ** SOAP_FMAC4 soap_in_PointerTott__ColorDescriptor(struct soap *soap, const char *tag, struct tt__ColorDescriptor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorDescriptor **)soap_malloc(soap, sizeof(struct tt__ColorDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorDescriptor, sizeof(struct tt__ColorDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorDescriptor(soap, tag ? tag : "tt:ColorDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorDescriptor ** SOAP_FMAC4 soap_get_PointerTott__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ShapeDescriptor))
		soap_serialize_tt__ShapeDescriptor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ShapeDescriptor(struct soap *soap, const char *tag, int id, struct tt__ShapeDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ShapeDescriptor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ShapeDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ShapeDescriptor ** SOAP_FMAC4 soap_in_PointerTott__ShapeDescriptor(struct soap *soap, const char *tag, struct tt__ShapeDescriptor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ShapeDescriptor **)soap_malloc(soap, sizeof(struct tt__ShapeDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ShapeDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ShapeDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ShapeDescriptor, sizeof(struct tt__ShapeDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ShapeDescriptor(soap, tag ? tag : "tt:ShapeDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ShapeDescriptor ** SOAP_FMAC4 soap_get_PointerTott__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ShapeDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocalOrientation(struct soap *soap, struct tt__LocalOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocalOrientation))
		soap_serialize_tt__LocalOrientation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocalOrientation(struct soap *soap, const char *tag, int id, struct tt__LocalOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocalOrientation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LocalOrientation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LocalOrientation ** SOAP_FMAC4 soap_in_PointerTott__LocalOrientation(struct soap *soap, const char *tag, struct tt__LocalOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LocalOrientation **)soap_malloc(soap, sizeof(struct tt__LocalOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LocalOrientation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LocalOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocalOrientation, sizeof(struct tt__LocalOrientation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocalOrientation(struct soap *soap, struct tt__LocalOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocalOrientation(soap, tag ? tag : "tt:LocalOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LocalOrientation ** SOAP_FMAC4 soap_get_PointerTott__LocalOrientation(struct soap *soap, struct tt__LocalOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocalOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocalLocation(struct soap *soap, struct tt__LocalLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocalLocation))
		soap_serialize_tt__LocalLocation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocalLocation(struct soap *soap, const char *tag, int id, struct tt__LocalLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocalLocation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LocalLocation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LocalLocation ** SOAP_FMAC4 soap_in_PointerTott__LocalLocation(struct soap *soap, const char *tag, struct tt__LocalLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LocalLocation **)soap_malloc(soap, sizeof(struct tt__LocalLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LocalLocation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LocalLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocalLocation, sizeof(struct tt__LocalLocation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocalLocation(struct soap *soap, struct tt__LocalLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocalLocation(soap, tag ? tag : "tt:LocalLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LocalLocation ** SOAP_FMAC4 soap_get_PointerTott__LocalLocation(struct soap *soap, struct tt__LocalLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocalLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GeoOrientation(struct soap *soap, struct tt__GeoOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GeoOrientation))
		soap_serialize_tt__GeoOrientation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GeoOrientation(struct soap *soap, const char *tag, int id, struct tt__GeoOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GeoOrientation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GeoOrientation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GeoOrientation ** SOAP_FMAC4 soap_in_PointerTott__GeoOrientation(struct soap *soap, const char *tag, struct tt__GeoOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GeoOrientation **)soap_malloc(soap, sizeof(struct tt__GeoOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GeoOrientation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GeoOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoOrientation, sizeof(struct tt__GeoOrientation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GeoOrientation(struct soap *soap, struct tt__GeoOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GeoOrientation(soap, tag ? tag : "tt:GeoOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GeoOrientation ** SOAP_FMAC4 soap_get_PointerTott__GeoOrientation(struct soap *soap, struct tt__GeoOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GeoOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GeoLocation(struct soap *soap, struct tt__GeoLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GeoLocation))
		soap_serialize_tt__GeoLocation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GeoLocation(struct soap *soap, const char *tag, int id, struct tt__GeoLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GeoLocation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GeoLocation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GeoLocation ** SOAP_FMAC4 soap_in_PointerTott__GeoLocation(struct soap *soap, const char *tag, struct tt__GeoLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GeoLocation **)soap_malloc(soap, sizeof(struct tt__GeoLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GeoLocation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoLocation, sizeof(struct tt__GeoLocation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GeoLocation(struct soap *soap, struct tt__GeoLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GeoLocation(soap, tag ? tag : "tt:GeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GeoLocation ** SOAP_FMAC4 soap_get_PointerTott__GeoLocation(struct soap *soap, struct tt__GeoLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodouble(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TransformationExtension))
		soap_serialize_tt__TransformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TransformationExtension(struct soap *soap, const char *tag, int id, struct tt__TransformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TransformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TransformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TransformationExtension ** SOAP_FMAC4 soap_in_PointerTott__TransformationExtension(struct soap *soap, const char *tag, struct tt__TransformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TransformationExtension **)soap_malloc(soap, sizeof(struct tt__TransformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TransformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TransformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TransformationExtension, sizeof(struct tt__TransformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TransformationExtension(soap, tag ? tag : "tt:TransformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TransformationExtension ** SOAP_FMAC4 soap_get_PointerTott__TransformationExtension(struct soap *soap, struct tt__TransformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster))
		soap_serialize__tt__ColorDescriptor_ColorCluster(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, int id, struct _tt__ColorDescriptor_ColorCluster *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ColorDescriptor_ColorCluster(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster ** SOAP_FMAC4 soap_in_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, struct _tt__ColorDescriptor_ColorCluster **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ColorDescriptor_ColorCluster **)soap_malloc(soap, sizeof(struct _tt__ColorDescriptor_ColorCluster *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ColorDescriptor_ColorCluster(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ColorDescriptor_ColorCluster **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, sizeof(struct _tt__ColorDescriptor_ColorCluster), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ColorDescriptor_ColorCluster(soap, tag ? tag : "tt:ColorDescriptor-ColorCluster", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster ** SOAP_FMAC4 soap_get_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ColorDescriptor_ColorCluster(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorCovariance))
		soap_serialize_tt__ColorCovariance(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorCovariance(struct soap *soap, const char *tag, int id, struct tt__ColorCovariance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorCovariance, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorCovariance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorCovariance ** SOAP_FMAC4 soap_in_PointerTott__ColorCovariance(struct soap *soap, const char *tag, struct tt__ColorCovariance **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorCovariance **)soap_malloc(soap, sizeof(struct tt__ColorCovariance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorCovariance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorCovariance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorCovariance, sizeof(struct tt__ColorCovariance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorCovariance(soap, tag ? tag : "tt:ColorCovariance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorCovariance ** SOAP_FMAC4 soap_get_PointerTott__ColorCovariance(struct soap *soap, struct tt__ColorCovariance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorCovariance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__MoveStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveStatus(struct soap *soap, const char *tag, int id, enum tt__MoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MoveStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MoveStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__MoveStatus ** SOAP_FMAC4 soap_in_PointerTott__MoveStatus(struct soap *soap, const char *tag, enum tt__MoveStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__MoveStatus **)soap_malloc(soap, sizeof(enum tt__MoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MoveStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__MoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MoveStatus(soap, tag ? tag : "tt:MoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MoveStatus ** SOAP_FMAC4 soap_get_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZMoveStatus))
		soap_serialize_tt__PTZMoveStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZMoveStatus(struct soap *soap, const char *tag, int id, struct tt__PTZMoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZMoveStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZMoveStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZMoveStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZMoveStatus(struct soap *soap, const char *tag, struct tt__PTZMoveStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZMoveStatus **)soap_malloc(soap, sizeof(struct tt__PTZMoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZMoveStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZMoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZMoveStatus(soap, tag ? tag : "tt:PTZMoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZMoveStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
