/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:05 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetZeroConfiguration(struct soap *soap, struct __tds__GetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetZeroConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetZeroConfiguration(struct soap *soap, const struct __tds__GetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetZeroConfiguration(soap, &a->tds__GetZeroConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetZeroConfiguration(soap, "tds:GetZeroConfiguration", -1, &a->tds__GetZeroConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetZeroConfiguration * SOAP_FMAC4 soap_in___tds__GetZeroConfiguration(struct soap *soap, const char *tag, struct __tds__GetZeroConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetZeroConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetZeroConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetZeroConfiguration, sizeof(struct __tds__GetZeroConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetZeroConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetZeroConfiguration(soap, "tds:GetZeroConfiguration", &a->tds__GetZeroConfiguration, ""))
				{	soap_flag_tds__GetZeroConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetZeroConfiguration * SOAP_FMAC4 soap_new___tds__GetZeroConfiguration(struct soap *soap, int n)
{
	struct __tds__GetZeroConfiguration *p;
	struct __tds__GetZeroConfiguration *a = (struct __tds__GetZeroConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetZeroConfiguration));
	for (p = a; p && n--; p++)
		soap_default___tds__GetZeroConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetZeroConfiguration(struct soap *soap, const struct __tds__GetZeroConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetZeroConfiguration(soap, tag ? tag : "-tds:GetZeroConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetZeroConfiguration * SOAP_FMAC4 soap_get___tds__GetZeroConfiguration(struct soap *soap, struct __tds__GetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkDefaultGateway(struct soap *soap, struct __tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkDefaultGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkDefaultGateway(struct soap *soap, const struct __tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetNetworkDefaultGateway(soap, &a->tds__SetNetworkDefaultGateway);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetNetworkDefaultGateway(soap, "tds:SetNetworkDefaultGateway", -1, &a->tds__SetNetworkDefaultGateway, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in___tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, struct __tds__SetNetworkDefaultGateway *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkDefaultGateway = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetNetworkDefaultGateway*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkDefaultGateway, sizeof(struct __tds__SetNetworkDefaultGateway), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkDefaultGateway(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetNetworkDefaultGateway(soap, "tds:SetNetworkDefaultGateway", &a->tds__SetNetworkDefaultGateway, ""))
				{	soap_flag_tds__SetNetworkDefaultGateway--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_new___tds__SetNetworkDefaultGateway(struct soap *soap, int n)
{
	struct __tds__SetNetworkDefaultGateway *p;
	struct __tds__SetNetworkDefaultGateway *a = (struct __tds__SetNetworkDefaultGateway*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetNetworkDefaultGateway));
	for (p = a; p && n--; p++)
		soap_default___tds__SetNetworkDefaultGateway(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkDefaultGateway(struct soap *soap, const struct __tds__SetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetNetworkDefaultGateway(soap, tag ? tag : "-tds:SetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get___tds__SetNetworkDefaultGateway(struct soap *soap, struct __tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkDefaultGateway(struct soap *soap, struct __tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkDefaultGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkDefaultGateway(struct soap *soap, const struct __tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetNetworkDefaultGateway(soap, &a->tds__GetNetworkDefaultGateway);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetNetworkDefaultGateway(soap, "tds:GetNetworkDefaultGateway", -1, &a->tds__GetNetworkDefaultGateway, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in___tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, struct __tds__GetNetworkDefaultGateway *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkDefaultGateway = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetNetworkDefaultGateway*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkDefaultGateway, sizeof(struct __tds__GetNetworkDefaultGateway), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNetworkDefaultGateway(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetNetworkDefaultGateway(soap, "tds:GetNetworkDefaultGateway", &a->tds__GetNetworkDefaultGateway, ""))
				{	soap_flag_tds__GetNetworkDefaultGateway--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_new___tds__GetNetworkDefaultGateway(struct soap *soap, int n)
{
	struct __tds__GetNetworkDefaultGateway *p;
	struct __tds__GetNetworkDefaultGateway *a = (struct __tds__GetNetworkDefaultGateway*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetNetworkDefaultGateway));
	for (p = a; p && n--; p++)
		soap_default___tds__GetNetworkDefaultGateway(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkDefaultGateway(struct soap *soap, const struct __tds__GetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetNetworkDefaultGateway(soap, tag ? tag : "-tds:GetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get___tds__GetNetworkDefaultGateway(struct soap *soap, struct __tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkProtocols(struct soap *soap, struct __tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkProtocols(struct soap *soap, const struct __tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetNetworkProtocols(soap, &a->tds__SetNetworkProtocols);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetNetworkProtocols(soap, "tds:SetNetworkProtocols", -1, &a->tds__SetNetworkProtocols, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkProtocols * SOAP_FMAC4 soap_in___tds__SetNetworkProtocols(struct soap *soap, const char *tag, struct __tds__SetNetworkProtocols *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkProtocols = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetNetworkProtocols*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkProtocols, sizeof(struct __tds__SetNetworkProtocols), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkProtocols(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetNetworkProtocols(soap, "tds:SetNetworkProtocols", &a->tds__SetNetworkProtocols, ""))
				{	soap_flag_tds__SetNetworkProtocols--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetNetworkProtocols * SOAP_FMAC4 soap_new___tds__SetNetworkProtocols(struct soap *soap, int n)
{
	struct __tds__SetNetworkProtocols *p;
	struct __tds__SetNetworkProtocols *a = (struct __tds__SetNetworkProtocols*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetNetworkProtocols));
	for (p = a; p && n--; p++)
		soap_default___tds__SetNetworkProtocols(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkProtocols(struct soap *soap, const struct __tds__SetNetworkProtocols *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetNetworkProtocols(soap, tag ? tag : "-tds:SetNetworkProtocols", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkProtocols * SOAP_FMAC4 soap_get___tds__SetNetworkProtocols(struct soap *soap, struct __tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkProtocols(struct soap *soap, struct __tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkProtocols(struct soap *soap, const struct __tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetNetworkProtocols(soap, &a->tds__GetNetworkProtocols);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetNetworkProtocols(soap, "tds:GetNetworkProtocols", -1, &a->tds__GetNetworkProtocols, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkProtocols * SOAP_FMAC4 soap_in___tds__GetNetworkProtocols(struct soap *soap, const char *tag, struct __tds__GetNetworkProtocols *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkProtocols = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetNetworkProtocols*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkProtocols, sizeof(struct __tds__GetNetworkProtocols), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNetworkProtocols(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetNetworkProtocols(soap, "tds:GetNetworkProtocols", &a->tds__GetNetworkProtocols, ""))
				{	soap_flag_tds__GetNetworkProtocols--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetNetworkProtocols * SOAP_FMAC4 soap_new___tds__GetNetworkProtocols(struct soap *soap, int n)
{
	struct __tds__GetNetworkProtocols *p;
	struct __tds__GetNetworkProtocols *a = (struct __tds__GetNetworkProtocols*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetNetworkProtocols));
	for (p = a; p && n--; p++)
		soap_default___tds__GetNetworkProtocols(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkProtocols(struct soap *soap, const struct __tds__GetNetworkProtocols *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetNetworkProtocols(soap, tag ? tag : "-tds:GetNetworkProtocols", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkProtocols * SOAP_FMAC4 soap_get___tds__GetNetworkProtocols(struct soap *soap, struct __tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkInterfaces(struct soap *soap, struct __tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkInterfaces(struct soap *soap, const struct __tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetNetworkInterfaces(soap, &a->tds__SetNetworkInterfaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetNetworkInterfaces(soap, "tds:SetNetworkInterfaces", -1, &a->tds__SetNetworkInterfaces, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in___tds__SetNetworkInterfaces(struct soap *soap, const char *tag, struct __tds__SetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkInterfaces = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetNetworkInterfaces*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkInterfaces, sizeof(struct __tds__SetNetworkInterfaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkInterfaces(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetNetworkInterfaces(soap, "tds:SetNetworkInterfaces", &a->tds__SetNetworkInterfaces, ""))
				{	soap_flag_tds__SetNetworkInterfaces--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetNetworkInterfaces * SOAP_FMAC4 soap_new___tds__SetNetworkInterfaces(struct soap *soap, int n)
{
	struct __tds__SetNetworkInterfaces *p;
	struct __tds__SetNetworkInterfaces *a = (struct __tds__SetNetworkInterfaces*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetNetworkInterfaces));
	for (p = a; p && n--; p++)
		soap_default___tds__SetNetworkInterfaces(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkInterfaces(struct soap *soap, const struct __tds__SetNetworkInterfaces *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetNetworkInterfaces(soap, tag ? tag : "-tds:SetNetworkInterfaces", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get___tds__SetNetworkInterfaces(struct soap *soap, struct __tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkInterfaces(struct soap *soap, struct __tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkInterfaces(struct soap *soap, const struct __tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetNetworkInterfaces(soap, &a->tds__GetNetworkInterfaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetNetworkInterfaces(soap, "tds:GetNetworkInterfaces", -1, &a->tds__GetNetworkInterfaces, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in___tds__GetNetworkInterfaces(struct soap *soap, const char *tag, struct __tds__GetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkInterfaces = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetNetworkInterfaces*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkInterfaces, sizeof(struct __tds__GetNetworkInterfaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNetworkInterfaces(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetNetworkInterfaces(soap, "tds:GetNetworkInterfaces", &a->tds__GetNetworkInterfaces, ""))
				{	soap_flag_tds__GetNetworkInterfaces--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetNetworkInterfaces * SOAP_FMAC4 soap_new___tds__GetNetworkInterfaces(struct soap *soap, int n)
{
	struct __tds__GetNetworkInterfaces *p;
	struct __tds__GetNetworkInterfaces *a = (struct __tds__GetNetworkInterfaces*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetNetworkInterfaces));
	for (p = a; p && n--; p++)
		soap_default___tds__GetNetworkInterfaces(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkInterfaces(struct soap *soap, const struct __tds__GetNetworkInterfaces *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetNetworkInterfaces(soap, tag ? tag : "-tds:GetNetworkInterfaces", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get___tds__GetNetworkInterfaces(struct soap *soap, struct __tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDynamicDNS(struct soap *soap, struct __tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDynamicDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDynamicDNS(struct soap *soap, const struct __tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDynamicDNS(soap, &a->tds__SetDynamicDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const struct __tds__SetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDynamicDNS(soap, "tds:SetDynamicDNS", -1, &a->tds__SetDynamicDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDynamicDNS * SOAP_FMAC4 soap_in___tds__SetDynamicDNS(struct soap *soap, const char *tag, struct __tds__SetDynamicDNS *a, const char *type)
{
	size_t soap_flag_tds__SetDynamicDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDynamicDNS*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDynamicDNS, sizeof(struct __tds__SetDynamicDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDynamicDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDynamicDNS(soap, "tds:SetDynamicDNS", &a->tds__SetDynamicDNS, ""))
				{	soap_flag_tds__SetDynamicDNS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetDynamicDNS * SOAP_FMAC4 soap_new___tds__SetDynamicDNS(struct soap *soap, int n)
{
	struct __tds__SetDynamicDNS *p;
	struct __tds__SetDynamicDNS *a = (struct __tds__SetDynamicDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetDynamicDNS));
	for (p = a; p && n--; p++)
		soap_default___tds__SetDynamicDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDynamicDNS(struct soap *soap, const struct __tds__SetDynamicDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDynamicDNS(soap, tag ? tag : "-tds:SetDynamicDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDynamicDNS * SOAP_FMAC4 soap_get___tds__SetDynamicDNS(struct soap *soap, struct __tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDynamicDNS(struct soap *soap, struct __tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDynamicDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDynamicDNS(struct soap *soap, const struct __tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDynamicDNS(soap, &a->tds__GetDynamicDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const struct __tds__GetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDynamicDNS(soap, "tds:GetDynamicDNS", -1, &a->tds__GetDynamicDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDynamicDNS * SOAP_FMAC4 soap_in___tds__GetDynamicDNS(struct soap *soap, const char *tag, struct __tds__GetDynamicDNS *a, const char *type)
{
	size_t soap_flag_tds__GetDynamicDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDynamicDNS*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDynamicDNS, sizeof(struct __tds__GetDynamicDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDynamicDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDynamicDNS(soap, "tds:GetDynamicDNS", &a->tds__GetDynamicDNS, ""))
				{	soap_flag_tds__GetDynamicDNS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetDynamicDNS * SOAP_FMAC4 soap_new___tds__GetDynamicDNS(struct soap *soap, int n)
{
	struct __tds__GetDynamicDNS *p;
	struct __tds__GetDynamicDNS *a = (struct __tds__GetDynamicDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetDynamicDNS));
	for (p = a; p && n--; p++)
		soap_default___tds__GetDynamicDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDynamicDNS(struct soap *soap, const struct __tds__GetDynamicDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDynamicDNS(soap, tag ? tag : "-tds:GetDynamicDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDynamicDNS * SOAP_FMAC4 soap_get___tds__GetDynamicDNS(struct soap *soap, struct __tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNTP(struct soap *soap, struct __tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNTP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNTP(struct soap *soap, const struct __tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetNTP(soap, &a->tds__SetNTP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNTP(struct soap *soap, const char *tag, int id, const struct __tds__SetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetNTP(soap, "tds:SetNTP", -1, &a->tds__SetNTP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNTP * SOAP_FMAC4 soap_in___tds__SetNTP(struct soap *soap, const char *tag, struct __tds__SetNTP *a, const char *type)
{
	size_t soap_flag_tds__SetNTP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetNTP*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNTP, sizeof(struct __tds__SetNTP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNTP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNTP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetNTP(soap, "tds:SetNTP", &a->tds__SetNTP, ""))
				{	soap_flag_tds__SetNTP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetNTP * SOAP_FMAC4 soap_new___tds__SetNTP(struct soap *soap, int n)
{
	struct __tds__SetNTP *p;
	struct __tds__SetNTP *a = (struct __tds__SetNTP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetNTP));
	for (p = a; p && n--; p++)
		soap_default___tds__SetNTP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNTP(struct soap *soap, const struct __tds__SetNTP *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetNTP(soap, tag ? tag : "-tds:SetNTP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNTP * SOAP_FMAC4 soap_get___tds__SetNTP(struct soap *soap, struct __tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNTP(struct soap *soap, struct __tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNTP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNTP(struct soap *soap, const struct __tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetNTP(soap, &a->tds__GetNTP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNTP(struct soap *soap, const char *tag, int id, const struct __tds__GetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetNTP(soap, "tds:GetNTP", -1, &a->tds__GetNTP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNTP * SOAP_FMAC4 soap_in___tds__GetNTP(struct soap *soap, const char *tag, struct __tds__GetNTP *a, const char *type)
{
	size_t soap_flag_tds__GetNTP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetNTP*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNTP, sizeof(struct __tds__GetNTP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNTP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNTP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetNTP(soap, "tds:GetNTP", &a->tds__GetNTP, ""))
				{	soap_flag_tds__GetNTP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetNTP * SOAP_FMAC4 soap_new___tds__GetNTP(struct soap *soap, int n)
{
	struct __tds__GetNTP *p;
	struct __tds__GetNTP *a = (struct __tds__GetNTP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetNTP));
	for (p = a; p && n--; p++)
		soap_default___tds__GetNTP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNTP(struct soap *soap, const struct __tds__GetNTP *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetNTP(soap, tag ? tag : "-tds:GetNTP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNTP * SOAP_FMAC4 soap_get___tds__GetNTP(struct soap *soap, struct __tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDNS(struct soap *soap, struct __tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDNS(struct soap *soap, const struct __tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDNS(soap, &a->tds__SetDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDNS(struct soap *soap, const char *tag, int id, const struct __tds__SetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDNS(soap, "tds:SetDNS", -1, &a->tds__SetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDNS * SOAP_FMAC4 soap_in___tds__SetDNS(struct soap *soap, const char *tag, struct __tds__SetDNS *a, const char *type)
{
	size_t soap_flag_tds__SetDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDNS*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDNS, sizeof(struct __tds__SetDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDNS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDNS(soap, "tds:SetDNS", &a->tds__SetDNS, ""))
				{	soap_flag_tds__SetDNS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetDNS * SOAP_FMAC4 soap_new___tds__SetDNS(struct soap *soap, int n)
{
	struct __tds__SetDNS *p;
	struct __tds__SetDNS *a = (struct __tds__SetDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetDNS));
	for (p = a; p && n--; p++)
		soap_default___tds__SetDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDNS(struct soap *soap, const struct __tds__SetDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDNS(soap, tag ? tag : "-tds:SetDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDNS * SOAP_FMAC4 soap_get___tds__SetDNS(struct soap *soap, struct __tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDNS(struct soap *soap, const struct __tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDNS(soap, &a->tds__GetDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDNS(struct soap *soap, const char *tag, int id, const struct __tds__GetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDNS(soap, "tds:GetDNS", -1, &a->tds__GetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_in___tds__GetDNS(struct soap *soap, const char *tag, struct __tds__GetDNS *a, const char *type)
{
	size_t soap_flag_tds__GetDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDNS*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDNS, sizeof(struct __tds__GetDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDNS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDNS(soap, "tds:GetDNS", &a->tds__GetDNS, ""))
				{	soap_flag_tds__GetDNS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_new___tds__GetDNS(struct soap *soap, int n)
{
	struct __tds__GetDNS *p;
	struct __tds__GetDNS *a = (struct __tds__GetDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetDNS));
	for (p = a; p && n--; p++)
		soap_default___tds__GetDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDNS(struct soap *soap, const struct __tds__GetDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDNS(soap, tag ? tag : "-tds:GetDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_get___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHostnameFromDHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHostnameFromDHCP(struct soap *soap, const struct __tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetHostnameFromDHCP(soap, &a->tds__SetHostnameFromDHCP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const struct __tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, "tds:SetHostnameFromDHCP", -1, &a->tds__SetHostnameFromDHCP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in___tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct __tds__SetHostnameFromDHCP *a, const char *type)
{
	size_t soap_flag_tds__SetHostnameFromDHCP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetHostnameFromDHCP*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHostnameFromDHCP, sizeof(struct __tds__SetHostnameFromDHCP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetHostnameFromDHCP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetHostnameFromDHCP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, "tds:SetHostnameFromDHCP", &a->tds__SetHostnameFromDHCP, ""))
				{	soap_flag_tds__SetHostnameFromDHCP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_new___tds__SetHostnameFromDHCP(struct soap *soap, int n)
{
	struct __tds__SetHostnameFromDHCP *p;
	struct __tds__SetHostnameFromDHCP *a = (struct __tds__SetHostnameFromDHCP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetHostnameFromDHCP));
	for (p = a; p && n--; p++)
		soap_default___tds__SetHostnameFromDHCP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHostnameFromDHCP(struct soap *soap, const struct __tds__SetHostnameFromDHCP *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetHostnameFromDHCP(soap, tag ? tag : "-tds:SetHostnameFromDHCP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHostname = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHostname(struct soap *soap, const struct __tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetHostname(soap, &a->tds__SetHostname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHostname(struct soap *soap, const char *tag, int id, const struct __tds__SetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetHostname(soap, "tds:SetHostname", -1, &a->tds__SetHostname, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_in___tds__SetHostname(struct soap *soap, const char *tag, struct __tds__SetHostname *a, const char *type)
{
	size_t soap_flag_tds__SetHostname = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetHostname*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHostname, sizeof(struct __tds__SetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetHostname(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetHostname && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetHostname(soap, "tds:SetHostname", &a->tds__SetHostname, ""))
				{	soap_flag_tds__SetHostname--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_new___tds__SetHostname(struct soap *soap, int n)
{
	struct __tds__SetHostname *p;
	struct __tds__SetHostname *a = (struct __tds__SetHostname*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetHostname));
	for (p = a; p && n--; p++)
		soap_default___tds__SetHostname(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHostname(struct soap *soap, const struct __tds__SetHostname *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetHostname(soap, tag ? tag : "-tds:SetHostname", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_get___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetHostname = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetHostname(struct soap *soap, const struct __tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetHostname(soap, &a->tds__GetHostname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetHostname(struct soap *soap, const char *tag, int id, const struct __tds__GetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetHostname(soap, "tds:GetHostname", -1, &a->tds__GetHostname, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_in___tds__GetHostname(struct soap *soap, const char *tag, struct __tds__GetHostname *a, const char *type)
{
	size_t soap_flag_tds__GetHostname = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetHostname*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetHostname, sizeof(struct __tds__GetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetHostname(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetHostname && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetHostname(soap, "tds:GetHostname", &a->tds__GetHostname, ""))
				{	soap_flag_tds__GetHostname--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_new___tds__GetHostname(struct soap *soap, int n)
{
	struct __tds__GetHostname *p;
	struct __tds__GetHostname *a = (struct __tds__GetHostname*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetHostname));
	for (p = a; p && n--; p++)
		soap_default___tds__GetHostname(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetHostname(struct soap *soap, const struct __tds__GetHostname *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetHostname(soap, tag ? tag : "-tds:GetHostname", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_get___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDPAddresses(struct soap *soap, struct __tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDPAddresses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDPAddresses(struct soap *soap, const struct __tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDPAddresses(soap, &a->tds__SetDPAddresses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDPAddresses(struct soap *soap, const char *tag, int id, const struct __tds__SetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDPAddresses(soap, "tds:SetDPAddresses", -1, &a->tds__SetDPAddresses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDPAddresses * SOAP_FMAC4 soap_in___tds__SetDPAddresses(struct soap *soap, const char *tag, struct __tds__SetDPAddresses *a, const char *type)
{
	size_t soap_flag_tds__SetDPAddresses = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDPAddresses*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDPAddresses, sizeof(struct __tds__SetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDPAddresses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDPAddresses(soap, "tds:SetDPAddresses", &a->tds__SetDPAddresses, ""))
				{	soap_flag_tds__SetDPAddresses--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetDPAddresses * SOAP_FMAC4 soap_new___tds__SetDPAddresses(struct soap *soap, int n)
{
	struct __tds__SetDPAddresses *p;
	struct __tds__SetDPAddresses *a = (struct __tds__SetDPAddresses*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetDPAddresses));
	for (p = a; p && n--; p++)
		soap_default___tds__SetDPAddresses(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDPAddresses(struct soap *soap, const struct __tds__SetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDPAddresses(soap, tag ? tag : "-tds:SetDPAddresses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDPAddresses * SOAP_FMAC4 soap_get___tds__SetDPAddresses(struct soap *soap, struct __tds__SetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCapabilities(soap, &a->tds__GetCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", -1, &a->tds__GetCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_in___tds__GetCapabilities(struct soap *soap, const char *tag, struct __tds__GetCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCapabilities, sizeof(struct __tds__GetCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", &a->tds__GetCapabilities, ""))
				{	soap_flag_tds__GetCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_new___tds__GetCapabilities(struct soap *soap, int n)
{
	struct __tds__GetCapabilities *p;
	struct __tds__GetCapabilities *a = (struct __tds__GetCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetCapabilities));
	for (p = a; p && n--; p++)
		soap_default___tds__GetCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCapabilities(soap, tag ? tag : "-tds:GetCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_get___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetWsdlUrl(struct soap *soap, struct __tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetWsdlUrl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetWsdlUrl(struct soap *soap, const struct __tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetWsdlUrl(soap, &a->tds__GetWsdlUrl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, const struct __tds__GetWsdlUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetWsdlUrl(soap, "tds:GetWsdlUrl", -1, &a->tds__GetWsdlUrl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetWsdlUrl * SOAP_FMAC4 soap_in___tds__GetWsdlUrl(struct soap *soap, const char *tag, struct __tds__GetWsdlUrl *a, const char *type)
{
	size_t soap_flag_tds__GetWsdlUrl = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetWsdlUrl*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetWsdlUrl, sizeof(struct __tds__GetWsdlUrl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetWsdlUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetWsdlUrl && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetWsdlUrl(soap, "tds:GetWsdlUrl", &a->tds__GetWsdlUrl, ""))
				{	soap_flag_tds__GetWsdlUrl--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetWsdlUrl * SOAP_FMAC4 soap_new___tds__GetWsdlUrl(struct soap *soap, int n)
{
	struct __tds__GetWsdlUrl *p;
	struct __tds__GetWsdlUrl *a = (struct __tds__GetWsdlUrl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetWsdlUrl));
	for (p = a; p && n--; p++)
		soap_default___tds__GetWsdlUrl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetWsdlUrl(struct soap *soap, const struct __tds__GetWsdlUrl *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetWsdlUrl(soap, tag ? tag : "-tds:GetWsdlUrl", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetWsdlUrl * SOAP_FMAC4 soap_get___tds__GetWsdlUrl(struct soap *soap, struct __tds__GetWsdlUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetUser(struct soap *soap, struct __tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetUser(struct soap *soap, const struct __tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetUser(soap, &a->tds__SetUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetUser(struct soap *soap, const char *tag, int id, const struct __tds__SetUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetUser(soap, "tds:SetUser", -1, &a->tds__SetUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_in___tds__SetUser(struct soap *soap, const char *tag, struct __tds__SetUser *a, const char *type)
{
	size_t soap_flag_tds__SetUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetUser*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetUser, sizeof(struct __tds__SetUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetUser(soap, "tds:SetUser", &a->tds__SetUser, ""))
				{	soap_flag_tds__SetUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_new___tds__SetUser(struct soap *soap, int n)
{
	struct __tds__SetUser *p;
	struct __tds__SetUser *a = (struct __tds__SetUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetUser));
	for (p = a; p && n--; p++)
		soap_default___tds__SetUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetUser(struct soap *soap, const struct __tds__SetUser *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetUser(soap, tag ? tag : "-tds:SetUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_get___tds__SetUser(struct soap *soap, struct __tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteUsers(struct soap *soap, const struct __tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__DeleteUsers(soap, &a->tds__DeleteUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteUsers(struct soap *soap, const char *tag, int id, const struct __tds__DeleteUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__DeleteUsers(soap, "tds:DeleteUsers", -1, &a->tds__DeleteUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_in___tds__DeleteUsers(struct soap *soap, const char *tag, struct __tds__DeleteUsers *a, const char *type)
{
	size_t soap_flag_tds__DeleteUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__DeleteUsers*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteUsers, sizeof(struct __tds__DeleteUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteUsers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__DeleteUsers(soap, "tds:DeleteUsers", &a->tds__DeleteUsers, ""))
				{	soap_flag_tds__DeleteUsers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_new___tds__DeleteUsers(struct soap *soap, int n)
{
	struct __tds__DeleteUsers *p;
	struct __tds__DeleteUsers *a = (struct __tds__DeleteUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__DeleteUsers));
	for (p = a; p && n--; p++)
		soap_default___tds__DeleteUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteUsers(struct soap *soap, const struct __tds__DeleteUsers *a, const char *tag, const char *type)
{
	if (soap_out___tds__DeleteUsers(soap, tag ? tag : "-tds:DeleteUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_get___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateUsers(struct soap *soap, const struct __tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__CreateUsers(soap, &a->tds__CreateUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateUsers(struct soap *soap, const char *tag, int id, const struct __tds__CreateUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__CreateUsers(soap, "tds:CreateUsers", -1, &a->tds__CreateUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_in___tds__CreateUsers(struct soap *soap, const char *tag, struct __tds__CreateUsers *a, const char *type)
{
	size_t soap_flag_tds__CreateUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__CreateUsers*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateUsers, sizeof(struct __tds__CreateUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateUsers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__CreateUsers(soap, "tds:CreateUsers", &a->tds__CreateUsers, ""))
				{	soap_flag_tds__CreateUsers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_new___tds__CreateUsers(struct soap *soap, int n)
{
	struct __tds__CreateUsers *p;
	struct __tds__CreateUsers *a = (struct __tds__CreateUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__CreateUsers));
	for (p = a; p && n--; p++)
		soap_default___tds__CreateUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateUsers(struct soap *soap, const struct __tds__CreateUsers *a, const char *tag, const char *type)
{
	if (soap_out___tds__CreateUsers(soap, tag ? tag : "-tds:CreateUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_get___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetUsers(struct soap *soap, const struct __tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetUsers(soap, &a->tds__GetUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetUsers(struct soap *soap, const char *tag, int id, const struct __tds__GetUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetUsers(soap, "tds:GetUsers", -1, &a->tds__GetUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_in___tds__GetUsers(struct soap *soap, const char *tag, struct __tds__GetUsers *a, const char *type)
{
	size_t soap_flag_tds__GetUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetUsers*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetUsers, sizeof(struct __tds__GetUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetUsers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetUsers(soap, "tds:GetUsers", &a->tds__GetUsers, ""))
				{	soap_flag_tds__GetUsers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_new___tds__GetUsers(struct soap *soap, int n)
{
	struct __tds__GetUsers *p;
	struct __tds__GetUsers *a = (struct __tds__GetUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetUsers));
	for (p = a; p && n--; p++)
		soap_default___tds__GetUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetUsers(struct soap *soap, const struct __tds__GetUsers *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetUsers(soap, tag ? tag : "-tds:GetUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_get___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRemoteUser(struct soap *soap, struct __tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRemoteUser(struct soap *soap, const struct __tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetRemoteUser(soap, &a->tds__SetRemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRemoteUser(struct soap *soap, const char *tag, int id, const struct __tds__SetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetRemoteUser(soap, "tds:SetRemoteUser", -1, &a->tds__SetRemoteUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteUser * SOAP_FMAC4 soap_in___tds__SetRemoteUser(struct soap *soap, const char *tag, struct __tds__SetRemoteUser *a, const char *type)
{
	size_t soap_flag_tds__SetRemoteUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetRemoteUser*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRemoteUser, sizeof(struct __tds__SetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRemoteUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetRemoteUser(soap, "tds:SetRemoteUser", &a->tds__SetRemoteUser, ""))
				{	soap_flag_tds__SetRemoteUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetRemoteUser * SOAP_FMAC4 soap_new___tds__SetRemoteUser(struct soap *soap, int n)
{
	struct __tds__SetRemoteUser *p;
	struct __tds__SetRemoteUser *a = (struct __tds__SetRemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetRemoteUser));
	for (p = a; p && n--; p++)
		soap_default___tds__SetRemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRemoteUser(struct soap *soap, const struct __tds__SetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetRemoteUser(soap, tag ? tag : "-tds:SetRemoteUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteUser * SOAP_FMAC4 soap_get___tds__SetRemoteUser(struct soap *soap, struct __tds__SetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRemoteUser(struct soap *soap, struct __tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRemoteUser(struct soap *soap, const struct __tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetRemoteUser(soap, &a->tds__GetRemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRemoteUser(struct soap *soap, const char *tag, int id, const struct __tds__GetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetRemoteUser(soap, "tds:GetRemoteUser", -1, &a->tds__GetRemoteUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteUser * SOAP_FMAC4 soap_in___tds__GetRemoteUser(struct soap *soap, const char *tag, struct __tds__GetRemoteUser *a, const char *type)
{
	size_t soap_flag_tds__GetRemoteUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetRemoteUser*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRemoteUser, sizeof(struct __tds__GetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRemoteUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetRemoteUser(soap, "tds:GetRemoteUser", &a->tds__GetRemoteUser, ""))
				{	soap_flag_tds__GetRemoteUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetRemoteUser * SOAP_FMAC4 soap_new___tds__GetRemoteUser(struct soap *soap, int n)
{
	struct __tds__GetRemoteUser *p;
	struct __tds__GetRemoteUser *a = (struct __tds__GetRemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetRemoteUser));
	for (p = a; p && n--; p++)
		soap_default___tds__GetRemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRemoteUser(struct soap *soap, const struct __tds__GetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetRemoteUser(soap, tag ? tag : "-tds:GetRemoteUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteUser * SOAP_FMAC4 soap_get___tds__GetRemoteUser(struct soap *soap, struct __tds__GetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetEndpointReference(struct soap *soap, struct __tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetEndpointReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetEndpointReference(struct soap *soap, const struct __tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetEndpointReference(soap, &a->tds__GetEndpointReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetEndpointReference(struct soap *soap, const char *tag, int id, const struct __tds__GetEndpointReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetEndpointReference(soap, "tds:GetEndpointReference", -1, &a->tds__GetEndpointReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetEndpointReference * SOAP_FMAC4 soap_in___tds__GetEndpointReference(struct soap *soap, const char *tag, struct __tds__GetEndpointReference *a, const char *type)
{
	size_t soap_flag_tds__GetEndpointReference = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetEndpointReference*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetEndpointReference, sizeof(struct __tds__GetEndpointReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetEndpointReference(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetEndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetEndpointReference(soap, "tds:GetEndpointReference", &a->tds__GetEndpointReference, ""))
				{	soap_flag_tds__GetEndpointReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetEndpointReference * SOAP_FMAC4 soap_new___tds__GetEndpointReference(struct soap *soap, int n)
{
	struct __tds__GetEndpointReference *p;
	struct __tds__GetEndpointReference *a = (struct __tds__GetEndpointReference*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetEndpointReference));
	for (p = a; p && n--; p++)
		soap_default___tds__GetEndpointReference(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetEndpointReference(struct soap *soap, const struct __tds__GetEndpointReference *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetEndpointReference(soap, tag ? tag : "-tds:GetEndpointReference", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetEndpointReference * SOAP_FMAC4 soap_get___tds__GetEndpointReference(struct soap *soap, struct __tds__GetEndpointReference *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDPAddresses(struct soap *soap, struct __tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDPAddresses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDPAddresses(struct soap *soap, const struct __tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDPAddresses(soap, &a->tds__GetDPAddresses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDPAddresses(struct soap *soap, const char *tag, int id, const struct __tds__GetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDPAddresses(soap, "tds:GetDPAddresses", -1, &a->tds__GetDPAddresses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDPAddresses * SOAP_FMAC4 soap_in___tds__GetDPAddresses(struct soap *soap, const char *tag, struct __tds__GetDPAddresses *a, const char *type)
{
	size_t soap_flag_tds__GetDPAddresses = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDPAddresses*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDPAddresses, sizeof(struct __tds__GetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDPAddresses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDPAddresses(soap, "tds:GetDPAddresses", &a->tds__GetDPAddresses, ""))
				{	soap_flag_tds__GetDPAddresses--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetDPAddresses * SOAP_FMAC4 soap_new___tds__GetDPAddresses(struct soap *soap, int n)
{
	struct __tds__GetDPAddresses *p;
	struct __tds__GetDPAddresses *a = (struct __tds__GetDPAddresses*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetDPAddresses));
	for (p = a; p && n--; p++)
		soap_default___tds__GetDPAddresses(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDPAddresses(struct soap *soap, const struct __tds__GetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDPAddresses(soap, tag ? tag : "-tds:GetDPAddresses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDPAddresses * SOAP_FMAC4 soap_get___tds__GetDPAddresses(struct soap *soap, struct __tds__GetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRemoteDiscoveryMode(struct soap *soap, struct __tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRemoteDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRemoteDiscoveryMode(struct soap *soap, const struct __tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetRemoteDiscoveryMode(soap, &a->tds__SetRemoteDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__SetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryMode(soap, "tds:SetRemoteDiscoveryMode", -1, &a->tds__SetRemoteDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_in___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct __tds__SetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__SetRemoteDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetRemoteDiscoveryMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRemoteDiscoveryMode, sizeof(struct __tds__SetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRemoteDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetRemoteDiscoveryMode(soap, "tds:SetRemoteDiscoveryMode", &a->tds__SetRemoteDiscoveryMode, ""))
				{	soap_flag_tds__SetRemoteDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_new___tds__SetRemoteDiscoveryMode(struct soap *soap, int n)
{
	struct __tds__SetRemoteDiscoveryMode *p;
	struct __tds__SetRemoteDiscoveryMode *a = (struct __tds__SetRemoteDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetRemoteDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default___tds__SetRemoteDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRemoteDiscoveryMode(struct soap *soap, const struct __tds__SetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetRemoteDiscoveryMode(soap, tag ? tag : "-tds:SetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_get___tds__SetRemoteDiscoveryMode(struct soap *soap, struct __tds__SetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRemoteDiscoveryMode(struct soap *soap, struct __tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRemoteDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRemoteDiscoveryMode(struct soap *soap, const struct __tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetRemoteDiscoveryMode(soap, &a->tds__GetRemoteDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__GetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryMode(soap, "tds:GetRemoteDiscoveryMode", -1, &a->tds__GetRemoteDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_in___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct __tds__GetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__GetRemoteDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetRemoteDiscoveryMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRemoteDiscoveryMode, sizeof(struct __tds__GetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRemoteDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetRemoteDiscoveryMode(soap, "tds:GetRemoteDiscoveryMode", &a->tds__GetRemoteDiscoveryMode, ""))
				{	soap_flag_tds__GetRemoteDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_new___tds__GetRemoteDiscoveryMode(struct soap *soap, int n)
{
	struct __tds__GetRemoteDiscoveryMode *p;
	struct __tds__GetRemoteDiscoveryMode *a = (struct __tds__GetRemoteDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetRemoteDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default___tds__GetRemoteDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRemoteDiscoveryMode(struct soap *soap, const struct __tds__GetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetRemoteDiscoveryMode(soap, tag ? tag : "-tds:GetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_get___tds__GetRemoteDiscoveryMode(struct soap *soap, struct __tds__GetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDiscoveryMode(struct soap *soap, struct __tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDiscoveryMode(struct soap *soap, const struct __tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDiscoveryMode(soap, &a->tds__SetDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__SetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDiscoveryMode(soap, "tds:SetDiscoveryMode", -1, &a->tds__SetDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDiscoveryMode * SOAP_FMAC4 soap_in___tds__SetDiscoveryMode(struct soap *soap, const char *tag, struct __tds__SetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__SetDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDiscoveryMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDiscoveryMode, sizeof(struct __tds__SetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDiscoveryMode(soap, "tds:SetDiscoveryMode", &a->tds__SetDiscoveryMode, ""))
				{	soap_flag_tds__SetDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetDiscoveryMode * SOAP_FMAC4 soap_new___tds__SetDiscoveryMode(struct soap *soap, int n)
{
	struct __tds__SetDiscoveryMode *p;
	struct __tds__SetDiscoveryMode *a = (struct __tds__SetDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default___tds__SetDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDiscoveryMode(struct soap *soap, const struct __tds__SetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDiscoveryMode(soap, tag ? tag : "-tds:SetDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDiscoveryMode * SOAP_FMAC4 soap_get___tds__SetDiscoveryMode(struct soap *soap, struct __tds__SetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDiscoveryMode(struct soap *soap, struct __tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDiscoveryMode(struct soap *soap, const struct __tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDiscoveryMode(soap, &a->tds__GetDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__GetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDiscoveryMode(soap, "tds:GetDiscoveryMode", -1, &a->tds__GetDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDiscoveryMode * SOAP_FMAC4 soap_in___tds__GetDiscoveryMode(struct soap *soap, const char *tag, struct __tds__GetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__GetDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDiscoveryMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDiscoveryMode, sizeof(struct __tds__GetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDiscoveryMode(soap, "tds:GetDiscoveryMode", &a->tds__GetDiscoveryMode, ""))
				{	soap_flag_tds__GetDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetDiscoveryMode * SOAP_FMAC4 soap_new___tds__GetDiscoveryMode(struct soap *soap, int n)
{
	struct __tds__GetDiscoveryMode *p;
	struct __tds__GetDiscoveryMode *a = (struct __tds__GetDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default___tds__GetDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDiscoveryMode(struct soap *soap, const struct __tds__GetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDiscoveryMode(soap, tag ? tag : "-tds:GetDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDiscoveryMode * SOAP_FMAC4 soap_get___tds__GetDiscoveryMode(struct soap *soap, struct __tds__GetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RemoveScopes(struct soap *soap, struct __tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RemoveScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RemoveScopes(struct soap *soap, const struct __tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__RemoveScopes(soap, &a->tds__RemoveScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RemoveScopes(struct soap *soap, const char *tag, int id, const struct __tds__RemoveScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__RemoveScopes(soap, "tds:RemoveScopes", -1, &a->tds__RemoveScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveScopes * SOAP_FMAC4 soap_in___tds__RemoveScopes(struct soap *soap, const char *tag, struct __tds__RemoveScopes *a, const char *type)
{
	size_t soap_flag_tds__RemoveScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__RemoveScopes*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RemoveScopes, sizeof(struct __tds__RemoveScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RemoveScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RemoveScopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__RemoveScopes(soap, "tds:RemoveScopes", &a->tds__RemoveScopes, ""))
				{	soap_flag_tds__RemoveScopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__RemoveScopes * SOAP_FMAC4 soap_new___tds__RemoveScopes(struct soap *soap, int n)
{
	struct __tds__RemoveScopes *p;
	struct __tds__RemoveScopes *a = (struct __tds__RemoveScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__RemoveScopes));
	for (p = a; p && n--; p++)
		soap_default___tds__RemoveScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RemoveScopes(struct soap *soap, const struct __tds__RemoveScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__RemoveScopes(soap, tag ? tag : "-tds:RemoveScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveScopes * SOAP_FMAC4 soap_get___tds__RemoveScopes(struct soap *soap, struct __tds__RemoveScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__AddScopes(struct soap *soap, struct __tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__AddScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__AddScopes(struct soap *soap, const struct __tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__AddScopes(soap, &a->tds__AddScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__AddScopes(struct soap *soap, const char *tag, int id, const struct __tds__AddScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__AddScopes(soap, "tds:AddScopes", -1, &a->tds__AddScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddScopes * SOAP_FMAC4 soap_in___tds__AddScopes(struct soap *soap, const char *tag, struct __tds__AddScopes *a, const char *type)
{
	size_t soap_flag_tds__AddScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__AddScopes*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__AddScopes, sizeof(struct __tds__AddScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__AddScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__AddScopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__AddScopes(soap, "tds:AddScopes", &a->tds__AddScopes, ""))
				{	soap_flag_tds__AddScopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__AddScopes * SOAP_FMAC4 soap_new___tds__AddScopes(struct soap *soap, int n)
{
	struct __tds__AddScopes *p;
	struct __tds__AddScopes *a = (struct __tds__AddScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__AddScopes));
	for (p = a; p && n--; p++)
		soap_default___tds__AddScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__AddScopes(struct soap *soap, const struct __tds__AddScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__AddScopes(soap, tag ? tag : "-tds:AddScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddScopes * SOAP_FMAC4 soap_get___tds__AddScopes(struct soap *soap, struct __tds__AddScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetScopes(struct soap *soap, struct __tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetScopes(struct soap *soap, const struct __tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetScopes(soap, &a->tds__SetScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetScopes(struct soap *soap, const char *tag, int id, const struct __tds__SetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetScopes(soap, "tds:SetScopes", -1, &a->tds__SetScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetScopes * SOAP_FMAC4 soap_in___tds__SetScopes(struct soap *soap, const char *tag, struct __tds__SetScopes *a, const char *type)
{
	size_t soap_flag_tds__SetScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetScopes*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetScopes, sizeof(struct __tds__SetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetScopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetScopes(soap, "tds:SetScopes", &a->tds__SetScopes, ""))
				{	soap_flag_tds__SetScopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetScopes * SOAP_FMAC4 soap_new___tds__SetScopes(struct soap *soap, int n)
{
	struct __tds__SetScopes *p;
	struct __tds__SetScopes *a = (struct __tds__SetScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetScopes));
	for (p = a; p && n--; p++)
		soap_default___tds__SetScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetScopes(struct soap *soap, const struct __tds__SetScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetScopes(soap, tag ? tag : "-tds:SetScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetScopes * SOAP_FMAC4 soap_get___tds__SetScopes(struct soap *soap, struct __tds__SetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetScopes(struct soap *soap, struct __tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetScopes(struct soap *soap, const struct __tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetScopes(soap, &a->tds__GetScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetScopes(struct soap *soap, const char *tag, int id, const struct __tds__GetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetScopes(soap, "tds:GetScopes", -1, &a->tds__GetScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetScopes * SOAP_FMAC4 soap_in___tds__GetScopes(struct soap *soap, const char *tag, struct __tds__GetScopes *a, const char *type)
{
	size_t soap_flag_tds__GetScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetScopes*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetScopes, sizeof(struct __tds__GetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetScopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetScopes(soap, "tds:GetScopes", &a->tds__GetScopes, ""))
				{	soap_flag_tds__GetScopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetScopes * SOAP_FMAC4 soap_new___tds__GetScopes(struct soap *soap, int n)
{
	struct __tds__GetScopes *p;
	struct __tds__GetScopes *a = (struct __tds__GetScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetScopes));
	for (p = a; p && n--; p++)
		soap_default___tds__GetScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetScopes(struct soap *soap, const struct __tds__GetScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetScopes(soap, tag ? tag : "-tds:GetScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetScopes * SOAP_FMAC4 soap_get___tds__GetScopes(struct soap *soap, struct __tds__GetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemSupportInformation(struct soap *soap, struct __tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemSupportInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemSupportInformation(struct soap *soap, const struct __tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemSupportInformation(soap, &a->tds__GetSystemSupportInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemSupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemSupportInformation(soap, "tds:GetSystemSupportInformation", -1, &a->tds__GetSystemSupportInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemSupportInformation * SOAP_FMAC4 soap_in___tds__GetSystemSupportInformation(struct soap *soap, const char *tag, struct __tds__GetSystemSupportInformation *a, const char *type)
{
	size_t soap_flag_tds__GetSystemSupportInformation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemSupportInformation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemSupportInformation, sizeof(struct __tds__GetSystemSupportInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemSupportInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemSupportInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemSupportInformation(soap, "tds:GetSystemSupportInformation", &a->tds__GetSystemSupportInformation, ""))
				{	soap_flag_tds__GetSystemSupportInformation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetSystemSupportInformation * SOAP_FMAC4 soap_new___tds__GetSystemSupportInformation(struct soap *soap, int n)
{
	struct __tds__GetSystemSupportInformation *p;
	struct __tds__GetSystemSupportInformation *a = (struct __tds__GetSystemSupportInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetSystemSupportInformation));
	for (p = a; p && n--; p++)
		soap_default___tds__GetSystemSupportInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemSupportInformation(struct soap *soap, const struct __tds__GetSystemSupportInformation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemSupportInformation(soap, tag ? tag : "-tds:GetSystemSupportInformation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemSupportInformation * SOAP_FMAC4 soap_get___tds__GetSystemSupportInformation(struct soap *soap, struct __tds__GetSystemSupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemLog(struct soap *soap, struct __tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemLog(struct soap *soap, const struct __tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemLog(soap, &a->tds__GetSystemLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemLog(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemLog(soap, "tds:GetSystemLog", -1, &a->tds__GetSystemLog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemLog * SOAP_FMAC4 soap_in___tds__GetSystemLog(struct soap *soap, const char *tag, struct __tds__GetSystemLog *a, const char *type)
{
	size_t soap_flag_tds__GetSystemLog = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemLog*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemLog, sizeof(struct __tds__GetSystemLog), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemLog && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemLog(soap, "tds:GetSystemLog", &a->tds__GetSystemLog, ""))
				{	soap_flag_tds__GetSystemLog--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetSystemLog * SOAP_FMAC4 soap_new___tds__GetSystemLog(struct soap *soap, int n)
{
	struct __tds__GetSystemLog *p;
	struct __tds__GetSystemLog *a = (struct __tds__GetSystemLog*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetSystemLog));
	for (p = a; p && n--; p++)
		soap_default___tds__GetSystemLog(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemLog(struct soap *soap, const struct __tds__GetSystemLog *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemLog(soap, tag ? tag : "-tds:GetSystemLog", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemLog * SOAP_FMAC4 soap_get___tds__GetSystemLog(struct soap *soap, struct __tds__GetSystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemBackup(struct soap *soap, struct __tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemBackup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemBackup(struct soap *soap, const struct __tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemBackup(soap, &a->tds__GetSystemBackup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemBackup(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemBackup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemBackup(soap, "tds:GetSystemBackup", -1, &a->tds__GetSystemBackup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemBackup * SOAP_FMAC4 soap_in___tds__GetSystemBackup(struct soap *soap, const char *tag, struct __tds__GetSystemBackup *a, const char *type)
{
	size_t soap_flag_tds__GetSystemBackup = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemBackup*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemBackup, sizeof(struct __tds__GetSystemBackup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemBackup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemBackup && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemBackup(soap, "tds:GetSystemBackup", &a->tds__GetSystemBackup, ""))
				{	soap_flag_tds__GetSystemBackup--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetSystemBackup * SOAP_FMAC4 soap_new___tds__GetSystemBackup(struct soap *soap, int n)
{
	struct __tds__GetSystemBackup *p;
	struct __tds__GetSystemBackup *a = (struct __tds__GetSystemBackup*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetSystemBackup));
	for (p = a; p && n--; p++)
		soap_default___tds__GetSystemBackup(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemBackup(struct soap *soap, const struct __tds__GetSystemBackup *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemBackup(soap, tag ? tag : "-tds:GetSystemBackup", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemBackup * SOAP_FMAC4 soap_get___tds__GetSystemBackup(struct soap *soap, struct __tds__GetSystemBackup *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RestoreSystem(struct soap *soap, struct __tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RestoreSystem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RestoreSystem(struct soap *soap, const struct __tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__RestoreSystem(soap, &a->tds__RestoreSystem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RestoreSystem(struct soap *soap, const char *tag, int id, const struct __tds__RestoreSystem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__RestoreSystem(soap, "tds:RestoreSystem", -1, &a->tds__RestoreSystem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RestoreSystem * SOAP_FMAC4 soap_in___tds__RestoreSystem(struct soap *soap, const char *tag, struct __tds__RestoreSystem *a, const char *type)
{
	size_t soap_flag_tds__RestoreSystem = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__RestoreSystem*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RestoreSystem, sizeof(struct __tds__RestoreSystem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RestoreSystem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RestoreSystem && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__RestoreSystem(soap, "tds:RestoreSystem", &a->tds__RestoreSystem, ""))
				{	soap_flag_tds__RestoreSystem--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__RestoreSystem * SOAP_FMAC4 soap_new___tds__RestoreSystem(struct soap *soap, int n)
{
	struct __tds__RestoreSystem *p;
	struct __tds__RestoreSystem *a = (struct __tds__RestoreSystem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__RestoreSystem));
	for (p = a; p && n--; p++)
		soap_default___tds__RestoreSystem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RestoreSystem(struct soap *soap, const struct __tds__RestoreSystem *a, const char *tag, const char *type)
{
	if (soap_out___tds__RestoreSystem(soap, tag ? tag : "-tds:RestoreSystem", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RestoreSystem * SOAP_FMAC4 soap_get___tds__RestoreSystem(struct soap *soap, struct __tds__RestoreSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SystemReboot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SystemReboot(soap, &a->tds__SystemReboot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SystemReboot(struct soap *soap, const char *tag, int id, const struct __tds__SystemReboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", -1, &a->tds__SystemReboot, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_in___tds__SystemReboot(struct soap *soap, const char *tag, struct __tds__SystemReboot *a, const char *type)
{
	size_t soap_flag_tds__SystemReboot = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SystemReboot*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SystemReboot, sizeof(struct __tds__SystemReboot), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SystemReboot(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SystemReboot && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", &a->tds__SystemReboot, ""))
				{	soap_flag_tds__SystemReboot--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_new___tds__SystemReboot(struct soap *soap, int n)
{
	struct __tds__SystemReboot *p;
	struct __tds__SystemReboot *a = (struct __tds__SystemReboot*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SystemReboot));
	for (p = a; p && n--; p++)
		soap_default___tds__SystemReboot(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a, const char *tag, const char *type)
{
	if (soap_out___tds__SystemReboot(soap, tag ? tag : "-tds:SystemReboot", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_get___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__UpgradeSystemFirmware(struct soap *soap, struct __tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__UpgradeSystemFirmware = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__UpgradeSystemFirmware(struct soap *soap, const struct __tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__UpgradeSystemFirmware(soap, &a->tds__UpgradeSystemFirmware);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, const struct __tds__UpgradeSystemFirmware *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, "tds:UpgradeSystemFirmware", -1, &a->tds__UpgradeSystemFirmware, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_in___tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, struct __tds__UpgradeSystemFirmware *a, const char *type)
{
	size_t soap_flag_tds__UpgradeSystemFirmware = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__UpgradeSystemFirmware*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__UpgradeSystemFirmware, sizeof(struct __tds__UpgradeSystemFirmware), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__UpgradeSystemFirmware(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__UpgradeSystemFirmware && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, "tds:UpgradeSystemFirmware", &a->tds__UpgradeSystemFirmware, ""))
				{	soap_flag_tds__UpgradeSystemFirmware--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_new___tds__UpgradeSystemFirmware(struct soap *soap, int n)
{
	struct __tds__UpgradeSystemFirmware *p;
	struct __tds__UpgradeSystemFirmware *a = (struct __tds__UpgradeSystemFirmware*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__UpgradeSystemFirmware));
	for (p = a; p && n--; p++)
		soap_default___tds__UpgradeSystemFirmware(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__UpgradeSystemFirmware(struct soap *soap, const struct __tds__UpgradeSystemFirmware *a, const char *tag, const char *type)
{
	if (soap_out___tds__UpgradeSystemFirmware(soap, tag ? tag : "-tds:UpgradeSystemFirmware", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_get___tds__UpgradeSystemFirmware(struct soap *soap, struct __tds__UpgradeSystemFirmware *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetSystemFactoryDefault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetSystemFactoryDefault(struct soap *soap, const struct __tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetSystemFactoryDefault(soap, &a->tds__SetSystemFactoryDefault);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, const struct __tds__SetSystemFactoryDefault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, "tds:SetSystemFactoryDefault", -1, &a->tds__SetSystemFactoryDefault, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_in___tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct __tds__SetSystemFactoryDefault *a, const char *type)
{
	size_t soap_flag_tds__SetSystemFactoryDefault = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetSystemFactoryDefault*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetSystemFactoryDefault, sizeof(struct __tds__SetSystemFactoryDefault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetSystemFactoryDefault(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetSystemFactoryDefault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, "tds:SetSystemFactoryDefault", &a->tds__SetSystemFactoryDefault, ""))
				{	soap_flag_tds__SetSystemFactoryDefault--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_new___tds__SetSystemFactoryDefault(struct soap *soap, int n)
{
	struct __tds__SetSystemFactoryDefault *p;
	struct __tds__SetSystemFactoryDefault *a = (struct __tds__SetSystemFactoryDefault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetSystemFactoryDefault));
	for (p = a; p && n--; p++)
		soap_default___tds__SetSystemFactoryDefault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetSystemFactoryDefault(struct soap *soap, const struct __tds__SetSystemFactoryDefault *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetSystemFactoryDefault(soap, tag ? tag : "-tds:SetSystemFactoryDefault", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_get___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemDateAndTime(struct soap *soap, const struct __tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemDateAndTime(soap, &a->tds__GetSystemDateAndTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, "tds:GetSystemDateAndTime", -1, &a->tds__GetSystemDateAndTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_in___tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct __tds__GetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_tds__GetSystemDateAndTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemDateAndTime*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemDateAndTime, sizeof(struct __tds__GetSystemDateAndTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemDateAndTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemDateAndTime(soap, "tds:GetSystemDateAndTime", &a->tds__GetSystemDateAndTime, ""))
				{	soap_flag_tds__GetSystemDateAndTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_new___tds__GetSystemDateAndTime(struct soap *soap, int n)
{
	struct __tds__GetSystemDateAndTime *p;
	struct __tds__GetSystemDateAndTime *a = (struct __tds__GetSystemDateAndTime*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetSystemDateAndTime));
	for (p = a; p && n--; p++)
		soap_default___tds__GetSystemDateAndTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemDateAndTime(struct soap *soap, const struct __tds__GetSystemDateAndTime *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemDateAndTime(soap, tag ? tag : "-tds:GetSystemDateAndTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_get___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetSystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetSystemDateAndTime(struct soap *soap, const struct __tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetSystemDateAndTime(soap, &a->tds__SetSystemDateAndTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct __tds__SetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, "tds:SetSystemDateAndTime", -1, &a->tds__SetSystemDateAndTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_in___tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct __tds__SetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_tds__SetSystemDateAndTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetSystemDateAndTime*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetSystemDateAndTime, sizeof(struct __tds__SetSystemDateAndTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetSystemDateAndTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetSystemDateAndTime(soap, "tds:SetSystemDateAndTime", &a->tds__SetSystemDateAndTime, ""))
				{	soap_flag_tds__SetSystemDateAndTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_new___tds__SetSystemDateAndTime(struct soap *soap, int n)
{
	struct __tds__SetSystemDateAndTime *p;
	struct __tds__SetSystemDateAndTime *a = (struct __tds__SetSystemDateAndTime*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetSystemDateAndTime));
	for (p = a; p && n--; p++)
		soap_default___tds__SetSystemDateAndTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetSystemDateAndTime(struct soap *soap, const struct __tds__SetSystemDateAndTime *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetSystemDateAndTime(soap, tag ? tag : "-tds:SetSystemDateAndTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_get___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDeviceInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDeviceInformation(struct soap *soap, const struct __tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDeviceInformation(soap, &a->tds__GetDeviceInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetDeviceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", -1, &a->tds__GetDeviceInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_in___tds__GetDeviceInformation(struct soap *soap, const char *tag, struct __tds__GetDeviceInformation *a, const char *type)
{
	size_t soap_flag_tds__GetDeviceInformation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDeviceInformation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDeviceInformation, sizeof(struct __tds__GetDeviceInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDeviceInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDeviceInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", &a->tds__GetDeviceInformation, ""))
				{	soap_flag_tds__GetDeviceInformation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_new___tds__GetDeviceInformation(struct soap *soap, int n)
{
	struct __tds__GetDeviceInformation *p;
	struct __tds__GetDeviceInformation *a = (struct __tds__GetDeviceInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetDeviceInformation));
	for (p = a; p && n--; p++)
		soap_default___tds__GetDeviceInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDeviceInformation(struct soap *soap, const struct __tds__GetDeviceInformation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDeviceInformation(soap, tag ? tag : "-tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_get___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetServiceCapabilities(struct soap *soap, const struct __tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetServiceCapabilities(soap, &a->tds__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", -1, &a->tds__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_in___tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tds__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetServiceCapabilities, sizeof(struct __tds__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", &a->tds__GetServiceCapabilities, ""))
				{	soap_flag_tds__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_new___tds__GetServiceCapabilities(struct soap *soap, int n)
{
	struct __tds__GetServiceCapabilities *p;
	struct __tds__GetServiceCapabilities *a = (struct __tds__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default___tds__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetServiceCapabilities(struct soap *soap, const struct __tds__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetServiceCapabilities(soap, tag ? tag : "-tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_get___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetServices(struct soap *soap, struct __tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetServices = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetServices(struct soap *soap, const struct __tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetServices(soap, &a->tds__GetServices);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetServices(struct soap *soap, const char *tag, int id, const struct __tds__GetServices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetServices(soap, "tds:GetServices", -1, &a->tds__GetServices, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_in___tds__GetServices(struct soap *soap, const char *tag, struct __tds__GetServices *a, const char *type)
{
	size_t soap_flag_tds__GetServices = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetServices*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetServices, sizeof(struct __tds__GetServices), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetServices(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetServices && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetServices(soap, "tds:GetServices", &a->tds__GetServices, ""))
				{	soap_flag_tds__GetServices--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_new___tds__GetServices(struct soap *soap, int n)
{
	struct __tds__GetServices *p;
	struct __tds__GetServices *a = (struct __tds__GetServices*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetServices));
	for (p = a; p && n--; p++)
		soap_default___tds__GetServices(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetServices(struct soap *soap, const struct __tds__GetServices *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetServices(soap, tag ? tag : "-tds:GetServices", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_get___tds__GetServices(struct soap *soap, struct __tds__GetServices *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Probe(struct soap *soap, struct __tdn__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__ProbeType(soap, &a->tdn__Probe);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Probe(struct soap *soap, const struct __tdn__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Probe, SOAP_TYPE_wsdd__ProbeType);
	soap_serialize_wsdd__ProbeType(soap, &a->tdn__Probe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Probe(struct soap *soap, const char *tag, int id, const struct __tdn__Probe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__ProbeType(soap, "tdn:Probe", -1, &a->tdn__Probe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_in___tdn__Probe(struct soap *soap, const char *tag, struct __tdn__Probe *a, const char *type)
{
	size_t soap_flag_tdn__Probe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Probe*)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Probe, sizeof(struct __tdn__Probe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Probe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Probe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdd__ProbeType(soap, "tdn:Probe", &a->tdn__Probe, "wsdd:ProbeType"))
				{	soap_flag_tdn__Probe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tdn__Probe > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_new___tdn__Probe(struct soap *soap, int n)
{
	struct __tdn__Probe *p;
	struct __tdn__Probe *a = (struct __tdn__Probe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tdn__Probe));
	for (p = a; p && n--; p++)
		soap_default___tdn__Probe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Probe(struct soap *soap, const struct __tdn__Probe *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Probe(soap, tag ? tag : "-tdn:Probe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_get___tdn__Probe(struct soap *soap, struct __tdn__Probe *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Probe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Bye(struct soap *soap, struct __tdn__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__ByeType(soap, &a->tdn__Bye);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Bye(struct soap *soap, const struct __tdn__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Bye, SOAP_TYPE_wsdd__ByeType);
	soap_serialize_wsdd__ByeType(soap, &a->tdn__Bye);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Bye(struct soap *soap, const char *tag, int id, const struct __tdn__Bye *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__ByeType(soap, "tdn:Bye", -1, &a->tdn__Bye, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_in___tdn__Bye(struct soap *soap, const char *tag, struct __tdn__Bye *a, const char *type)
{
	size_t soap_flag_tdn__Bye = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Bye*)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Bye, sizeof(struct __tdn__Bye), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Bye && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdd__ByeType(soap, "tdn:Bye", &a->tdn__Bye, "wsdd:ByeType"))
				{	soap_flag_tdn__Bye--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tdn__Bye > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_new___tdn__Bye(struct soap *soap, int n)
{
	struct __tdn__Bye *p;
	struct __tdn__Bye *a = (struct __tdn__Bye*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tdn__Bye));
	for (p = a; p && n--; p++)
		soap_default___tdn__Bye(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Bye(struct soap *soap, const struct __tdn__Bye *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Bye(soap, tag ? tag : "-tdn:Bye", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_get___tdn__Bye(struct soap *soap, struct __tdn__Bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Hello(struct soap *soap, struct __tdn__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__HelloType(soap, &a->tdn__Hello);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Hello(struct soap *soap, const struct __tdn__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Hello, SOAP_TYPE_wsdd__HelloType);
	soap_serialize_wsdd__HelloType(soap, &a->tdn__Hello);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Hello(struct soap *soap, const char *tag, int id, const struct __tdn__Hello *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__HelloType(soap, "tdn:Hello", -1, &a->tdn__Hello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_in___tdn__Hello(struct soap *soap, const char *tag, struct __tdn__Hello *a, const char *type)
{
	size_t soap_flag_tdn__Hello = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Hello*)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Hello, sizeof(struct __tdn__Hello), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Hello(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Hello && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdd__HelloType(soap, "tdn:Hello", &a->tdn__Hello, "wsdd:HelloType"))
				{	soap_flag_tdn__Hello--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tdn__Hello > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_new___tdn__Hello(struct soap *soap, int n)
{
	struct __tdn__Hello *p;
	struct __tdn__Hello *a = (struct __tdn__Hello*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tdn__Hello));
	for (p = a; p && n--; p++)
		soap_default___tdn__Hello(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Hello(struct soap *soap, const struct __tdn__Hello *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Hello(soap, tag ? tag : "-tdn:Hello", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_get___tdn__Hello(struct soap *soap, struct __tdn__Hello *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Hello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetSupportedMetadata(struct soap *soap, struct __tan__GetSupportedMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetSupportedMetadata = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetSupportedMetadata(struct soap *soap, const struct __tan__GetSupportedMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetSupportedMetadata(soap, &a->tan__GetSupportedMetadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetSupportedMetadata(struct soap *soap, const char *tag, int id, const struct __tan__GetSupportedMetadata *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetSupportedMetadata(soap, "tan:GetSupportedMetadata", -1, &a->tan__GetSupportedMetadata, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetSupportedMetadata * SOAP_FMAC4 soap_in___tan__GetSupportedMetadata(struct soap *soap, const char *tag, struct __tan__GetSupportedMetadata *a, const char *type)
{
	size_t soap_flag_tan__GetSupportedMetadata = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetSupportedMetadata*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetSupportedMetadata, sizeof(struct __tan__GetSupportedMetadata), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetSupportedMetadata(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetSupportedMetadata && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__GetSupportedMetadata(soap, "tan:GetSupportedMetadata", &a->tan__GetSupportedMetadata, ""))
				{	soap_flag_tan__GetSupportedMetadata--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetSupportedMetadata * SOAP_FMAC4 soap_new___tan__GetSupportedMetadata(struct soap *soap, int n)
{
	struct __tan__GetSupportedMetadata *p;
	struct __tan__GetSupportedMetadata *a = (struct __tan__GetSupportedMetadata*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetSupportedMetadata));
	for (p = a; p && n--; p++)
		soap_default___tan__GetSupportedMetadata(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetSupportedMetadata(struct soap *soap, const struct __tan__GetSupportedMetadata *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetSupportedMetadata(soap, tag ? tag : "-tan:GetSupportedMetadata", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetSupportedMetadata * SOAP_FMAC4 soap_get___tan__GetSupportedMetadata(struct soap *soap, struct __tan__GetSupportedMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetSupportedMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__ModifyAnalyticsModules(struct soap *soap, struct __tan__ModifyAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__ModifyAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__ModifyAnalyticsModules(struct soap *soap, const struct __tan__ModifyAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__ModifyAnalyticsModules(soap, &a->tan__ModifyAnalyticsModules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __tan__ModifyAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__ModifyAnalyticsModules(soap, "tan:ModifyAnalyticsModules", -1, &a->tan__ModifyAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_in___tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, struct __tan__ModifyAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__ModifyAnalyticsModules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__ModifyAnalyticsModules*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__ModifyAnalyticsModules, sizeof(struct __tan__ModifyAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__ModifyAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__ModifyAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__ModifyAnalyticsModules(soap, "tan:ModifyAnalyticsModules", &a->tan__ModifyAnalyticsModules, ""))
				{	soap_flag_tan__ModifyAnalyticsModules--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_new___tan__ModifyAnalyticsModules(struct soap *soap, int n)
{
	struct __tan__ModifyAnalyticsModules *p;
	struct __tan__ModifyAnalyticsModules *a = (struct __tan__ModifyAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__ModifyAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default___tan__ModifyAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__ModifyAnalyticsModules(struct soap *soap, const struct __tan__ModifyAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out___tan__ModifyAnalyticsModules(soap, tag ? tag : "-tan:ModifyAnalyticsModules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_get___tan__ModifyAnalyticsModules(struct soap *soap, struct __tan__ModifyAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__ModifyAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetAnalyticsModuleOptions(struct soap *soap, struct __tan__GetAnalyticsModuleOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetAnalyticsModuleOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetAnalyticsModuleOptions(struct soap *soap, const struct __tan__GetAnalyticsModuleOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetAnalyticsModuleOptions(soap, &a->tan__GetAnalyticsModuleOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetAnalyticsModuleOptions(struct soap *soap, const char *tag, int id, const struct __tan__GetAnalyticsModuleOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetAnalyticsModuleOptions(soap, "tan:GetAnalyticsModuleOptions", -1, &a->tan__GetAnalyticsModuleOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetAnalyticsModuleOptions * SOAP_FMAC4 soap_in___tan__GetAnalyticsModuleOptions(struct soap *soap, const char *tag, struct __tan__GetAnalyticsModuleOptions *a, const char *type)
{
	size_t soap_flag_tan__GetAnalyticsModuleOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetAnalyticsModuleOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetAnalyticsModuleOptions, sizeof(struct __tan__GetAnalyticsModuleOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetAnalyticsModuleOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetAnalyticsModuleOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__GetAnalyticsModuleOptions(soap, "tan:GetAnalyticsModuleOptions", &a->tan__GetAnalyticsModuleOptions, ""))
				{	soap_flag_tan__GetAnalyticsModuleOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetAnalyticsModuleOptions * SOAP_FMAC4 soap_new___tan__GetAnalyticsModuleOptions(struct soap *soap, int n)
{
	struct __tan__GetAnalyticsModuleOptions *p;
	struct __tan__GetAnalyticsModuleOptions *a = (struct __tan__GetAnalyticsModuleOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetAnalyticsModuleOptions));
	for (p = a; p && n--; p++)
		soap_default___tan__GetAnalyticsModuleOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetAnalyticsModuleOptions(struct soap *soap, const struct __tan__GetAnalyticsModuleOptions *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetAnalyticsModuleOptions(soap, tag ? tag : "-tan:GetAnalyticsModuleOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetAnalyticsModuleOptions * SOAP_FMAC4 soap_get___tan__GetAnalyticsModuleOptions(struct soap *soap, struct __tan__GetAnalyticsModuleOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetAnalyticsModuleOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetAnalyticsModules(struct soap *soap, struct __tan__GetAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetAnalyticsModules(struct soap *soap, const struct __tan__GetAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetAnalyticsModules(soap, &a->tan__GetAnalyticsModules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __tan__GetAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetAnalyticsModules(soap, "tan:GetAnalyticsModules", -1, &a->tan__GetAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetAnalyticsModules * SOAP_FMAC4 soap_in___tan__GetAnalyticsModules(struct soap *soap, const char *tag, struct __tan__GetAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__GetAnalyticsModules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetAnalyticsModules*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetAnalyticsModules, sizeof(struct __tan__GetAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__GetAnalyticsModules(soap, "tan:GetAnalyticsModules", &a->tan__GetAnalyticsModules, ""))
				{	soap_flag_tan__GetAnalyticsModules--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetAnalyticsModules * SOAP_FMAC4 soap_new___tan__GetAnalyticsModules(struct soap *soap, int n)
{
	struct __tan__GetAnalyticsModules *p;
	struct __tan__GetAnalyticsModules *a = (struct __tan__GetAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default___tan__GetAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetAnalyticsModules(struct soap *soap, const struct __tan__GetAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetAnalyticsModules(soap, tag ? tag : "-tan:GetAnalyticsModules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetAnalyticsModules * SOAP_FMAC4 soap_get___tan__GetAnalyticsModules(struct soap *soap, struct __tan__GetAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__DeleteAnalyticsModules(struct soap *soap, struct __tan__DeleteAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__DeleteAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__DeleteAnalyticsModules(struct soap *soap, const struct __tan__DeleteAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__DeleteAnalyticsModules(soap, &a->tan__DeleteAnalyticsModules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __tan__DeleteAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__DeleteAnalyticsModules(soap, "tan:DeleteAnalyticsModules", -1, &a->tan__DeleteAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_in___tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, struct __tan__DeleteAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__DeleteAnalyticsModules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__DeleteAnalyticsModules*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__DeleteAnalyticsModules, sizeof(struct __tan__DeleteAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__DeleteAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__DeleteAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__DeleteAnalyticsModules(soap, "tan:DeleteAnalyticsModules", &a->tan__DeleteAnalyticsModules, ""))
				{	soap_flag_tan__DeleteAnalyticsModules--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_new___tan__DeleteAnalyticsModules(struct soap *soap, int n)
{
	struct __tan__DeleteAnalyticsModules *p;
	struct __tan__DeleteAnalyticsModules *a = (struct __tan__DeleteAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__DeleteAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default___tan__DeleteAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__DeleteAnalyticsModules(struct soap *soap, const struct __tan__DeleteAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out___tan__DeleteAnalyticsModules(soap, tag ? tag : "-tan:DeleteAnalyticsModules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_get___tan__DeleteAnalyticsModules(struct soap *soap, struct __tan__DeleteAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__DeleteAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__CreateAnalyticsModules(struct soap *soap, struct __tan__CreateAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__CreateAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__CreateAnalyticsModules(struct soap *soap, const struct __tan__CreateAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__CreateAnalyticsModules(soap, &a->tan__CreateAnalyticsModules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__CreateAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __tan__CreateAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__CreateAnalyticsModules(soap, "tan:CreateAnalyticsModules", -1, &a->tan__CreateAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__CreateAnalyticsModules * SOAP_FMAC4 soap_in___tan__CreateAnalyticsModules(struct soap *soap, const char *tag, struct __tan__CreateAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__CreateAnalyticsModules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__CreateAnalyticsModules*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__CreateAnalyticsModules, sizeof(struct __tan__CreateAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__CreateAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__CreateAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__CreateAnalyticsModules(soap, "tan:CreateAnalyticsModules", &a->tan__CreateAnalyticsModules, ""))
				{	soap_flag_tan__CreateAnalyticsModules--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__CreateAnalyticsModules * SOAP_FMAC4 soap_new___tan__CreateAnalyticsModules(struct soap *soap, int n)
{
	struct __tan__CreateAnalyticsModules *p;
	struct __tan__CreateAnalyticsModules *a = (struct __tan__CreateAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__CreateAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default___tan__CreateAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__CreateAnalyticsModules(struct soap *soap, const struct __tan__CreateAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out___tan__CreateAnalyticsModules(soap, tag ? tag : "-tan:CreateAnalyticsModules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__CreateAnalyticsModules * SOAP_FMAC4 soap_get___tan__CreateAnalyticsModules(struct soap *soap, struct __tan__CreateAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__CreateAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetSupportedAnalyticsModules(struct soap *soap, struct __tan__GetSupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetSupportedAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetSupportedAnalyticsModules(struct soap *soap, const struct __tan__GetSupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetSupportedAnalyticsModules(soap, &a->tan__GetSupportedAnalyticsModules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __tan__GetSupportedAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetSupportedAnalyticsModules(soap, "tan:GetSupportedAnalyticsModules", -1, &a->tan__GetSupportedAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_in___tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, struct __tan__GetSupportedAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__GetSupportedAnalyticsModules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetSupportedAnalyticsModules*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetSupportedAnalyticsModules, sizeof(struct __tan__GetSupportedAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetSupportedAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetSupportedAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__GetSupportedAnalyticsModules(soap, "tan:GetSupportedAnalyticsModules", &a->tan__GetSupportedAnalyticsModules, ""))
				{	soap_flag_tan__GetSupportedAnalyticsModules--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_new___tan__GetSupportedAnalyticsModules(struct soap *soap, int n)
{
	struct __tan__GetSupportedAnalyticsModules *p;
	struct __tan__GetSupportedAnalyticsModules *a = (struct __tan__GetSupportedAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetSupportedAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default___tan__GetSupportedAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetSupportedAnalyticsModules(struct soap *soap, const struct __tan__GetSupportedAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetSupportedAnalyticsModules(soap, tag ? tag : "-tan:GetSupportedAnalyticsModules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_get___tan__GetSupportedAnalyticsModules(struct soap *soap, struct __tan__GetSupportedAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetSupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetServiceCapabilities(struct soap *soap, struct __tan__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetServiceCapabilities(struct soap *soap, const struct __tan__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetServiceCapabilities(soap, &a->tan__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tan__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetServiceCapabilities(soap, "tan:GetServiceCapabilities", -1, &a->tan__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetServiceCapabilities * SOAP_FMAC4 soap_in___tan__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tan__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tan__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetServiceCapabilities, sizeof(struct __tan__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__GetServiceCapabilities(soap, "tan:GetServiceCapabilities", &a->tan__GetServiceCapabilities, ""))
				{	soap_flag_tan__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetServiceCapabilities * SOAP_FMAC4 soap_new___tan__GetServiceCapabilities(struct soap *soap, int n)
{
	struct __tan__GetServiceCapabilities *p;
	struct __tan__GetServiceCapabilities *a = (struct __tan__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default___tan__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetServiceCapabilities(struct soap *soap, const struct __tan__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetServiceCapabilities(soap, tag ? tag : "-tan:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetServiceCapabilities * SOAP_FMAC4 soap_get___tan__GetServiceCapabilities(struct soap *soap, struct __tan__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__ModifyRules(struct soap *soap, struct __tan__ModifyRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__ModifyRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__ModifyRules(struct soap *soap, const struct __tan__ModifyRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__ModifyRules(soap, &a->tan__ModifyRules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__ModifyRules(struct soap *soap, const char *tag, int id, const struct __tan__ModifyRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__ModifyRules(soap, "tan:ModifyRules", -1, &a->tan__ModifyRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__ModifyRules * SOAP_FMAC4 soap_in___tan__ModifyRules(struct soap *soap, const char *tag, struct __tan__ModifyRules *a, const char *type)
{
	size_t soap_flag_tan__ModifyRules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__ModifyRules*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__ModifyRules, sizeof(struct __tan__ModifyRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__ModifyRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__ModifyRules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__ModifyRules(soap, "tan:ModifyRules", &a->tan__ModifyRules, ""))
				{	soap_flag_tan__ModifyRules--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__ModifyRules * SOAP_FMAC4 soap_new___tan__ModifyRules(struct soap *soap, int n)
{
	struct __tan__ModifyRules *p;
	struct __tan__ModifyRules *a = (struct __tan__ModifyRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__ModifyRules));
	for (p = a; p && n--; p++)
		soap_default___tan__ModifyRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__ModifyRules(struct soap *soap, const struct __tan__ModifyRules *a, const char *tag, const char *type)
{
	if (soap_out___tan__ModifyRules(soap, tag ? tag : "-tan:ModifyRules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__ModifyRules * SOAP_FMAC4 soap_get___tan__ModifyRules(struct soap *soap, struct __tan__ModifyRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__ModifyRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetRuleOptions(struct soap *soap, struct __tan__GetRuleOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetRuleOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetRuleOptions(struct soap *soap, const struct __tan__GetRuleOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetRuleOptions(soap, &a->tan__GetRuleOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetRuleOptions(struct soap *soap, const char *tag, int id, const struct __tan__GetRuleOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetRuleOptions(soap, "tan:GetRuleOptions", -1, &a->tan__GetRuleOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetRuleOptions * SOAP_FMAC4 soap_in___tan__GetRuleOptions(struct soap *soap, const char *tag, struct __tan__GetRuleOptions *a, const char *type)
{
	size_t soap_flag_tan__GetRuleOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetRuleOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetRuleOptions, sizeof(struct __tan__GetRuleOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetRuleOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetRuleOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__GetRuleOptions(soap, "tan:GetRuleOptions", &a->tan__GetRuleOptions, ""))
				{	soap_flag_tan__GetRuleOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetRuleOptions * SOAP_FMAC4 soap_new___tan__GetRuleOptions(struct soap *soap, int n)
{
	struct __tan__GetRuleOptions *p;
	struct __tan__GetRuleOptions *a = (struct __tan__GetRuleOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetRuleOptions));
	for (p = a; p && n--; p++)
		soap_default___tan__GetRuleOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetRuleOptions(struct soap *soap, const struct __tan__GetRuleOptions *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetRuleOptions(soap, tag ? tag : "-tan:GetRuleOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetRuleOptions * SOAP_FMAC4 soap_get___tan__GetRuleOptions(struct soap *soap, struct __tan__GetRuleOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetRuleOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetRules(struct soap *soap, struct __tan__GetRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetRules(struct soap *soap, const struct __tan__GetRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetRules(soap, &a->tan__GetRules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetRules(struct soap *soap, const char *tag, int id, const struct __tan__GetRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetRules(soap, "tan:GetRules", -1, &a->tan__GetRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetRules * SOAP_FMAC4 soap_in___tan__GetRules(struct soap *soap, const char *tag, struct __tan__GetRules *a, const char *type)
{
	size_t soap_flag_tan__GetRules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetRules*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetRules, sizeof(struct __tan__GetRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetRules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__GetRules(soap, "tan:GetRules", &a->tan__GetRules, ""))
				{	soap_flag_tan__GetRules--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetRules * SOAP_FMAC4 soap_new___tan__GetRules(struct soap *soap, int n)
{
	struct __tan__GetRules *p;
	struct __tan__GetRules *a = (struct __tan__GetRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetRules));
	for (p = a; p && n--; p++)
		soap_default___tan__GetRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetRules(struct soap *soap, const struct __tan__GetRules *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetRules(soap, tag ? tag : "-tan:GetRules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetRules * SOAP_FMAC4 soap_get___tan__GetRules(struct soap *soap, struct __tan__GetRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__DeleteRules(struct soap *soap, struct __tan__DeleteRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__DeleteRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__DeleteRules(struct soap *soap, const struct __tan__DeleteRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__DeleteRules(soap, &a->tan__DeleteRules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__DeleteRules(struct soap *soap, const char *tag, int id, const struct __tan__DeleteRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__DeleteRules(soap, "tan:DeleteRules", -1, &a->tan__DeleteRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__DeleteRules * SOAP_FMAC4 soap_in___tan__DeleteRules(struct soap *soap, const char *tag, struct __tan__DeleteRules *a, const char *type)
{
	size_t soap_flag_tan__DeleteRules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__DeleteRules*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__DeleteRules, sizeof(struct __tan__DeleteRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__DeleteRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__DeleteRules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__DeleteRules(soap, "tan:DeleteRules", &a->tan__DeleteRules, ""))
				{	soap_flag_tan__DeleteRules--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__DeleteRules * SOAP_FMAC4 soap_new___tan__DeleteRules(struct soap *soap, int n)
{
	struct __tan__DeleteRules *p;
	struct __tan__DeleteRules *a = (struct __tan__DeleteRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__DeleteRules));
	for (p = a; p && n--; p++)
		soap_default___tan__DeleteRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__DeleteRules(struct soap *soap, const struct __tan__DeleteRules *a, const char *tag, const char *type)
{
	if (soap_out___tan__DeleteRules(soap, tag ? tag : "-tan:DeleteRules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__DeleteRules * SOAP_FMAC4 soap_get___tan__DeleteRules(struct soap *soap, struct __tan__DeleteRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__DeleteRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__CreateRules(struct soap *soap, struct __tan__CreateRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__CreateRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__CreateRules(struct soap *soap, const struct __tan__CreateRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__CreateRules(soap, &a->tan__CreateRules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__CreateRules(struct soap *soap, const char *tag, int id, const struct __tan__CreateRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__CreateRules(soap, "tan:CreateRules", -1, &a->tan__CreateRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__CreateRules * SOAP_FMAC4 soap_in___tan__CreateRules(struct soap *soap, const char *tag, struct __tan__CreateRules *a, const char *type)
{
	size_t soap_flag_tan__CreateRules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__CreateRules*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__CreateRules, sizeof(struct __tan__CreateRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__CreateRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__CreateRules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__CreateRules(soap, "tan:CreateRules", &a->tan__CreateRules, ""))
				{	soap_flag_tan__CreateRules--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__CreateRules * SOAP_FMAC4 soap_new___tan__CreateRules(struct soap *soap, int n)
{
	struct __tan__CreateRules *p;
	struct __tan__CreateRules *a = (struct __tan__CreateRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__CreateRules));
	for (p = a; p && n--; p++)
		soap_default___tan__CreateRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__CreateRules(struct soap *soap, const struct __tan__CreateRules *a, const char *tag, const char *type)
{
	if (soap_out___tan__CreateRules(soap, tag ? tag : "-tan:CreateRules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__CreateRules * SOAP_FMAC4 soap_get___tan__CreateRules(struct soap *soap, struct __tan__CreateRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__CreateRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetSupportedRules(struct soap *soap, struct __tan__GetSupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetSupportedRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetSupportedRules(struct soap *soap, const struct __tan__GetSupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetSupportedRules(soap, &a->tan__GetSupportedRules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetSupportedRules(struct soap *soap, const char *tag, int id, const struct __tan__GetSupportedRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetSupportedRules(soap, "tan:GetSupportedRules", -1, &a->tan__GetSupportedRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetSupportedRules * SOAP_FMAC4 soap_in___tan__GetSupportedRules(struct soap *soap, const char *tag, struct __tan__GetSupportedRules *a, const char *type)
{
	size_t soap_flag_tan__GetSupportedRules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetSupportedRules*)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetSupportedRules, sizeof(struct __tan__GetSupportedRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetSupportedRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetSupportedRules && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tan__GetSupportedRules(soap, "tan:GetSupportedRules", &a->tan__GetSupportedRules, ""))
				{	soap_flag_tan__GetSupportedRules--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetSupportedRules * SOAP_FMAC4 soap_new___tan__GetSupportedRules(struct soap *soap, int n)
{
	struct __tan__GetSupportedRules *p;
	struct __tan__GetSupportedRules *a = (struct __tan__GetSupportedRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetSupportedRules));
	for (p = a; p && n--; p++)
		soap_default___tan__GetSupportedRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetSupportedRules(struct soap *soap, const struct __tan__GetSupportedRules *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetSupportedRules(soap, tag ? tag : "-tan:GetSupportedRules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetSupportedRules * SOAP_FMAC4 soap_get___tan__GetSupportedRules(struct soap *soap, struct __tan__GetSupportedRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetSupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__GetAnalyticsState(struct soap *soap, struct __tad__GetAnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__GetAnalyticsState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__GetAnalyticsState(struct soap *soap, const struct __tad__GetAnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__GetAnalyticsState(soap, &a->tad__GetAnalyticsState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__GetAnalyticsState(struct soap *soap, const char *tag, int id, const struct __tad__GetAnalyticsState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__GetAnalyticsState(soap, "tad:GetAnalyticsState", -1, &a->tad__GetAnalyticsState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsState * SOAP_FMAC4 soap_in___tad__GetAnalyticsState(struct soap *soap, const char *tag, struct __tad__GetAnalyticsState *a, const char *type)
{
	size_t soap_flag_tad__GetAnalyticsState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__GetAnalyticsState*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__GetAnalyticsState, sizeof(struct __tad__GetAnalyticsState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__GetAnalyticsState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__GetAnalyticsState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__GetAnalyticsState(soap, "tad:GetAnalyticsState", &a->tad__GetAnalyticsState, ""))
				{	soap_flag_tad__GetAnalyticsState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__GetAnalyticsState * SOAP_FMAC4 soap_new___tad__GetAnalyticsState(struct soap *soap, int n)
{
	struct __tad__GetAnalyticsState *p;
	struct __tad__GetAnalyticsState *a = (struct __tad__GetAnalyticsState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__GetAnalyticsState));
	for (p = a; p && n--; p++)
		soap_default___tad__GetAnalyticsState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__GetAnalyticsState(struct soap *soap, const struct __tad__GetAnalyticsState *a, const char *tag, const char *type)
{
	if (soap_out___tad__GetAnalyticsState(soap, tag ? tag : "-tad:GetAnalyticsState", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsState * SOAP_FMAC4 soap_get___tad__GetAnalyticsState(struct soap *soap, struct __tad__GetAnalyticsState *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__GetAnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__DeleteAnalyticsEngineInputs(struct soap *soap, struct __tad__DeleteAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__DeleteAnalyticsEngineInputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__DeleteAnalyticsEngineInputs(struct soap *soap, const struct __tad__DeleteAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__DeleteAnalyticsEngineInputs(soap, &a->tad__DeleteAnalyticsEngineInputs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__DeleteAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, const struct __tad__DeleteAnalyticsEngineInputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__DeleteAnalyticsEngineInputs(soap, "tad:DeleteAnalyticsEngineInputs", -1, &a->tad__DeleteAnalyticsEngineInputs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__DeleteAnalyticsEngineInputs * SOAP_FMAC4 soap_in___tad__DeleteAnalyticsEngineInputs(struct soap *soap, const char *tag, struct __tad__DeleteAnalyticsEngineInputs *a, const char *type)
{
	size_t soap_flag_tad__DeleteAnalyticsEngineInputs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__DeleteAnalyticsEngineInputs*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__DeleteAnalyticsEngineInputs, sizeof(struct __tad__DeleteAnalyticsEngineInputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__DeleteAnalyticsEngineInputs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__DeleteAnalyticsEngineInputs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__DeleteAnalyticsEngineInputs(soap, "tad:DeleteAnalyticsEngineInputs", &a->tad__DeleteAnalyticsEngineInputs, ""))
				{	soap_flag_tad__DeleteAnalyticsEngineInputs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__DeleteAnalyticsEngineInputs * SOAP_FMAC4 soap_new___tad__DeleteAnalyticsEngineInputs(struct soap *soap, int n)
{
	struct __tad__DeleteAnalyticsEngineInputs *p;
	struct __tad__DeleteAnalyticsEngineInputs *a = (struct __tad__DeleteAnalyticsEngineInputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__DeleteAnalyticsEngineInputs));
	for (p = a; p && n--; p++)
		soap_default___tad__DeleteAnalyticsEngineInputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__DeleteAnalyticsEngineInputs(struct soap *soap, const struct __tad__DeleteAnalyticsEngineInputs *a, const char *tag, const char *type)
{
	if (soap_out___tad__DeleteAnalyticsEngineInputs(soap, tag ? tag : "-tad:DeleteAnalyticsEngineInputs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__DeleteAnalyticsEngineInputs * SOAP_FMAC4 soap_get___tad__DeleteAnalyticsEngineInputs(struct soap *soap, struct __tad__DeleteAnalyticsEngineInputs *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__DeleteAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__CreateAnalyticsEngineInputs(struct soap *soap, struct __tad__CreateAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__CreateAnalyticsEngineInputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__CreateAnalyticsEngineInputs(struct soap *soap, const struct __tad__CreateAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__CreateAnalyticsEngineInputs(soap, &a->tad__CreateAnalyticsEngineInputs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__CreateAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, const struct __tad__CreateAnalyticsEngineInputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__CreateAnalyticsEngineInputs(soap, "tad:CreateAnalyticsEngineInputs", -1, &a->tad__CreateAnalyticsEngineInputs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__CreateAnalyticsEngineInputs * SOAP_FMAC4 soap_in___tad__CreateAnalyticsEngineInputs(struct soap *soap, const char *tag, struct __tad__CreateAnalyticsEngineInputs *a, const char *type)
{
	size_t soap_flag_tad__CreateAnalyticsEngineInputs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__CreateAnalyticsEngineInputs*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__CreateAnalyticsEngineInputs, sizeof(struct __tad__CreateAnalyticsEngineInputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__CreateAnalyticsEngineInputs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__CreateAnalyticsEngineInputs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__CreateAnalyticsEngineInputs(soap, "tad:CreateAnalyticsEngineInputs", &a->tad__CreateAnalyticsEngineInputs, ""))
				{	soap_flag_tad__CreateAnalyticsEngineInputs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__CreateAnalyticsEngineInputs * SOAP_FMAC4 soap_new___tad__CreateAnalyticsEngineInputs(struct soap *soap, int n)
{
	struct __tad__CreateAnalyticsEngineInputs *p;
	struct __tad__CreateAnalyticsEngineInputs *a = (struct __tad__CreateAnalyticsEngineInputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__CreateAnalyticsEngineInputs));
	for (p = a; p && n--; p++)
		soap_default___tad__CreateAnalyticsEngineInputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__CreateAnalyticsEngineInputs(struct soap *soap, const struct __tad__CreateAnalyticsEngineInputs *a, const char *tag, const char *type)
{
	if (soap_out___tad__CreateAnalyticsEngineInputs(soap, tag ? tag : "-tad:CreateAnalyticsEngineInputs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__CreateAnalyticsEngineInputs * SOAP_FMAC4 soap_get___tad__CreateAnalyticsEngineInputs(struct soap *soap, struct __tad__CreateAnalyticsEngineInputs *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__CreateAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__GetVideoAnalyticsConfiguration(struct soap *soap, struct __tad__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__GetVideoAnalyticsConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__GetVideoAnalyticsConfiguration(struct soap *soap, const struct __tad__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__GetVideoAnalyticsConfiguration(soap, &a->tad__GetVideoAnalyticsConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct __tad__GetVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__GetVideoAnalyticsConfiguration(soap, "tad:GetVideoAnalyticsConfiguration", -1, &a->tad__GetVideoAnalyticsConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in___tad__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct __tad__GetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_tad__GetVideoAnalyticsConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__GetVideoAnalyticsConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__GetVideoAnalyticsConfiguration, sizeof(struct __tad__GetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__GetVideoAnalyticsConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__GetVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__GetVideoAnalyticsConfiguration(soap, "tad:GetVideoAnalyticsConfiguration", &a->tad__GetVideoAnalyticsConfiguration, ""))
				{	soap_flag_tad__GetVideoAnalyticsConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_new___tad__GetVideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct __tad__GetVideoAnalyticsConfiguration *p;
	struct __tad__GetVideoAnalyticsConfiguration *a = (struct __tad__GetVideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__GetVideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default___tad__GetVideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__GetVideoAnalyticsConfiguration(struct soap *soap, const struct __tad__GetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tad__GetVideoAnalyticsConfiguration(soap, tag ? tag : "-tad:GetVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get___tad__GetVideoAnalyticsConfiguration(struct soap *soap, struct __tad__GetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__GetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__GetAnalyticsDeviceStreamUri(struct soap *soap, struct __tad__GetAnalyticsDeviceStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__GetAnalyticsDeviceStreamUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const struct __tad__GetAnalyticsDeviceStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__GetAnalyticsDeviceStreamUri(soap, &a->tad__GetAnalyticsDeviceStreamUri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const char *tag, int id, const struct __tad__GetAnalyticsDeviceStreamUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__GetAnalyticsDeviceStreamUri(soap, "tad:GetAnalyticsDeviceStreamUri", -1, &a->tad__GetAnalyticsDeviceStreamUri, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsDeviceStreamUri * SOAP_FMAC4 soap_in___tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const char *tag, struct __tad__GetAnalyticsDeviceStreamUri *a, const char *type)
{
	size_t soap_flag_tad__GetAnalyticsDeviceStreamUri = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__GetAnalyticsDeviceStreamUri*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__GetAnalyticsDeviceStreamUri, sizeof(struct __tad__GetAnalyticsDeviceStreamUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__GetAnalyticsDeviceStreamUri(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__GetAnalyticsDeviceStreamUri && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__GetAnalyticsDeviceStreamUri(soap, "tad:GetAnalyticsDeviceStreamUri", &a->tad__GetAnalyticsDeviceStreamUri, ""))
				{	soap_flag_tad__GetAnalyticsDeviceStreamUri--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__GetAnalyticsDeviceStreamUri * SOAP_FMAC4 soap_new___tad__GetAnalyticsDeviceStreamUri(struct soap *soap, int n)
{
	struct __tad__GetAnalyticsDeviceStreamUri *p;
	struct __tad__GetAnalyticsDeviceStreamUri *a = (struct __tad__GetAnalyticsDeviceStreamUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__GetAnalyticsDeviceStreamUri));
	for (p = a; p && n--; p++)
		soap_default___tad__GetAnalyticsDeviceStreamUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const struct __tad__GetAnalyticsDeviceStreamUri *a, const char *tag, const char *type)
{
	if (soap_out___tad__GetAnalyticsDeviceStreamUri(soap, tag ? tag : "-tad:GetAnalyticsDeviceStreamUri", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsDeviceStreamUri * SOAP_FMAC4 soap_get___tad__GetAnalyticsDeviceStreamUri(struct soap *soap, struct __tad__GetAnalyticsDeviceStreamUri *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__GetAnalyticsDeviceStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__GetAnalyticsEngineInputs(struct soap *soap, struct __tad__GetAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__GetAnalyticsEngineInputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__GetAnalyticsEngineInputs(struct soap *soap, const struct __tad__GetAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__GetAnalyticsEngineInputs(soap, &a->tad__GetAnalyticsEngineInputs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__GetAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, const struct __tad__GetAnalyticsEngineInputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__GetAnalyticsEngineInputs(soap, "tad:GetAnalyticsEngineInputs", -1, &a->tad__GetAnalyticsEngineInputs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngineInputs * SOAP_FMAC4 soap_in___tad__GetAnalyticsEngineInputs(struct soap *soap, const char *tag, struct __tad__GetAnalyticsEngineInputs *a, const char *type)
{
	size_t soap_flag_tad__GetAnalyticsEngineInputs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__GetAnalyticsEngineInputs*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__GetAnalyticsEngineInputs, sizeof(struct __tad__GetAnalyticsEngineInputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__GetAnalyticsEngineInputs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__GetAnalyticsEngineInputs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__GetAnalyticsEngineInputs(soap, "tad:GetAnalyticsEngineInputs", &a->tad__GetAnalyticsEngineInputs, ""))
				{	soap_flag_tad__GetAnalyticsEngineInputs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngineInputs * SOAP_FMAC4 soap_new___tad__GetAnalyticsEngineInputs(struct soap *soap, int n)
{
	struct __tad__GetAnalyticsEngineInputs *p;
	struct __tad__GetAnalyticsEngineInputs *a = (struct __tad__GetAnalyticsEngineInputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__GetAnalyticsEngineInputs));
	for (p = a; p && n--; p++)
		soap_default___tad__GetAnalyticsEngineInputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__GetAnalyticsEngineInputs(struct soap *soap, const struct __tad__GetAnalyticsEngineInputs *a, const char *tag, const char *type)
{
	if (soap_out___tad__GetAnalyticsEngineInputs(soap, tag ? tag : "-tad:GetAnalyticsEngineInputs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngineInputs * SOAP_FMAC4 soap_get___tad__GetAnalyticsEngineInputs(struct soap *soap, struct __tad__GetAnalyticsEngineInputs *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__GetAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__GetAnalyticsEngineInput(struct soap *soap, struct __tad__GetAnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__GetAnalyticsEngineInput = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__GetAnalyticsEngineInput(struct soap *soap, const struct __tad__GetAnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__GetAnalyticsEngineInput(soap, &a->tad__GetAnalyticsEngineInput);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__GetAnalyticsEngineInput(struct soap *soap, const char *tag, int id, const struct __tad__GetAnalyticsEngineInput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__GetAnalyticsEngineInput(soap, "tad:GetAnalyticsEngineInput", -1, &a->tad__GetAnalyticsEngineInput, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngineInput * SOAP_FMAC4 soap_in___tad__GetAnalyticsEngineInput(struct soap *soap, const char *tag, struct __tad__GetAnalyticsEngineInput *a, const char *type)
{
	size_t soap_flag_tad__GetAnalyticsEngineInput = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__GetAnalyticsEngineInput*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__GetAnalyticsEngineInput, sizeof(struct __tad__GetAnalyticsEngineInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__GetAnalyticsEngineInput(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__GetAnalyticsEngineInput && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__GetAnalyticsEngineInput(soap, "tad:GetAnalyticsEngineInput", &a->tad__GetAnalyticsEngineInput, ""))
				{	soap_flag_tad__GetAnalyticsEngineInput--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngineInput * SOAP_FMAC4 soap_new___tad__GetAnalyticsEngineInput(struct soap *soap, int n)
{
	struct __tad__GetAnalyticsEngineInput *p;
	struct __tad__GetAnalyticsEngineInput *a = (struct __tad__GetAnalyticsEngineInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__GetAnalyticsEngineInput));
	for (p = a; p && n--; p++)
		soap_default___tad__GetAnalyticsEngineInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__GetAnalyticsEngineInput(struct soap *soap, const struct __tad__GetAnalyticsEngineInput *a, const char *tag, const char *type)
{
	if (soap_out___tad__GetAnalyticsEngineInput(soap, tag ? tag : "-tad:GetAnalyticsEngineInput", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngineInput * SOAP_FMAC4 soap_get___tad__GetAnalyticsEngineInput(struct soap *soap, struct __tad__GetAnalyticsEngineInput *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__GetAnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__SetAnalyticsEngineInput(struct soap *soap, struct __tad__SetAnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__SetAnalyticsEngineInput = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__SetAnalyticsEngineInput(struct soap *soap, const struct __tad__SetAnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__SetAnalyticsEngineInput(soap, &a->tad__SetAnalyticsEngineInput);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__SetAnalyticsEngineInput(struct soap *soap, const char *tag, int id, const struct __tad__SetAnalyticsEngineInput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__SetAnalyticsEngineInput(soap, "tad:SetAnalyticsEngineInput", -1, &a->tad__SetAnalyticsEngineInput, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__SetAnalyticsEngineInput * SOAP_FMAC4 soap_in___tad__SetAnalyticsEngineInput(struct soap *soap, const char *tag, struct __tad__SetAnalyticsEngineInput *a, const char *type)
{
	size_t soap_flag_tad__SetAnalyticsEngineInput = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__SetAnalyticsEngineInput*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__SetAnalyticsEngineInput, sizeof(struct __tad__SetAnalyticsEngineInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__SetAnalyticsEngineInput(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__SetAnalyticsEngineInput && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__SetAnalyticsEngineInput(soap, "tad:SetAnalyticsEngineInput", &a->tad__SetAnalyticsEngineInput, ""))
				{	soap_flag_tad__SetAnalyticsEngineInput--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__SetAnalyticsEngineInput * SOAP_FMAC4 soap_new___tad__SetAnalyticsEngineInput(struct soap *soap, int n)
{
	struct __tad__SetAnalyticsEngineInput *p;
	struct __tad__SetAnalyticsEngineInput *a = (struct __tad__SetAnalyticsEngineInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__SetAnalyticsEngineInput));
	for (p = a; p && n--; p++)
		soap_default___tad__SetAnalyticsEngineInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__SetAnalyticsEngineInput(struct soap *soap, const struct __tad__SetAnalyticsEngineInput *a, const char *tag, const char *type)
{
	if (soap_out___tad__SetAnalyticsEngineInput(soap, tag ? tag : "-tad:SetAnalyticsEngineInput", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__SetAnalyticsEngineInput * SOAP_FMAC4 soap_get___tad__SetAnalyticsEngineInput(struct soap *soap, struct __tad__SetAnalyticsEngineInput *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__SetAnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__SetVideoAnalyticsConfiguration(struct soap *soap, struct __tad__SetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__SetVideoAnalyticsConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__SetVideoAnalyticsConfiguration(struct soap *soap, const struct __tad__SetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__SetVideoAnalyticsConfiguration(soap, &a->tad__SetVideoAnalyticsConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct __tad__SetVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__SetVideoAnalyticsConfiguration(soap, "tad:SetVideoAnalyticsConfiguration", -1, &a->tad__SetVideoAnalyticsConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in___tad__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct __tad__SetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_tad__SetVideoAnalyticsConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__SetVideoAnalyticsConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__SetVideoAnalyticsConfiguration, sizeof(struct __tad__SetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__SetVideoAnalyticsConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__SetVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__SetVideoAnalyticsConfiguration(soap, "tad:SetVideoAnalyticsConfiguration", &a->tad__SetVideoAnalyticsConfiguration, ""))
				{	soap_flag_tad__SetVideoAnalyticsConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_new___tad__SetVideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct __tad__SetVideoAnalyticsConfiguration *p;
	struct __tad__SetVideoAnalyticsConfiguration *a = (struct __tad__SetVideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__SetVideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default___tad__SetVideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__SetVideoAnalyticsConfiguration(struct soap *soap, const struct __tad__SetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tad__SetVideoAnalyticsConfiguration(soap, tag ? tag : "-tad:SetVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get___tad__SetVideoAnalyticsConfiguration(struct soap *soap, struct __tad__SetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__SetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__GetAnalyticsEngines(struct soap *soap, struct __tad__GetAnalyticsEngines *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__GetAnalyticsEngines = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__GetAnalyticsEngines(struct soap *soap, const struct __tad__GetAnalyticsEngines *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__GetAnalyticsEngines(soap, &a->tad__GetAnalyticsEngines);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__GetAnalyticsEngines(struct soap *soap, const char *tag, int id, const struct __tad__GetAnalyticsEngines *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__GetAnalyticsEngines(soap, "tad:GetAnalyticsEngines", -1, &a->tad__GetAnalyticsEngines, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngines * SOAP_FMAC4 soap_in___tad__GetAnalyticsEngines(struct soap *soap, const char *tag, struct __tad__GetAnalyticsEngines *a, const char *type)
{
	size_t soap_flag_tad__GetAnalyticsEngines = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__GetAnalyticsEngines*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__GetAnalyticsEngines, sizeof(struct __tad__GetAnalyticsEngines), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__GetAnalyticsEngines(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__GetAnalyticsEngines && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__GetAnalyticsEngines(soap, "tad:GetAnalyticsEngines", &a->tad__GetAnalyticsEngines, ""))
				{	soap_flag_tad__GetAnalyticsEngines--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngines * SOAP_FMAC4 soap_new___tad__GetAnalyticsEngines(struct soap *soap, int n)
{
	struct __tad__GetAnalyticsEngines *p;
	struct __tad__GetAnalyticsEngines *a = (struct __tad__GetAnalyticsEngines*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__GetAnalyticsEngines));
	for (p = a; p && n--; p++)
		soap_default___tad__GetAnalyticsEngines(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__GetAnalyticsEngines(struct soap *soap, const struct __tad__GetAnalyticsEngines *a, const char *tag, const char *type)
{
	if (soap_out___tad__GetAnalyticsEngines(soap, tag ? tag : "-tad:GetAnalyticsEngines", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngines * SOAP_FMAC4 soap_get___tad__GetAnalyticsEngines(struct soap *soap, struct __tad__GetAnalyticsEngines *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__GetAnalyticsEngines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__GetAnalyticsEngine(struct soap *soap, struct __tad__GetAnalyticsEngine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__GetAnalyticsEngine = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__GetAnalyticsEngine(struct soap *soap, const struct __tad__GetAnalyticsEngine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__GetAnalyticsEngine(soap, &a->tad__GetAnalyticsEngine);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__GetAnalyticsEngine(struct soap *soap, const char *tag, int id, const struct __tad__GetAnalyticsEngine *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__GetAnalyticsEngine(soap, "tad:GetAnalyticsEngine", -1, &a->tad__GetAnalyticsEngine, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngine * SOAP_FMAC4 soap_in___tad__GetAnalyticsEngine(struct soap *soap, const char *tag, struct __tad__GetAnalyticsEngine *a, const char *type)
{
	size_t soap_flag_tad__GetAnalyticsEngine = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__GetAnalyticsEngine*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__GetAnalyticsEngine, sizeof(struct __tad__GetAnalyticsEngine), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__GetAnalyticsEngine(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__GetAnalyticsEngine && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__GetAnalyticsEngine(soap, "tad:GetAnalyticsEngine", &a->tad__GetAnalyticsEngine, ""))
				{	soap_flag_tad__GetAnalyticsEngine--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngine * SOAP_FMAC4 soap_new___tad__GetAnalyticsEngine(struct soap *soap, int n)
{
	struct __tad__GetAnalyticsEngine *p;
	struct __tad__GetAnalyticsEngine *a = (struct __tad__GetAnalyticsEngine*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__GetAnalyticsEngine));
	for (p = a; p && n--; p++)
		soap_default___tad__GetAnalyticsEngine(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__GetAnalyticsEngine(struct soap *soap, const struct __tad__GetAnalyticsEngine *a, const char *tag, const char *type)
{
	if (soap_out___tad__GetAnalyticsEngine(soap, tag ? tag : "-tad:GetAnalyticsEngine", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngine * SOAP_FMAC4 soap_get___tad__GetAnalyticsEngine(struct soap *soap, struct __tad__GetAnalyticsEngine *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__GetAnalyticsEngine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__GetAnalyticsEngineControls(struct soap *soap, struct __tad__GetAnalyticsEngineControls *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__GetAnalyticsEngineControls = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__GetAnalyticsEngineControls(struct soap *soap, const struct __tad__GetAnalyticsEngineControls *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__GetAnalyticsEngineControls(soap, &a->tad__GetAnalyticsEngineControls);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__GetAnalyticsEngineControls(struct soap *soap, const char *tag, int id, const struct __tad__GetAnalyticsEngineControls *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__GetAnalyticsEngineControls(soap, "tad:GetAnalyticsEngineControls", -1, &a->tad__GetAnalyticsEngineControls, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngineControls * SOAP_FMAC4 soap_in___tad__GetAnalyticsEngineControls(struct soap *soap, const char *tag, struct __tad__GetAnalyticsEngineControls *a, const char *type)
{
	size_t soap_flag_tad__GetAnalyticsEngineControls = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__GetAnalyticsEngineControls*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__GetAnalyticsEngineControls, sizeof(struct __tad__GetAnalyticsEngineControls), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__GetAnalyticsEngineControls(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__GetAnalyticsEngineControls && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__GetAnalyticsEngineControls(soap, "tad:GetAnalyticsEngineControls", &a->tad__GetAnalyticsEngineControls, ""))
				{	soap_flag_tad__GetAnalyticsEngineControls--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngineControls * SOAP_FMAC4 soap_new___tad__GetAnalyticsEngineControls(struct soap *soap, int n)
{
	struct __tad__GetAnalyticsEngineControls *p;
	struct __tad__GetAnalyticsEngineControls *a = (struct __tad__GetAnalyticsEngineControls*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__GetAnalyticsEngineControls));
	for (p = a; p && n--; p++)
		soap_default___tad__GetAnalyticsEngineControls(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__GetAnalyticsEngineControls(struct soap *soap, const struct __tad__GetAnalyticsEngineControls *a, const char *tag, const char *type)
{
	if (soap_out___tad__GetAnalyticsEngineControls(soap, tag ? tag : "-tad:GetAnalyticsEngineControls", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngineControls * SOAP_FMAC4 soap_get___tad__GetAnalyticsEngineControls(struct soap *soap, struct __tad__GetAnalyticsEngineControls *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__GetAnalyticsEngineControls(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__GetAnalyticsEngineControl(struct soap *soap, struct __tad__GetAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__GetAnalyticsEngineControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__GetAnalyticsEngineControl(struct soap *soap, const struct __tad__GetAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__GetAnalyticsEngineControl(soap, &a->tad__GetAnalyticsEngineControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__GetAnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct __tad__GetAnalyticsEngineControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__GetAnalyticsEngineControl(soap, "tad:GetAnalyticsEngineControl", -1, &a->tad__GetAnalyticsEngineControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngineControl * SOAP_FMAC4 soap_in___tad__GetAnalyticsEngineControl(struct soap *soap, const char *tag, struct __tad__GetAnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_tad__GetAnalyticsEngineControl = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__GetAnalyticsEngineControl*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__GetAnalyticsEngineControl, sizeof(struct __tad__GetAnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__GetAnalyticsEngineControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__GetAnalyticsEngineControl && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__GetAnalyticsEngineControl(soap, "tad:GetAnalyticsEngineControl", &a->tad__GetAnalyticsEngineControl, ""))
				{	soap_flag_tad__GetAnalyticsEngineControl--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngineControl * SOAP_FMAC4 soap_new___tad__GetAnalyticsEngineControl(struct soap *soap, int n)
{
	struct __tad__GetAnalyticsEngineControl *p;
	struct __tad__GetAnalyticsEngineControl *a = (struct __tad__GetAnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__GetAnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default___tad__GetAnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__GetAnalyticsEngineControl(struct soap *soap, const struct __tad__GetAnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out___tad__GetAnalyticsEngineControl(soap, tag ? tag : "-tad:GetAnalyticsEngineControl", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsEngineControl * SOAP_FMAC4 soap_get___tad__GetAnalyticsEngineControl(struct soap *soap, struct __tad__GetAnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__GetAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__SetAnalyticsEngineControl(struct soap *soap, struct __tad__SetAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__SetAnalyticsEngineControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__SetAnalyticsEngineControl(struct soap *soap, const struct __tad__SetAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__SetAnalyticsEngineControl(soap, &a->tad__SetAnalyticsEngineControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__SetAnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct __tad__SetAnalyticsEngineControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__SetAnalyticsEngineControl(soap, "tad:SetAnalyticsEngineControl", -1, &a->tad__SetAnalyticsEngineControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__SetAnalyticsEngineControl * SOAP_FMAC4 soap_in___tad__SetAnalyticsEngineControl(struct soap *soap, const char *tag, struct __tad__SetAnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_tad__SetAnalyticsEngineControl = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__SetAnalyticsEngineControl*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__SetAnalyticsEngineControl, sizeof(struct __tad__SetAnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__SetAnalyticsEngineControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__SetAnalyticsEngineControl && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__SetAnalyticsEngineControl(soap, "tad:SetAnalyticsEngineControl", &a->tad__SetAnalyticsEngineControl, ""))
				{	soap_flag_tad__SetAnalyticsEngineControl--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__SetAnalyticsEngineControl * SOAP_FMAC4 soap_new___tad__SetAnalyticsEngineControl(struct soap *soap, int n)
{
	struct __tad__SetAnalyticsEngineControl *p;
	struct __tad__SetAnalyticsEngineControl *a = (struct __tad__SetAnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__SetAnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default___tad__SetAnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__SetAnalyticsEngineControl(struct soap *soap, const struct __tad__SetAnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out___tad__SetAnalyticsEngineControl(soap, tag ? tag : "-tad:SetAnalyticsEngineControl", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__SetAnalyticsEngineControl * SOAP_FMAC4 soap_get___tad__SetAnalyticsEngineControl(struct soap *soap, struct __tad__SetAnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__SetAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__CreateAnalyticsEngineControl(struct soap *soap, struct __tad__CreateAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__CreateAnalyticsEngineControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__CreateAnalyticsEngineControl(struct soap *soap, const struct __tad__CreateAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__CreateAnalyticsEngineControl(soap, &a->tad__CreateAnalyticsEngineControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__CreateAnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct __tad__CreateAnalyticsEngineControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__CreateAnalyticsEngineControl(soap, "tad:CreateAnalyticsEngineControl", -1, &a->tad__CreateAnalyticsEngineControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__CreateAnalyticsEngineControl * SOAP_FMAC4 soap_in___tad__CreateAnalyticsEngineControl(struct soap *soap, const char *tag, struct __tad__CreateAnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_tad__CreateAnalyticsEngineControl = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__CreateAnalyticsEngineControl*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__CreateAnalyticsEngineControl, sizeof(struct __tad__CreateAnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__CreateAnalyticsEngineControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__CreateAnalyticsEngineControl && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__CreateAnalyticsEngineControl(soap, "tad:CreateAnalyticsEngineControl", &a->tad__CreateAnalyticsEngineControl, ""))
				{	soap_flag_tad__CreateAnalyticsEngineControl--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__CreateAnalyticsEngineControl * SOAP_FMAC4 soap_new___tad__CreateAnalyticsEngineControl(struct soap *soap, int n)
{
	struct __tad__CreateAnalyticsEngineControl *p;
	struct __tad__CreateAnalyticsEngineControl *a = (struct __tad__CreateAnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__CreateAnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default___tad__CreateAnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__CreateAnalyticsEngineControl(struct soap *soap, const struct __tad__CreateAnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out___tad__CreateAnalyticsEngineControl(soap, tag ? tag : "-tad:CreateAnalyticsEngineControl", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__CreateAnalyticsEngineControl * SOAP_FMAC4 soap_get___tad__CreateAnalyticsEngineControl(struct soap *soap, struct __tad__CreateAnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__CreateAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__DeleteAnalyticsEngineControl(struct soap *soap, struct __tad__DeleteAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__DeleteAnalyticsEngineControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__DeleteAnalyticsEngineControl(struct soap *soap, const struct __tad__DeleteAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__DeleteAnalyticsEngineControl(soap, &a->tad__DeleteAnalyticsEngineControl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__DeleteAnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct __tad__DeleteAnalyticsEngineControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__DeleteAnalyticsEngineControl(soap, "tad:DeleteAnalyticsEngineControl", -1, &a->tad__DeleteAnalyticsEngineControl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__DeleteAnalyticsEngineControl * SOAP_FMAC4 soap_in___tad__DeleteAnalyticsEngineControl(struct soap *soap, const char *tag, struct __tad__DeleteAnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_tad__DeleteAnalyticsEngineControl = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__DeleteAnalyticsEngineControl*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__DeleteAnalyticsEngineControl, sizeof(struct __tad__DeleteAnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__DeleteAnalyticsEngineControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__DeleteAnalyticsEngineControl && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__DeleteAnalyticsEngineControl(soap, "tad:DeleteAnalyticsEngineControl", &a->tad__DeleteAnalyticsEngineControl, ""))
				{	soap_flag_tad__DeleteAnalyticsEngineControl--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__DeleteAnalyticsEngineControl * SOAP_FMAC4 soap_new___tad__DeleteAnalyticsEngineControl(struct soap *soap, int n)
{
	struct __tad__DeleteAnalyticsEngineControl *p;
	struct __tad__DeleteAnalyticsEngineControl *a = (struct __tad__DeleteAnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__DeleteAnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default___tad__DeleteAnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__DeleteAnalyticsEngineControl(struct soap *soap, const struct __tad__DeleteAnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out___tad__DeleteAnalyticsEngineControl(soap, tag ? tag : "-tad:DeleteAnalyticsEngineControl", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__DeleteAnalyticsEngineControl * SOAP_FMAC4 soap_get___tad__DeleteAnalyticsEngineControl(struct soap *soap, struct __tad__DeleteAnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__DeleteAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__GetServiceCapabilities(struct soap *soap, struct __tad__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__GetServiceCapabilities(struct soap *soap, const struct __tad__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__GetServiceCapabilities(soap, &a->tad__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tad__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__GetServiceCapabilities(soap, "tad:GetServiceCapabilities", -1, &a->tad__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetServiceCapabilities * SOAP_FMAC4 soap_in___tad__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tad__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tad__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tad__GetServiceCapabilities, sizeof(struct __tad__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tad__GetServiceCapabilities(soap, "tad:GetServiceCapabilities", &a->tad__GetServiceCapabilities, ""))
				{	soap_flag_tad__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__GetServiceCapabilities * SOAP_FMAC4 soap_new___tad__GetServiceCapabilities(struct soap *soap, int n)
{
	struct __tad__GetServiceCapabilities *p;
	struct __tad__GetServiceCapabilities *a = (struct __tad__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default___tad__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__GetServiceCapabilities(struct soap *soap, const struct __tad__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tad__GetServiceCapabilities(soap, tag ? tag : "-tad:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetServiceCapabilities * SOAP_FMAC4 soap_get___tad__GetServiceCapabilities(struct soap *soap, struct __tad__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause * SOAP_FMAC4 soap_new__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnavailableFaultType_FaultCause *p;
	struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnavailableFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description * SOAP_FMAC4 soap_in__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsrfr__ResourceUnavailableFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description, sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsrfr__ResourceUnavailableFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description * SOAP_FMAC4 soap_new__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnavailableFaultType_Description *p;
	struct _wsrfr__ResourceUnavailableFaultType_Description *a = (struct _wsrfr__ResourceUnavailableFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnavailableFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnavailableFaultType_Description(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description * SOAP_FMAC4 soap_get__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnavailableFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *p;
	struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrfr__ResourceUnavailableFaultType(struct soap *soap, struct wsrfr__ResourceUnavailableFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const struct wsrfr__ResourceUnavailableFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description);
			soap_serialize__wsrfr__ResourceUnavailableFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const char *tag, int id, const struct wsrfr__ResourceUnavailableFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsrfr__ResourceUnavailableFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrfr__ResourceUnavailableFaultType * SOAP_FMAC4 soap_in_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const char *tag, struct wsrfr__ResourceUnavailableFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrfr__ResourceUnavailableFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, sizeof(struct wsrfr__ResourceUnavailableFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrfr__ResourceUnavailableFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsrfr__ResourceUnavailableFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsrfr__ResourceUnavailableFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsrfr__ResourceUnavailableFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsrfr__ResourceUnavailableFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrfr__ResourceUnavailableFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, sizeof(struct wsrfr__ResourceUnavailableFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrfr__ResourceUnavailableFaultType * SOAP_FMAC4 soap_new_wsrfr__ResourceUnavailableFaultType(struct soap *soap, int n)
{
	struct wsrfr__ResourceUnavailableFaultType *p;
	struct wsrfr__ResourceUnavailableFaultType *a = (struct wsrfr__ResourceUnavailableFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsrfr__ResourceUnavailableFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsrfr__ResourceUnavailableFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const struct wsrfr__ResourceUnavailableFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsrfr__ResourceUnavailableFaultType(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrfr__ResourceUnavailableFaultType * SOAP_FMAC4 soap_get_wsrfr__ResourceUnavailableFaultType(struct soap *soap, struct wsrfr__ResourceUnavailableFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfr__ResourceUnavailableFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnknownFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfr__ResourceUnknownFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause * SOAP_FMAC4 soap_new__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnknownFaultType_FaultCause *p;
	struct _wsrfr__ResourceUnknownFaultType_FaultCause *a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnknownFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnknownFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description * SOAP_FMAC4 soap_in__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsrfr__ResourceUnknownFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description, sizeof(struct _wsrfr__ResourceUnknownFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsrfr__ResourceUnknownFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description * SOAP_FMAC4 soap_new__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnknownFaultType_Description *p;
	struct _wsrfr__ResourceUnknownFaultType_Description *a = (struct _wsrfr__ResourceUnknownFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnknownFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnknownFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnknownFaultType_Description(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description * SOAP_FMAC4 soap_get__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnknownFaultType_ErrorCode *p;
	struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrfr__ResourceUnknownFaultType(struct soap *soap, struct wsrfr__ResourceUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrfr__ResourceUnknownFaultType(struct soap *soap, const struct wsrfr__ResourceUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description);
			soap_serialize__wsrfr__ResourceUnknownFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, int id, const struct wsrfr__ResourceUnknownFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsrfr__ResourceUnknownFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType * SOAP_FMAC4 soap_in_wsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, struct wsrfr__ResourceUnknownFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsrfr__ResourceUnknownFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(struct wsrfr__ResourceUnknownFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrfr__ResourceUnknownFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsrfr__ResourceUnknownFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsrfr__ResourceUnknownFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsrfr__ResourceUnknownFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsrfr__ResourceUnknownFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsrfr__ResourceUnknownFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrfr__ResourceUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(struct wsrfr__ResourceUnknownFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType * SOAP_FMAC4 soap_new_wsrfr__ResourceUnknownFaultType(struct soap *soap, int n)
{
	struct wsrfr__ResourceUnknownFaultType *p;
	struct wsrfr__ResourceUnknownFaultType *a = (struct wsrfr__ResourceUnknownFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsrfr__ResourceUnknownFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsrfr__ResourceUnknownFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrfr__ResourceUnknownFaultType(struct soap *soap, const struct wsrfr__ResourceUnknownFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsrfr__ResourceUnknownFaultType(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType * SOAP_FMAC4 soap_get_wsrfr__ResourceUnknownFaultType(struct soap *soap, struct wsrfr__ResourceUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfr__ResourceUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__TopicType(struct soap *soap, struct wstop__TopicType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	a->MessagePattern = NULL;
	a->__sizeTopic = 0;
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	a->messageTypes = NULL;
	a->final_ = (enum xsd__boolean)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__TopicType(struct soap *soap, const struct wstop__TopicType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &a->MessagePattern);
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
		{
			soap_embedded(soap, a->Topic + i, SOAP_TYPE_wstop__TopicType);
			soap_serialize_wstop__TopicType(soap, a->Topic + i);
		}
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicType(struct soap *soap, const char *tag, int id, const struct wstop__TopicType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "name", a->name ? soap_xsd__NCName2s(soap, a->name) : "", 1);
	if (a->messageTypes)
	{	if (*a->messageTypes)
			soap_set_attr(soap, "messageTypes", soap__QName2s(soap, *a->messageTypes), 1);
	}
	if (a->final_ != (enum xsd__boolean)0)
	{	soap_set_attr(soap, "final", soap_xsd__boolean2s(soap, a->final_), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicType), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->MessagePattern, ""))
		return soap->error;
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
			if (soap_out_wstop__TopicType(soap, "wstop:Topic", -1, a->Topic + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__TopicType * SOAP_FMAC4 soap_in_wstop__TopicType(struct soap *soap, const char *tag, struct wstop__TopicType *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	size_t soap_flag_MessagePattern = 1;
	struct soap_blist *soap_blist_Topic = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__TopicType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__TopicType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &a->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(a->messageTypes = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_QName(soap, t, a->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "final", 5, 0), &a->final_))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap_flag_MessagePattern && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->Topic == NULL)
				{	if (soap_blist_Topic == NULL)
						soap_blist_Topic = soap_alloc_block(soap);
					a->Topic = (struct wstop__TopicType *)soap_push_block_max(soap, soap_blist_Topic, sizeof(struct wstop__TopicType));
					if (a->Topic == NULL)
						return NULL;
					soap_default_wstop__TopicType(soap, a->Topic);
				}
				soap_revert(soap);
				if (soap_in_wstop__TopicType(soap, "wstop:Topic", a->Topic, "wstop:TopicType"))
				{	a->__sizeTopic++;
					a->Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Topic)
			soap_pop_block(soap, soap_blist_Topic);
		if (a->__sizeTopic)
		{	a->Topic = (struct wstop__TopicType *)soap_save_block(soap, soap_blist_Topic, NULL, 1);
		}
		else
		{	a->Topic = NULL;
			if (soap_blist_Topic)
				soap_end_block(soap, soap_blist_Topic);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicType, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__TopicType * SOAP_FMAC4 soap_new_wstop__TopicType(struct soap *soap, int n)
{
	struct wstop__TopicType *p;
	struct wstop__TopicType *a = (struct wstop__TopicType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__TopicType));
	for (p = a; p && n--; p++)
		soap_default_wstop__TopicType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__TopicType(struct soap *soap, const struct wstop__TopicType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicType * SOAP_FMAC4 soap_get_wstop__TopicType(struct soap *soap, struct wstop__TopicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	a->MessagePattern = NULL;
	a->__sizeTopic = 0;
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	a->messageTypes = NULL;
	a->final_ = (enum xsd__boolean)0;
	soap_default_wstop__ConcreteTopicExpression(soap, &a->parent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wstop__TopicNamespaceType_Topic(struct soap *soap, const struct _wstop__TopicNamespaceType_Topic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &a->MessagePattern);
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
		{
			soap_embedded(soap, a->Topic + i, SOAP_TYPE_wstop__TopicType);
			soap_serialize_wstop__TopicType(soap, a->Topic + i);
		}
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const struct _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	soap_set_attr(soap, "name", a->name ? soap_xsd__NCName2s(soap, a->name) : "", 1);
	if (a->messageTypes)
	{	if (*a->messageTypes)
			soap_set_attr(soap, "messageTypes", soap__QName2s(soap, *a->messageTypes), 1);
	}
	if (a->final_ != (enum xsd__boolean)0)
	{	soap_set_attr(soap, "final", soap_xsd__boolean2s(soap, a->final_), 1);
	}
	if (a->parent)
		soap_set_attr(soap, "parent", soap_wstop__ConcreteTopicExpression2s(soap, a->parent), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->MessagePattern, ""))
		return soap->error;
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
			if (soap_out_wstop__TopicType(soap, "wstop:Topic", -1, a->Topic + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_in__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, struct _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	size_t soap_flag_MessagePattern = 1;
	struct soap_blist *soap_blist_Topic = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wstop__TopicNamespaceType_Topic*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wstop__TopicNamespaceType_Topic(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 1), &a->name))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "messageTypes", 2, 0);
		if (t)
		{
			if (!(a->messageTypes = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_QName(soap, t, a->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "final", 5, 0), &a->final_))
		return NULL;
	if (soap_s2wstop__ConcreteTopicExpression(soap, soap_attr_value(soap, "parent", 5, 0), &a->parent))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap_flag_MessagePattern && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->Topic == NULL)
				{	if (soap_blist_Topic == NULL)
						soap_blist_Topic = soap_alloc_block(soap);
					a->Topic = (struct wstop__TopicType *)soap_push_block_max(soap, soap_blist_Topic, sizeof(struct wstop__TopicType));
					if (a->Topic == NULL)
						return NULL;
					soap_default_wstop__TopicType(soap, a->Topic);
				}
				soap_revert(soap);
				if (soap_in_wstop__TopicType(soap, "wstop:Topic", a->Topic, "wstop:TopicType"))
				{	a->__sizeTopic++;
					a->Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Topic)
			soap_pop_block(soap, soap_blist_Topic);
		if (a->__sizeTopic)
		{	a->Topic = (struct wstop__TopicType *)soap_save_block(soap, soap_blist_Topic, NULL, 1);
		}
		else
		{	a->Topic = NULL;
			if (soap_blist_Topic)
				soap_end_block(soap, soap_blist_Topic);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wstop__TopicNamespaceType_Topic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wstop__TopicNamespaceType_Topic, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_new__wstop__TopicNamespaceType_Topic(struct soap *soap, int n)
{
	struct _wstop__TopicNamespaceType_Topic *p;
	struct _wstop__TopicNamespaceType_Topic *a = (struct _wstop__TopicNamespaceType_Topic*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wstop__TopicNamespaceType_Topic));
	for (p = a; p && n--; p++)
		soap_default__wstop__TopicNamespaceType_Topic(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wstop__TopicNamespaceType_Topic(struct soap *soap, const struct _wstop__TopicNamespaceType_Topic *a, const char *tag, const char *type)
{
	if (soap_out__wstop__TopicNamespaceType_Topic(soap, tag ? tag : "wstop:TopicNamespaceType-Topic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_get__wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *p, const char *tag, const char *type)
{
	if ((p = soap_in__wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__TopicNamespaceType(struct soap *soap, struct wstop__TopicNamespaceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	a->__sizeTopic = 0;
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	soap_default_xsd__anyURI(soap, &a->targetNamespace);
	a->final_ = (enum xsd__boolean)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__TopicNamespaceType(struct soap *soap, const struct wstop__TopicNamespaceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
		{
			soap_embedded(soap, a->Topic + i, SOAP_TYPE__wstop__TopicNamespaceType_Topic);
			soap_serialize__wstop__TopicNamespaceType_Topic(soap, a->Topic + i);
		}
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicNamespaceType(struct soap *soap, const char *tag, int id, const struct wstop__TopicNamespaceType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (a->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, a->name), 1);
	soap_set_attr(soap, "targetNamespace", a->targetNamespace ? soap_xsd__anyURI2s(soap, a->targetNamespace) : "", 1);
	if (a->final_ != (enum xsd__boolean)0)
	{	soap_set_attr(soap, "final", soap_xsd__boolean2s(soap, a->final_), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicNamespaceType), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
			if (soap_out__wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", -1, a->Topic + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__TopicNamespaceType * SOAP_FMAC4 soap_in_wstop__TopicNamespaceType(struct soap *soap, const char *tag, struct wstop__TopicNamespaceType *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	struct soap_blist *soap_blist_Topic = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wstop__TopicNamespaceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(struct wstop__TopicNamespaceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__TopicNamespaceType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 5, 0), &a->name))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 4, 1), &a->targetNamespace))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "final", 5, 0), &a->final_))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->Topic == NULL)
				{	if (soap_blist_Topic == NULL)
						soap_blist_Topic = soap_alloc_block(soap);
					a->Topic = (struct _wstop__TopicNamespaceType_Topic *)soap_push_block_max(soap, soap_blist_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic));
					if (a->Topic == NULL)
						return NULL;
					soap_default__wstop__TopicNamespaceType_Topic(soap, a->Topic);
				}
				soap_revert(soap);
				if (soap_in__wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", a->Topic, ""))
				{	a->__sizeTopic++;
					a->Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Topic)
			soap_pop_block(soap, soap_blist_Topic);
		if (a->__sizeTopic)
		{	a->Topic = (struct _wstop__TopicNamespaceType_Topic *)soap_save_block(soap, soap_blist_Topic, NULL, 1);
		}
		else
		{	a->Topic = NULL;
			if (soap_blist_Topic)
				soap_end_block(soap, soap_blist_Topic);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicNamespaceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicNamespaceType, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(struct wstop__TopicNamespaceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__TopicNamespaceType * SOAP_FMAC4 soap_new_wstop__TopicNamespaceType(struct soap *soap, int n)
{
	struct wstop__TopicNamespaceType *p;
	struct wstop__TopicNamespaceType *a = (struct wstop__TopicNamespaceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__TopicNamespaceType));
	for (p = a; p && n--; p++)
		soap_default_wstop__TopicNamespaceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__TopicNamespaceType(struct soap *soap, const struct wstop__TopicNamespaceType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__TopicNamespaceType(soap, tag ? tag : "wstop:TopicNamespaceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicNamespaceType * SOAP_FMAC4 soap_get_wstop__TopicNamespaceType(struct soap *soap, struct wstop__TopicNamespaceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicNamespaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__ResumeFailedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeFailedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__ResumeFailedFaultType_FaultCause *p;
	struct _wsnt__ResumeFailedFaultType_FaultCause *a = (struct _wsnt__ResumeFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:ResumeFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__ResumeFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__ResumeFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__ResumeFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__ResumeFailedFaultType_Description *p;
	struct _wsnt__ResumeFailedFaultType_Description *a = (struct _wsnt__ResumeFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeFailedFaultType_Description(soap, tag ? tag : "wsnt:ResumeFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeFailedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__ResumeFailedFaultType_ErrorCode *p;
	struct _wsnt__ResumeFailedFaultType_ErrorCode *a = (struct _wsnt__ResumeFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:ResumeFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__ResumeFailedFaultType(struct soap *soap, const struct wsnt__ResumeFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description);
			soap_serialize__wsnt__ResumeFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__ResumeFailedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__ResumeFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_in_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, struct wsnt__ResumeFailedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__ResumeFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__ResumeFailedFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__ResumeFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__ResumeFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__ResumeFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__ResumeFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__ResumeFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__ResumeFailedFaultType, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_new_wsnt__ResumeFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__ResumeFailedFaultType *p;
	struct wsnt__ResumeFailedFaultType *a = (struct wsnt__ResumeFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__ResumeFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__ResumeFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__ResumeFailedFaultType(struct soap *soap, const struct wsnt__ResumeFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__ResumeFailedFaultType(soap, tag ? tag : "wsnt:ResumeFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_get_wsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &a->__any);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__PauseFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__any, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__any);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &a->__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__PauseFailedFaultType_FaultCause*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseFailedFaultType_FaultCause(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-any", &a->__any, "xsd:anyType"))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__PauseFailedFaultType_FaultCause *p;
	struct _wsnt__PauseFailedFaultType_FaultCause *a = (struct _wsnt__PauseFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__PauseFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:PauseFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseFailedFaultType_Description(struct soap *soap, const struct _wsnt__PauseFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_Description *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct _wsnt__PauseFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description, sizeof(struct _wsnt__PauseFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__PauseFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 1, 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__PauseFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__PauseFailedFaultType_Description *p;
	struct _wsnt__PauseFailedFaultType_Description *a = (struct _wsnt__PauseFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseFailedFaultType_Description(struct soap *soap, const struct _wsnt__PauseFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseFailedFaultType_Description(soap, tag ? tag : "wsnt:PauseFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	soap_default_xsd__anyType(soap, &a->__mixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__PauseFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__mixed, SOAP_TYPE_xsd__anyType);
	soap_serialize_xsd__anyType(soap, &a->__mixed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseFailedFaultType_ErrorCode *a, const char *type)
{
	soap_set_attr(soap, "dialect", a->dialect ? soap_xsd__anyURI2s(soap, a->dialect) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &a->__mixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _wsnt__PauseFailedFaultType_ErrorCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 4, 1), &a->dialect))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__anyType(soap, "-mixed", &a->__mixed, "xsd:anyType"))
				{	soap_flag___mixed--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__PauseFailedFaultType_ErrorCode *p;
	struct _wsnt__PauseFailedFaultType_ErrorCode *a = (struct _wsnt__PauseFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__PauseFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:PauseFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__PauseFailedFaultType(struct soap *soap, const struct wsnt__PauseFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__PauseFailedFaultType_Description);
			soap_serialize__wsnt__PauseFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__PauseFailedFaultType *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__PauseFailedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__PauseFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_in_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, struct wsnt__PauseFailedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsnt__PauseFailedFaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__PauseFailedFaultType(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__PauseFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__PauseFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__PauseFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__PauseFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__PauseFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__PauseFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__PauseFailedFaultType, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_new_wsnt__PauseFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__PauseFailedFaultType *p;
	struct wsnt__PauseFailedFaultType *a = (struct wsnt__PauseFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__PauseFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__PauseFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__PauseFailedFaultType(struct soap *soap, const struct wsnt__PauseFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__PauseFailedFaultType(soap, tag ? tag : "wsnt:PauseFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_get_wsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
