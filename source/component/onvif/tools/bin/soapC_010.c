/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:05 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputConfigurations(struct soap *soap, struct _trt__GetAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputConfigurations(struct soap *soap, const struct _trt__GetAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurations * SOAP_FMAC4 soap_in__trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioOutputConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurations, sizeof(struct _trt__GetAudioOutputConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurations, SOAP_TYPE__trt__GetAudioOutputConfigurations, sizeof(struct _trt__GetAudioOutputConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurations * SOAP_FMAC4 soap_new__trt__GetAudioOutputConfigurations(struct soap *soap, int n)
{
	struct _trt__GetAudioOutputConfigurations *p;
	struct _trt__GetAudioOutputConfigurations *a = (struct _trt__GetAudioOutputConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioOutputConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioOutputConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputConfigurations(struct soap *soap, const struct _trt__GetAudioOutputConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioOutputConfigurations(soap, tag ? tag : "trt:GetAudioOutputConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurations * SOAP_FMAC4 soap_get__trt__GetAudioOutputConfigurations(struct soap *soap, struct _trt__GetAudioOutputConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetMetadataConfigurationsResponse(struct soap *soap, const struct _trt__GetMetadataConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__MetadataConfiguration);
			soap_serialize_tt__MetadataConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetMetadataConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetMetadataConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__MetadataConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetMetadataConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurationsResponse, sizeof(struct _trt__GetMetadataConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetMetadataConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__MetadataConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__MetadataConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__MetadataConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__MetadataConfiguration(soap, "trt:Configurations", a->Configurations, "tt:MetadataConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__MetadataConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurationsResponse, SOAP_TYPE__trt__GetMetadataConfigurationsResponse, sizeof(struct _trt__GetMetadataConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationsResponse * SOAP_FMAC4 soap_new__trt__GetMetadataConfigurationsResponse(struct soap *soap, int n)
{
	struct _trt__GetMetadataConfigurationsResponse *p;
	struct _trt__GetMetadataConfigurationsResponse *a = (struct _trt__GetMetadataConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetMetadataConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetMetadataConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetMetadataConfigurationsResponse(struct soap *soap, const struct _trt__GetMetadataConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetMetadataConfigurationsResponse(soap, tag ? tag : "trt:GetMetadataConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetMetadataConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetMetadataConfigurations(struct soap *soap, struct _trt__GetMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetMetadataConfigurations(struct soap *soap, const struct _trt__GetMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetMetadataConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetMetadataConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetMetadataConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurations * SOAP_FMAC4 soap_in__trt__GetMetadataConfigurations(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetMetadataConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurations, sizeof(struct _trt__GetMetadataConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetMetadataConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurations, SOAP_TYPE__trt__GetMetadataConfigurations, sizeof(struct _trt__GetMetadataConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurations * SOAP_FMAC4 soap_new__trt__GetMetadataConfigurations(struct soap *soap, int n)
{
	struct _trt__GetMetadataConfigurations *p;
	struct _trt__GetMetadataConfigurations *a = (struct _trt__GetMetadataConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetMetadataConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetMetadataConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetMetadataConfigurations(struct soap *soap, const struct _trt__GetMetadataConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetMetadataConfigurations(soap, tag ? tag : "trt:GetMetadataConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurations * SOAP_FMAC4 soap_get__trt__GetMetadataConfigurations(struct soap *soap, struct _trt__GetMetadataConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoAnalyticsConfiguration);
			soap_serialize_tt__VideoAnalyticsConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoAnalyticsConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoAnalyticsConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetVideoAnalyticsConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoAnalyticsConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__VideoAnalyticsConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__VideoAnalyticsConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoAnalyticsConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoAnalyticsConfiguration(soap, "trt:Configurations", a->Configurations, "tt:VideoAnalyticsConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__VideoAnalyticsConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_new__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, int n)
{
	struct _trt__GetVideoAnalyticsConfigurationsResponse *p;
	struct _trt__GetVideoAnalyticsConfigurationsResponse *a = (struct _trt__GetVideoAnalyticsConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoAnalyticsConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoAnalyticsConfigurationsResponse(soap, tag ? tag : "trt:GetVideoAnalyticsConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoAnalyticsConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoAnalyticsConfigurations(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoAnalyticsConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_in__trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetVideoAnalyticsConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, sizeof(struct _trt__GetVideoAnalyticsConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoAnalyticsConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, sizeof(struct _trt__GetVideoAnalyticsConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_new__trt__GetVideoAnalyticsConfigurations(struct soap *soap, int n)
{
	struct _trt__GetVideoAnalyticsConfigurations *p;
	struct _trt__GetVideoAnalyticsConfigurations *a = (struct _trt__GetVideoAnalyticsConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoAnalyticsConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoAnalyticsConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoAnalyticsConfigurations(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoAnalyticsConfigurations(soap, tag ? tag : "trt:GetVideoAnalyticsConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_get__trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioSourceConfiguration);
			soap_serialize_tt__AudioSourceConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourceConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioSourceConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioSourceConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, sizeof(struct _trt__GetAudioSourceConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSourceConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__AudioSourceConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__AudioSourceConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioSourceConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioSourceConfiguration(soap, "trt:Configurations", a->Configurations, "tt:AudioSourceConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__AudioSourceConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, sizeof(struct _trt__GetAudioSourceConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_new__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioSourceConfigurationsResponse *p;
	struct _trt__GetAudioSourceConfigurationsResponse *a = (struct _trt__GetAudioSourceConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioSourceConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioSourceConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioSourceConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioSourceConfigurationsResponse(soap, tag ? tag : "trt:GetAudioSourceConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourceConfigurations(struct soap *soap, struct _trt__GetAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourceConfigurations(struct soap *soap, const struct _trt__GetAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourceConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurations * SOAP_FMAC4 soap_in__trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioSourceConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurations, sizeof(struct _trt__GetAudioSourceConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSourceConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurations, SOAP_TYPE__trt__GetAudioSourceConfigurations, sizeof(struct _trt__GetAudioSourceConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurations * SOAP_FMAC4 soap_new__trt__GetAudioSourceConfigurations(struct soap *soap, int n)
{
	struct _trt__GetAudioSourceConfigurations *p;
	struct _trt__GetAudioSourceConfigurations *a = (struct _trt__GetAudioSourceConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioSourceConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioSourceConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSourceConfigurations(struct soap *soap, const struct _trt__GetAudioSourceConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioSourceConfigurations(soap, tag ? tag : "trt:GetAudioSourceConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurations * SOAP_FMAC4 soap_get__trt__GetAudioSourceConfigurations(struct soap *soap, struct _trt__GetAudioSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioEncoderConfiguration);
			soap_serialize_tt__AudioEncoderConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioEncoderConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioEncoderConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioEncoderConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioEncoderConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__AudioEncoderConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__AudioEncoderConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioEncoderConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioEncoderConfiguration(soap, "trt:Configurations", a->Configurations, "tt:AudioEncoderConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__AudioEncoderConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_new__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioEncoderConfigurationsResponse *p;
	struct _trt__GetAudioEncoderConfigurationsResponse *a = (struct _trt__GetAudioEncoderConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioEncoderConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioEncoderConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioEncoderConfigurationsResponse(soap, tag ? tag : "trt:GetAudioEncoderConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioEncoderConfigurations(struct soap *soap, struct _trt__GetAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioEncoderConfigurations(struct soap *soap, const struct _trt__GetAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurations * SOAP_FMAC4 soap_in__trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioEncoderConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurations, sizeof(struct _trt__GetAudioEncoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioEncoderConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurations, SOAP_TYPE__trt__GetAudioEncoderConfigurations, sizeof(struct _trt__GetAudioEncoderConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurations * SOAP_FMAC4 soap_new__trt__GetAudioEncoderConfigurations(struct soap *soap, int n)
{
	struct _trt__GetAudioEncoderConfigurations *p;
	struct _trt__GetAudioEncoderConfigurations *a = (struct _trt__GetAudioEncoderConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioEncoderConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioEncoderConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioEncoderConfigurations(struct soap *soap, const struct _trt__GetAudioEncoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioEncoderConfigurations(soap, tag ? tag : "trt:GetAudioEncoderConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurations * SOAP_FMAC4 soap_get__trt__GetAudioEncoderConfigurations(struct soap *soap, struct _trt__GetAudioEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoSourceConfiguration);
			soap_serialize_tt__VideoSourceConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoSourceConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetVideoSourceConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, sizeof(struct _trt__GetVideoSourceConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__VideoSourceConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__VideoSourceConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoSourceConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoSourceConfiguration(soap, "trt:Configurations", a->Configurations, "tt:VideoSourceConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__VideoSourceConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, sizeof(struct _trt__GetVideoSourceConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_new__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, int n)
{
	struct _trt__GetVideoSourceConfigurationsResponse *p;
	struct _trt__GetVideoSourceConfigurationsResponse *a = (struct _trt__GetVideoSourceConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoSourceConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoSourceConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoSourceConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoSourceConfigurationsResponse(soap, tag ? tag : "trt:GetVideoSourceConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceConfigurations(struct soap *soap, struct _trt__GetVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceConfigurations(struct soap *soap, const struct _trt__GetVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurations * SOAP_FMAC4 soap_in__trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetVideoSourceConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurations, sizeof(struct _trt__GetVideoSourceConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurations, SOAP_TYPE__trt__GetVideoSourceConfigurations, sizeof(struct _trt__GetVideoSourceConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurations * SOAP_FMAC4 soap_new__trt__GetVideoSourceConfigurations(struct soap *soap, int n)
{
	struct _trt__GetVideoSourceConfigurations *p;
	struct _trt__GetVideoSourceConfigurations *a = (struct _trt__GetVideoSourceConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoSourceConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoSourceConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceConfigurations(struct soap *soap, const struct _trt__GetVideoSourceConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoSourceConfigurations(soap, tag ? tag : "trt:GetVideoSourceConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurations * SOAP_FMAC4 soap_get__trt__GetVideoSourceConfigurations(struct soap *soap, struct _trt__GetVideoSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoEncoderConfiguration);
			soap_serialize_tt__VideoEncoderConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoEncoderConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetVideoEncoderConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoEncoderConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__VideoEncoderConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__VideoEncoderConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoEncoderConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoEncoderConfiguration(soap, "trt:Configurations", a->Configurations, "tt:VideoEncoderConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__VideoEncoderConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_new__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, int n)
{
	struct _trt__GetVideoEncoderConfigurationsResponse *p;
	struct _trt__GetVideoEncoderConfigurationsResponse *a = (struct _trt__GetVideoEncoderConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoEncoderConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoEncoderConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoEncoderConfigurationsResponse(soap, tag ? tag : "trt:GetVideoEncoderConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfigurations(struct soap *soap, struct _trt__GetVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfigurations(struct soap *soap, const struct _trt__GetVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurations * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetVideoEncoderConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurations, sizeof(struct _trt__GetVideoEncoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoEncoderConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurations, SOAP_TYPE__trt__GetVideoEncoderConfigurations, sizeof(struct _trt__GetVideoEncoderConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurations * SOAP_FMAC4 soap_new__trt__GetVideoEncoderConfigurations(struct soap *soap, int n)
{
	struct _trt__GetVideoEncoderConfigurations *p;
	struct _trt__GetVideoEncoderConfigurations *a = (struct _trt__GetVideoEncoderConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoEncoderConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoEncoderConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfigurations(struct soap *soap, const struct _trt__GetVideoEncoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoEncoderConfigurations(soap, tag ? tag : "trt:GetVideoEncoderConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurations * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfigurations(struct soap *soap, struct _trt__GetVideoEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__DeleteProfileResponse(struct soap *soap, const struct _trt__DeleteProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__DeleteProfileResponse(struct soap *soap, const char *tag, int id, const struct _trt__DeleteProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__DeleteProfileResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse * SOAP_FMAC4 soap_in__trt__DeleteProfileResponse(struct soap *soap, const char *tag, struct _trt__DeleteProfileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__DeleteProfileResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(struct _trt__DeleteProfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__DeleteProfileResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteProfileResponse, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(struct _trt__DeleteProfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse * SOAP_FMAC4 soap_new__trt__DeleteProfileResponse(struct soap *soap, int n)
{
	struct _trt__DeleteProfileResponse *p;
	struct _trt__DeleteProfileResponse *a = (struct _trt__DeleteProfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__DeleteProfileResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__DeleteProfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__DeleteProfileResponse(struct soap *soap, const struct _trt__DeleteProfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__DeleteProfileResponse(soap, tag ? tag : "trt:DeleteProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse * SOAP_FMAC4 soap_get__trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__DeleteProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__DeleteProfile(struct soap *soap, const struct _trt__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__DeleteProfile(struct soap *soap, const char *tag, int id, const struct _trt__DeleteProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__DeleteProfile), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__DeleteProfile * SOAP_FMAC4 soap_in__trt__DeleteProfile(struct soap *soap, const char *tag, struct _trt__DeleteProfile *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__DeleteProfile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteProfile, sizeof(struct _trt__DeleteProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__DeleteProfile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__DeleteProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteProfile, SOAP_TYPE__trt__DeleteProfile, sizeof(struct _trt__DeleteProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__DeleteProfile * SOAP_FMAC4 soap_new__trt__DeleteProfile(struct soap *soap, int n)
{
	struct _trt__DeleteProfile *p;
	struct _trt__DeleteProfile *a = (struct _trt__DeleteProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__DeleteProfile));
	for (p = a; p && n--; p++)
		soap_default__trt__DeleteProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__DeleteProfile(struct soap *soap, const struct _trt__DeleteProfile *a, const char *tag, const char *type)
{
	if (soap_out__trt__DeleteProfile(soap, tag ? tag : "trt:DeleteProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteProfile * SOAP_FMAC4 soap_get__trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__DeleteProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioDecoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioDecoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveAudioDecoderConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioDecoderConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioDecoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveAudioDecoderConfigurationResponse *p;
	struct _trt__RemoveAudioDecoderConfigurationResponse *a = (struct _trt__RemoveAudioDecoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioDecoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioDecoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioDecoderConfigurationResponse(soap, tag ? tag : "trt:RemoveAudioDecoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioDecoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct _trt__RemoveAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioDecoderConfiguration(struct soap *soap, const struct _trt__RemoveAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfiguration * SOAP_FMAC4 soap_in__trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveAudioDecoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, sizeof(struct _trt__RemoveAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioDecoderConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, sizeof(struct _trt__RemoveAudioDecoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfiguration * SOAP_FMAC4 soap_new__trt__RemoveAudioDecoderConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveAudioDecoderConfiguration *p;
	struct _trt__RemoveAudioDecoderConfiguration *a = (struct _trt__RemoveAudioDecoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioDecoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioDecoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioDecoderConfiguration(struct soap *soap, const struct _trt__RemoveAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioDecoderConfiguration(soap, tag ? tag : "trt:RemoveAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfiguration * SOAP_FMAC4 soap_get__trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct _trt__RemoveAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__AddAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioDecoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioDecoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddAudioDecoderConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, sizeof(struct _trt__AddAudioDecoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioDecoderConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioDecoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, sizeof(struct _trt__AddAudioDecoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddAudioDecoderConfigurationResponse *p;
	struct _trt__AddAudioDecoderConfigurationResponse *a = (struct _trt__AddAudioDecoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioDecoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioDecoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__AddAudioDecoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioDecoderConfigurationResponse(soap, tag ? tag : "trt:AddAudioDecoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioDecoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioDecoderConfiguration(struct soap *soap, struct _trt__AddAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioDecoderConfiguration(struct soap *soap, const struct _trt__AddAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioDecoderConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "trt:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfiguration * SOAP_FMAC4 soap_in__trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddAudioDecoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioDecoderConfiguration, sizeof(struct _trt__AddAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioDecoderConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioDecoderConfiguration, SOAP_TYPE__trt__AddAudioDecoderConfiguration, sizeof(struct _trt__AddAudioDecoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfiguration * SOAP_FMAC4 soap_new__trt__AddAudioDecoderConfiguration(struct soap *soap, int n)
{
	struct _trt__AddAudioDecoderConfiguration *p;
	struct _trt__AddAudioDecoderConfiguration *a = (struct _trt__AddAudioDecoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioDecoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioDecoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioDecoderConfiguration(struct soap *soap, const struct _trt__AddAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioDecoderConfiguration(soap, tag ? tag : "trt:AddAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfiguration * SOAP_FMAC4 soap_get__trt__AddAudioDecoderConfiguration(struct soap *soap, struct _trt__AddAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioOutputConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioOutputConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveAudioOutputConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioOutputConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveAudioOutputConfigurationResponse *p;
	struct _trt__RemoveAudioOutputConfigurationResponse *a = (struct _trt__RemoveAudioOutputConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioOutputConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioOutputConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioOutputConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioOutputConfigurationResponse(soap, tag ? tag : "trt:RemoveAudioOutputConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioOutputConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioOutputConfiguration(struct soap *soap, struct _trt__RemoveAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioOutputConfiguration(struct soap *soap, const struct _trt__RemoveAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfiguration * SOAP_FMAC4 soap_in__trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveAudioOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, sizeof(struct _trt__RemoveAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioOutputConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, sizeof(struct _trt__RemoveAudioOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfiguration * SOAP_FMAC4 soap_new__trt__RemoveAudioOutputConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveAudioOutputConfiguration *p;
	struct _trt__RemoveAudioOutputConfiguration *a = (struct _trt__RemoveAudioOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioOutputConfiguration(struct soap *soap, const struct _trt__RemoveAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioOutputConfiguration(soap, tag ? tag : "trt:RemoveAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfiguration * SOAP_FMAC4 soap_get__trt__RemoveAudioOutputConfiguration(struct soap *soap, struct _trt__RemoveAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioOutputConfigurationResponse(struct soap *soap, struct _trt__AddAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__AddAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioOutputConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioOutputConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddAudioOutputConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, sizeof(struct _trt__AddAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioOutputConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, sizeof(struct _trt__AddAudioOutputConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddAudioOutputConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddAudioOutputConfigurationResponse *p;
	struct _trt__AddAudioOutputConfigurationResponse *a = (struct _trt__AddAudioOutputConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioOutputConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioOutputConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__AddAudioOutputConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioOutputConfigurationResponse(soap, tag ? tag : "trt:AddAudioOutputConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddAudioOutputConfigurationResponse(struct soap *soap, struct _trt__AddAudioOutputConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioOutputConfiguration(struct soap *soap, struct _trt__AddAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioOutputConfiguration(struct soap *soap, const struct _trt__AddAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioOutputConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "trt:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfiguration * SOAP_FMAC4 soap_in__trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddAudioOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioOutputConfiguration, sizeof(struct _trt__AddAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioOutputConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioOutputConfiguration, SOAP_TYPE__trt__AddAudioOutputConfiguration, sizeof(struct _trt__AddAudioOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfiguration * SOAP_FMAC4 soap_new__trt__AddAudioOutputConfiguration(struct soap *soap, int n)
{
	struct _trt__AddAudioOutputConfiguration *p;
	struct _trt__AddAudioOutputConfiguration *a = (struct _trt__AddAudioOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioOutputConfiguration(struct soap *soap, const struct _trt__AddAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioOutputConfiguration(soap, tag ? tag : "trt:AddAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfiguration * SOAP_FMAC4 soap_get__trt__AddAudioOutputConfiguration(struct soap *soap, struct _trt__AddAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveMetadataConfigurationResponse(struct soap *soap, struct _trt__RemoveMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveMetadataConfigurationResponse(struct soap *soap, const struct _trt__RemoveMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveMetadataConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveMetadataConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveMetadataConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, sizeof(struct _trt__RemoveMetadataConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveMetadataConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveMetadataConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, sizeof(struct _trt__RemoveMetadataConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveMetadataConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveMetadataConfigurationResponse *p;
	struct _trt__RemoveMetadataConfigurationResponse *a = (struct _trt__RemoveMetadataConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveMetadataConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveMetadataConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveMetadataConfigurationResponse(struct soap *soap, const struct _trt__RemoveMetadataConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveMetadataConfigurationResponse(soap, tag ? tag : "trt:RemoveMetadataConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveMetadataConfigurationResponse(struct soap *soap, struct _trt__RemoveMetadataConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveMetadataConfiguration(struct soap *soap, struct _trt__RemoveMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveMetadataConfiguration(struct soap *soap, const struct _trt__RemoveMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveMetadataConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfiguration * SOAP_FMAC4 soap_in__trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveMetadataConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveMetadataConfiguration, sizeof(struct _trt__RemoveMetadataConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveMetadataConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveMetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveMetadataConfiguration, SOAP_TYPE__trt__RemoveMetadataConfiguration, sizeof(struct _trt__RemoveMetadataConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfiguration * SOAP_FMAC4 soap_new__trt__RemoveMetadataConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveMetadataConfiguration *p;
	struct _trt__RemoveMetadataConfiguration *a = (struct _trt__RemoveMetadataConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveMetadataConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveMetadataConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveMetadataConfiguration(struct soap *soap, const struct _trt__RemoveMetadataConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveMetadataConfiguration(soap, tag ? tag : "trt:RemoveMetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfiguration * SOAP_FMAC4 soap_get__trt__RemoveMetadataConfiguration(struct soap *soap, struct _trt__RemoveMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddMetadataConfigurationResponse(struct soap *soap, struct _trt__AddMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddMetadataConfigurationResponse(struct soap *soap, const struct _trt__AddMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddMetadataConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddMetadataConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddMetadataConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddMetadataConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddMetadataConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddMetadataConfigurationResponse, sizeof(struct _trt__AddMetadataConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddMetadataConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddMetadataConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddMetadataConfigurationResponse, SOAP_TYPE__trt__AddMetadataConfigurationResponse, sizeof(struct _trt__AddMetadataConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddMetadataConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddMetadataConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddMetadataConfigurationResponse *p;
	struct _trt__AddMetadataConfigurationResponse *a = (struct _trt__AddMetadataConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddMetadataConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddMetadataConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddMetadataConfigurationResponse(struct soap *soap, const struct _trt__AddMetadataConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddMetadataConfigurationResponse(soap, tag ? tag : "trt:AddMetadataConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddMetadataConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddMetadataConfigurationResponse(struct soap *soap, struct _trt__AddMetadataConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddMetadataConfiguration(struct soap *soap, struct _trt__AddMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddMetadataConfiguration(struct soap *soap, const struct _trt__AddMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddMetadataConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "trt:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddMetadataConfiguration * SOAP_FMAC4 soap_in__trt__AddMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__AddMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddMetadataConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddMetadataConfiguration, sizeof(struct _trt__AddMetadataConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddMetadataConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddMetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddMetadataConfiguration, SOAP_TYPE__trt__AddMetadataConfiguration, sizeof(struct _trt__AddMetadataConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddMetadataConfiguration * SOAP_FMAC4 soap_new__trt__AddMetadataConfiguration(struct soap *soap, int n)
{
	struct _trt__AddMetadataConfiguration *p;
	struct _trt__AddMetadataConfiguration *a = (struct _trt__AddMetadataConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddMetadataConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddMetadataConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddMetadataConfiguration(struct soap *soap, const struct _trt__AddMetadataConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddMetadataConfiguration(soap, tag ? tag : "trt:AddMetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddMetadataConfiguration * SOAP_FMAC4 soap_get__trt__AddMetadataConfiguration(struct soap *soap, struct _trt__AddMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoAnalyticsConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoAnalyticsConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoAnalyticsConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveVideoAnalyticsConfigurationResponse *p;
	struct _trt__RemoveVideoAnalyticsConfigurationResponse *a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveVideoAnalyticsConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoAnalyticsConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag ? tag : "trt:RemoveVideoAnalyticsConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__RemoveVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveVideoAnalyticsConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoAnalyticsConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC4 soap_new__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveVideoAnalyticsConfiguration *p;
	struct _trt__RemoveVideoAnalyticsConfiguration *a = (struct _trt__RemoveVideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveVideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveVideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__RemoveVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveVideoAnalyticsConfiguration(soap, tag ? tag : "trt:RemoveVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__AddVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__AddVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoAnalyticsConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoAnalyticsConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddVideoAnalyticsConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoAnalyticsConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddVideoAnalyticsConfigurationResponse *p;
	struct _trt__AddVideoAnalyticsConfigurationResponse *a = (struct _trt__AddVideoAnalyticsConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddVideoAnalyticsConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__AddVideoAnalyticsConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddVideoAnalyticsConfigurationResponse(soap, tag ? tag : "trt:AddVideoAnalyticsConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__AddVideoAnalyticsConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct _trt__AddVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__AddVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "trt:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in__trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddVideoAnalyticsConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, sizeof(struct _trt__AddVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoAnalyticsConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, sizeof(struct _trt__AddVideoAnalyticsConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfiguration * SOAP_FMAC4 soap_new__trt__AddVideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct _trt__AddVideoAnalyticsConfiguration *p;
	struct _trt__AddVideoAnalyticsConfiguration *a = (struct _trt__AddVideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddVideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddVideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__AddVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddVideoAnalyticsConfiguration(soap, tag ? tag : "trt:AddVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get__trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct _trt__AddVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemovePTZConfigurationResponse(struct soap *soap, struct _trt__RemovePTZConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemovePTZConfigurationResponse(struct soap *soap, const struct _trt__RemovePTZConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemovePTZConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemovePTZConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemovePTZConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemovePTZConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemovePTZConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemovePTZConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemovePTZConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemovePTZConfigurationResponse, sizeof(struct _trt__RemovePTZConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemovePTZConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemovePTZConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemovePTZConfigurationResponse, SOAP_TYPE__trt__RemovePTZConfigurationResponse, sizeof(struct _trt__RemovePTZConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemovePTZConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemovePTZConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemovePTZConfigurationResponse *p;
	struct _trt__RemovePTZConfigurationResponse *a = (struct _trt__RemovePTZConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemovePTZConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemovePTZConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemovePTZConfigurationResponse(struct soap *soap, const struct _trt__RemovePTZConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemovePTZConfigurationResponse(soap, tag ? tag : "trt:RemovePTZConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemovePTZConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemovePTZConfigurationResponse(struct soap *soap, struct _trt__RemovePTZConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemovePTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemovePTZConfiguration(struct soap *soap, struct _trt__RemovePTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemovePTZConfiguration(struct soap *soap, const struct _trt__RemovePTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemovePTZConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemovePTZConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemovePTZConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemovePTZConfiguration * SOAP_FMAC4 soap_in__trt__RemovePTZConfiguration(struct soap *soap, const char *tag, struct _trt__RemovePTZConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemovePTZConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemovePTZConfiguration, sizeof(struct _trt__RemovePTZConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemovePTZConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemovePTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemovePTZConfiguration, SOAP_TYPE__trt__RemovePTZConfiguration, sizeof(struct _trt__RemovePTZConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemovePTZConfiguration * SOAP_FMAC4 soap_new__trt__RemovePTZConfiguration(struct soap *soap, int n)
{
	struct _trt__RemovePTZConfiguration *p;
	struct _trt__RemovePTZConfiguration *a = (struct _trt__RemovePTZConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemovePTZConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemovePTZConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemovePTZConfiguration(struct soap *soap, const struct _trt__RemovePTZConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemovePTZConfiguration(soap, tag ? tag : "trt:RemovePTZConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemovePTZConfiguration * SOAP_FMAC4 soap_get__trt__RemovePTZConfiguration(struct soap *soap, struct _trt__RemovePTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemovePTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddPTZConfigurationResponse(struct soap *soap, struct _trt__AddPTZConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddPTZConfigurationResponse(struct soap *soap, const struct _trt__AddPTZConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddPTZConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddPTZConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddPTZConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddPTZConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddPTZConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddPTZConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddPTZConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddPTZConfigurationResponse, sizeof(struct _trt__AddPTZConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddPTZConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddPTZConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddPTZConfigurationResponse, SOAP_TYPE__trt__AddPTZConfigurationResponse, sizeof(struct _trt__AddPTZConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddPTZConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddPTZConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddPTZConfigurationResponse *p;
	struct _trt__AddPTZConfigurationResponse *a = (struct _trt__AddPTZConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddPTZConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddPTZConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddPTZConfigurationResponse(struct soap *soap, const struct _trt__AddPTZConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddPTZConfigurationResponse(soap, tag ? tag : "trt:AddPTZConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddPTZConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddPTZConfigurationResponse(struct soap *soap, struct _trt__AddPTZConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddPTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddPTZConfiguration(struct soap *soap, struct _trt__AddPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddPTZConfiguration(struct soap *soap, const struct _trt__AddPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddPTZConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddPTZConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddPTZConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "trt:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddPTZConfiguration * SOAP_FMAC4 soap_in__trt__AddPTZConfiguration(struct soap *soap, const char *tag, struct _trt__AddPTZConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddPTZConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddPTZConfiguration, sizeof(struct _trt__AddPTZConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddPTZConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddPTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddPTZConfiguration, SOAP_TYPE__trt__AddPTZConfiguration, sizeof(struct _trt__AddPTZConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddPTZConfiguration * SOAP_FMAC4 soap_new__trt__AddPTZConfiguration(struct soap *soap, int n)
{
	struct _trt__AddPTZConfiguration *p;
	struct _trt__AddPTZConfiguration *a = (struct _trt__AddPTZConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddPTZConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddPTZConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddPTZConfiguration(struct soap *soap, const struct _trt__AddPTZConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddPTZConfiguration(soap, tag ? tag : "trt:AddPTZConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddPTZConfiguration * SOAP_FMAC4 soap_get__trt__AddPTZConfiguration(struct soap *soap, struct _trt__AddPTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioSourceConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveAudioSourceConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioSourceConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveAudioSourceConfigurationResponse *p;
	struct _trt__RemoveAudioSourceConfigurationResponse *a = (struct _trt__RemoveAudioSourceConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioSourceConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioSourceConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioSourceConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioSourceConfigurationResponse(soap, tag ? tag : "trt:RemoveAudioSourceConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioSourceConfiguration(struct soap *soap, struct _trt__RemoveAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioSourceConfiguration(struct soap *soap, const struct _trt__RemoveAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfiguration * SOAP_FMAC4 soap_in__trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveAudioSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, sizeof(struct _trt__RemoveAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioSourceConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, sizeof(struct _trt__RemoveAudioSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfiguration * SOAP_FMAC4 soap_new__trt__RemoveAudioSourceConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveAudioSourceConfiguration *p;
	struct _trt__RemoveAudioSourceConfiguration *a = (struct _trt__RemoveAudioSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioSourceConfiguration(struct soap *soap, const struct _trt__RemoveAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioSourceConfiguration(soap, tag ? tag : "trt:RemoveAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfiguration * SOAP_FMAC4 soap_get__trt__RemoveAudioSourceConfiguration(struct soap *soap, struct _trt__RemoveAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioSourceConfigurationResponse(struct soap *soap, struct _trt__AddAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__AddAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioSourceConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddAudioSourceConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, sizeof(struct _trt__AddAudioSourceConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioSourceConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, sizeof(struct _trt__AddAudioSourceConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddAudioSourceConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddAudioSourceConfigurationResponse *p;
	struct _trt__AddAudioSourceConfigurationResponse *a = (struct _trt__AddAudioSourceConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioSourceConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioSourceConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__AddAudioSourceConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioSourceConfigurationResponse(soap, tag ? tag : "trt:AddAudioSourceConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddAudioSourceConfigurationResponse(struct soap *soap, struct _trt__AddAudioSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioSourceConfiguration(struct soap *soap, struct _trt__AddAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioSourceConfiguration(struct soap *soap, const struct _trt__AddAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioSourceConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "trt:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfiguration * SOAP_FMAC4 soap_in__trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddAudioSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioSourceConfiguration, sizeof(struct _trt__AddAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioSourceConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioSourceConfiguration, SOAP_TYPE__trt__AddAudioSourceConfiguration, sizeof(struct _trt__AddAudioSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfiguration * SOAP_FMAC4 soap_new__trt__AddAudioSourceConfiguration(struct soap *soap, int n)
{
	struct _trt__AddAudioSourceConfiguration *p;
	struct _trt__AddAudioSourceConfiguration *a = (struct _trt__AddAudioSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioSourceConfiguration(struct soap *soap, const struct _trt__AddAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioSourceConfiguration(soap, tag ? tag : "trt:AddAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfiguration * SOAP_FMAC4 soap_get__trt__AddAudioSourceConfiguration(struct soap *soap, struct _trt__AddAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioEncoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveAudioEncoderConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioEncoderConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveAudioEncoderConfigurationResponse *p;
	struct _trt__RemoveAudioEncoderConfigurationResponse *a = (struct _trt__RemoveAudioEncoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioEncoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioEncoderConfigurationResponse(soap, tag ? tag : "trt:RemoveAudioEncoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct _trt__RemoveAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioEncoderConfiguration(struct soap *soap, const struct _trt__RemoveAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfiguration * SOAP_FMAC4 soap_in__trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveAudioEncoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, sizeof(struct _trt__RemoveAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioEncoderConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, sizeof(struct _trt__RemoveAudioEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfiguration * SOAP_FMAC4 soap_new__trt__RemoveAudioEncoderConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveAudioEncoderConfiguration *p;
	struct _trt__RemoveAudioEncoderConfiguration *a = (struct _trt__RemoveAudioEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioEncoderConfiguration(struct soap *soap, const struct _trt__RemoveAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioEncoderConfiguration(soap, tag ? tag : "trt:RemoveAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfiguration * SOAP_FMAC4 soap_get__trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct _trt__RemoveAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__AddAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioEncoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddAudioEncoderConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, sizeof(struct _trt__AddAudioEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioEncoderConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, sizeof(struct _trt__AddAudioEncoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddAudioEncoderConfigurationResponse *p;
	struct _trt__AddAudioEncoderConfigurationResponse *a = (struct _trt__AddAudioEncoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioEncoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioEncoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__AddAudioEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioEncoderConfigurationResponse(soap, tag ? tag : "trt:AddAudioEncoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioEncoderConfiguration(struct soap *soap, struct _trt__AddAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioEncoderConfiguration(struct soap *soap, const struct _trt__AddAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioEncoderConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "trt:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfiguration * SOAP_FMAC4 soap_in__trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddAudioEncoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioEncoderConfiguration, sizeof(struct _trt__AddAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioEncoderConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddAudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioEncoderConfiguration, SOAP_TYPE__trt__AddAudioEncoderConfiguration, sizeof(struct _trt__AddAudioEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfiguration * SOAP_FMAC4 soap_new__trt__AddAudioEncoderConfiguration(struct soap *soap, int n)
{
	struct _trt__AddAudioEncoderConfiguration *p;
	struct _trt__AddAudioEncoderConfiguration *a = (struct _trt__AddAudioEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioEncoderConfiguration(struct soap *soap, const struct _trt__AddAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioEncoderConfiguration(soap, tag ? tag : "trt:AddAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfiguration * SOAP_FMAC4 soap_get__trt__AddAudioEncoderConfiguration(struct soap *soap, struct _trt__AddAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoSourceConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveVideoSourceConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoSourceConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveVideoSourceConfigurationResponse *p;
	struct _trt__RemoveVideoSourceConfigurationResponse *a = (struct _trt__RemoveVideoSourceConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveVideoSourceConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveVideoSourceConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoSourceConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveVideoSourceConfigurationResponse(soap, tag ? tag : "trt:RemoveVideoSourceConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoSourceConfiguration(struct soap *soap, struct _trt__RemoveVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoSourceConfiguration(struct soap *soap, const struct _trt__RemoveVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfiguration * SOAP_FMAC4 soap_in__trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveVideoSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, sizeof(struct _trt__RemoveVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoSourceConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, sizeof(struct _trt__RemoveVideoSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfiguration * SOAP_FMAC4 soap_new__trt__RemoveVideoSourceConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveVideoSourceConfiguration *p;
	struct _trt__RemoveVideoSourceConfiguration *a = (struct _trt__RemoveVideoSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveVideoSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveVideoSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoSourceConfiguration(struct soap *soap, const struct _trt__RemoveVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveVideoSourceConfiguration(soap, tag ? tag : "trt:RemoveVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfiguration * SOAP_FMAC4 soap_get__trt__RemoveVideoSourceConfiguration(struct soap *soap, struct _trt__RemoveVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoSourceConfigurationResponse(struct soap *soap, struct _trt__AddVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__AddVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoSourceConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddVideoSourceConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, sizeof(struct _trt__AddVideoSourceConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoSourceConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, sizeof(struct _trt__AddVideoSourceConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddVideoSourceConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddVideoSourceConfigurationResponse *p;
	struct _trt__AddVideoSourceConfigurationResponse *a = (struct _trt__AddVideoSourceConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddVideoSourceConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddVideoSourceConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__AddVideoSourceConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddVideoSourceConfigurationResponse(soap, tag ? tag : "trt:AddVideoSourceConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddVideoSourceConfigurationResponse(struct soap *soap, struct _trt__AddVideoSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoSourceConfiguration(struct soap *soap, struct _trt__AddVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoSourceConfiguration(struct soap *soap, const struct _trt__AddVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoSourceConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "trt:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfiguration * SOAP_FMAC4 soap_in__trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddVideoSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoSourceConfiguration, sizeof(struct _trt__AddVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoSourceConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoSourceConfiguration, SOAP_TYPE__trt__AddVideoSourceConfiguration, sizeof(struct _trt__AddVideoSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfiguration * SOAP_FMAC4 soap_new__trt__AddVideoSourceConfiguration(struct soap *soap, int n)
{
	struct _trt__AddVideoSourceConfiguration *p;
	struct _trt__AddVideoSourceConfiguration *a = (struct _trt__AddVideoSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddVideoSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddVideoSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoSourceConfiguration(struct soap *soap, const struct _trt__AddVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddVideoSourceConfiguration(soap, tag ? tag : "trt:AddVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfiguration * SOAP_FMAC4 soap_get__trt__AddVideoSourceConfiguration(struct soap *soap, struct _trt__AddVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoEncoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveVideoEncoderConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoEncoderConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveVideoEncoderConfigurationResponse *p;
	struct _trt__RemoveVideoEncoderConfigurationResponse *a = (struct _trt__RemoveVideoEncoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveVideoEncoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveVideoEncoderConfigurationResponse(soap, tag ? tag : "trt:RemoveVideoEncoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct _trt__RemoveVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoEncoderConfiguration(struct soap *soap, const struct _trt__RemoveVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfiguration * SOAP_FMAC4 soap_in__trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__RemoveVideoEncoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, sizeof(struct _trt__RemoveVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoEncoderConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, sizeof(struct _trt__RemoveVideoEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfiguration * SOAP_FMAC4 soap_new__trt__RemoveVideoEncoderConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveVideoEncoderConfiguration *p;
	struct _trt__RemoveVideoEncoderConfiguration *a = (struct _trt__RemoveVideoEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveVideoEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveVideoEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoEncoderConfiguration(struct soap *soap, const struct _trt__RemoveVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveVideoEncoderConfiguration(soap, tag ? tag : "trt:RemoveVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfiguration * SOAP_FMAC4 soap_get__trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct _trt__RemoveVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__AddVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__AddVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoEncoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddVideoEncoderConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, sizeof(struct _trt__AddVideoEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoEncoderConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, sizeof(struct _trt__AddVideoEncoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddVideoEncoderConfigurationResponse *p;
	struct _trt__AddVideoEncoderConfigurationResponse *a = (struct _trt__AddVideoEncoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddVideoEncoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddVideoEncoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__AddVideoEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddVideoEncoderConfigurationResponse(soap, tag ? tag : "trt:AddVideoEncoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__AddVideoEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoEncoderConfiguration(struct soap *soap, struct _trt__AddVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoEncoderConfiguration(struct soap *soap, const struct _trt__AddVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoEncoderConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "trt:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfiguration * SOAP_FMAC4 soap_in__trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__AddVideoEncoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoEncoderConfiguration, sizeof(struct _trt__AddVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoEncoderConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken || !a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoEncoderConfiguration, SOAP_TYPE__trt__AddVideoEncoderConfiguration, sizeof(struct _trt__AddVideoEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfiguration * SOAP_FMAC4 soap_new__trt__AddVideoEncoderConfiguration(struct soap *soap, int n)
{
	struct _trt__AddVideoEncoderConfiguration *p;
	struct _trt__AddVideoEncoderConfiguration *a = (struct _trt__AddVideoEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddVideoEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddVideoEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoEncoderConfiguration(struct soap *soap, const struct _trt__AddVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddVideoEncoderConfiguration(soap, tag ? tag : "trt:AddVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfiguration * SOAP_FMAC4 soap_get__trt__AddVideoEncoderConfiguration(struct soap *soap, struct _trt__AddVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProfiles = 0;
	a->Profiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfilesResponse(struct soap *soap, const struct _trt__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Profiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeProfiles; i++)
		{
			soap_embedded(soap, a->Profiles + i, SOAP_TYPE_tt__Profile);
			soap_serialize_tt__Profile(soap, a->Profiles + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfilesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetProfilesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfilesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeProfiles");
	if (a->Profiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeProfiles; i++)
			if (soap_out_tt__Profile(soap, "trt:Profiles", -1, a->Profiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_in__trt__GetProfilesResponse(struct soap *soap, const char *tag, struct _trt__GetProfilesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Profiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetProfilesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfilesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Profiles", 1, NULL))
			{	if (a->Profiles == NULL)
				{	if (soap_blist_Profiles == NULL)
						soap_blist_Profiles = soap_alloc_block(soap);
					a->Profiles = (struct tt__Profile *)soap_push_block_max(soap, soap_blist_Profiles, sizeof(struct tt__Profile));
					if (a->Profiles == NULL)
						return NULL;
					soap_default_tt__Profile(soap, a->Profiles);
				}
				soap_revert(soap);
				if (soap_in_tt__Profile(soap, "trt:Profiles", a->Profiles, "tt:Profile"))
				{	a->__sizeProfiles++;
					a->Profiles = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProfiles");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Profiles)
			soap_pop_block(soap, soap_blist_Profiles);
		if (a->__sizeProfiles)
		{	a->Profiles = (struct tt__Profile *)soap_save_block(soap, soap_blist_Profiles, NULL, 1);
		}
		else
		{	a->Profiles = NULL;
			if (soap_blist_Profiles)
				soap_end_block(soap, soap_blist_Profiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfilesResponse, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_new__trt__GetProfilesResponse(struct soap *soap, int n)
{
	struct _trt__GetProfilesResponse *p;
	struct _trt__GetProfilesResponse *a = (struct _trt__GetProfilesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetProfilesResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetProfilesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfilesResponse(struct soap *soap, const struct _trt__GetProfilesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetProfilesResponse(soap, tag ? tag : "trt:GetProfilesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_get__trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfiles(struct soap *soap, const struct _trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfiles(struct soap *soap, const char *tag, int id, const struct _trt__GetProfiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfiles), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfiles * SOAP_FMAC4 soap_in__trt__GetProfiles(struct soap *soap, const char *tag, struct _trt__GetProfiles *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetProfiles*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfiles(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfiles, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetProfiles * SOAP_FMAC4 soap_new__trt__GetProfiles(struct soap *soap, int n)
{
	struct _trt__GetProfiles *p;
	struct _trt__GetProfiles *a = (struct _trt__GetProfiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetProfiles));
	for (p = a; p && n--; p++)
		soap_default__trt__GetProfiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfiles(struct soap *soap, const struct _trt__GetProfiles *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetProfiles(soap, tag ? tag : "trt:GetProfiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfiles * SOAP_FMAC4 soap_get__trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Profile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfileResponse(struct soap *soap, const struct _trt__GetProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Profile(soap, &a->Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfileResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfileResponse), type))
		return soap->error;
	if (a->Profile)
		soap_element_result(soap, "trt:Profile");
	if (!a->Profile)
	{	if (soap_element_empty(soap, "trt:Profile", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Profile(soap, "trt:Profile", -1, &a->Profile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfileResponse * SOAP_FMAC4 soap_in__trt__GetProfileResponse(struct soap *soap, const char *tag, struct _trt__GetProfileResponse *a, const char *type)
{
	size_t soap_flag_Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetProfileResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfileResponse, sizeof(struct _trt__GetProfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfileResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Profile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Profile(soap, "trt:Profile", &a->Profile, "tt:Profile"))
				{	soap_flag_Profile--;
					continue;
				}
			}
			soap_check_result(soap, "trt:Profile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Profile))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfileResponse, SOAP_TYPE__trt__GetProfileResponse, sizeof(struct _trt__GetProfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetProfileResponse * SOAP_FMAC4 soap_new__trt__GetProfileResponse(struct soap *soap, int n)
{
	struct _trt__GetProfileResponse *p;
	struct _trt__GetProfileResponse *a = (struct _trt__GetProfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetProfileResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetProfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfileResponse(struct soap *soap, const struct _trt__GetProfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetProfileResponse(soap, tag ? tag : "trt:GetProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfileResponse * SOAP_FMAC4 soap_get__trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfile(struct soap *soap, struct _trt__GetProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfile(struct soap *soap, const struct _trt__GetProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfile(struct soap *soap, const char *tag, int id, const struct _trt__GetProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfile), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_empty(soap, "trt:ProfileToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfile * SOAP_FMAC4 soap_in__trt__GetProfile(struct soap *soap, const char *tag, struct _trt__GetProfile *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetProfile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfile, sizeof(struct _trt__GetProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfile, SOAP_TYPE__trt__GetProfile, sizeof(struct _trt__GetProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetProfile * SOAP_FMAC4 soap_new__trt__GetProfile(struct soap *soap, int n)
{
	struct _trt__GetProfile *p;
	struct _trt__GetProfile *a = (struct _trt__GetProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetProfile));
	for (p = a; p && n--; p++)
		soap_default__trt__GetProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfile(struct soap *soap, const struct _trt__GetProfile *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetProfile(soap, tag ? tag : "trt:GetProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfile * SOAP_FMAC4 soap_get__trt__GetProfile(struct soap *soap, struct _trt__GetProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Profile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__CreateProfileResponse(struct soap *soap, const struct _trt__CreateProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Profile(soap, &a->Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__CreateProfileResponse(struct soap *soap, const char *tag, int id, const struct _trt__CreateProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__CreateProfileResponse), type))
		return soap->error;
	if (a->Profile)
		soap_element_result(soap, "trt:Profile");
	if (!a->Profile)
	{	if (soap_element_empty(soap, "trt:Profile", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Profile(soap, "trt:Profile", -1, &a->Profile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__CreateProfileResponse * SOAP_FMAC4 soap_in__trt__CreateProfileResponse(struct soap *soap, const char *tag, struct _trt__CreateProfileResponse *a, const char *type)
{
	size_t soap_flag_Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__CreateProfileResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateProfileResponse, sizeof(struct _trt__CreateProfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__CreateProfileResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Profile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Profile(soap, "trt:Profile", &a->Profile, "tt:Profile"))
				{	soap_flag_Profile--;
					continue;
				}
			}
			soap_check_result(soap, "trt:Profile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Profile))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__CreateProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateProfileResponse, SOAP_TYPE__trt__CreateProfileResponse, sizeof(struct _trt__CreateProfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__CreateProfileResponse * SOAP_FMAC4 soap_new__trt__CreateProfileResponse(struct soap *soap, int n)
{
	struct _trt__CreateProfileResponse *p;
	struct _trt__CreateProfileResponse *a = (struct _trt__CreateProfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__CreateProfileResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__CreateProfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__CreateProfileResponse(struct soap *soap, const struct _trt__CreateProfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__CreateProfileResponse(soap, tag ? tag : "trt:CreateProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateProfileResponse * SOAP_FMAC4 soap_get__trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__CreateProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__CreateProfile(struct soap *soap, const struct _trt__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__CreateProfile(struct soap *soap, const char *tag, int id, const struct _trt__CreateProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__CreateProfile), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "trt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "trt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__CreateProfile * SOAP_FMAC4 soap_in__trt__CreateProfile(struct soap *soap, const char *tag, struct _trt__CreateProfile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__CreateProfile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateProfile, sizeof(struct _trt__CreateProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__CreateProfile(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "trt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "trt:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__CreateProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateProfile, SOAP_TYPE__trt__CreateProfile, sizeof(struct _trt__CreateProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__CreateProfile * SOAP_FMAC4 soap_new__trt__CreateProfile(struct soap *soap, int n)
{
	struct _trt__CreateProfile *p;
	struct _trt__CreateProfile *a = (struct _trt__CreateProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__CreateProfile));
	for (p = a; p && n--; p++)
		soap_default__trt__CreateProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__CreateProfile(struct soap *soap, const struct _trt__CreateProfile *a, const char *tag, const char *type)
{
	if (soap_out__trt__CreateProfile(soap, tag ? tag : "trt:CreateProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateProfile * SOAP_FMAC4 soap_get__trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioOutput(struct soap *soap, struct tt__AudioOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioOutput(struct soap *soap, const struct tt__AudioOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutput(struct soap *soap, const char *tag, int id, const struct tt__AudioOutput *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutput), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioOutput * SOAP_FMAC4 soap_in_tt__AudioOutput(struct soap *soap, const char *tag, struct tt__AudioOutput *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioOutput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutput, sizeof(struct tt__AudioOutput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioOutput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutput, SOAP_TYPE_tt__AudioOutput, sizeof(struct tt__AudioOutput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioOutput * SOAP_FMAC4 soap_new_tt__AudioOutput(struct soap *soap, int n)
{
	struct tt__AudioOutput *p;
	struct tt__AudioOutput *a = (struct tt__AudioOutput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioOutput));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioOutput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioOutput(struct soap *soap, const struct tt__AudioOutput *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioOutput(soap, tag ? tag : "tt:AudioOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutput * SOAP_FMAC4 soap_get_tt__AudioOutput(struct soap *soap, struct tt__AudioOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputsResponse(struct soap *soap, struct _trt__GetAudioOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudioOutputs = 0;
	a->AudioOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputsResponse(struct soap *soap, const struct _trt__GetAudioOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AudioOutputs)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudioOutputs; i++)
		{
			soap_embedded(soap, a->AudioOutputs + i, SOAP_TYPE_tt__AudioOutput);
			soap_serialize_tt__AudioOutput(soap, a->AudioOutputs + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAudioOutputs");
	if (a->AudioOutputs)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudioOutputs; i++)
			if (soap_out_tt__AudioOutput(soap, "trt:AudioOutputs", -1, a->AudioOutputs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputsResponse * SOAP_FMAC4 soap_in__trt__GetAudioOutputsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AudioOutputs = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioOutputsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputsResponse, sizeof(struct _trt__GetAudioOutputsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:AudioOutputs", 1, NULL))
			{	if (a->AudioOutputs == NULL)
				{	if (soap_blist_AudioOutputs == NULL)
						soap_blist_AudioOutputs = soap_alloc_block(soap);
					a->AudioOutputs = (struct tt__AudioOutput *)soap_push_block_max(soap, soap_blist_AudioOutputs, sizeof(struct tt__AudioOutput));
					if (a->AudioOutputs == NULL)
						return NULL;
					soap_default_tt__AudioOutput(soap, a->AudioOutputs);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioOutput(soap, "trt:AudioOutputs", a->AudioOutputs, "tt:AudioOutput"))
				{	a->__sizeAudioOutputs++;
					a->AudioOutputs = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAudioOutputs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AudioOutputs)
			soap_pop_block(soap, soap_blist_AudioOutputs);
		if (a->__sizeAudioOutputs)
		{	a->AudioOutputs = (struct tt__AudioOutput *)soap_save_block(soap, soap_blist_AudioOutputs, NULL, 1);
		}
		else
		{	a->AudioOutputs = NULL;
			if (soap_blist_AudioOutputs)
				soap_end_block(soap, soap_blist_AudioOutputs);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputsResponse, SOAP_TYPE__trt__GetAudioOutputsResponse, sizeof(struct _trt__GetAudioOutputsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioOutputsResponse * SOAP_FMAC4 soap_new__trt__GetAudioOutputsResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioOutputsResponse *p;
	struct _trt__GetAudioOutputsResponse *a = (struct _trt__GetAudioOutputsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioOutputsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioOutputsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputsResponse(struct soap *soap, const struct _trt__GetAudioOutputsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioOutputsResponse(soap, tag ? tag : "trt:GetAudioOutputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputsResponse * SOAP_FMAC4 soap_get__trt__GetAudioOutputsResponse(struct soap *soap, struct _trt__GetAudioOutputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputs(struct soap *soap, struct _trt__GetAudioOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputs(struct soap *soap, const struct _trt__GetAudioOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputs(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputs * SOAP_FMAC4 soap_in__trt__GetAudioOutputs(struct soap *soap, const char *tag, struct _trt__GetAudioOutputs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioOutputs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputs, sizeof(struct _trt__GetAudioOutputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputs(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputs, SOAP_TYPE__trt__GetAudioOutputs, sizeof(struct _trt__GetAudioOutputs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioOutputs * SOAP_FMAC4 soap_new__trt__GetAudioOutputs(struct soap *soap, int n)
{
	struct _trt__GetAudioOutputs *p;
	struct _trt__GetAudioOutputs *a = (struct _trt__GetAudioOutputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioOutputs));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioOutputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputs(struct soap *soap, const struct _trt__GetAudioOutputs *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioOutputs(soap, tag ? tag : "trt:GetAudioOutputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputs * SOAP_FMAC4 soap_get__trt__GetAudioOutputs(struct soap *soap, struct _trt__GetAudioOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioSource(struct soap *soap, struct tt__AudioSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_int(soap, &a->Channels);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioSource(struct soap *soap, const struct tt__AudioSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Channels, SOAP_TYPE_int);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSource(struct soap *soap, const char *tag, int id, const struct tt__AudioSource *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSource), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Channels", -1, &a->Channels, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioSource * SOAP_FMAC4 soap_in_tt__AudioSource(struct soap *soap, const char *tag, struct tt__AudioSource *a, const char *type)
{
	size_t soap_flag_Channels = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AudioSource*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSource, sizeof(struct tt__AudioSource), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioSource(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Channels && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Channels", &a->Channels, "xsd:int"))
				{	soap_flag_Channels--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Channels > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSource, SOAP_TYPE_tt__AudioSource, sizeof(struct tt__AudioSource), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioSource * SOAP_FMAC4 soap_new_tt__AudioSource(struct soap *soap, int n)
{
	struct tt__AudioSource *p;
	struct tt__AudioSource *a = (struct tt__AudioSource*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioSource));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioSource(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioSource(struct soap *soap, const struct tt__AudioSource *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioSource(soap, tag ? tag : "tt:AudioSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSource * SOAP_FMAC4 soap_get_tt__AudioSource(struct soap *soap, struct tt__AudioSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourcesResponse(struct soap *soap, struct _trt__GetAudioSourcesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudioSources = 0;
	a->AudioSources = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourcesResponse(struct soap *soap, const struct _trt__GetAudioSourcesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AudioSources)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudioSources; i++)
		{
			soap_embedded(soap, a->AudioSources + i, SOAP_TYPE_tt__AudioSource);
			soap_serialize_tt__AudioSource(soap, a->AudioSources + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourcesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourcesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourcesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAudioSources");
	if (a->AudioSources)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudioSources; i++)
			if (soap_out_tt__AudioSource(soap, "trt:AudioSources", -1, a->AudioSources + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSourcesResponse * SOAP_FMAC4 soap_in__trt__GetAudioSourcesResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourcesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AudioSources = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioSourcesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourcesResponse, sizeof(struct _trt__GetAudioSourcesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSourcesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:AudioSources", 1, NULL))
			{	if (a->AudioSources == NULL)
				{	if (soap_blist_AudioSources == NULL)
						soap_blist_AudioSources = soap_alloc_block(soap);
					a->AudioSources = (struct tt__AudioSource *)soap_push_block_max(soap, soap_blist_AudioSources, sizeof(struct tt__AudioSource));
					if (a->AudioSources == NULL)
						return NULL;
					soap_default_tt__AudioSource(soap, a->AudioSources);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioSource(soap, "trt:AudioSources", a->AudioSources, "tt:AudioSource"))
				{	a->__sizeAudioSources++;
					a->AudioSources = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAudioSources");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AudioSources)
			soap_pop_block(soap, soap_blist_AudioSources);
		if (a->__sizeAudioSources)
		{	a->AudioSources = (struct tt__AudioSource *)soap_save_block(soap, soap_blist_AudioSources, NULL, 1);
		}
		else
		{	a->AudioSources = NULL;
			if (soap_blist_AudioSources)
				soap_end_block(soap, soap_blist_AudioSources);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourcesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourcesResponse, SOAP_TYPE__trt__GetAudioSourcesResponse, sizeof(struct _trt__GetAudioSourcesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioSourcesResponse * SOAP_FMAC4 soap_new__trt__GetAudioSourcesResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioSourcesResponse *p;
	struct _trt__GetAudioSourcesResponse *a = (struct _trt__GetAudioSourcesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioSourcesResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioSourcesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSourcesResponse(struct soap *soap, const struct _trt__GetAudioSourcesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioSourcesResponse(soap, tag ? tag : "trt:GetAudioSourcesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourcesResponse * SOAP_FMAC4 soap_get__trt__GetAudioSourcesResponse(struct soap *soap, struct _trt__GetAudioSourcesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSourcesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSources(struct soap *soap, struct _trt__GetAudioSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSources(struct soap *soap, const struct _trt__GetAudioSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSources(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSources *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSources), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSources * SOAP_FMAC4 soap_in__trt__GetAudioSources(struct soap *soap, const char *tag, struct _trt__GetAudioSources *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetAudioSources*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSources, sizeof(struct _trt__GetAudioSources), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSources(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSources *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSources, SOAP_TYPE__trt__GetAudioSources, sizeof(struct _trt__GetAudioSources), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioSources * SOAP_FMAC4 soap_new__trt__GetAudioSources(struct soap *soap, int n)
{
	struct _trt__GetAudioSources *p;
	struct _trt__GetAudioSources *a = (struct _trt__GetAudioSources*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioSources));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioSources(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSources(struct soap *soap, const struct _trt__GetAudioSources *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioSources(soap, tag ? tag : "trt:GetAudioSources", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSources * SOAP_FMAC4 soap_get__trt__GetAudioSources(struct soap *soap, struct _trt__GetAudioSources *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSource(struct soap *soap, struct tt__VideoSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_float(soap, &a->Framerate);
	a->Resolution = NULL;
	a->Imaging = NULL;
	a->Extension = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSource(struct soap *soap, const struct tt__VideoSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Framerate, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoResolution(soap, &a->Resolution);
	soap_serialize_PointerTott__ImagingSettings(soap, &a->Imaging);
	soap_serialize_PointerTott__VideoSourceExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSource(struct soap *soap, const char *tag, int id, const struct tt__VideoSource *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSource), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Framerate", -1, &a->Framerate, ""))
		return soap->error;
	if (!a->Resolution)
	{	if (soap_element_empty(soap, "tt:Resolution", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->Resolution, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettings(soap, "tt:Imaging", -1, &a->Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSource * SOAP_FMAC4 soap_in_tt__VideoSource(struct soap *soap, const char *tag, struct tt__VideoSource *a, const char *type)
{
	size_t soap_flag_Framerate = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_Imaging = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__VideoSource*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSource, sizeof(struct tt__VideoSource), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSource(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Framerate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Framerate", &a->Framerate, "xsd:float"))
				{	soap_flag_Framerate--;
					continue;
				}
			}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution--;
					continue;
				}
			}
			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettings(soap, "tt:Imaging", &a->Imaging, "tt:ImagingSettings"))
				{	soap_flag_Imaging--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceExtension(soap, "tt:Extension", &a->Extension, "tt:VideoSourceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Framerate > 0 || !a->Resolution))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSource, SOAP_TYPE_tt__VideoSource, sizeof(struct tt__VideoSource), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoSource * SOAP_FMAC4 soap_new_tt__VideoSource(struct soap *soap, int n)
{
	struct tt__VideoSource *p;
	struct tt__VideoSource *a = (struct tt__VideoSource*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoSource));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoSource(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSource(struct soap *soap, const struct tt__VideoSource *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoSource(soap, tag ? tag : "tt:VideoSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSource * SOAP_FMAC4 soap_get_tt__VideoSource(struct soap *soap, struct tt__VideoSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourcesResponse(struct soap *soap, struct _trt__GetVideoSourcesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeVideoSources = 0;
	a->VideoSources = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourcesResponse(struct soap *soap, const struct _trt__GetVideoSourcesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->VideoSources)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoSources; i++)
		{
			soap_embedded(soap, a->VideoSources + i, SOAP_TYPE_tt__VideoSource);
			soap_serialize_tt__VideoSource(soap, a->VideoSources + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourcesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourcesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourcesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeVideoSources");
	if (a->VideoSources)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoSources; i++)
			if (soap_out_tt__VideoSource(soap, "trt:VideoSources", -1, a->VideoSources + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourcesResponse * SOAP_FMAC4 soap_in__trt__GetVideoSourcesResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourcesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_VideoSources = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetVideoSourcesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourcesResponse, sizeof(struct _trt__GetVideoSourcesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourcesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:VideoSources", 1, NULL))
			{	if (a->VideoSources == NULL)
				{	if (soap_blist_VideoSources == NULL)
						soap_blist_VideoSources = soap_alloc_block(soap);
					a->VideoSources = (struct tt__VideoSource *)soap_push_block_max(soap, soap_blist_VideoSources, sizeof(struct tt__VideoSource));
					if (a->VideoSources == NULL)
						return NULL;
					soap_default_tt__VideoSource(soap, a->VideoSources);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoSource(soap, "trt:VideoSources", a->VideoSources, "tt:VideoSource"))
				{	a->__sizeVideoSources++;
					a->VideoSources = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeVideoSources");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->VideoSources)
			soap_pop_block(soap, soap_blist_VideoSources);
		if (a->__sizeVideoSources)
		{	a->VideoSources = (struct tt__VideoSource *)soap_save_block(soap, soap_blist_VideoSources, NULL, 1);
		}
		else
		{	a->VideoSources = NULL;
			if (soap_blist_VideoSources)
				soap_end_block(soap, soap_blist_VideoSources);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourcesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourcesResponse, SOAP_TYPE__trt__GetVideoSourcesResponse, sizeof(struct _trt__GetVideoSourcesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoSourcesResponse * SOAP_FMAC4 soap_new__trt__GetVideoSourcesResponse(struct soap *soap, int n)
{
	struct _trt__GetVideoSourcesResponse *p;
	struct _trt__GetVideoSourcesResponse *a = (struct _trt__GetVideoSourcesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoSourcesResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoSourcesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourcesResponse(struct soap *soap, const struct _trt__GetVideoSourcesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoSourcesResponse(soap, tag ? tag : "trt:GetVideoSourcesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourcesResponse * SOAP_FMAC4 soap_get__trt__GetVideoSourcesResponse(struct soap *soap, struct _trt__GetVideoSourcesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourcesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSources(struct soap *soap, struct _trt__GetVideoSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSources(struct soap *soap, const struct _trt__GetVideoSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSources(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSources *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSources), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSources * SOAP_FMAC4 soap_in__trt__GetVideoSources(struct soap *soap, const char *tag, struct _trt__GetVideoSources *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetVideoSources*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSources, sizeof(struct _trt__GetVideoSources), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSources(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSources *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSources, SOAP_TYPE__trt__GetVideoSources, sizeof(struct _trt__GetVideoSources), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoSources * SOAP_FMAC4 soap_new__trt__GetVideoSources(struct soap *soap, int n)
{
	struct _trt__GetVideoSources *p;
	struct _trt__GetVideoSources *a = (struct _trt__GetVideoSources*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoSources));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoSources(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSources(struct soap *soap, const struct _trt__GetVideoSources *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoSources(soap, tag ? tag : "trt:GetVideoSources", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSources * SOAP_FMAC4 soap_get__trt__GetVideoSources(struct soap *soap, struct _trt__GetVideoSources *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trt__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrt__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "trt:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "trt:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotrt__Capabilities(soap, "trt:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trt__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, sizeof(struct _trt__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotrt__Capabilities(soap, "trt:Capabilities", &a->Capabilities, "trt:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "trt:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, sizeof(struct _trt__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__trt__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _trt__GetServiceCapabilitiesResponse *p;
	struct _trt__GetServiceCapabilitiesResponse *a = (struct _trt__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trt__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetServiceCapabilitiesResponse(soap, tag ? tag : "trt:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetServiceCapabilities(struct soap *soap, const struct _trt__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _trt__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities * SOAP_FMAC4 soap_in__trt__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trt__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trt__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(struct _trt__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetServiceCapabilities, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(struct _trt__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities * SOAP_FMAC4 soap_new__trt__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _trt__GetServiceCapabilities *p;
	struct _trt__GetServiceCapabilities *a = (struct _trt__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__trt__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetServiceCapabilities(struct soap *soap, const struct _trt__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetServiceCapabilities(soap, tag ? tag : "trt:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities * SOAP_FMAC4 soap_get__trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trt__VideoSourceModeExtension(struct soap *soap, struct trt__VideoSourceModeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trt__VideoSourceModeExtension(struct soap *soap, const struct trt__VideoSourceModeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trt__VideoSourceModeExtension(struct soap *soap, const char *tag, int id, const struct trt__VideoSourceModeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trt__VideoSourceModeExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trt__VideoSourceModeExtension * SOAP_FMAC4 soap_in_trt__VideoSourceModeExtension(struct soap *soap, const char *tag, struct trt__VideoSourceModeExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trt__VideoSourceModeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__VideoSourceModeExtension, sizeof(struct trt__VideoSourceModeExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trt__VideoSourceModeExtension(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trt__VideoSourceModeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__VideoSourceModeExtension, SOAP_TYPE_trt__VideoSourceModeExtension, sizeof(struct trt__VideoSourceModeExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trt__VideoSourceModeExtension * SOAP_FMAC4 soap_new_trt__VideoSourceModeExtension(struct soap *soap, int n)
{
	struct trt__VideoSourceModeExtension *p;
	struct trt__VideoSourceModeExtension *a = (struct trt__VideoSourceModeExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trt__VideoSourceModeExtension));
	for (p = a; p && n--; p++)
		soap_default_trt__VideoSourceModeExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trt__VideoSourceModeExtension(struct soap *soap, const struct trt__VideoSourceModeExtension *a, const char *tag, const char *type)
{
	if (soap_out_trt__VideoSourceModeExtension(soap, tag ? tag : "trt:VideoSourceModeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__VideoSourceModeExtension * SOAP_FMAC4 soap_get_trt__VideoSourceModeExtension(struct soap *soap, struct trt__VideoSourceModeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_trt__VideoSourceModeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trt__VideoSourceMode(struct soap *soap, struct trt__VideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->MaxFramerate);
	a->MaxResolution = NULL;
	soap_default_trt__EncodingTypes(soap, &a->Encodings);
	soap_default_xsd__boolean(soap, &a->Reboot);
	soap_default_tt__Description(soap, &a->Description);
	a->Extension = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->Enabled = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trt__VideoSourceMode(struct soap *soap, const struct trt__VideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->MaxFramerate, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoResolution(soap, &a->MaxResolution);
	soap_serialize_trt__EncodingTypes(soap, (char*const*)&a->Encodings);
	soap_embedded(soap, &a->Reboot, SOAP_TYPE_xsd__boolean);
	soap_serialize_tt__Description(soap, (char*const*)&a->Description);
	soap_serialize_PointerTotrt__VideoSourceModeExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trt__VideoSourceMode(struct soap *soap, const char *tag, int id, const struct trt__VideoSourceMode *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (a->Enabled)
	{	soap_set_attr(soap, "Enabled", soap_xsd__boolean2s(soap, *a->Enabled), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trt__VideoSourceMode), type))
		return soap->error;
	if (soap_out_float(soap, "trt:MaxFramerate", -1, &a->MaxFramerate, ""))
		return soap->error;
	if (!a->MaxResolution)
	{	if (soap_element_empty(soap, "trt:MaxResolution", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoResolution(soap, "trt:MaxResolution", -1, &a->MaxResolution, ""))
		return soap->error;
	if (!a->Encodings)
	{	if (soap_element_empty(soap, "trt:Encodings", 0, NULL))
			return soap->error;
	}
	else if (soap_out_trt__EncodingTypes(soap, "trt:Encodings", -1, (char*const*)&a->Encodings, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "trt:Reboot", -1, &a->Reboot, ""))
		return soap->error;
	if (soap_out_tt__Description(soap, "trt:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	if (soap_out_PointerTotrt__VideoSourceModeExtension(soap, "trt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trt__VideoSourceMode * SOAP_FMAC4 soap_in_trt__VideoSourceMode(struct soap *soap, const char *tag, struct trt__VideoSourceMode *a, const char *type)
{
	size_t soap_flag_MaxFramerate = 1;
	size_t soap_flag_MaxResolution = 1;
	size_t soap_flag_Encodings = 1;
	size_t soap_flag_Reboot = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trt__VideoSourceMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__VideoSourceMode, sizeof(struct trt__VideoSourceMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trt__VideoSourceMode(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "Enabled", 5, 0);
		if (t)
		{
			if (!(a->Enabled = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Enabled))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaxFramerate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "trt:MaxFramerate", &a->MaxFramerate, "xsd:float"))
				{	soap_flag_MaxFramerate--;
					continue;
				}
			}
			if (soap_flag_MaxResolution && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution(soap, "trt:MaxResolution", &a->MaxResolution, "tt:VideoResolution"))
				{	soap_flag_MaxResolution--;
					continue;
				}
			}
			if (soap_flag_Encodings && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_trt__EncodingTypes(soap, "trt:Encodings", (char**)&a->Encodings, "trt:EncodingTypes"))
				{	soap_flag_Encodings--;
					continue;
				}
			}
			if (soap_flag_Reboot && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "trt:Reboot", &a->Reboot, "xsd:boolean"))
				{	soap_flag_Reboot--;
					continue;
				}
			}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Description(soap, "trt:Description", (char**)&a->Description, "tt:Description"))
				{	soap_flag_Description--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotrt__VideoSourceModeExtension(soap, "trt:Extension", &a->Extension, "trt:VideoSourceModeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaxFramerate > 0 || !a->MaxResolution || !a->Encodings || soap_flag_Reboot > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct trt__VideoSourceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__VideoSourceMode, SOAP_TYPE_trt__VideoSourceMode, sizeof(struct trt__VideoSourceMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trt__VideoSourceMode * SOAP_FMAC4 soap_new_trt__VideoSourceMode(struct soap *soap, int n)
{
	struct trt__VideoSourceMode *p;
	struct trt__VideoSourceMode *a = (struct trt__VideoSourceMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trt__VideoSourceMode));
	for (p = a; p && n--; p++)
		soap_default_trt__VideoSourceMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trt__VideoSourceMode(struct soap *soap, const struct trt__VideoSourceMode *a, const char *tag, const char *type)
{
	if (soap_out_trt__VideoSourceMode(soap, tag ? tag : "trt:VideoSourceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__VideoSourceMode * SOAP_FMAC4 soap_get_trt__VideoSourceMode(struct soap *soap, struct trt__VideoSourceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_trt__VideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->RTPMulticast = NULL;
	a->RTP_USCORETCP = NULL;
	a->RTP_USCORERTSP_USCORETCP = NULL;
	a->NonAggregateControl = NULL;
	a->NoRTSPStreaming = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trt__StreamingCapabilities(struct soap *soap, const struct trt__StreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trt__StreamingCapabilities(struct soap *soap, const char *tag, int id, const struct trt__StreamingCapabilities *a, const char *type)
{
	if (a->RTPMulticast)
	{	soap_set_attr(soap, "RTPMulticast", soap_xsd__boolean2s(soap, *a->RTPMulticast), 1);
	}
	if (a->RTP_USCORETCP)
	{	soap_set_attr(soap, "RTP_TCP", soap_xsd__boolean2s(soap, *a->RTP_USCORETCP), 1);
	}
	if (a->RTP_USCORERTSP_USCORETCP)
	{	soap_set_attr(soap, "RTP_RTSP_TCP", soap_xsd__boolean2s(soap, *a->RTP_USCORERTSP_USCORETCP), 1);
	}
	if (a->NonAggregateControl)
	{	soap_set_attr(soap, "NonAggregateControl", soap_xsd__boolean2s(soap, *a->NonAggregateControl), 1);
	}
	if (a->NoRTSPStreaming)
	{	soap_set_attr(soap, "NoRTSPStreaming", soap_xsd__boolean2s(soap, *a->NoRTSPStreaming), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trt__StreamingCapabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trt__StreamingCapabilities * SOAP_FMAC4 soap_in_trt__StreamingCapabilities(struct soap *soap, const char *tag, struct trt__StreamingCapabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trt__StreamingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__StreamingCapabilities, sizeof(struct trt__StreamingCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trt__StreamingCapabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "RTPMulticast", 5, 0);
		if (t)
		{
			if (!(a->RTPMulticast = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTPMulticast))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RTP_TCP", 5, 0);
		if (t)
		{
			if (!(a->RTP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCORETCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RTP_RTSP_TCP", 5, 0);
		if (t)
		{
			if (!(a->RTP_USCORERTSP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCORERTSP_USCORETCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NonAggregateControl", 5, 0);
		if (t)
		{
			if (!(a->NonAggregateControl = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->NonAggregateControl))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NoRTSPStreaming", 5, 0);
		if (t)
		{
			if (!(a->NoRTSPStreaming = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->NoRTSPStreaming))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trt__StreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__StreamingCapabilities, SOAP_TYPE_trt__StreamingCapabilities, sizeof(struct trt__StreamingCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trt__StreamingCapabilities * SOAP_FMAC4 soap_new_trt__StreamingCapabilities(struct soap *soap, int n)
{
	struct trt__StreamingCapabilities *p;
	struct trt__StreamingCapabilities *a = (struct trt__StreamingCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trt__StreamingCapabilities));
	for (p = a; p && n--; p++)
		soap_default_trt__StreamingCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trt__StreamingCapabilities(struct soap *soap, const struct trt__StreamingCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_trt__StreamingCapabilities(soap, tag ? tag : "trt:StreamingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__StreamingCapabilities * SOAP_FMAC4 soap_get_trt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trt__StreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->MaximumNumberOfProfiles = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trt__ProfileCapabilities(struct soap *soap, const struct trt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trt__ProfileCapabilities(struct soap *soap, const char *tag, int id, const struct trt__ProfileCapabilities *a, const char *type)
{
	if (a->MaximumNumberOfProfiles)
	{	soap_set_attr(soap, "MaximumNumberOfProfiles", soap_int2s(soap, *a->MaximumNumberOfProfiles), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trt__ProfileCapabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trt__ProfileCapabilities * SOAP_FMAC4 soap_in_trt__ProfileCapabilities(struct soap *soap, const char *tag, struct trt__ProfileCapabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trt__ProfileCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__ProfileCapabilities, sizeof(struct trt__ProfileCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trt__ProfileCapabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "MaximumNumberOfProfiles", 5, 0);
		if (t)
		{
			if (!(a->MaximumNumberOfProfiles = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaximumNumberOfProfiles))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__ProfileCapabilities, SOAP_TYPE_trt__ProfileCapabilities, sizeof(struct trt__ProfileCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trt__ProfileCapabilities * SOAP_FMAC4 soap_new_trt__ProfileCapabilities(struct soap *soap, int n)
{
	struct trt__ProfileCapabilities *p;
	struct trt__ProfileCapabilities *a = (struct trt__ProfileCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trt__ProfileCapabilities));
	for (p = a; p && n--; p++)
		soap_default_trt__ProfileCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trt__ProfileCapabilities(struct soap *soap, const struct trt__ProfileCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_trt__ProfileCapabilities(soap, tag ? tag : "trt:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__ProfileCapabilities * SOAP_FMAC4 soap_get_trt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trt__Capabilities(struct soap *soap, struct trt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ProfileCapabilities = NULL;
	a->StreamingCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->SnapshotUri = NULL;
	a->Rotation = NULL;
	a->VideoSourceMode = NULL;
	a->OSD = NULL;
	a->TemporaryOSDText = NULL;
	a->EXICompression = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trt__Capabilities(struct soap *soap, const struct trt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrt__ProfileCapabilities(soap, &a->ProfileCapabilities);
	soap_serialize_PointerTotrt__StreamingCapabilities(soap, &a->StreamingCapabilities);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trt__Capabilities(struct soap *soap, const char *tag, int id, const struct trt__Capabilities *a, const char *type)
{
	if (a->SnapshotUri)
	{	soap_set_attr(soap, "SnapshotUri", soap_xsd__boolean2s(soap, *a->SnapshotUri), 1);
	}
	if (a->Rotation)
	{	soap_set_attr(soap, "Rotation", soap_xsd__boolean2s(soap, *a->Rotation), 1);
	}
	if (a->VideoSourceMode)
	{	soap_set_attr(soap, "VideoSourceMode", soap_xsd__boolean2s(soap, *a->VideoSourceMode), 1);
	}
	if (a->OSD)
	{	soap_set_attr(soap, "OSD", soap_xsd__boolean2s(soap, *a->OSD), 1);
	}
	if (a->TemporaryOSDText)
	{	soap_set_attr(soap, "TemporaryOSDText", soap_xsd__boolean2s(soap, *a->TemporaryOSDText), 1);
	}
	if (a->EXICompression)
	{	soap_set_attr(soap, "EXICompression", soap_xsd__boolean2s(soap, *a->EXICompression), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trt__Capabilities), type))
		return soap->error;
	if (!a->ProfileCapabilities)
	{	if (soap_element_empty(soap, "trt:ProfileCapabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotrt__ProfileCapabilities(soap, "trt:ProfileCapabilities", -1, &a->ProfileCapabilities, ""))
		return soap->error;
	if (!a->StreamingCapabilities)
	{	if (soap_element_empty(soap, "trt:StreamingCapabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotrt__StreamingCapabilities(soap, "trt:StreamingCapabilities", -1, &a->StreamingCapabilities, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trt__Capabilities * SOAP_FMAC4 soap_in_trt__Capabilities(struct soap *soap, const char *tag, struct trt__Capabilities *a, const char *type)
{
	size_t soap_flag_ProfileCapabilities = 1;
	size_t soap_flag_StreamingCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trt__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__Capabilities, sizeof(struct trt__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trt__Capabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "SnapshotUri", 5, 0);
		if (t)
		{
			if (!(a->SnapshotUri = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->SnapshotUri))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Rotation", 5, 0);
		if (t)
		{
			if (!(a->Rotation = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Rotation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "VideoSourceMode", 5, 0);
		if (t)
		{
			if (!(a->VideoSourceMode = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->VideoSourceMode))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "OSD", 5, 0);
		if (t)
		{
			if (!(a->OSD = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->OSD))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "TemporaryOSDText", 5, 0);
		if (t)
		{
			if (!(a->TemporaryOSDText = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->TemporaryOSDText))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "EXICompression", 5, 0);
		if (t)
		{
			if (!(a->EXICompression = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->EXICompression))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotrt__ProfileCapabilities(soap, "trt:ProfileCapabilities", &a->ProfileCapabilities, "trt:ProfileCapabilities"))
				{	soap_flag_ProfileCapabilities--;
					continue;
				}
			}
			if (soap_flag_StreamingCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotrt__StreamingCapabilities(soap, "trt:StreamingCapabilities", &a->StreamingCapabilities, "trt:StreamingCapabilities"))
				{	soap_flag_StreamingCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ProfileCapabilities || !a->StreamingCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct trt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__Capabilities, SOAP_TYPE_trt__Capabilities, sizeof(struct trt__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trt__Capabilities * SOAP_FMAC4 soap_new_trt__Capabilities(struct soap *soap, int n)
{
	struct trt__Capabilities *p;
	struct trt__Capabilities *a = (struct trt__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trt__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_trt__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trt__Capabilities(struct soap *soap, const struct trt__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_trt__Capabilities(soap, tag ? tag : "trt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__Capabilities * SOAP_FMAC4 soap_get_trt__Capabilities(struct soap *soap, struct trt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsStateResponse(struct soap *soap, struct _tad__GetAnalyticsStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->State = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsStateResponse(struct soap *soap, const struct _tad__GetAnalyticsStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsStateInformation(soap, &a->State);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsStateResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsStateResponse), type))
		return soap->error;
	if (a->State)
		soap_element_result(soap, "tad:State");
	if (!a->State)
	{	if (soap_element_empty(soap, "tad:State", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsStateInformation(soap, "tad:State", -1, &a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsStateResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsStateResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsStateResponse *a, const char *type)
{
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsStateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsStateResponse, sizeof(struct _tad__GetAnalyticsStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsStateResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsStateInformation(soap, "tad:State", &a->State, "tt:AnalyticsStateInformation"))
				{	soap_flag_State--;
					continue;
				}
			}
			soap_check_result(soap, "tad:State");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->State))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsStateResponse, SOAP_TYPE__tad__GetAnalyticsStateResponse, sizeof(struct _tad__GetAnalyticsStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsStateResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsStateResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsStateResponse *p;
	struct _tad__GetAnalyticsStateResponse *a = (struct _tad__GetAnalyticsStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsStateResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsStateResponse(struct soap *soap, const struct _tad__GetAnalyticsStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsStateResponse(soap, tag ? tag : "tad:GetAnalyticsStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsStateResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsStateResponse(struct soap *soap, struct _tad__GetAnalyticsStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsState(struct soap *soap, struct _tad__GetAnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->AnalyticsEngineControlToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsState(struct soap *soap, const struct _tad__GetAnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AnalyticsEngineControlToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsState(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsState), type))
		return soap->error;
	if (!a->AnalyticsEngineControlToken)
	{	if (soap_element_empty(soap, "tad:AnalyticsEngineControlToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tad:AnalyticsEngineControlToken", -1, (char*const*)&a->AnalyticsEngineControlToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsState * SOAP_FMAC4 soap_in__tad__GetAnalyticsState(struct soap *soap, const char *tag, struct _tad__GetAnalyticsState *a, const char *type)
{
	size_t soap_flag_AnalyticsEngineControlToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsState, sizeof(struct _tad__GetAnalyticsState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsState(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnalyticsEngineControlToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tad:AnalyticsEngineControlToken", (char**)&a->AnalyticsEngineControlToken, "tt:ReferenceToken"))
				{	soap_flag_AnalyticsEngineControlToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->AnalyticsEngineControlToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsState, SOAP_TYPE__tad__GetAnalyticsState, sizeof(struct _tad__GetAnalyticsState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsState * SOAP_FMAC4 soap_new__tad__GetAnalyticsState(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsState *p;
	struct _tad__GetAnalyticsState *a = (struct _tad__GetAnalyticsState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsState));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsState(struct soap *soap, const struct _tad__GetAnalyticsState *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsState(soap, tag ? tag : "tad:GetAnalyticsState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsState * SOAP_FMAC4 soap_get__tad__GetAnalyticsState(struct soap *soap, struct _tad__GetAnalyticsState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, const struct _tad__DeleteAnalyticsEngineInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, int id, const struct _tad__DeleteAnalyticsEngineInputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_in__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineInputsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__DeleteAnalyticsEngineInputsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__DeleteAnalyticsEngineInputsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineInputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_new__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, int n)
{
	struct _tad__DeleteAnalyticsEngineInputsResponse *p;
	struct _tad__DeleteAnalyticsEngineInputsResponse *a = (struct _tad__DeleteAnalyticsEngineInputsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__DeleteAnalyticsEngineInputsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, const struct _tad__DeleteAnalyticsEngineInputsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__DeleteAnalyticsEngineInputsResponse(soap, tag ? tag : "tad:DeleteAnalyticsEngineInputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_get__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__DeleteAnalyticsEngineInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__DeleteAnalyticsEngineInputs(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurationToken = 0;
	a->ConfigurationToken = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__DeleteAnalyticsEngineInputs(struct soap *soap, const struct _tad__DeleteAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ConfigurationToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurationToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->ConfigurationToken + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__DeleteAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, const struct _tad__DeleteAnalyticsEngineInputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs), type))
		return soap->error;
	if (a->ConfigurationToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurationToken; i++)
			if (soap_out_string(soap, "tad:ConfigurationToken", -1, (char*const*)(a->ConfigurationToken + i), ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputs * SOAP_FMAC4 soap_in__tad__DeleteAnalyticsEngineInputs(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineInputs *a, const char *type)
{
	struct soap_blist *soap_blist_ConfigurationToken = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__DeleteAnalyticsEngineInputs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, sizeof(struct _tad__DeleteAnalyticsEngineInputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__DeleteAnalyticsEngineInputs(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:ConfigurationToken", 1, NULL))
			{	if (a->ConfigurationToken == NULL)
				{	if (soap_blist_ConfigurationToken == NULL)
						soap_blist_ConfigurationToken = soap_alloc_block(soap);
					a->ConfigurationToken = (char **)soap_push_block_max(soap, soap_blist_ConfigurationToken, sizeof(char *));
					if (a->ConfigurationToken == NULL)
						return NULL;
					*a->ConfigurationToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tad:ConfigurationToken", (char**)a->ConfigurationToken, "tt:ReferenceToken"))
				{	a->__sizeConfigurationToken++;
					a->ConfigurationToken = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ConfigurationToken)
			soap_pop_block(soap, soap_blist_ConfigurationToken);
		if (a->__sizeConfigurationToken)
		{	a->ConfigurationToken = (char **)soap_save_block(soap, soap_blist_ConfigurationToken, NULL, 1);
		}
		else
		{	a->ConfigurationToken = NULL;
			if (soap_blist_ConfigurationToken)
				soap_end_block(soap, soap_blist_ConfigurationToken);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfigurationToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineInputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, sizeof(struct _tad__DeleteAnalyticsEngineInputs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputs * SOAP_FMAC4 soap_new__tad__DeleteAnalyticsEngineInputs(struct soap *soap, int n)
{
	struct _tad__DeleteAnalyticsEngineInputs *p;
	struct _tad__DeleteAnalyticsEngineInputs *a = (struct _tad__DeleteAnalyticsEngineInputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__DeleteAnalyticsEngineInputs));
	for (p = a; p && n--; p++)
		soap_default__tad__DeleteAnalyticsEngineInputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__DeleteAnalyticsEngineInputs(struct soap *soap, const struct _tad__DeleteAnalyticsEngineInputs *a, const char *tag, const char *type)
{
	if (soap_out__tad__DeleteAnalyticsEngineInputs(soap, tag ? tag : "tad:DeleteAnalyticsEngineInputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputs * SOAP_FMAC4 soap_get__tad__DeleteAnalyticsEngineInputs(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__DeleteAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__GetVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _tad__GetVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetVideoAnalyticsConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "tad:Configuration");
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tad:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_in__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _tad__GetVideoAnalyticsConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetVideoAnalyticsConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetVideoAnalyticsConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tad:Configuration", &a->Configuration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			soap_check_result(soap, "tad:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_new__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, int n)
{
	struct _tad__GetVideoAnalyticsConfigurationResponse *p;
	struct _tad__GetVideoAnalyticsConfigurationResponse *a = (struct _tad__GetVideoAnalyticsConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetVideoAnalyticsConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _tad__GetVideoAnalyticsConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetVideoAnalyticsConfigurationResponse(soap, tag ? tag : "tad:GetVideoAnalyticsConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_get__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__GetVideoAnalyticsConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetVideoAnalyticsConfiguration(struct soap *soap, const struct _tad__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct _tad__GetVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tad:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tad:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in__tad__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _tad__GetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetVideoAnalyticsConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration, sizeof(struct _tad__GetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetVideoAnalyticsConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tad:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration, sizeof(struct _tad__GetVideoAnalyticsConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_new__tad__GetVideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct _tad__GetVideoAnalyticsConfiguration *p;
	struct _tad__GetVideoAnalyticsConfiguration *a = (struct _tad__GetVideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetVideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tad__GetVideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetVideoAnalyticsConfiguration(struct soap *soap, const struct _tad__GetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetVideoAnalyticsConfiguration(soap, tag ? tag : "tad:GetVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get__tad__GetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__GetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, const struct _tad__GetAnalyticsDeviceStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Uri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsDeviceStreamUriResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse), type))
		return soap->error;
	if (a->Uri)
		soap_element_result(soap, "tad:Uri");
	if (!a->Uri)
	{	if (soap_element_empty(soap, "tad:Uri", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tad:Uri", -1, (char*const*)&a->Uri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUriResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsDeviceStreamUriResponse *a, const char *type)
{
	size_t soap_flag_Uri = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsDeviceStreamUriResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse, sizeof(struct _tad__GetAnalyticsDeviceStreamUriResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsDeviceStreamUriResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tad:Uri", (char**)&a->Uri, "xsd:anyURI"))
				{	soap_flag_Uri--;
					continue;
				}
			}
			soap_check_result(soap, "tad:Uri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Uri))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsDeviceStreamUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse, sizeof(struct _tad__GetAnalyticsDeviceStreamUriResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUriResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsDeviceStreamUriResponse *p;
	struct _tad__GetAnalyticsDeviceStreamUriResponse *a = (struct _tad__GetAnalyticsDeviceStreamUriResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsDeviceStreamUriResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsDeviceStreamUriResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, const struct _tad__GetAnalyticsDeviceStreamUriResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsDeviceStreamUriResponse(soap, tag ? tag : "tad:GetAnalyticsDeviceStreamUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUriResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsDeviceStreamUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StreamSetup = NULL;
	soap_default_tt__ReferenceToken(soap, &a->AnalyticsEngineControlToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const struct _tad__GetAnalyticsDeviceStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__StreamSetup(soap, &a->StreamSetup);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AnalyticsEngineControlToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsDeviceStreamUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri), type))
		return soap->error;
	if (!a->StreamSetup)
	{	if (soap_element_empty(soap, "tad:StreamSetup", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__StreamSetup(soap, "tad:StreamSetup", -1, &a->StreamSetup, ""))
		return soap->error;
	if (!a->AnalyticsEngineControlToken)
	{	if (soap_element_empty(soap, "tad:AnalyticsEngineControlToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tad:AnalyticsEngineControlToken", -1, (char*const*)&a->AnalyticsEngineControlToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUri * SOAP_FMAC4 soap_in__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const char *tag, struct _tad__GetAnalyticsDeviceStreamUri *a, const char *type)
{
	size_t soap_flag_StreamSetup = 1;
	size_t soap_flag_AnalyticsEngineControlToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsDeviceStreamUri*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri, sizeof(struct _tad__GetAnalyticsDeviceStreamUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsDeviceStreamUri(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__StreamSetup(soap, "tad:StreamSetup", &a->StreamSetup, "tt:StreamSetup"))
				{	soap_flag_StreamSetup--;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineControlToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tad:AnalyticsEngineControlToken", (char**)&a->AnalyticsEngineControlToken, "tt:ReferenceToken"))
				{	soap_flag_AnalyticsEngineControlToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->StreamSetup || !a->AnalyticsEngineControlToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsDeviceStreamUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri, sizeof(struct _tad__GetAnalyticsDeviceStreamUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUri * SOAP_FMAC4 soap_new__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsDeviceStreamUri *p;
	struct _tad__GetAnalyticsDeviceStreamUri *a = (struct _tad__GetAnalyticsDeviceStreamUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsDeviceStreamUri));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsDeviceStreamUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const struct _tad__GetAnalyticsDeviceStreamUri *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsDeviceStreamUri(soap, tag ? tag : "tad:GetAnalyticsDeviceStreamUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUri * SOAP_FMAC4 soap_get__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsDeviceStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_tt__AnalyticsEngineInput);
			soap_serialize_tt__AnalyticsEngineInput(soap, a->Configuration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineInputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfiguration");
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_tt__AnalyticsEngineInput(soap, "tad:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineInputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configuration = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsEngineInputsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse, sizeof(struct _tad__GetAnalyticsEngineInputsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineInputsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct tt__AnalyticsEngineInput *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct tt__AnalyticsEngineInput));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_tt__AnalyticsEngineInput(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_tt__AnalyticsEngineInput(soap, "tad:Configuration", a->Configuration, "tt:AnalyticsEngineInput"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct tt__AnalyticsEngineInput *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineInputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse, sizeof(struct _tad__GetAnalyticsEngineInputsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineInputsResponse *p;
	struct _tad__GetAnalyticsEngineInputsResponse *a = (struct _tad__GetAnalyticsEngineInputsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineInputsResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineInputsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineInputsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineInputsResponse(soap, tag ? tag : "tad:GetAnalyticsEngineInputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineInputs(struct soap *soap, struct _tad__GetAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineInputs(struct soap *soap, const struct _tad__GetAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineInputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputs * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineInputs(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineInputs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsEngineInputs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputs, sizeof(struct _tad__GetAnalyticsEngineInputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineInputs(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineInputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineInputs, SOAP_TYPE__tad__GetAnalyticsEngineInputs, sizeof(struct _tad__GetAnalyticsEngineInputs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputs * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineInputs(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineInputs *p;
	struct _tad__GetAnalyticsEngineInputs *a = (struct _tad__GetAnalyticsEngineInputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineInputs));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineInputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineInputs(struct soap *soap, const struct _tad__GetAnalyticsEngineInputs *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineInputs(soap, tag ? tag : "tad:GetAnalyticsEngineInputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputs * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineInputs(struct soap *soap, struct _tad__GetAnalyticsEngineInputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineInputResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineInputResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineInput(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineInputResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineInputResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "tad:Configuration");
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tad:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsEngineInput(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineInputResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineInputResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsEngineInputResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse, sizeof(struct _tad__GetAnalyticsEngineInputResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineInputResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineInput(soap, "tad:Configuration", &a->Configuration, "tt:AnalyticsEngineInput"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			soap_check_result(soap, "tad:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineInputResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse, sizeof(struct _tad__GetAnalyticsEngineInputResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineInputResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineInputResponse *p;
	struct _tad__GetAnalyticsEngineInputResponse *a = (struct _tad__GetAnalyticsEngineInputResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineInputResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineInputResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineInputResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineInputResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineInputResponse(soap, tag ? tag : "tad:GetAnalyticsEngineInputResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineInputResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineInput(struct soap *soap, struct _tad__GetAnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineInput(struct soap *soap, const struct _tad__GetAnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineInput(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineInput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineInput), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tad:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tad:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInput * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineInput(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineInput *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsEngineInput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineInput, sizeof(struct _tad__GetAnalyticsEngineInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineInput(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tad:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineInput, SOAP_TYPE__tad__GetAnalyticsEngineInput, sizeof(struct _tad__GetAnalyticsEngineInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInput * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineInput(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineInput *p;
	struct _tad__GetAnalyticsEngineInput *a = (struct _tad__GetAnalyticsEngineInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineInput));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineInput(struct soap *soap, const struct _tad__GetAnalyticsEngineInput *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineInput(soap, tag ? tag : "tad:GetAnalyticsEngineInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInput * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineInput(struct soap *soap, struct _tad__GetAnalyticsEngineInput *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__SetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__SetAnalyticsEngineInputResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__SetAnalyticsEngineInputResponse(struct soap *soap, const struct _tad__SetAnalyticsEngineInputResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__SetAnalyticsEngineInputResponse(struct soap *soap, const char *tag, int id, const struct _tad__SetAnalyticsEngineInputResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInputResponse * SOAP_FMAC4 soap_in__tad__SetAnalyticsEngineInputResponse(struct soap *soap, const char *tag, struct _tad__SetAnalyticsEngineInputResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__SetAnalyticsEngineInputResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse, sizeof(struct _tad__SetAnalyticsEngineInputResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__SetAnalyticsEngineInputResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__SetAnalyticsEngineInputResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse, sizeof(struct _tad__SetAnalyticsEngineInputResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInputResponse * SOAP_FMAC4 soap_new__tad__SetAnalyticsEngineInputResponse(struct soap *soap, int n)
{
	struct _tad__SetAnalyticsEngineInputResponse *p;
	struct _tad__SetAnalyticsEngineInputResponse *a = (struct _tad__SetAnalyticsEngineInputResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__SetAnalyticsEngineInputResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__SetAnalyticsEngineInputResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__SetAnalyticsEngineInputResponse(struct soap *soap, const struct _tad__SetAnalyticsEngineInputResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__SetAnalyticsEngineInputResponse(soap, tag ? tag : "tad:SetAnalyticsEngineInputResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInputResponse * SOAP_FMAC4 soap_get__tad__SetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__SetAnalyticsEngineInputResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__SetAnalyticsEngineInputResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__SetAnalyticsEngineInput(struct soap *soap, struct _tad__SetAnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__SetAnalyticsEngineInput(struct soap *soap, const struct _tad__SetAnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineInput(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__SetAnalyticsEngineInput(struct soap *soap, const char *tag, int id, const struct _tad__SetAnalyticsEngineInput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__SetAnalyticsEngineInput), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tad:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsEngineInput(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tad:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInput * SOAP_FMAC4 soap_in__tad__SetAnalyticsEngineInput(struct soap *soap, const char *tag, struct _tad__SetAnalyticsEngineInput *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__SetAnalyticsEngineInput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetAnalyticsEngineInput, sizeof(struct _tad__SetAnalyticsEngineInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__SetAnalyticsEngineInput(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineInput(soap, "tad:Configuration", &a->Configuration, "tt:AnalyticsEngineInput"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tad:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__SetAnalyticsEngineInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetAnalyticsEngineInput, SOAP_TYPE__tad__SetAnalyticsEngineInput, sizeof(struct _tad__SetAnalyticsEngineInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInput * SOAP_FMAC4 soap_new__tad__SetAnalyticsEngineInput(struct soap *soap, int n)
{
	struct _tad__SetAnalyticsEngineInput *p;
	struct _tad__SetAnalyticsEngineInput *a = (struct _tad__SetAnalyticsEngineInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__SetAnalyticsEngineInput));
	for (p = a; p && n--; p++)
		soap_default__tad__SetAnalyticsEngineInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__SetAnalyticsEngineInput(struct soap *soap, const struct _tad__SetAnalyticsEngineInput *a, const char *tag, const char *type)
{
	if (soap_out__tad__SetAnalyticsEngineInput(soap, tag ? tag : "tad:SetAnalyticsEngineInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInput * SOAP_FMAC4 soap_get__tad__SetAnalyticsEngineInput(struct soap *soap, struct _tad__SetAnalyticsEngineInput *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__SetAnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__SetVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _tad__SetVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tad__SetVideoAnalyticsConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_in__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _tad__SetVideoAnalyticsConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__SetVideoAnalyticsConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__SetVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__SetVideoAnalyticsConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__SetVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__SetVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_new__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, int n)
{
	struct _tad__SetVideoAnalyticsConfigurationResponse *p;
	struct _tad__SetVideoAnalyticsConfigurationResponse *a = (struct _tad__SetVideoAnalyticsConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__SetVideoAnalyticsConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__SetVideoAnalyticsConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _tad__SetVideoAnalyticsConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__SetVideoAnalyticsConfigurationResponse(soap, tag ? tag : "tad:SetVideoAnalyticsConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_get__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__SetVideoAnalyticsConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__SetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__SetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__SetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__SetVideoAnalyticsConfiguration(struct soap *soap, const struct _tad__SetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct _tad__SetVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tad:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tad:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in__tad__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _tad__SetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__SetVideoAnalyticsConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration, sizeof(struct _tad__SetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__SetVideoAnalyticsConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tad:Configuration", &a->Configuration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tad:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__SetVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration, sizeof(struct _tad__SetVideoAnalyticsConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_new__tad__SetVideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct _tad__SetVideoAnalyticsConfiguration *p;
	struct _tad__SetVideoAnalyticsConfiguration *a = (struct _tad__SetVideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__SetVideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tad__SetVideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__SetVideoAnalyticsConfiguration(struct soap *soap, const struct _tad__SetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tad__SetVideoAnalyticsConfiguration(soap, tag ? tag : "tad:SetVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get__tad__SetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__SetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__SetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEnginesResponse(struct soap *soap, struct _tad__GetAnalyticsEnginesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEnginesResponse(struct soap *soap, const struct _tad__GetAnalyticsEnginesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_tt__AnalyticsEngine);
			soap_serialize_tt__AnalyticsEngine(soap, a->Configuration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEnginesResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEnginesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEnginesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfiguration");
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_tt__AnalyticsEngine(soap, "tad:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEnginesResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsEnginesResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEnginesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configuration = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsEnginesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEnginesResponse, sizeof(struct _tad__GetAnalyticsEnginesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEnginesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct tt__AnalyticsEngine *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct tt__AnalyticsEngine));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_tt__AnalyticsEngine(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_tt__AnalyticsEngine(soap, "tad:Configuration", a->Configuration, "tt:AnalyticsEngine"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct tt__AnalyticsEngine *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEnginesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEnginesResponse, SOAP_TYPE__tad__GetAnalyticsEnginesResponse, sizeof(struct _tad__GetAnalyticsEnginesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEnginesResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsEnginesResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEnginesResponse *p;
	struct _tad__GetAnalyticsEnginesResponse *a = (struct _tad__GetAnalyticsEnginesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEnginesResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEnginesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEnginesResponse(struct soap *soap, const struct _tad__GetAnalyticsEnginesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEnginesResponse(soap, tag ? tag : "tad:GetAnalyticsEnginesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEnginesResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsEnginesResponse(struct soap *soap, struct _tad__GetAnalyticsEnginesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEnginesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngines(struct soap *soap, struct _tad__GetAnalyticsEngines *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngines(struct soap *soap, const struct _tad__GetAnalyticsEngines *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngines(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngines *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngines), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngines * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngines(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngines *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsEngines*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngines, sizeof(struct _tad__GetAnalyticsEngines), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngines(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngines *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngines, SOAP_TYPE__tad__GetAnalyticsEngines, sizeof(struct _tad__GetAnalyticsEngines), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngines * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngines(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngines *p;
	struct _tad__GetAnalyticsEngines *a = (struct _tad__GetAnalyticsEngines*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngines));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngines(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngines(struct soap *soap, const struct _tad__GetAnalyticsEngines *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngines(soap, tag ? tag : "tad:GetAnalyticsEngines", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngines * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngines(struct soap *soap, struct _tad__GetAnalyticsEngines *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngine(struct soap *soap, struct tt__AnalyticsEngine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->AnalyticsEngineConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngine(struct soap *soap, const struct tt__AnalyticsEngine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__AnalyticsDeviceEngineConfiguration(soap, &a->AnalyticsEngineConfiguration);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngine(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngine *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngine), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "tt:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->AnalyticsEngineConfiguration)
	{	if (soap_element_empty(soap, "tt:AnalyticsEngineConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->AnalyticsEngineConfiguration, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngine * SOAP_FMAC4 soap_in_tt__AnalyticsEngine(struct soap *soap, const char *tag, struct tt__AnalyticsEngine *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_AnalyticsEngineConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tt__AnalyticsEngine*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngine, sizeof(struct tt__AnalyticsEngine), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngine(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->AnalyticsEngineConfiguration, "tt:AnalyticsDeviceEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_UseCount > 0 || !a->AnalyticsEngineConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngine, SOAP_TYPE_tt__AnalyticsEngine, sizeof(struct tt__AnalyticsEngine), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngine * SOAP_FMAC4 soap_new_tt__AnalyticsEngine(struct soap *soap, int n)
{
	struct tt__AnalyticsEngine *p;
	struct tt__AnalyticsEngine *a = (struct tt__AnalyticsEngine*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngine));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngine(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngine(struct soap *soap, const struct tt__AnalyticsEngine *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngine(soap, tag ? tag : "tt:AnalyticsEngine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngine * SOAP_FMAC4 soap_get_tt__AnalyticsEngine(struct soap *soap, struct tt__AnalyticsEngine *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineResponse(struct soap *soap, struct _tad__GetAnalyticsEngineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngine(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "tad:Configuration");
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tad:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsEngine(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsEngineResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineResponse, sizeof(struct _tad__GetAnalyticsEngineResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngine(soap, "tad:Configuration", &a->Configuration, "tt:AnalyticsEngine"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			soap_check_result(soap, "tad:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineResponse, SOAP_TYPE__tad__GetAnalyticsEngineResponse, sizeof(struct _tad__GetAnalyticsEngineResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineResponse *p;
	struct _tad__GetAnalyticsEngineResponse *a = (struct _tad__GetAnalyticsEngineResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineResponse(soap, tag ? tag : "tad:GetAnalyticsEngineResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineResponse(struct soap *soap, struct _tad__GetAnalyticsEngineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngine(struct soap *soap, struct _tad__GetAnalyticsEngine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngine(struct soap *soap, const struct _tad__GetAnalyticsEngine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngine(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngine *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngine), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tad:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tad:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngine * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngine(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngine *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsEngine*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngine, sizeof(struct _tad__GetAnalyticsEngine), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngine(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tad:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngine, SOAP_TYPE__tad__GetAnalyticsEngine, sizeof(struct _tad__GetAnalyticsEngine), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngine * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngine(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngine *p;
	struct _tad__GetAnalyticsEngine *a = (struct _tad__GetAnalyticsEngine*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngine));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngine(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngine(struct soap *soap, const struct _tad__GetAnalyticsEngine *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngine(soap, tag ? tag : "tad:GetAnalyticsEngine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngine * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngine(struct soap *soap, struct _tad__GetAnalyticsEngine *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsEngineControls = 0;
	a->AnalyticsEngineControls = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineControlsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AnalyticsEngineControls)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsEngineControls; i++)
		{
			soap_embedded(soap, a->AnalyticsEngineControls + i, SOAP_TYPE_tt__AnalyticsEngineControl);
			soap_serialize_tt__AnalyticsEngineControl(soap, a->AnalyticsEngineControls + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineControlsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAnalyticsEngineControls");
	if (a->AnalyticsEngineControls)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsEngineControls; i++)
			if (soap_out_tt__AnalyticsEngineControl(soap, "tad:AnalyticsEngineControls", -1, a->AnalyticsEngineControls + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlsResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineControlsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsEngineControls = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsEngineControlsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse, sizeof(struct _tad__GetAnalyticsEngineControlsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineControlsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:AnalyticsEngineControls", 1, NULL))
			{	if (a->AnalyticsEngineControls == NULL)
				{	if (soap_blist_AnalyticsEngineControls == NULL)
						soap_blist_AnalyticsEngineControls = soap_alloc_block(soap);
					a->AnalyticsEngineControls = (struct tt__AnalyticsEngineControl *)soap_push_block_max(soap, soap_blist_AnalyticsEngineControls, sizeof(struct tt__AnalyticsEngineControl));
					if (a->AnalyticsEngineControls == NULL)
						return NULL;
					soap_default_tt__AnalyticsEngineControl(soap, a->AnalyticsEngineControls);
				}
				soap_revert(soap);
				if (soap_in_tt__AnalyticsEngineControl(soap, "tad:AnalyticsEngineControls", a->AnalyticsEngineControls, "tt:AnalyticsEngineControl"))
				{	a->__sizeAnalyticsEngineControls++;
					a->AnalyticsEngineControls = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAnalyticsEngineControls");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsEngineControls)
			soap_pop_block(soap, soap_blist_AnalyticsEngineControls);
		if (a->__sizeAnalyticsEngineControls)
		{	a->AnalyticsEngineControls = (struct tt__AnalyticsEngineControl *)soap_save_block(soap, soap_blist_AnalyticsEngineControls, NULL, 1);
		}
		else
		{	a->AnalyticsEngineControls = NULL;
			if (soap_blist_AnalyticsEngineControls)
				soap_end_block(soap, soap_blist_AnalyticsEngineControls);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAnalyticsEngineControls < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineControlsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse, sizeof(struct _tad__GetAnalyticsEngineControlsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlsResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineControlsResponse *p;
	struct _tad__GetAnalyticsEngineControlsResponse *a = (struct _tad__GetAnalyticsEngineControlsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineControlsResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineControlsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineControlsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineControlsResponse(soap, tag ? tag : "tad:GetAnalyticsEngineControlsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlsResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineControlsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineControls(struct soap *soap, struct _tad__GetAnalyticsEngineControls *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineControls(struct soap *soap, const struct _tad__GetAnalyticsEngineControls *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineControls(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineControls *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineControls), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControls * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineControls(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineControls *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsEngineControls*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineControls, sizeof(struct _tad__GetAnalyticsEngineControls), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineControls(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineControls *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineControls, SOAP_TYPE__tad__GetAnalyticsEngineControls, sizeof(struct _tad__GetAnalyticsEngineControls), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControls * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineControls(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineControls *p;
	struct _tad__GetAnalyticsEngineControls *a = (struct _tad__GetAnalyticsEngineControls*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineControls));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineControls(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineControls(struct soap *soap, const struct _tad__GetAnalyticsEngineControls *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineControls(soap, tag ? tag : "tad:GetAnalyticsEngineControls", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControls * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineControls(struct soap *soap, struct _tad__GetAnalyticsEngineControls *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineControls(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineControl(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineControlResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineControlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "tad:Configuration");
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tad:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsEngineControl(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineControlResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineControlResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsEngineControlResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse, sizeof(struct _tad__GetAnalyticsEngineControlResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineControlResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineControl(soap, "tad:Configuration", &a->Configuration, "tt:AnalyticsEngineControl"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			soap_check_result(soap, "tad:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse, sizeof(struct _tad__GetAnalyticsEngineControlResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineControlResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineControlResponse *p;
	struct _tad__GetAnalyticsEngineControlResponse *a = (struct _tad__GetAnalyticsEngineControlResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineControlResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineControlResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineControlResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineControlResponse(soap, tag ? tag : "tad:GetAnalyticsEngineControlResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineControl(struct soap *soap, struct _tad__GetAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineControl(struct soap *soap, const struct _tad__GetAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineControl), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_empty(soap, "tad:ConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tad:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControl * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineControl(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__GetAnalyticsEngineControl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineControl, sizeof(struct _tad__GetAnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineControl(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tad:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ConfigurationToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineControl, SOAP_TYPE__tad__GetAnalyticsEngineControl, sizeof(struct _tad__GetAnalyticsEngineControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControl * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineControl(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineControl *p;
	struct _tad__GetAnalyticsEngineControl *a = (struct _tad__GetAnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineControl(struct soap *soap, const struct _tad__GetAnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineControl(soap, tag ? tag : "tad:GetAnalyticsEngineControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControl * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineControl(struct soap *soap, struct _tad__GetAnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__SetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__SetAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__SetAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__SetAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__SetAnalyticsEngineControlResponse(struct soap *soap, const char *tag, int id, const struct _tad__SetAnalyticsEngineControlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControlResponse * SOAP_FMAC4 soap_in__tad__SetAnalyticsEngineControlResponse(struct soap *soap, const char *tag, struct _tad__SetAnalyticsEngineControlResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__SetAnalyticsEngineControlResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse, sizeof(struct _tad__SetAnalyticsEngineControlResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__SetAnalyticsEngineControlResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__SetAnalyticsEngineControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse, sizeof(struct _tad__SetAnalyticsEngineControlResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControlResponse * SOAP_FMAC4 soap_new__tad__SetAnalyticsEngineControlResponse(struct soap *soap, int n)
{
	struct _tad__SetAnalyticsEngineControlResponse *p;
	struct _tad__SetAnalyticsEngineControlResponse *a = (struct _tad__SetAnalyticsEngineControlResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__SetAnalyticsEngineControlResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__SetAnalyticsEngineControlResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__SetAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__SetAnalyticsEngineControlResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__SetAnalyticsEngineControlResponse(soap, tag ? tag : "tad:SetAnalyticsEngineControlResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControlResponse * SOAP_FMAC4 soap_get__tad__SetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__SetAnalyticsEngineControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__SetAnalyticsEngineControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__SetAnalyticsEngineControl(struct soap *soap, struct _tad__SetAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__SetAnalyticsEngineControl(struct soap *soap, const struct _tad__SetAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineControl(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__SetAnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct _tad__SetAnalyticsEngineControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__SetAnalyticsEngineControl), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_empty(soap, "tad:Configuration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsEngineControl(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tad:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControl * SOAP_FMAC4 soap_in__tad__SetAnalyticsEngineControl(struct soap *soap, const char *tag, struct _tad__SetAnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tad__SetAnalyticsEngineControl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetAnalyticsEngineControl, sizeof(struct _tad__SetAnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__SetAnalyticsEngineControl(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineControl(soap, "tad:Configuration", &a->Configuration, "tt:AnalyticsEngineControl"))
				{	soap_flag_Configuration--;
					continue;
				}
			}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "tad:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Configuration || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__SetAnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetAnalyticsEngineControl, SOAP_TYPE__tad__SetAnalyticsEngineControl, sizeof(struct _tad__SetAnalyticsEngineControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControl * SOAP_FMAC4 soap_new__tad__SetAnalyticsEngineControl(struct soap *soap, int n)
{
	struct _tad__SetAnalyticsEngineControl *p;
	struct _tad__SetAnalyticsEngineControl *a = (struct _tad__SetAnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__SetAnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default__tad__SetAnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__SetAnalyticsEngineControl(struct soap *soap, const struct _tad__SetAnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out__tad__SetAnalyticsEngineControl(soap, tag ? tag : "tad:SetAnalyticsEngineControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControl * SOAP_FMAC4 soap_get__tad__SetAnalyticsEngineControl(struct soap *soap, struct _tad__SetAnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__SetAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
