/* soapC_nnn.c
   Generated by gSOAP 2.8.114 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.114 2021-05-24 10:18:05 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingOptions(struct soap *soap, struct _trc__GetRecordingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingOptions(struct soap *soap, const struct _trc__GetRecordingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingOptions(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingOptions), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "trc:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingOptions * SOAP_FMAC4 soap_in__trc__GetRecordingOptions(struct soap *soap, const char *tag, struct _trc__GetRecordingOptions *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetRecordingOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingOptions, sizeof(struct _trc__GetRecordingOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingOptions, SOAP_TYPE__trc__GetRecordingOptions, sizeof(struct _trc__GetRecordingOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingOptions * SOAP_FMAC4 soap_new__trc__GetRecordingOptions(struct soap *soap, int n)
{
	struct _trc__GetRecordingOptions *p;
	struct _trc__GetRecordingOptions *a = (struct _trc__GetRecordingOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingOptions));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingOptions(struct soap *soap, const struct _trc__GetRecordingOptions *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingOptions(soap, tag ? tag : "trc:GetRecordingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingOptions * SOAP_FMAC4 soap_get__trc__GetRecordingOptions(struct soap *soap, struct _trc__GetRecordingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobStateResponse(struct soap *soap, struct _trc__GetRecordingJobStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->State = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobStateResponse(struct soap *soap, const struct _trc__GetRecordingJobStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingJobStateInformation(soap, &a->State);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobStateResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobStateResponse), type))
		return soap->error;
	if (a->State)
		soap_element_result(soap, "trc:State");
	if (!a->State)
	{	if (soap_element_empty(soap, "trc:State", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingJobStateInformation(soap, "trc:State", -1, &a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobStateResponse * SOAP_FMAC4 soap_in__trc__GetRecordingJobStateResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingJobStateResponse *a, const char *type)
{
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetRecordingJobStateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobStateResponse, sizeof(struct _trc__GetRecordingJobStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobStateResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobStateInformation(soap, "trc:State", &a->State, "tt:RecordingJobStateInformation"))
				{	soap_flag_State--;
					continue;
				}
			}
			soap_check_result(soap, "trc:State");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->State))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobStateResponse, SOAP_TYPE__trc__GetRecordingJobStateResponse, sizeof(struct _trc__GetRecordingJobStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingJobStateResponse * SOAP_FMAC4 soap_new__trc__GetRecordingJobStateResponse(struct soap *soap, int n)
{
	struct _trc__GetRecordingJobStateResponse *p;
	struct _trc__GetRecordingJobStateResponse *a = (struct _trc__GetRecordingJobStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingJobStateResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingJobStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobStateResponse(struct soap *soap, const struct _trc__GetRecordingJobStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingJobStateResponse(soap, tag ? tag : "trc:GetRecordingJobStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobStateResponse * SOAP_FMAC4 soap_get__trc__GetRecordingJobStateResponse(struct soap *soap, struct _trc__GetRecordingJobStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobState(struct soap *soap, struct _trc__GetRecordingJobState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobState(struct soap *soap, const struct _trc__GetRecordingJobState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobState(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobState), type))
		return soap->error;
	if (!a->JobToken)
	{	if (soap_element_empty(soap, "trc:JobToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobState * SOAP_FMAC4 soap_in__trc__GetRecordingJobState(struct soap *soap, const char *tag, struct _trc__GetRecordingJobState *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetRecordingJobState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobState, sizeof(struct _trc__GetRecordingJobState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobState(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobState, SOAP_TYPE__trc__GetRecordingJobState, sizeof(struct _trc__GetRecordingJobState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingJobState * SOAP_FMAC4 soap_new__trc__GetRecordingJobState(struct soap *soap, int n)
{
	struct _trc__GetRecordingJobState *p;
	struct _trc__GetRecordingJobState *a = (struct _trc__GetRecordingJobState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingJobState));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingJobState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobState(struct soap *soap, const struct _trc__GetRecordingJobState *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingJobState(soap, tag ? tag : "trc:GetRecordingJobState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobState * SOAP_FMAC4 soap_get__trc__GetRecordingJobState(struct soap *soap, struct _trc__GetRecordingJobState *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingJobModeResponse(struct soap *soap, struct _trc__SetRecordingJobModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingJobModeResponse(struct soap *soap, const struct _trc__SetRecordingJobModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingJobModeResponse(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingJobModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingJobModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingJobModeResponse * SOAP_FMAC4 soap_in__trc__SetRecordingJobModeResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingJobModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__SetRecordingJobModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobModeResponse, sizeof(struct _trc__SetRecordingJobModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingJobModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobModeResponse, SOAP_TYPE__trc__SetRecordingJobModeResponse, sizeof(struct _trc__SetRecordingJobModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetRecordingJobModeResponse * SOAP_FMAC4 soap_new__trc__SetRecordingJobModeResponse(struct soap *soap, int n)
{
	struct _trc__SetRecordingJobModeResponse *p;
	struct _trc__SetRecordingJobModeResponse *a = (struct _trc__SetRecordingJobModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetRecordingJobModeResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__SetRecordingJobModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingJobModeResponse(struct soap *soap, const struct _trc__SetRecordingJobModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetRecordingJobModeResponse(soap, tag ? tag : "trc:SetRecordingJobModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobModeResponse * SOAP_FMAC4 soap_get__trc__SetRecordingJobModeResponse(struct soap *soap, struct _trc__SetRecordingJobModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingJobModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingJobMode(struct soap *soap, struct _trc__SetRecordingJobMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
	soap_default_tt__RecordingJobMode(soap, &a->Mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingJobMode(struct soap *soap, const struct _trc__SetRecordingJobMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
	soap_serialize_tt__RecordingJobMode(soap, (char*const*)&a->Mode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingJobMode(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingJobMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingJobMode), type))
		return soap->error;
	if (!a->JobToken)
	{	if (soap_element_empty(soap, "trc:JobToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	if (!a->Mode)
	{	if (soap_element_empty(soap, "trc:Mode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingJobMode(soap, "trc:Mode", -1, (char*const*)&a->Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingJobMode * SOAP_FMAC4 soap_in__trc__SetRecordingJobMode(struct soap *soap, const char *tag, struct _trc__SetRecordingJobMode *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	size_t soap_flag_Mode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__SetRecordingJobMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobMode, sizeof(struct _trc__SetRecordingJobMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingJobMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			}
			if (soap_flag_Mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobMode(soap, "trc:Mode", (char**)&a->Mode, "tt:RecordingJobMode"))
				{	soap_flag_Mode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken || !a->Mode))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobMode, SOAP_TYPE__trc__SetRecordingJobMode, sizeof(struct _trc__SetRecordingJobMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetRecordingJobMode * SOAP_FMAC4 soap_new__trc__SetRecordingJobMode(struct soap *soap, int n)
{
	struct _trc__SetRecordingJobMode *p;
	struct _trc__SetRecordingJobMode *a = (struct _trc__SetRecordingJobMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetRecordingJobMode));
	for (p = a; p && n--; p++)
		soap_default__trc__SetRecordingJobMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingJobMode(struct soap *soap, const struct _trc__SetRecordingJobMode *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetRecordingJobMode(soap, tag ? tag : "trc:SetRecordingJobMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobMode * SOAP_FMAC4 soap_get__trc__SetRecordingJobMode(struct soap *soap, struct _trc__SetRecordingJobMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingJobMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__GetRecordingJobConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobConfigurationResponse(struct soap *soap, const struct _trc__GetRecordingJobConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse), type))
		return soap->error;
	if (a->JobConfiguration)
		soap_element_result(soap, "trc:JobConfiguration");
	if (!a->JobConfiguration)
	{	if (soap_element_empty(soap, "trc:JobConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_in__trc__GetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingJobConfigurationResponse *a, const char *type)
{
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetRecordingJobConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, sizeof(struct _trc__GetRecordingJobConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			}
			soap_check_result(soap, "trc:JobConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, sizeof(struct _trc__GetRecordingJobConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_new__trc__GetRecordingJobConfigurationResponse(struct soap *soap, int n)
{
	struct _trc__GetRecordingJobConfigurationResponse *p;
	struct _trc__GetRecordingJobConfigurationResponse *a = (struct _trc__GetRecordingJobConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingJobConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingJobConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobConfigurationResponse(struct soap *soap, const struct _trc__GetRecordingJobConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingJobConfigurationResponse(soap, tag ? tag : "trc:GetRecordingJobConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_get__trc__GetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__GetRecordingJobConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobConfiguration(struct soap *soap, struct _trc__GetRecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobConfiguration(struct soap *soap, const struct _trc__GetRecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobConfiguration), type))
		return soap->error;
	if (!a->JobToken)
	{	if (soap_element_empty(soap, "trc:JobToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfiguration * SOAP_FMAC4 soap_in__trc__GetRecordingJobConfiguration(struct soap *soap, const char *tag, struct _trc__GetRecordingJobConfiguration *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetRecordingJobConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobConfiguration, sizeof(struct _trc__GetRecordingJobConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobConfiguration, SOAP_TYPE__trc__GetRecordingJobConfiguration, sizeof(struct _trc__GetRecordingJobConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfiguration * SOAP_FMAC4 soap_new__trc__GetRecordingJobConfiguration(struct soap *soap, int n)
{
	struct _trc__GetRecordingJobConfiguration *p;
	struct _trc__GetRecordingJobConfiguration *a = (struct _trc__GetRecordingJobConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingJobConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingJobConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobConfiguration(struct soap *soap, const struct _trc__GetRecordingJobConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingJobConfiguration(soap, tag ? tag : "trc:GetRecordingJobConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfiguration * SOAP_FMAC4 soap_get__trc__GetRecordingJobConfiguration(struct soap *soap, struct _trc__GetRecordingJobConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__SetRecordingJobConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingJobConfigurationResponse(struct soap *soap, const struct _trc__SetRecordingJobConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingJobConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse), type))
		return soap->error;
	if (a->JobConfiguration)
		soap_element_result(soap, "trc:JobConfiguration");
	if (!a->JobConfiguration)
	{	if (soap_element_empty(soap, "trc:JobConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_in__trc__SetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingJobConfigurationResponse *a, const char *type)
{
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__SetRecordingJobConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, sizeof(struct _trc__SetRecordingJobConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingJobConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			}
			soap_check_result(soap, "trc:JobConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, sizeof(struct _trc__SetRecordingJobConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_new__trc__SetRecordingJobConfigurationResponse(struct soap *soap, int n)
{
	struct _trc__SetRecordingJobConfigurationResponse *p;
	struct _trc__SetRecordingJobConfigurationResponse *a = (struct _trc__SetRecordingJobConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetRecordingJobConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__SetRecordingJobConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingJobConfigurationResponse(struct soap *soap, const struct _trc__SetRecordingJobConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetRecordingJobConfigurationResponse(soap, tag ? tag : "trc:SetRecordingJobConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_get__trc__SetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__SetRecordingJobConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingJobConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingJobConfiguration(struct soap *soap, struct _trc__SetRecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingJobConfiguration(struct soap *soap, const struct _trc__SetRecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingJobConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingJobConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingJobConfiguration), type))
		return soap->error;
	if (!a->JobToken)
	{	if (soap_element_empty(soap, "trc:JobToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	if (!a->JobConfiguration)
	{	if (soap_element_empty(soap, "trc:JobConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfiguration * SOAP_FMAC4 soap_in__trc__SetRecordingJobConfiguration(struct soap *soap, const char *tag, struct _trc__SetRecordingJobConfiguration *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__SetRecordingJobConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobConfiguration, sizeof(struct _trc__SetRecordingJobConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingJobConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			}
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken || !a->JobConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobConfiguration, SOAP_TYPE__trc__SetRecordingJobConfiguration, sizeof(struct _trc__SetRecordingJobConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfiguration * SOAP_FMAC4 soap_new__trc__SetRecordingJobConfiguration(struct soap *soap, int n)
{
	struct _trc__SetRecordingJobConfiguration *p;
	struct _trc__SetRecordingJobConfiguration *a = (struct _trc__SetRecordingJobConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetRecordingJobConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trc__SetRecordingJobConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingJobConfiguration(struct soap *soap, const struct _trc__SetRecordingJobConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetRecordingJobConfiguration(soap, tag ? tag : "trc:SetRecordingJobConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfiguration * SOAP_FMAC4 soap_get__trc__SetRecordingJobConfiguration(struct soap *soap, struct _trc__SetRecordingJobConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobsResponse(struct soap *soap, struct _trc__GetRecordingJobsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeJobItem = 0;
	a->JobItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobsResponse(struct soap *soap, const struct _trc__GetRecordingJobsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->JobItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeJobItem; i++)
		{
			soap_embedded(soap, a->JobItem + i, SOAP_TYPE_tt__GetRecordingJobsResponseItem);
			soap_serialize_tt__GetRecordingJobsResponseItem(soap, a->JobItem + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobsResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeJobItem");
	if (a->JobItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeJobItem; i++)
			if (soap_out_tt__GetRecordingJobsResponseItem(soap, "trc:JobItem", -1, a->JobItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobsResponse * SOAP_FMAC4 soap_in__trc__GetRecordingJobsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingJobsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_JobItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetRecordingJobsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobsResponse, sizeof(struct _trc__GetRecordingJobsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trc:JobItem", 1, NULL))
			{	if (a->JobItem == NULL)
				{	if (soap_blist_JobItem == NULL)
						soap_blist_JobItem = soap_alloc_block(soap);
					a->JobItem = (struct tt__GetRecordingJobsResponseItem *)soap_push_block_max(soap, soap_blist_JobItem, sizeof(struct tt__GetRecordingJobsResponseItem));
					if (a->JobItem == NULL)
						return NULL;
					soap_default_tt__GetRecordingJobsResponseItem(soap, a->JobItem);
				}
				soap_revert(soap);
				if (soap_in_tt__GetRecordingJobsResponseItem(soap, "trc:JobItem", a->JobItem, "tt:GetRecordingJobsResponseItem"))
				{	a->__sizeJobItem++;
					a->JobItem = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeJobItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->JobItem)
			soap_pop_block(soap, soap_blist_JobItem);
		if (a->__sizeJobItem)
		{	a->JobItem = (struct tt__GetRecordingJobsResponseItem *)soap_save_block(soap, soap_blist_JobItem, NULL, 1);
		}
		else
		{	a->JobItem = NULL;
			if (soap_blist_JobItem)
				soap_end_block(soap, soap_blist_JobItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobsResponse, SOAP_TYPE__trc__GetRecordingJobsResponse, sizeof(struct _trc__GetRecordingJobsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingJobsResponse * SOAP_FMAC4 soap_new__trc__GetRecordingJobsResponse(struct soap *soap, int n)
{
	struct _trc__GetRecordingJobsResponse *p;
	struct _trc__GetRecordingJobsResponse *a = (struct _trc__GetRecordingJobsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingJobsResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingJobsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobsResponse(struct soap *soap, const struct _trc__GetRecordingJobsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingJobsResponse(soap, tag ? tag : "trc:GetRecordingJobsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobsResponse * SOAP_FMAC4 soap_get__trc__GetRecordingJobsResponse(struct soap *soap, struct _trc__GetRecordingJobsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobs(struct soap *soap, struct _trc__GetRecordingJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobs(struct soap *soap, const struct _trc__GetRecordingJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobs(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobs * SOAP_FMAC4 soap_in__trc__GetRecordingJobs(struct soap *soap, const char *tag, struct _trc__GetRecordingJobs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetRecordingJobs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobs, sizeof(struct _trc__GetRecordingJobs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobs(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobs, SOAP_TYPE__trc__GetRecordingJobs, sizeof(struct _trc__GetRecordingJobs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingJobs * SOAP_FMAC4 soap_new__trc__GetRecordingJobs(struct soap *soap, int n)
{
	struct _trc__GetRecordingJobs *p;
	struct _trc__GetRecordingJobs *a = (struct _trc__GetRecordingJobs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingJobs));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingJobs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobs(struct soap *soap, const struct _trc__GetRecordingJobs *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingJobs(soap, tag ? tag : "trc:GetRecordingJobs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobs * SOAP_FMAC4 soap_get__trc__GetRecordingJobs(struct soap *soap, struct _trc__GetRecordingJobs *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteRecordingJobResponse(struct soap *soap, struct _trc__DeleteRecordingJobResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteRecordingJobResponse(struct soap *soap, const struct _trc__DeleteRecordingJobResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteRecordingJobResponse(struct soap *soap, const char *tag, int id, const struct _trc__DeleteRecordingJobResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteRecordingJobResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJobResponse * SOAP_FMAC4 soap_in__trc__DeleteRecordingJobResponse(struct soap *soap, const char *tag, struct _trc__DeleteRecordingJobResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__DeleteRecordingJobResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecordingJobResponse, sizeof(struct _trc__DeleteRecordingJobResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteRecordingJobResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecordingJobResponse, SOAP_TYPE__trc__DeleteRecordingJobResponse, sizeof(struct _trc__DeleteRecordingJobResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__DeleteRecordingJobResponse * SOAP_FMAC4 soap_new__trc__DeleteRecordingJobResponse(struct soap *soap, int n)
{
	struct _trc__DeleteRecordingJobResponse *p;
	struct _trc__DeleteRecordingJobResponse *a = (struct _trc__DeleteRecordingJobResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__DeleteRecordingJobResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__DeleteRecordingJobResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteRecordingJobResponse(struct soap *soap, const struct _trc__DeleteRecordingJobResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__DeleteRecordingJobResponse(soap, tag ? tag : "trc:DeleteRecordingJobResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJobResponse * SOAP_FMAC4 soap_get__trc__DeleteRecordingJobResponse(struct soap *soap, struct _trc__DeleteRecordingJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteRecordingJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteRecordingJob(struct soap *soap, struct _trc__DeleteRecordingJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteRecordingJob(struct soap *soap, const struct _trc__DeleteRecordingJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteRecordingJob(struct soap *soap, const char *tag, int id, const struct _trc__DeleteRecordingJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteRecordingJob), type))
		return soap->error;
	if (!a->JobToken)
	{	if (soap_element_empty(soap, "trc:JobToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJob * SOAP_FMAC4 soap_in__trc__DeleteRecordingJob(struct soap *soap, const char *tag, struct _trc__DeleteRecordingJob *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__DeleteRecordingJob*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecordingJob, sizeof(struct _trc__DeleteRecordingJob), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteRecordingJob(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecordingJob, SOAP_TYPE__trc__DeleteRecordingJob, sizeof(struct _trc__DeleteRecordingJob), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__DeleteRecordingJob * SOAP_FMAC4 soap_new__trc__DeleteRecordingJob(struct soap *soap, int n)
{
	struct _trc__DeleteRecordingJob *p;
	struct _trc__DeleteRecordingJob *a = (struct _trc__DeleteRecordingJob*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__DeleteRecordingJob));
	for (p = a; p && n--; p++)
		soap_default__trc__DeleteRecordingJob(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteRecordingJob(struct soap *soap, const struct _trc__DeleteRecordingJob *a, const char *tag, const char *type)
{
	if (soap_out__trc__DeleteRecordingJob(soap, tag ? tag : "trc:DeleteRecordingJob", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJob * SOAP_FMAC4 soap_get__trc__DeleteRecordingJob(struct soap *soap, struct _trc__DeleteRecordingJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteRecordingJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateRecordingJobResponse(struct soap *soap, struct _trc__CreateRecordingJobResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateRecordingJobResponse(struct soap *soap, const struct _trc__CreateRecordingJobResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateRecordingJobResponse(struct soap *soap, const char *tag, int id, const struct _trc__CreateRecordingJobResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateRecordingJobResponse), type))
		return soap->error;
	if (a->JobToken)
		soap_element_result(soap, "trc:JobToken");
	if (!a->JobToken)
	{	if (soap_element_empty(soap, "trc:JobToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	if (!a->JobConfiguration)
	{	if (soap_element_empty(soap, "trc:JobConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateRecordingJobResponse * SOAP_FMAC4 soap_in__trc__CreateRecordingJobResponse(struct soap *soap, const char *tag, struct _trc__CreateRecordingJobResponse *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__CreateRecordingJobResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecordingJobResponse, sizeof(struct _trc__CreateRecordingJobResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateRecordingJobResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			}
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			}
			soap_check_result(soap, "trc:JobToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobToken || !a->JobConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecordingJobResponse, SOAP_TYPE__trc__CreateRecordingJobResponse, sizeof(struct _trc__CreateRecordingJobResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__CreateRecordingJobResponse * SOAP_FMAC4 soap_new__trc__CreateRecordingJobResponse(struct soap *soap, int n)
{
	struct _trc__CreateRecordingJobResponse *p;
	struct _trc__CreateRecordingJobResponse *a = (struct _trc__CreateRecordingJobResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__CreateRecordingJobResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__CreateRecordingJobResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateRecordingJobResponse(struct soap *soap, const struct _trc__CreateRecordingJobResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__CreateRecordingJobResponse(soap, tag ? tag : "trc:CreateRecordingJobResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingJobResponse * SOAP_FMAC4 soap_get__trc__CreateRecordingJobResponse(struct soap *soap, struct _trc__CreateRecordingJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateRecordingJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateRecordingJob(struct soap *soap, struct _trc__CreateRecordingJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateRecordingJob(struct soap *soap, const struct _trc__CreateRecordingJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateRecordingJob(struct soap *soap, const char *tag, int id, const struct _trc__CreateRecordingJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateRecordingJob), type))
		return soap->error;
	if (!a->JobConfiguration)
	{	if (soap_element_empty(soap, "trc:JobConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateRecordingJob * SOAP_FMAC4 soap_in__trc__CreateRecordingJob(struct soap *soap, const char *tag, struct _trc__CreateRecordingJob *a, const char *type)
{
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__CreateRecordingJob*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecordingJob, sizeof(struct _trc__CreateRecordingJob), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateRecordingJob(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->JobConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecordingJob, SOAP_TYPE__trc__CreateRecordingJob, sizeof(struct _trc__CreateRecordingJob), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__CreateRecordingJob * SOAP_FMAC4 soap_new__trc__CreateRecordingJob(struct soap *soap, int n)
{
	struct _trc__CreateRecordingJob *p;
	struct _trc__CreateRecordingJob *a = (struct _trc__CreateRecordingJob*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__CreateRecordingJob));
	for (p = a; p && n--; p++)
		soap_default__trc__CreateRecordingJob(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateRecordingJob(struct soap *soap, const struct _trc__CreateRecordingJob *a, const char *tag, const char *type)
{
	if (soap_out__trc__CreateRecordingJob(soap, tag ? tag : "trc:CreateRecordingJob", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingJob * SOAP_FMAC4 soap_get__trc__CreateRecordingJob(struct soap *soap, struct _trc__CreateRecordingJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateRecordingJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetTrackConfigurationResponse(struct soap *soap, struct _trc__SetTrackConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetTrackConfigurationResponse(struct soap *soap, const struct _trc__SetTrackConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetTrackConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__SetTrackConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetTrackConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetTrackConfigurationResponse * SOAP_FMAC4 soap_in__trc__SetTrackConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetTrackConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__SetTrackConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetTrackConfigurationResponse, sizeof(struct _trc__SetTrackConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetTrackConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetTrackConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetTrackConfigurationResponse, SOAP_TYPE__trc__SetTrackConfigurationResponse, sizeof(struct _trc__SetTrackConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetTrackConfigurationResponse * SOAP_FMAC4 soap_new__trc__SetTrackConfigurationResponse(struct soap *soap, int n)
{
	struct _trc__SetTrackConfigurationResponse *p;
	struct _trc__SetTrackConfigurationResponse *a = (struct _trc__SetTrackConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetTrackConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__SetTrackConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetTrackConfigurationResponse(struct soap *soap, const struct _trc__SetTrackConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetTrackConfigurationResponse(soap, tag ? tag : "trc:SetTrackConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetTrackConfigurationResponse * SOAP_FMAC4 soap_get__trc__SetTrackConfigurationResponse(struct soap *soap, struct _trc__SetTrackConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetTrackConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetTrackConfiguration(struct soap *soap, struct _trc__SetTrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	a->TrackConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetTrackConfiguration(struct soap *soap, const struct _trc__SetTrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
	soap_serialize_PointerTott__TrackConfiguration(soap, &a->TrackConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetTrackConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__SetTrackConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetTrackConfiguration), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "trc:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_empty(soap, "trc:TrackToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__TrackReference(soap, "trc:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	if (!a->TrackConfiguration)
	{	if (soap_element_empty(soap, "trc:TrackConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", -1, &a->TrackConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetTrackConfiguration * SOAP_FMAC4 soap_in__trc__SetTrackConfiguration(struct soap *soap, const char *tag, struct _trc__SetTrackConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_TrackConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__SetTrackConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetTrackConfiguration, sizeof(struct _trc__SetTrackConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetTrackConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "trc:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			}
			if (soap_flag_TrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", &a->TrackConfiguration, "tt:TrackConfiguration"))
				{	soap_flag_TrackConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackToken || !a->TrackConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__SetTrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetTrackConfiguration, SOAP_TYPE__trc__SetTrackConfiguration, sizeof(struct _trc__SetTrackConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetTrackConfiguration * SOAP_FMAC4 soap_new__trc__SetTrackConfiguration(struct soap *soap, int n)
{
	struct _trc__SetTrackConfiguration *p;
	struct _trc__SetTrackConfiguration *a = (struct _trc__SetTrackConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetTrackConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trc__SetTrackConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetTrackConfiguration(struct soap *soap, const struct _trc__SetTrackConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetTrackConfiguration(soap, tag ? tag : "trc:SetTrackConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetTrackConfiguration * SOAP_FMAC4 soap_get__trc__SetTrackConfiguration(struct soap *soap, struct _trc__SetTrackConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetTrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetTrackConfigurationResponse(struct soap *soap, struct _trc__GetTrackConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TrackConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetTrackConfigurationResponse(struct soap *soap, const struct _trc__GetTrackConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__TrackConfiguration(soap, &a->TrackConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetTrackConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetTrackConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetTrackConfigurationResponse), type))
		return soap->error;
	if (a->TrackConfiguration)
		soap_element_result(soap, "trc:TrackConfiguration");
	if (!a->TrackConfiguration)
	{	if (soap_element_empty(soap, "trc:TrackConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", -1, &a->TrackConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetTrackConfigurationResponse * SOAP_FMAC4 soap_in__trc__GetTrackConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetTrackConfigurationResponse *a, const char *type)
{
	size_t soap_flag_TrackConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetTrackConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetTrackConfigurationResponse, sizeof(struct _trc__GetTrackConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetTrackConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", &a->TrackConfiguration, "tt:TrackConfiguration"))
				{	soap_flag_TrackConfiguration--;
					continue;
				}
			}
			soap_check_result(soap, "trc:TrackConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->TrackConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetTrackConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetTrackConfigurationResponse, SOAP_TYPE__trc__GetTrackConfigurationResponse, sizeof(struct _trc__GetTrackConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetTrackConfigurationResponse * SOAP_FMAC4 soap_new__trc__GetTrackConfigurationResponse(struct soap *soap, int n)
{
	struct _trc__GetTrackConfigurationResponse *p;
	struct _trc__GetTrackConfigurationResponse *a = (struct _trc__GetTrackConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetTrackConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetTrackConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetTrackConfigurationResponse(struct soap *soap, const struct _trc__GetTrackConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetTrackConfigurationResponse(soap, tag ? tag : "trc:GetTrackConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetTrackConfigurationResponse * SOAP_FMAC4 soap_get__trc__GetTrackConfigurationResponse(struct soap *soap, struct _trc__GetTrackConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetTrackConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetTrackConfiguration(struct soap *soap, struct _trc__GetTrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetTrackConfiguration(struct soap *soap, const struct _trc__GetTrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetTrackConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__GetTrackConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetTrackConfiguration), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "trc:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_empty(soap, "trc:TrackToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__TrackReference(soap, "trc:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetTrackConfiguration * SOAP_FMAC4 soap_in__trc__GetTrackConfiguration(struct soap *soap, const char *tag, struct _trc__GetTrackConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetTrackConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetTrackConfiguration, sizeof(struct _trc__GetTrackConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetTrackConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "trc:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetTrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetTrackConfiguration, SOAP_TYPE__trc__GetTrackConfiguration, sizeof(struct _trc__GetTrackConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetTrackConfiguration * SOAP_FMAC4 soap_new__trc__GetTrackConfiguration(struct soap *soap, int n)
{
	struct _trc__GetTrackConfiguration *p;
	struct _trc__GetTrackConfiguration *a = (struct _trc__GetTrackConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetTrackConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trc__GetTrackConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetTrackConfiguration(struct soap *soap, const struct _trc__GetTrackConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetTrackConfiguration(soap, tag ? tag : "trc:GetTrackConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetTrackConfiguration * SOAP_FMAC4 soap_get__trc__GetTrackConfiguration(struct soap *soap, struct _trc__GetTrackConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetTrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteTrackResponse(struct soap *soap, struct _trc__DeleteTrackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteTrackResponse(struct soap *soap, const struct _trc__DeleteTrackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteTrackResponse(struct soap *soap, const char *tag, int id, const struct _trc__DeleteTrackResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteTrackResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteTrackResponse * SOAP_FMAC4 soap_in__trc__DeleteTrackResponse(struct soap *soap, const char *tag, struct _trc__DeleteTrackResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__DeleteTrackResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteTrackResponse, sizeof(struct _trc__DeleteTrackResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteTrackResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteTrackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteTrackResponse, SOAP_TYPE__trc__DeleteTrackResponse, sizeof(struct _trc__DeleteTrackResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__DeleteTrackResponse * SOAP_FMAC4 soap_new__trc__DeleteTrackResponse(struct soap *soap, int n)
{
	struct _trc__DeleteTrackResponse *p;
	struct _trc__DeleteTrackResponse *a = (struct _trc__DeleteTrackResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__DeleteTrackResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__DeleteTrackResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteTrackResponse(struct soap *soap, const struct _trc__DeleteTrackResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__DeleteTrackResponse(soap, tag ? tag : "trc:DeleteTrackResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteTrackResponse * SOAP_FMAC4 soap_get__trc__DeleteTrackResponse(struct soap *soap, struct _trc__DeleteTrackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteTrackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteTrack(struct soap *soap, struct _trc__DeleteTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteTrack(struct soap *soap, const struct _trc__DeleteTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteTrack(struct soap *soap, const char *tag, int id, const struct _trc__DeleteTrack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteTrack), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "trc:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_empty(soap, "trc:TrackToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__TrackReference(soap, "trc:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteTrack * SOAP_FMAC4 soap_in__trc__DeleteTrack(struct soap *soap, const char *tag, struct _trc__DeleteTrack *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__DeleteTrack*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteTrack, sizeof(struct _trc__DeleteTrack), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteTrack(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "trc:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__DeleteTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteTrack, SOAP_TYPE__trc__DeleteTrack, sizeof(struct _trc__DeleteTrack), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__DeleteTrack * SOAP_FMAC4 soap_new__trc__DeleteTrack(struct soap *soap, int n)
{
	struct _trc__DeleteTrack *p;
	struct _trc__DeleteTrack *a = (struct _trc__DeleteTrack*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__DeleteTrack));
	for (p = a; p && n--; p++)
		soap_default__trc__DeleteTrack(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteTrack(struct soap *soap, const struct _trc__DeleteTrack *a, const char *tag, const char *type)
{
	if (soap_out__trc__DeleteTrack(soap, tag ? tag : "trc:DeleteTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteTrack * SOAP_FMAC4 soap_get__trc__DeleteTrack(struct soap *soap, struct _trc__DeleteTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateTrackResponse(struct soap *soap, struct _trc__CreateTrackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TrackReference(soap, &a->TrackToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateTrackResponse(struct soap *soap, const struct _trc__CreateTrackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateTrackResponse(struct soap *soap, const char *tag, int id, const struct _trc__CreateTrackResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateTrackResponse), type))
		return soap->error;
	if (a->TrackToken)
		soap_element_result(soap, "trc:TrackToken");
	if (!a->TrackToken)
	{	if (soap_element_empty(soap, "trc:TrackToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__TrackReference(soap, "trc:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateTrackResponse * SOAP_FMAC4 soap_in__trc__CreateTrackResponse(struct soap *soap, const char *tag, struct _trc__CreateTrackResponse *a, const char *type)
{
	size_t soap_flag_TrackToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__CreateTrackResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateTrackResponse, sizeof(struct _trc__CreateTrackResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateTrackResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__TrackReference(soap, "trc:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			}
			soap_check_result(soap, "trc:TrackToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->TrackToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__CreateTrackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateTrackResponse, SOAP_TYPE__trc__CreateTrackResponse, sizeof(struct _trc__CreateTrackResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__CreateTrackResponse * SOAP_FMAC4 soap_new__trc__CreateTrackResponse(struct soap *soap, int n)
{
	struct _trc__CreateTrackResponse *p;
	struct _trc__CreateTrackResponse *a = (struct _trc__CreateTrackResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__CreateTrackResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__CreateTrackResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateTrackResponse(struct soap *soap, const struct _trc__CreateTrackResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__CreateTrackResponse(soap, tag ? tag : "trc:CreateTrackResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateTrackResponse * SOAP_FMAC4 soap_get__trc__CreateTrackResponse(struct soap *soap, struct _trc__CreateTrackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateTrackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateTrack(struct soap *soap, struct _trc__CreateTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->TrackConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateTrack(struct soap *soap, const struct _trc__CreateTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_PointerTott__TrackConfiguration(soap, &a->TrackConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateTrack(struct soap *soap, const char *tag, int id, const struct _trc__CreateTrack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateTrack), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "trc:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackConfiguration)
	{	if (soap_element_empty(soap, "trc:TrackConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", -1, &a->TrackConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateTrack * SOAP_FMAC4 soap_in__trc__CreateTrack(struct soap *soap, const char *tag, struct _trc__CreateTrack *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__CreateTrack*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateTrack, sizeof(struct _trc__CreateTrack), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateTrack(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap_flag_TrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", &a->TrackConfiguration, "tt:TrackConfiguration"))
				{	soap_flag_TrackConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->TrackConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__CreateTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateTrack, SOAP_TYPE__trc__CreateTrack, sizeof(struct _trc__CreateTrack), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__CreateTrack * SOAP_FMAC4 soap_new__trc__CreateTrack(struct soap *soap, int n)
{
	struct _trc__CreateTrack *p;
	struct _trc__CreateTrack *a = (struct _trc__CreateTrack*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__CreateTrack));
	for (p = a; p && n--; p++)
		soap_default__trc__CreateTrack(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateTrack(struct soap *soap, const struct _trc__CreateTrack *a, const char *tag, const char *type)
{
	if (soap_out__trc__CreateTrack(soap, tag ? tag : "trc:CreateTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateTrack * SOAP_FMAC4 soap_get__trc__CreateTrack(struct soap *soap, struct _trc__CreateTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingConfigurationResponse(struct soap *soap, struct _trc__GetRecordingConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecordingConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingConfigurationResponse(struct soap *soap, const struct _trc__GetRecordingConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingConfiguration(soap, &a->RecordingConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingConfigurationResponse), type))
		return soap->error;
	if (a->RecordingConfiguration)
		soap_element_result(soap, "trc:RecordingConfiguration");
	if (!a->RecordingConfiguration)
	{	if (soap_element_empty(soap, "trc:RecordingConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", -1, &a->RecordingConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingConfigurationResponse * SOAP_FMAC4 soap_in__trc__GetRecordingConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingConfigurationResponse *a, const char *type)
{
	size_t soap_flag_RecordingConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetRecordingConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingConfigurationResponse, sizeof(struct _trc__GetRecordingConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", &a->RecordingConfiguration, "tt:RecordingConfiguration"))
				{	soap_flag_RecordingConfiguration--;
					continue;
				}
			}
			soap_check_result(soap, "trc:RecordingConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingConfigurationResponse, SOAP_TYPE__trc__GetRecordingConfigurationResponse, sizeof(struct _trc__GetRecordingConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingConfigurationResponse * SOAP_FMAC4 soap_new__trc__GetRecordingConfigurationResponse(struct soap *soap, int n)
{
	struct _trc__GetRecordingConfigurationResponse *p;
	struct _trc__GetRecordingConfigurationResponse *a = (struct _trc__GetRecordingConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingConfigurationResponse(struct soap *soap, const struct _trc__GetRecordingConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingConfigurationResponse(soap, tag ? tag : "trc:GetRecordingConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingConfigurationResponse * SOAP_FMAC4 soap_get__trc__GetRecordingConfigurationResponse(struct soap *soap, struct _trc__GetRecordingConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingConfiguration(struct soap *soap, struct _trc__GetRecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingConfiguration(struct soap *soap, const struct _trc__GetRecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingConfiguration), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "trc:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingConfiguration * SOAP_FMAC4 soap_in__trc__GetRecordingConfiguration(struct soap *soap, const char *tag, struct _trc__GetRecordingConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetRecordingConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingConfiguration, sizeof(struct _trc__GetRecordingConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingConfiguration, SOAP_TYPE__trc__GetRecordingConfiguration, sizeof(struct _trc__GetRecordingConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingConfiguration * SOAP_FMAC4 soap_new__trc__GetRecordingConfiguration(struct soap *soap, int n)
{
	struct _trc__GetRecordingConfiguration *p;
	struct _trc__GetRecordingConfiguration *a = (struct _trc__GetRecordingConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingConfiguration(struct soap *soap, const struct _trc__GetRecordingConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingConfiguration(soap, tag ? tag : "trc:GetRecordingConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingConfiguration * SOAP_FMAC4 soap_get__trc__GetRecordingConfiguration(struct soap *soap, struct _trc__GetRecordingConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingConfigurationResponse(struct soap *soap, struct _trc__SetRecordingConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingConfigurationResponse(struct soap *soap, const struct _trc__SetRecordingConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingConfigurationResponse * SOAP_FMAC4 soap_in__trc__SetRecordingConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__SetRecordingConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingConfigurationResponse, sizeof(struct _trc__SetRecordingConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingConfigurationResponse, SOAP_TYPE__trc__SetRecordingConfigurationResponse, sizeof(struct _trc__SetRecordingConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetRecordingConfigurationResponse * SOAP_FMAC4 soap_new__trc__SetRecordingConfigurationResponse(struct soap *soap, int n)
{
	struct _trc__SetRecordingConfigurationResponse *p;
	struct _trc__SetRecordingConfigurationResponse *a = (struct _trc__SetRecordingConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetRecordingConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__SetRecordingConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingConfigurationResponse(struct soap *soap, const struct _trc__SetRecordingConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetRecordingConfigurationResponse(soap, tag ? tag : "trc:SetRecordingConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingConfigurationResponse * SOAP_FMAC4 soap_get__trc__SetRecordingConfigurationResponse(struct soap *soap, struct _trc__SetRecordingConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingConfiguration(struct soap *soap, struct _trc__SetRecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->RecordingConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingConfiguration(struct soap *soap, const struct _trc__SetRecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_PointerTott__RecordingConfiguration(soap, &a->RecordingConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingConfiguration), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "trc:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->RecordingConfiguration)
	{	if (soap_element_empty(soap, "trc:RecordingConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", -1, &a->RecordingConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingConfiguration * SOAP_FMAC4 soap_in__trc__SetRecordingConfiguration(struct soap *soap, const char *tag, struct _trc__SetRecordingConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_RecordingConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__SetRecordingConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingConfiguration, sizeof(struct _trc__SetRecordingConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap_flag_RecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", &a->RecordingConfiguration, "tt:RecordingConfiguration"))
				{	soap_flag_RecordingConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken || !a->RecordingConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingConfiguration, SOAP_TYPE__trc__SetRecordingConfiguration, sizeof(struct _trc__SetRecordingConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetRecordingConfiguration * SOAP_FMAC4 soap_new__trc__SetRecordingConfiguration(struct soap *soap, int n)
{
	struct _trc__SetRecordingConfiguration *p;
	struct _trc__SetRecordingConfiguration *a = (struct _trc__SetRecordingConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetRecordingConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trc__SetRecordingConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingConfiguration(struct soap *soap, const struct _trc__SetRecordingConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetRecordingConfiguration(soap, tag ? tag : "trc:SetRecordingConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingConfiguration * SOAP_FMAC4 soap_get__trc__SetRecordingConfiguration(struct soap *soap, struct _trc__SetRecordingConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingsResponse(struct soap *soap, struct _trc__GetRecordingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRecordingItem = 0;
	a->RecordingItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingsResponse(struct soap *soap, const struct _trc__GetRecordingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RecordingItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeRecordingItem; i++)
		{
			soap_embedded(soap, a->RecordingItem + i, SOAP_TYPE_tt__GetRecordingsResponseItem);
			soap_serialize_tt__GetRecordingsResponseItem(soap, a->RecordingItem + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingsResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeRecordingItem");
	if (a->RecordingItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeRecordingItem; i++)
			if (soap_out_tt__GetRecordingsResponseItem(soap, "trc:RecordingItem", -1, a->RecordingItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingsResponse * SOAP_FMAC4 soap_in__trc__GetRecordingsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_RecordingItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetRecordingsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingsResponse, sizeof(struct _trc__GetRecordingsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trc:RecordingItem", 1, NULL))
			{	if (a->RecordingItem == NULL)
				{	if (soap_blist_RecordingItem == NULL)
						soap_blist_RecordingItem = soap_alloc_block(soap);
					a->RecordingItem = (struct tt__GetRecordingsResponseItem *)soap_push_block_max(soap, soap_blist_RecordingItem, sizeof(struct tt__GetRecordingsResponseItem));
					if (a->RecordingItem == NULL)
						return NULL;
					soap_default_tt__GetRecordingsResponseItem(soap, a->RecordingItem);
				}
				soap_revert(soap);
				if (soap_in_tt__GetRecordingsResponseItem(soap, "trc:RecordingItem", a->RecordingItem, "tt:GetRecordingsResponseItem"))
				{	a->__sizeRecordingItem++;
					a->RecordingItem = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRecordingItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RecordingItem)
			soap_pop_block(soap, soap_blist_RecordingItem);
		if (a->__sizeRecordingItem)
		{	a->RecordingItem = (struct tt__GetRecordingsResponseItem *)soap_save_block(soap, soap_blist_RecordingItem, NULL, 1);
		}
		else
		{	a->RecordingItem = NULL;
			if (soap_blist_RecordingItem)
				soap_end_block(soap, soap_blist_RecordingItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingsResponse, SOAP_TYPE__trc__GetRecordingsResponse, sizeof(struct _trc__GetRecordingsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingsResponse * SOAP_FMAC4 soap_new__trc__GetRecordingsResponse(struct soap *soap, int n)
{
	struct _trc__GetRecordingsResponse *p;
	struct _trc__GetRecordingsResponse *a = (struct _trc__GetRecordingsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingsResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingsResponse(struct soap *soap, const struct _trc__GetRecordingsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingsResponse(soap, tag ? tag : "trc:GetRecordingsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingsResponse * SOAP_FMAC4 soap_get__trc__GetRecordingsResponse(struct soap *soap, struct _trc__GetRecordingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordings(struct soap *soap, struct _trc__GetRecordings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordings(struct soap *soap, const struct _trc__GetRecordings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordings(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordings), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordings * SOAP_FMAC4 soap_in__trc__GetRecordings(struct soap *soap, const char *tag, struct _trc__GetRecordings *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetRecordings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordings, sizeof(struct _trc__GetRecordings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordings(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordings, SOAP_TYPE__trc__GetRecordings, sizeof(struct _trc__GetRecordings), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordings * SOAP_FMAC4 soap_new__trc__GetRecordings(struct soap *soap, int n)
{
	struct _trc__GetRecordings *p;
	struct _trc__GetRecordings *a = (struct _trc__GetRecordings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordings));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordings(struct soap *soap, const struct _trc__GetRecordings *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordings(soap, tag ? tag : "trc:GetRecordings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordings * SOAP_FMAC4 soap_get__trc__GetRecordings(struct soap *soap, struct _trc__GetRecordings *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteRecordingResponse(struct soap *soap, struct _trc__DeleteRecordingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteRecordingResponse(struct soap *soap, const struct _trc__DeleteRecordingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteRecordingResponse(struct soap *soap, const char *tag, int id, const struct _trc__DeleteRecordingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteRecordingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteRecordingResponse * SOAP_FMAC4 soap_in__trc__DeleteRecordingResponse(struct soap *soap, const char *tag, struct _trc__DeleteRecordingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__DeleteRecordingResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecordingResponse, sizeof(struct _trc__DeleteRecordingResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteRecordingResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecordingResponse, SOAP_TYPE__trc__DeleteRecordingResponse, sizeof(struct _trc__DeleteRecordingResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__DeleteRecordingResponse * SOAP_FMAC4 soap_new__trc__DeleteRecordingResponse(struct soap *soap, int n)
{
	struct _trc__DeleteRecordingResponse *p;
	struct _trc__DeleteRecordingResponse *a = (struct _trc__DeleteRecordingResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__DeleteRecordingResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__DeleteRecordingResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteRecordingResponse(struct soap *soap, const struct _trc__DeleteRecordingResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__DeleteRecordingResponse(soap, tag ? tag : "trc:DeleteRecordingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingResponse * SOAP_FMAC4 soap_get__trc__DeleteRecordingResponse(struct soap *soap, struct _trc__DeleteRecordingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteRecording(struct soap *soap, struct _trc__DeleteRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteRecording(struct soap *soap, const struct _trc__DeleteRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteRecording(struct soap *soap, const char *tag, int id, const struct _trc__DeleteRecording *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteRecording), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "trc:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteRecording * SOAP_FMAC4 soap_in__trc__DeleteRecording(struct soap *soap, const char *tag, struct _trc__DeleteRecording *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__DeleteRecording*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecording, sizeof(struct _trc__DeleteRecording), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteRecording(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecording *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecording, SOAP_TYPE__trc__DeleteRecording, sizeof(struct _trc__DeleteRecording), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__DeleteRecording * SOAP_FMAC4 soap_new__trc__DeleteRecording(struct soap *soap, int n)
{
	struct _trc__DeleteRecording *p;
	struct _trc__DeleteRecording *a = (struct _trc__DeleteRecording*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__DeleteRecording));
	for (p = a; p && n--; p++)
		soap_default__trc__DeleteRecording(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteRecording(struct soap *soap, const struct _trc__DeleteRecording *a, const char *tag, const char *type)
{
	if (soap_out__trc__DeleteRecording(soap, tag ? tag : "trc:DeleteRecording", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecording * SOAP_FMAC4 soap_get__trc__DeleteRecording(struct soap *soap, struct _trc__DeleteRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateRecordingResponse(struct soap *soap, struct _trc__CreateRecordingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateRecordingResponse(struct soap *soap, const struct _trc__CreateRecordingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateRecordingResponse(struct soap *soap, const char *tag, int id, const struct _trc__CreateRecordingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateRecordingResponse), type))
		return soap->error;
	if (a->RecordingToken)
		soap_element_result(soap, "trc:RecordingToken");
	if (!a->RecordingToken)
	{	if (soap_element_empty(soap, "trc:RecordingToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateRecordingResponse * SOAP_FMAC4 soap_in__trc__CreateRecordingResponse(struct soap *soap, const char *tag, struct _trc__CreateRecordingResponse *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__CreateRecordingResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecordingResponse, sizeof(struct _trc__CreateRecordingResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateRecordingResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			}
			soap_check_result(soap, "trc:RecordingToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecordingResponse, SOAP_TYPE__trc__CreateRecordingResponse, sizeof(struct _trc__CreateRecordingResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__CreateRecordingResponse * SOAP_FMAC4 soap_new__trc__CreateRecordingResponse(struct soap *soap, int n)
{
	struct _trc__CreateRecordingResponse *p;
	struct _trc__CreateRecordingResponse *a = (struct _trc__CreateRecordingResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__CreateRecordingResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__CreateRecordingResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateRecordingResponse(struct soap *soap, const struct _trc__CreateRecordingResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__CreateRecordingResponse(soap, tag ? tag : "trc:CreateRecordingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingResponse * SOAP_FMAC4 soap_get__trc__CreateRecordingResponse(struct soap *soap, struct _trc__CreateRecordingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateRecording(struct soap *soap, struct _trc__CreateRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecordingConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateRecording(struct soap *soap, const struct _trc__CreateRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingConfiguration(soap, &a->RecordingConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateRecording(struct soap *soap, const char *tag, int id, const struct _trc__CreateRecording *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateRecording), type))
		return soap->error;
	if (!a->RecordingConfiguration)
	{	if (soap_element_empty(soap, "trc:RecordingConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", -1, &a->RecordingConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateRecording * SOAP_FMAC4 soap_in__trc__CreateRecording(struct soap *soap, const char *tag, struct _trc__CreateRecording *a, const char *type)
{
	size_t soap_flag_RecordingConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__CreateRecording*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecording, sizeof(struct _trc__CreateRecording), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateRecording(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", &a->RecordingConfiguration, "tt:RecordingConfiguration"))
				{	soap_flag_RecordingConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->RecordingConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__CreateRecording *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecording, SOAP_TYPE__trc__CreateRecording, sizeof(struct _trc__CreateRecording), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__CreateRecording * SOAP_FMAC4 soap_new__trc__CreateRecording(struct soap *soap, int n)
{
	struct _trc__CreateRecording *p;
	struct _trc__CreateRecording *a = (struct _trc__CreateRecording*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__CreateRecording));
	for (p = a; p && n--; p++)
		soap_default__trc__CreateRecording(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateRecording(struct soap *soap, const struct _trc__CreateRecording *a, const char *tag, const char *type)
{
	if (soap_out__trc__CreateRecording(soap, tag ? tag : "trc:CreateRecording", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecording * SOAP_FMAC4 soap_get__trc__CreateRecording(struct soap *soap, struct _trc__CreateRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetServiceCapabilitiesResponse(struct soap *soap, struct _trc__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trc__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrc__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "trc:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "trc:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotrc__Capabilities(soap, "trc:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__trc__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trc__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, sizeof(struct _trc__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotrc__Capabilities(soap, "trc:Capabilities", &a->Capabilities, "trc:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "trc:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, sizeof(struct _trc__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__trc__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _trc__GetServiceCapabilitiesResponse *p;
	struct _trc__GetServiceCapabilitiesResponse *a = (struct _trc__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trc__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetServiceCapabilitiesResponse(soap, tag ? tag : "trc:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__trc__GetServiceCapabilitiesResponse(struct soap *soap, struct _trc__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetServiceCapabilities(struct soap *soap, struct _trc__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetServiceCapabilities(struct soap *soap, const struct _trc__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _trc__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilities * SOAP_FMAC4 soap_in__trc__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trc__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _trc__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetServiceCapabilities, sizeof(struct _trc__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetServiceCapabilities, SOAP_TYPE__trc__GetServiceCapabilities, sizeof(struct _trc__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetServiceCapabilities * SOAP_FMAC4 soap_new__trc__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _trc__GetServiceCapabilities *p;
	struct _trc__GetServiceCapabilities *a = (struct _trc__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__trc__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetServiceCapabilities(struct soap *soap, const struct _trc__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetServiceCapabilities(soap, tag ? tag : "trc:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilities * SOAP_FMAC4 soap_get__trc__GetServiceCapabilities(struct soap *soap, struct _trc__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trc__TrackOptions(struct soap *soap, struct trc__TrackOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SpareTotal = NULL;
	a->SpareVideo = NULL;
	a->SpareAudio = NULL;
	a->SpareMetadata = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__TrackOptions(struct soap *soap, const struct trc__TrackOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__TrackOptions(struct soap *soap, const char *tag, int id, const struct trc__TrackOptions *a, const char *type)
{
	if (a->SpareTotal)
	{	soap_set_attr(soap, "SpareTotal", soap_int2s(soap, *a->SpareTotal), 1);
	}
	if (a->SpareVideo)
	{	soap_set_attr(soap, "SpareVideo", soap_int2s(soap, *a->SpareVideo), 1);
	}
	if (a->SpareAudio)
	{	soap_set_attr(soap, "SpareAudio", soap_int2s(soap, *a->SpareAudio), 1);
	}
	if (a->SpareMetadata)
	{	soap_set_attr(soap, "SpareMetadata", soap_int2s(soap, *a->SpareMetadata), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trc__TrackOptions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trc__TrackOptions * SOAP_FMAC4 soap_in_trc__TrackOptions(struct soap *soap, const char *tag, struct trc__TrackOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trc__TrackOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__TrackOptions, sizeof(struct trc__TrackOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trc__TrackOptions(soap, a);
	{
		const char *t = soap_attr_value(soap, "SpareTotal", 5, 0);
		if (t)
		{
			if (!(a->SpareTotal = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->SpareTotal))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SpareVideo", 5, 0);
		if (t)
		{
			if (!(a->SpareVideo = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->SpareVideo))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SpareAudio", 5, 0);
		if (t)
		{
			if (!(a->SpareAudio = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->SpareAudio))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SpareMetadata", 5, 0);
		if (t)
		{
			if (!(a->SpareMetadata = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->SpareMetadata))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trc__TrackOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__TrackOptions, SOAP_TYPE_trc__TrackOptions, sizeof(struct trc__TrackOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trc__TrackOptions * SOAP_FMAC4 soap_new_trc__TrackOptions(struct soap *soap, int n)
{
	struct trc__TrackOptions *p;
	struct trc__TrackOptions *a = (struct trc__TrackOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trc__TrackOptions));
	for (p = a; p && n--; p++)
		soap_default_trc__TrackOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__TrackOptions(struct soap *soap, const struct trc__TrackOptions *a, const char *tag, const char *type)
{
	if (soap_out_trc__TrackOptions(soap, tag ? tag : "trc:TrackOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__TrackOptions * SOAP_FMAC4 soap_get_trc__TrackOptions(struct soap *soap, struct trc__TrackOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__TrackOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trc__JobOptions(struct soap *soap, struct trc__JobOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Spare = NULL;
	soap_default_tt__StringAttrList(soap, &a->CompatibleSources);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__JobOptions(struct soap *soap, const struct trc__JobOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__JobOptions(struct soap *soap, const char *tag, int id, const struct trc__JobOptions *a, const char *type)
{
	if (a->Spare)
	{	soap_set_attr(soap, "Spare", soap_int2s(soap, *a->Spare), 1);
	}
	if (a->CompatibleSources)
		soap_set_attr(soap, "CompatibleSources", soap_tt__StringAttrList2s(soap, a->CompatibleSources), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trc__JobOptions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trc__JobOptions * SOAP_FMAC4 soap_in_trc__JobOptions(struct soap *soap, const char *tag, struct trc__JobOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trc__JobOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__JobOptions, sizeof(struct trc__JobOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trc__JobOptions(soap, a);
	{
		const char *t = soap_attr_value(soap, "Spare", 5, 0);
		if (t)
		{
			if (!(a->Spare = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Spare))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "CompatibleSources", 1, 0), &a->CompatibleSources))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trc__JobOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__JobOptions, SOAP_TYPE_trc__JobOptions, sizeof(struct trc__JobOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trc__JobOptions * SOAP_FMAC4 soap_new_trc__JobOptions(struct soap *soap, int n)
{
	struct trc__JobOptions *p;
	struct trc__JobOptions *a = (struct trc__JobOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trc__JobOptions));
	for (p = a; p && n--; p++)
		soap_default_trc__JobOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__JobOptions(struct soap *soap, const struct trc__JobOptions *a, const char *tag, const char *type)
{
	if (soap_out_trc__JobOptions(soap, tag ? tag : "trc:JobOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__JobOptions * SOAP_FMAC4 soap_get_trc__JobOptions(struct soap *soap, struct trc__JobOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__JobOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trc__RecordingOptions(struct soap *soap, struct trc__RecordingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Job = NULL;
	a->Track = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__RecordingOptions(struct soap *soap, const struct trc__RecordingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrc__JobOptions(soap, &a->Job);
	soap_serialize_PointerTotrc__TrackOptions(soap, &a->Track);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__RecordingOptions(struct soap *soap, const char *tag, int id, const struct trc__RecordingOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trc__RecordingOptions), type))
		return soap->error;
	if (!a->Job)
	{	if (soap_element_empty(soap, "trc:Job", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotrc__JobOptions(soap, "trc:Job", -1, &a->Job, ""))
		return soap->error;
	if (!a->Track)
	{	if (soap_element_empty(soap, "trc:Track", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotrc__TrackOptions(soap, "trc:Track", -1, &a->Track, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trc__RecordingOptions * SOAP_FMAC4 soap_in_trc__RecordingOptions(struct soap *soap, const char *tag, struct trc__RecordingOptions *a, const char *type)
{
	size_t soap_flag_Job = 1;
	size_t soap_flag_Track = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trc__RecordingOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__RecordingOptions, sizeof(struct trc__RecordingOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trc__RecordingOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Job && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotrc__JobOptions(soap, "trc:Job", &a->Job, "trc:JobOptions"))
				{	soap_flag_Job--;
					continue;
				}
			}
			if (soap_flag_Track && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotrc__TrackOptions(soap, "trc:Track", &a->Track, "trc:TrackOptions"))
				{	soap_flag_Track--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Job || !a->Track))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct trc__RecordingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__RecordingOptions, SOAP_TYPE_trc__RecordingOptions, sizeof(struct trc__RecordingOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trc__RecordingOptions * SOAP_FMAC4 soap_new_trc__RecordingOptions(struct soap *soap, int n)
{
	struct trc__RecordingOptions *p;
	struct trc__RecordingOptions *a = (struct trc__RecordingOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trc__RecordingOptions));
	for (p = a; p && n--; p++)
		soap_default_trc__RecordingOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__RecordingOptions(struct soap *soap, const struct trc__RecordingOptions *a, const char *tag, const char *type)
{
	if (soap_out_trc__RecordingOptions(soap, tag ? tag : "trc:RecordingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__RecordingOptions * SOAP_FMAC4 soap_get_trc__RecordingOptions(struct soap *soap, struct trc__RecordingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__RecordingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trc__Capabilities(struct soap *soap, struct trc__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->DynamicRecordings = NULL;
	a->DynamicTracks = NULL;
	soap_default_trc__EncodingTypes(soap, &a->Encoding);
	a->MaxRate = NULL;
	a->MaxTotalRate = NULL;
	a->MaxRecordings = NULL;
	a->MaxRecordingJobs = NULL;
	a->Options = NULL;
	a->MetadataRecording = NULL;
	soap_default_tt__StringAttrList(soap, &a->SupportedExportFileFormats);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__Capabilities(struct soap *soap, const struct trc__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__Capabilities(struct soap *soap, const char *tag, int id, const struct trc__Capabilities *a, const char *type)
{
	if (a->DynamicRecordings)
	{	soap_set_attr(soap, "DynamicRecordings", soap_xsd__boolean2s(soap, *a->DynamicRecordings), 1);
	}
	if (a->DynamicTracks)
	{	soap_set_attr(soap, "DynamicTracks", soap_xsd__boolean2s(soap, *a->DynamicTracks), 1);
	}
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_trc__EncodingTypes2s(soap, a->Encoding), 1);
	if (a->MaxRate)
	{	soap_set_attr(soap, "MaxRate", soap_float2s(soap, *a->MaxRate), 1);
	}
	if (a->MaxTotalRate)
	{	soap_set_attr(soap, "MaxTotalRate", soap_float2s(soap, *a->MaxTotalRate), 1);
	}
	if (a->MaxRecordings)
	{	soap_set_attr(soap, "MaxRecordings", soap_float2s(soap, *a->MaxRecordings), 1);
	}
	if (a->MaxRecordingJobs)
	{	soap_set_attr(soap, "MaxRecordingJobs", soap_int2s(soap, *a->MaxRecordingJobs), 1);
	}
	if (a->Options)
	{	soap_set_attr(soap, "Options", soap_xsd__boolean2s(soap, *a->Options), 1);
	}
	if (a->MetadataRecording)
	{	soap_set_attr(soap, "MetadataRecording", soap_xsd__boolean2s(soap, *a->MetadataRecording), 1);
	}
	if (a->SupportedExportFileFormats)
		soap_set_attr(soap, "SupportedExportFileFormats", soap_tt__StringAttrList2s(soap, a->SupportedExportFileFormats), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trc__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trc__Capabilities * SOAP_FMAC4 soap_in_trc__Capabilities(struct soap *soap, const char *tag, struct trc__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct trc__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__Capabilities, sizeof(struct trc__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trc__Capabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "DynamicRecordings", 5, 0);
		if (t)
		{
			if (!(a->DynamicRecordings = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DynamicRecordings))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DynamicTracks", 5, 0);
		if (t)
		{
			if (!(a->DynamicTracks = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DynamicTracks))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2trc__EncodingTypes(soap, soap_attr_value(soap, "Encoding", 1, 0), &a->Encoding))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "MaxRate", 5, 0);
		if (t)
		{
			if (!(a->MaxRate = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->MaxRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxTotalRate", 5, 0);
		if (t)
		{
			if (!(a->MaxTotalRate = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->MaxTotalRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxRecordings", 5, 0);
		if (t)
		{
			if (!(a->MaxRecordings = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->MaxRecordings))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxRecordingJobs", 5, 0);
		if (t)
		{
			if (!(a->MaxRecordingJobs = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxRecordingJobs))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Options", 5, 0);
		if (t)
		{
			if (!(a->Options = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Options))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MetadataRecording", 5, 0);
		if (t)
		{
			if (!(a->MetadataRecording = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->MetadataRecording))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "SupportedExportFileFormats", 1, 0), &a->SupportedExportFileFormats))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trc__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__Capabilities, SOAP_TYPE_trc__Capabilities, sizeof(struct trc__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trc__Capabilities * SOAP_FMAC4 soap_new_trc__Capabilities(struct soap *soap, int n)
{
	struct trc__Capabilities *p;
	struct trc__Capabilities *a = (struct trc__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trc__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_trc__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__Capabilities(struct soap *soap, const struct trc__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_trc__Capabilities(soap, tag ? tag : "trc:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__Capabilities * SOAP_FMAC4 soap_get_trc__Capabilities(struct soap *soap, struct trc__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__SetCurrentPresetResponse(struct soap *soap, struct _timg__SetCurrentPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__SetCurrentPresetResponse(struct soap *soap, const struct _timg__SetCurrentPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetCurrentPresetResponse(struct soap *soap, const char *tag, int id, const struct _timg__SetCurrentPresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetCurrentPresetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__SetCurrentPresetResponse * SOAP_FMAC4 soap_in__timg__SetCurrentPresetResponse(struct soap *soap, const char *tag, struct _timg__SetCurrentPresetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__SetCurrentPresetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetCurrentPresetResponse, sizeof(struct _timg__SetCurrentPresetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__SetCurrentPresetResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__SetCurrentPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetCurrentPresetResponse, SOAP_TYPE__timg__SetCurrentPresetResponse, sizeof(struct _timg__SetCurrentPresetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__SetCurrentPresetResponse * SOAP_FMAC4 soap_new__timg__SetCurrentPresetResponse(struct soap *soap, int n)
{
	struct _timg__SetCurrentPresetResponse *p;
	struct _timg__SetCurrentPresetResponse *a = (struct _timg__SetCurrentPresetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__SetCurrentPresetResponse));
	for (p = a; p && n--; p++)
		soap_default__timg__SetCurrentPresetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__SetCurrentPresetResponse(struct soap *soap, const struct _timg__SetCurrentPresetResponse *a, const char *tag, const char *type)
{
	if (soap_out__timg__SetCurrentPresetResponse(soap, tag ? tag : "timg:SetCurrentPresetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetCurrentPresetResponse * SOAP_FMAC4 soap_get__timg__SetCurrentPresetResponse(struct soap *soap, struct _timg__SetCurrentPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetCurrentPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__SetCurrentPreset(struct soap *soap, struct _timg__SetCurrentPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__SetCurrentPreset(struct soap *soap, const struct _timg__SetCurrentPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetCurrentPreset(struct soap *soap, const char *tag, int id, const struct _timg__SetCurrentPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetCurrentPreset), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "timg:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	if (!a->PresetToken)
	{	if (soap_element_empty(soap, "timg:PresetToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "timg:PresetToken", -1, (char*const*)&a->PresetToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__SetCurrentPreset * SOAP_FMAC4 soap_in__timg__SetCurrentPreset(struct soap *soap, const char *tag, struct _timg__SetCurrentPreset *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	size_t soap_flag_PresetToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__SetCurrentPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetCurrentPreset, sizeof(struct _timg__SetCurrentPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__SetCurrentPreset(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:PresetToken", (char**)&a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken || !a->PresetToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__SetCurrentPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetCurrentPreset, SOAP_TYPE__timg__SetCurrentPreset, sizeof(struct _timg__SetCurrentPreset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__SetCurrentPreset * SOAP_FMAC4 soap_new__timg__SetCurrentPreset(struct soap *soap, int n)
{
	struct _timg__SetCurrentPreset *p;
	struct _timg__SetCurrentPreset *a = (struct _timg__SetCurrentPreset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__SetCurrentPreset));
	for (p = a; p && n--; p++)
		soap_default__timg__SetCurrentPreset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__SetCurrentPreset(struct soap *soap, const struct _timg__SetCurrentPreset *a, const char *tag, const char *type)
{
	if (soap_out__timg__SetCurrentPreset(soap, tag ? tag : "timg:SetCurrentPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetCurrentPreset * SOAP_FMAC4 soap_get__timg__SetCurrentPreset(struct soap *soap, struct _timg__SetCurrentPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetCurrentPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetCurrentPresetResponse(struct soap *soap, struct _timg__GetCurrentPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Preset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetCurrentPresetResponse(struct soap *soap, const struct _timg__GetCurrentPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotimg__ImagingPreset(soap, &a->Preset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetCurrentPresetResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetCurrentPresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetCurrentPresetResponse), type))
		return soap->error;
	if (a->Preset)
		soap_element_result(soap, "timg:Preset");
	if (soap_out_PointerTotimg__ImagingPreset(soap, "timg:Preset", -1, &a->Preset, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetCurrentPresetResponse * SOAP_FMAC4 soap_in__timg__GetCurrentPresetResponse(struct soap *soap, const char *tag, struct _timg__GetCurrentPresetResponse *a, const char *type)
{
	size_t soap_flag_Preset = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetCurrentPresetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetCurrentPresetResponse, sizeof(struct _timg__GetCurrentPresetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetCurrentPresetResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Preset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotimg__ImagingPreset(soap, "timg:Preset", &a->Preset, "timg:ImagingPreset"))
				{	soap_flag_Preset--;
					continue;
				}
			}
			soap_check_result(soap, "timg:Preset");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetCurrentPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetCurrentPresetResponse, SOAP_TYPE__timg__GetCurrentPresetResponse, sizeof(struct _timg__GetCurrentPresetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetCurrentPresetResponse * SOAP_FMAC4 soap_new__timg__GetCurrentPresetResponse(struct soap *soap, int n)
{
	struct _timg__GetCurrentPresetResponse *p;
	struct _timg__GetCurrentPresetResponse *a = (struct _timg__GetCurrentPresetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetCurrentPresetResponse));
	for (p = a; p && n--; p++)
		soap_default__timg__GetCurrentPresetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetCurrentPresetResponse(struct soap *soap, const struct _timg__GetCurrentPresetResponse *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetCurrentPresetResponse(soap, tag ? tag : "timg:GetCurrentPresetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetCurrentPresetResponse * SOAP_FMAC4 soap_get__timg__GetCurrentPresetResponse(struct soap *soap, struct _timg__GetCurrentPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetCurrentPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetCurrentPreset(struct soap *soap, struct _timg__GetCurrentPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetCurrentPreset(struct soap *soap, const struct _timg__GetCurrentPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetCurrentPreset(struct soap *soap, const char *tag, int id, const struct _timg__GetCurrentPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetCurrentPreset), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "timg:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetCurrentPreset * SOAP_FMAC4 soap_in__timg__GetCurrentPreset(struct soap *soap, const char *tag, struct _timg__GetCurrentPreset *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetCurrentPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetCurrentPreset, sizeof(struct _timg__GetCurrentPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetCurrentPreset(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__GetCurrentPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetCurrentPreset, SOAP_TYPE__timg__GetCurrentPreset, sizeof(struct _timg__GetCurrentPreset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetCurrentPreset * SOAP_FMAC4 soap_new__timg__GetCurrentPreset(struct soap *soap, int n)
{
	struct _timg__GetCurrentPreset *p;
	struct _timg__GetCurrentPreset *a = (struct _timg__GetCurrentPreset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetCurrentPreset));
	for (p = a; p && n--; p++)
		soap_default__timg__GetCurrentPreset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetCurrentPreset(struct soap *soap, const struct _timg__GetCurrentPreset *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetCurrentPreset(soap, tag ? tag : "timg:GetCurrentPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetCurrentPreset * SOAP_FMAC4 soap_get__timg__GetCurrentPreset(struct soap *soap, struct _timg__GetCurrentPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetCurrentPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetPresetsResponse(struct soap *soap, struct _timg__GetPresetsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePreset = 0;
	a->Preset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetPresetsResponse(struct soap *soap, const struct _timg__GetPresetsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Preset)
	{	int i;
		for (i = 0; i < (int)a->__sizePreset; i++)
		{
			soap_embedded(soap, a->Preset + i, SOAP_TYPE_timg__ImagingPreset);
			soap_serialize_timg__ImagingPreset(soap, a->Preset + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetPresetsResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetPresetsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetPresetsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePreset");
	if (a->Preset)
	{	int i;
		for (i = 0; i < (int)a->__sizePreset; i++)
			if (soap_out_timg__ImagingPreset(soap, "timg:Preset", -1, a->Preset + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetPresetsResponse * SOAP_FMAC4 soap_in__timg__GetPresetsResponse(struct soap *soap, const char *tag, struct _timg__GetPresetsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Preset = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetPresetsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetPresetsResponse, sizeof(struct _timg__GetPresetsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetPresetsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "timg:Preset", 1, NULL))
			{	if (a->Preset == NULL)
				{	if (soap_blist_Preset == NULL)
						soap_blist_Preset = soap_alloc_block(soap);
					a->Preset = (struct timg__ImagingPreset *)soap_push_block_max(soap, soap_blist_Preset, sizeof(struct timg__ImagingPreset));
					if (a->Preset == NULL)
						return NULL;
					soap_default_timg__ImagingPreset(soap, a->Preset);
				}
				soap_revert(soap);
				if (soap_in_timg__ImagingPreset(soap, "timg:Preset", a->Preset, "timg:ImagingPreset"))
				{	a->__sizePreset++;
					a->Preset = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePreset");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Preset)
			soap_pop_block(soap, soap_blist_Preset);
		if (a->__sizePreset)
		{	a->Preset = (struct timg__ImagingPreset *)soap_save_block(soap, soap_blist_Preset, NULL, 1);
		}
		else
		{	a->Preset = NULL;
			if (soap_blist_Preset)
				soap_end_block(soap, soap_blist_Preset);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePreset < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__GetPresetsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetPresetsResponse, SOAP_TYPE__timg__GetPresetsResponse, sizeof(struct _timg__GetPresetsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetPresetsResponse * SOAP_FMAC4 soap_new__timg__GetPresetsResponse(struct soap *soap, int n)
{
	struct _timg__GetPresetsResponse *p;
	struct _timg__GetPresetsResponse *a = (struct _timg__GetPresetsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetPresetsResponse));
	for (p = a; p && n--; p++)
		soap_default__timg__GetPresetsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetPresetsResponse(struct soap *soap, const struct _timg__GetPresetsResponse *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetPresetsResponse(soap, tag ? tag : "timg:GetPresetsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetPresetsResponse * SOAP_FMAC4 soap_get__timg__GetPresetsResponse(struct soap *soap, struct _timg__GetPresetsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetPresetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetPresets(struct soap *soap, struct _timg__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetPresets(struct soap *soap, const struct _timg__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetPresets(struct soap *soap, const char *tag, int id, const struct _timg__GetPresets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetPresets), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "timg:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetPresets * SOAP_FMAC4 soap_in__timg__GetPresets(struct soap *soap, const char *tag, struct _timg__GetPresets *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetPresets*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetPresets, sizeof(struct _timg__GetPresets), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetPresets(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__GetPresets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetPresets, SOAP_TYPE__timg__GetPresets, sizeof(struct _timg__GetPresets), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetPresets * SOAP_FMAC4 soap_new__timg__GetPresets(struct soap *soap, int n)
{
	struct _timg__GetPresets *p;
	struct _timg__GetPresets *a = (struct _timg__GetPresets*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetPresets));
	for (p = a; p && n--; p++)
		soap_default__timg__GetPresets(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetPresets(struct soap *soap, const struct _timg__GetPresets *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetPresets(soap, tag ? tag : "timg:GetPresets", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetPresets * SOAP_FMAC4 soap_get__timg__GetPresets(struct soap *soap, struct _timg__GetPresets *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetStatusResponse(struct soap *soap, struct _timg__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetStatusResponse(struct soap *soap, const struct _timg__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImagingStatus20(soap, &a->Status);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetStatusResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetStatusResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "timg:Status");
	if (!a->Status)
	{	if (soap_element_empty(soap, "timg:Status", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ImagingStatus20(soap, "timg:Status", -1, &a->Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetStatusResponse * SOAP_FMAC4 soap_in__timg__GetStatusResponse(struct soap *soap, const char *tag, struct _timg__GetStatusResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetStatusResponse, sizeof(struct _timg__GetStatusResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetStatusResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingStatus20(soap, "timg:Status", &a->Status, "tt:ImagingStatus20"))
				{	soap_flag_Status--;
					continue;
				}
			}
			soap_check_result(soap, "timg:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Status))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetStatusResponse, SOAP_TYPE__timg__GetStatusResponse, sizeof(struct _timg__GetStatusResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetStatusResponse * SOAP_FMAC4 soap_new__timg__GetStatusResponse(struct soap *soap, int n)
{
	struct _timg__GetStatusResponse *p;
	struct _timg__GetStatusResponse *a = (struct _timg__GetStatusResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetStatusResponse));
	for (p = a; p && n--; p++)
		soap_default__timg__GetStatusResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetStatusResponse(struct soap *soap, const struct _timg__GetStatusResponse *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetStatusResponse(soap, tag ? tag : "timg:GetStatusResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetStatusResponse * SOAP_FMAC4 soap_get__timg__GetStatusResponse(struct soap *soap, struct _timg__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetStatus(struct soap *soap, struct _timg__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetStatus(struct soap *soap, const struct _timg__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetStatus(struct soap *soap, const char *tag, int id, const struct _timg__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetStatus), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "timg:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetStatus * SOAP_FMAC4 soap_in__timg__GetStatus(struct soap *soap, const char *tag, struct _timg__GetStatus *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetStatus, sizeof(struct _timg__GetStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetStatus, SOAP_TYPE__timg__GetStatus, sizeof(struct _timg__GetStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetStatus * SOAP_FMAC4 soap_new__timg__GetStatus(struct soap *soap, int n)
{
	struct _timg__GetStatus *p;
	struct _timg__GetStatus *a = (struct _timg__GetStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetStatus));
	for (p = a; p && n--; p++)
		soap_default__timg__GetStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetStatus(struct soap *soap, const struct _timg__GetStatus *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetStatus(soap, tag ? tag : "timg:GetStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetStatus * SOAP_FMAC4 soap_get__timg__GetStatus(struct soap *soap, struct _timg__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__StopResponse(struct soap *soap, struct _timg__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__StopResponse(struct soap *soap, const struct _timg__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__StopResponse(struct soap *soap, const char *tag, int id, const struct _timg__StopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__StopResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__StopResponse * SOAP_FMAC4 soap_in__timg__StopResponse(struct soap *soap, const char *tag, struct _timg__StopResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__StopResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__StopResponse, sizeof(struct _timg__StopResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__StopResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__StopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__StopResponse, SOAP_TYPE__timg__StopResponse, sizeof(struct _timg__StopResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__StopResponse * SOAP_FMAC4 soap_new__timg__StopResponse(struct soap *soap, int n)
{
	struct _timg__StopResponse *p;
	struct _timg__StopResponse *a = (struct _timg__StopResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__StopResponse));
	for (p = a; p && n--; p++)
		soap_default__timg__StopResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__StopResponse(struct soap *soap, const struct _timg__StopResponse *a, const char *tag, const char *type)
{
	if (soap_out__timg__StopResponse(soap, tag ? tag : "timg:StopResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__StopResponse * SOAP_FMAC4 soap_get__timg__StopResponse(struct soap *soap, struct _timg__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__Stop(struct soap *soap, struct _timg__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__Stop(struct soap *soap, const struct _timg__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__Stop(struct soap *soap, const char *tag, int id, const struct _timg__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__Stop), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "timg:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__Stop * SOAP_FMAC4 soap_in__timg__Stop(struct soap *soap, const char *tag, struct _timg__Stop *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__Stop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__Stop, sizeof(struct _timg__Stop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__Stop(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__Stop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__Stop, SOAP_TYPE__timg__Stop, sizeof(struct _timg__Stop), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__Stop * SOAP_FMAC4 soap_new__timg__Stop(struct soap *soap, int n)
{
	struct _timg__Stop *p;
	struct _timg__Stop *a = (struct _timg__Stop*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__Stop));
	for (p = a; p && n--; p++)
		soap_default__timg__Stop(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__Stop(struct soap *soap, const struct _timg__Stop *a, const char *tag, const char *type)
{
	if (soap_out__timg__Stop(soap, tag ? tag : "timg:Stop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__Stop * SOAP_FMAC4 soap_get__timg__Stop(struct soap *soap, struct _timg__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetMoveOptionsResponse(struct soap *soap, struct _timg__GetMoveOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MoveOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetMoveOptionsResponse(struct soap *soap, const struct _timg__GetMoveOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MoveOptions20(soap, &a->MoveOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetMoveOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetMoveOptionsResponse), type))
		return soap->error;
	if (a->MoveOptions)
		soap_element_result(soap, "timg:MoveOptions");
	if (!a->MoveOptions)
	{	if (soap_element_empty(soap, "timg:MoveOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MoveOptions20(soap, "timg:MoveOptions", -1, &a->MoveOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetMoveOptionsResponse * SOAP_FMAC4 soap_in__timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, struct _timg__GetMoveOptionsResponse *a, const char *type)
{
	size_t soap_flag_MoveOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetMoveOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetMoveOptionsResponse, sizeof(struct _timg__GetMoveOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetMoveOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoveOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MoveOptions20(soap, "timg:MoveOptions", &a->MoveOptions, "tt:MoveOptions20"))
				{	soap_flag_MoveOptions--;
					continue;
				}
			}
			soap_check_result(soap, "timg:MoveOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->MoveOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__GetMoveOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetMoveOptionsResponse, SOAP_TYPE__timg__GetMoveOptionsResponse, sizeof(struct _timg__GetMoveOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetMoveOptionsResponse * SOAP_FMAC4 soap_new__timg__GetMoveOptionsResponse(struct soap *soap, int n)
{
	struct _timg__GetMoveOptionsResponse *p;
	struct _timg__GetMoveOptionsResponse *a = (struct _timg__GetMoveOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetMoveOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__timg__GetMoveOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetMoveOptionsResponse(struct soap *soap, const struct _timg__GetMoveOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetMoveOptionsResponse(soap, tag ? tag : "timg:GetMoveOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetMoveOptionsResponse * SOAP_FMAC4 soap_get__timg__GetMoveOptionsResponse(struct soap *soap, struct _timg__GetMoveOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetMoveOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetMoveOptions(struct soap *soap, struct _timg__GetMoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetMoveOptions(struct soap *soap, const struct _timg__GetMoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetMoveOptions(struct soap *soap, const char *tag, int id, const struct _timg__GetMoveOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetMoveOptions), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "timg:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetMoveOptions * SOAP_FMAC4 soap_in__timg__GetMoveOptions(struct soap *soap, const char *tag, struct _timg__GetMoveOptions *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetMoveOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetMoveOptions, sizeof(struct _timg__GetMoveOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetMoveOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__GetMoveOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetMoveOptions, SOAP_TYPE__timg__GetMoveOptions, sizeof(struct _timg__GetMoveOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetMoveOptions * SOAP_FMAC4 soap_new__timg__GetMoveOptions(struct soap *soap, int n)
{
	struct _timg__GetMoveOptions *p;
	struct _timg__GetMoveOptions *a = (struct _timg__GetMoveOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetMoveOptions));
	for (p = a; p && n--; p++)
		soap_default__timg__GetMoveOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetMoveOptions(struct soap *soap, const struct _timg__GetMoveOptions *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetMoveOptions(soap, tag ? tag : "timg:GetMoveOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetMoveOptions * SOAP_FMAC4 soap_get__timg__GetMoveOptions(struct soap *soap, struct _timg__GetMoveOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetMoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__MoveResponse(struct soap *soap, struct _timg__MoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__MoveResponse(struct soap *soap, const struct _timg__MoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__MoveResponse(struct soap *soap, const char *tag, int id, const struct _timg__MoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__MoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__MoveResponse * SOAP_FMAC4 soap_in__timg__MoveResponse(struct soap *soap, const char *tag, struct _timg__MoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__MoveResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__MoveResponse, sizeof(struct _timg__MoveResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__MoveResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__MoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__MoveResponse, SOAP_TYPE__timg__MoveResponse, sizeof(struct _timg__MoveResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__MoveResponse * SOAP_FMAC4 soap_new__timg__MoveResponse(struct soap *soap, int n)
{
	struct _timg__MoveResponse *p;
	struct _timg__MoveResponse *a = (struct _timg__MoveResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__MoveResponse));
	for (p = a; p && n--; p++)
		soap_default__timg__MoveResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__MoveResponse(struct soap *soap, const struct _timg__MoveResponse *a, const char *tag, const char *type)
{
	if (soap_out__timg__MoveResponse(soap, tag ? tag : "timg:MoveResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__MoveResponse * SOAP_FMAC4 soap_get__timg__MoveResponse(struct soap *soap, struct _timg__MoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__MoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__Move(struct soap *soap, struct _timg__Move *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	a->Focus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__Move(struct soap *soap, const struct _timg__Move *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
	soap_serialize_PointerTott__FocusMove(soap, &a->Focus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__Move(struct soap *soap, const char *tag, int id, const struct _timg__Move *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__Move), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "timg:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	if (!a->Focus)
	{	if (soap_element_empty(soap, "timg:Focus", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FocusMove(soap, "timg:Focus", -1, &a->Focus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__Move * SOAP_FMAC4 soap_in__timg__Move(struct soap *soap, const char *tag, struct _timg__Move *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	size_t soap_flag_Focus = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__Move*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__Move, sizeof(struct _timg__Move), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__Move(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusMove(soap, "timg:Focus", &a->Focus, "tt:FocusMove"))
				{	soap_flag_Focus--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken || !a->Focus))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__Move *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__Move, SOAP_TYPE__timg__Move, sizeof(struct _timg__Move), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__Move * SOAP_FMAC4 soap_new__timg__Move(struct soap *soap, int n)
{
	struct _timg__Move *p;
	struct _timg__Move *a = (struct _timg__Move*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__Move));
	for (p = a; p && n--; p++)
		soap_default__timg__Move(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__Move(struct soap *soap, const struct _timg__Move *a, const char *tag, const char *type)
{
	if (soap_out__timg__Move(soap, tag ? tag : "timg:Move", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__Move * SOAP_FMAC4 soap_get__timg__Move(struct soap *soap, struct _timg__Move *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__Move(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetOptionsResponse(struct soap *soap, struct _timg__GetOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ImagingOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetOptionsResponse(struct soap *soap, const struct _timg__GetOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImagingOptions20(soap, &a->ImagingOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetOptionsResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetOptionsResponse), type))
		return soap->error;
	if (a->ImagingOptions)
		soap_element_result(soap, "timg:ImagingOptions");
	if (!a->ImagingOptions)
	{	if (soap_element_empty(soap, "timg:ImagingOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ImagingOptions20(soap, "timg:ImagingOptions", -1, &a->ImagingOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetOptionsResponse * SOAP_FMAC4 soap_in__timg__GetOptionsResponse(struct soap *soap, const char *tag, struct _timg__GetOptionsResponse *a, const char *type)
{
	size_t soap_flag_ImagingOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetOptionsResponse, sizeof(struct _timg__GetOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImagingOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20(soap, "timg:ImagingOptions", &a->ImagingOptions, "tt:ImagingOptions20"))
				{	soap_flag_ImagingOptions--;
					continue;
				}
			}
			soap_check_result(soap, "timg:ImagingOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ImagingOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__GetOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetOptionsResponse, SOAP_TYPE__timg__GetOptionsResponse, sizeof(struct _timg__GetOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetOptionsResponse * SOAP_FMAC4 soap_new__timg__GetOptionsResponse(struct soap *soap, int n)
{
	struct _timg__GetOptionsResponse *p;
	struct _timg__GetOptionsResponse *a = (struct _timg__GetOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__timg__GetOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetOptionsResponse(struct soap *soap, const struct _timg__GetOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetOptionsResponse(soap, tag ? tag : "timg:GetOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetOptionsResponse * SOAP_FMAC4 soap_get__timg__GetOptionsResponse(struct soap *soap, struct _timg__GetOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetOptions(struct soap *soap, struct _timg__GetOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetOptions(struct soap *soap, const struct _timg__GetOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetOptions(struct soap *soap, const char *tag, int id, const struct _timg__GetOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetOptions), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "timg:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetOptions * SOAP_FMAC4 soap_in__timg__GetOptions(struct soap *soap, const char *tag, struct _timg__GetOptions *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetOptions, sizeof(struct _timg__GetOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__GetOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetOptions, SOAP_TYPE__timg__GetOptions, sizeof(struct _timg__GetOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetOptions * SOAP_FMAC4 soap_new__timg__GetOptions(struct soap *soap, int n)
{
	struct _timg__GetOptions *p;
	struct _timg__GetOptions *a = (struct _timg__GetOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetOptions));
	for (p = a; p && n--; p++)
		soap_default__timg__GetOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetOptions(struct soap *soap, const struct _timg__GetOptions *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetOptions(soap, tag ? tag : "timg:GetOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetOptions * SOAP_FMAC4 soap_get__timg__GetOptions(struct soap *soap, struct _timg__GetOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__SetImagingSettingsResponse(struct soap *soap, const struct _timg__SetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, int id, const struct _timg__SetImagingSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetImagingSettingsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_in__timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, struct _timg__SetImagingSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__SetImagingSettingsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(struct _timg__SetImagingSettingsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__SetImagingSettingsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__SetImagingSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetImagingSettingsResponse, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(struct _timg__SetImagingSettingsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_new__timg__SetImagingSettingsResponse(struct soap *soap, int n)
{
	struct _timg__SetImagingSettingsResponse *p;
	struct _timg__SetImagingSettingsResponse *a = (struct _timg__SetImagingSettingsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__SetImagingSettingsResponse));
	for (p = a; p && n--; p++)
		soap_default__timg__SetImagingSettingsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__SetImagingSettingsResponse(struct soap *soap, const struct _timg__SetImagingSettingsResponse *a, const char *tag, const char *type)
{
	if (soap_out__timg__SetImagingSettingsResponse(soap, tag ? tag : "timg:SetImagingSettingsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_get__timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	a->ImagingSettings = NULL;
	a->ForcePersistence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__SetImagingSettings(struct soap *soap, const struct _timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
	soap_serialize_PointerTott__ImagingSettings20(soap, &a->ImagingSettings);
	soap_serialize_PointerToxsd__boolean(soap, &a->ForcePersistence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetImagingSettings(struct soap *soap, const char *tag, int id, const struct _timg__SetImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetImagingSettings), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "timg:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	if (!a->ImagingSettings)
	{	if (soap_element_empty(soap, "timg:ImagingSettings", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", -1, &a->ImagingSettings, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "timg:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__SetImagingSettings * SOAP_FMAC4 soap_in__timg__SetImagingSettings(struct soap *soap, const char *tag, struct _timg__SetImagingSettings *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	size_t soap_flag_ImagingSettings = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__SetImagingSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetImagingSettings, sizeof(struct _timg__SetImagingSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__SetImagingSettings(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap_flag_ImagingSettings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", &a->ImagingSettings, "tt:ImagingSettings20"))
				{	soap_flag_ImagingSettings--;
					continue;
				}
			}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "timg:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken || !a->ImagingSettings))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__SetImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetImagingSettings, SOAP_TYPE__timg__SetImagingSettings, sizeof(struct _timg__SetImagingSettings), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__SetImagingSettings * SOAP_FMAC4 soap_new__timg__SetImagingSettings(struct soap *soap, int n)
{
	struct _timg__SetImagingSettings *p;
	struct _timg__SetImagingSettings *a = (struct _timg__SetImagingSettings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__SetImagingSettings));
	for (p = a; p && n--; p++)
		soap_default__timg__SetImagingSettings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__SetImagingSettings(struct soap *soap, const struct _timg__SetImagingSettings *a, const char *tag, const char *type)
{
	if (soap_out__timg__SetImagingSettings(soap, tag ? tag : "timg:SetImagingSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettings * SOAP_FMAC4 soap_get__timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ImagingSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetImagingSettingsResponse(struct soap *soap, const struct _timg__GetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImagingSettings20(soap, &a->ImagingSettings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetImagingSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetImagingSettingsResponse), type))
		return soap->error;
	if (a->ImagingSettings)
		soap_element_result(soap, "timg:ImagingSettings");
	if (!a->ImagingSettings)
	{	if (soap_element_empty(soap, "timg:ImagingSettings", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", -1, &a->ImagingSettings, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_in__timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, struct _timg__GetImagingSettingsResponse *a, const char *type)
{
	size_t soap_flag_ImagingSettings = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetImagingSettingsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(struct _timg__GetImagingSettingsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetImagingSettingsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImagingSettings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", &a->ImagingSettings, "tt:ImagingSettings20"))
				{	soap_flag_ImagingSettings--;
					continue;
				}
			}
			soap_check_result(soap, "timg:ImagingSettings");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ImagingSettings))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__GetImagingSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetImagingSettingsResponse, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(struct _timg__GetImagingSettingsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_new__timg__GetImagingSettingsResponse(struct soap *soap, int n)
{
	struct _timg__GetImagingSettingsResponse *p;
	struct _timg__GetImagingSettingsResponse *a = (struct _timg__GetImagingSettingsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetImagingSettingsResponse));
	for (p = a; p && n--; p++)
		soap_default__timg__GetImagingSettingsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetImagingSettingsResponse(struct soap *soap, const struct _timg__GetImagingSettingsResponse *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetImagingSettingsResponse(soap, tag ? tag : "timg:GetImagingSettingsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_get__timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetImagingSettings(struct soap *soap, const struct _timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetImagingSettings(struct soap *soap, const char *tag, int id, const struct _timg__GetImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetImagingSettings), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_empty(soap, "timg:VideoSourceToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetImagingSettings * SOAP_FMAC4 soap_in__timg__GetImagingSettings(struct soap *soap, const char *tag, struct _timg__GetImagingSettings *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetImagingSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetImagingSettings, sizeof(struct _timg__GetImagingSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetImagingSettings(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoSourceToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__GetImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetImagingSettings, SOAP_TYPE__timg__GetImagingSettings, sizeof(struct _timg__GetImagingSettings), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetImagingSettings * SOAP_FMAC4 soap_new__timg__GetImagingSettings(struct soap *soap, int n)
{
	struct _timg__GetImagingSettings *p;
	struct _timg__GetImagingSettings *a = (struct _timg__GetImagingSettings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetImagingSettings));
	for (p = a; p && n--; p++)
		soap_default__timg__GetImagingSettings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetImagingSettings(struct soap *soap, const struct _timg__GetImagingSettings *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetImagingSettings(soap, tag ? tag : "timg:GetImagingSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettings * SOAP_FMAC4 soap_get__timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetServiceCapabilitiesResponse(struct soap *soap, struct _timg__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetServiceCapabilitiesResponse(struct soap *soap, const struct _timg__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotimg__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "timg:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "timg:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotimg__Capabilities(soap, "timg:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _timg__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, sizeof(struct _timg__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotimg__Capabilities(soap, "timg:Capabilities", &a->Capabilities, "timg:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "timg:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _timg__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, sizeof(struct _timg__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__timg__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _timg__GetServiceCapabilitiesResponse *p;
	struct _timg__GetServiceCapabilitiesResponse *a = (struct _timg__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__timg__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetServiceCapabilitiesResponse(struct soap *soap, const struct _timg__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetServiceCapabilitiesResponse(soap, tag ? tag : "timg:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__timg__GetServiceCapabilitiesResponse(struct soap *soap, struct _timg__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetServiceCapabilities(struct soap *soap, struct _timg__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetServiceCapabilities(struct soap *soap, const struct _timg__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _timg__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilities * SOAP_FMAC4 soap_in__timg__GetServiceCapabilities(struct soap *soap, const char *tag, struct _timg__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _timg__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(struct _timg__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetServiceCapabilities, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(struct _timg__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _timg__GetServiceCapabilities * SOAP_FMAC4 soap_new__timg__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _timg__GetServiceCapabilities *p;
	struct _timg__GetServiceCapabilities *a = (struct _timg__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _timg__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__timg__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetServiceCapabilities(struct soap *soap, const struct _timg__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__timg__GetServiceCapabilities(soap, tag ? tag : "timg:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilities * SOAP_FMAC4 soap_get__timg__GetServiceCapabilities(struct soap *soap, struct _timg__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_timg__ImagingPreset(struct soap *soap, struct timg__ImagingPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_string(soap, &a->type);
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_timg__ImagingPreset(struct soap *soap, const struct timg__ImagingPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_timg__ImagingPreset(struct soap *soap, const char *tag, int id, const struct timg__ImagingPreset *a, const char *type)
{
	soap_set_attr(soap, "token", a->token ? soap_tt__ReferenceToken2s(soap, a->token) : "", 1);
	soap_set_attr(soap, "type", a->type ? soap_string2s(soap, a->type) : "", 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_timg__ImagingPreset), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "timg:Name", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__Name(soap, "timg:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct timg__ImagingPreset * SOAP_FMAC4 soap_in_timg__ImagingPreset(struct soap *soap, const char *tag, struct timg__ImagingPreset *a, const char *type)
{
	size_t soap_flag_Name = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct timg__ImagingPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_timg__ImagingPreset, sizeof(struct timg__ImagingPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_timg__ImagingPreset(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &a->token))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "type", 1, 1), &a->type))
		return NULL;
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "timg:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct timg__ImagingPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_timg__ImagingPreset, SOAP_TYPE_timg__ImagingPreset, sizeof(struct timg__ImagingPreset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct timg__ImagingPreset * SOAP_FMAC4 soap_new_timg__ImagingPreset(struct soap *soap, int n)
{
	struct timg__ImagingPreset *p;
	struct timg__ImagingPreset *a = (struct timg__ImagingPreset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct timg__ImagingPreset));
	for (p = a; p && n--; p++)
		soap_default_timg__ImagingPreset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_timg__ImagingPreset(struct soap *soap, const struct timg__ImagingPreset *a, const char *tag, const char *type)
{
	if (soap_out_timg__ImagingPreset(soap, tag ? tag : "timg:ImagingPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct timg__ImagingPreset * SOAP_FMAC4 soap_get_timg__ImagingPreset(struct soap *soap, struct timg__ImagingPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in_timg__ImagingPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_timg__Capabilities(struct soap *soap, struct timg__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->ImageStabilization = NULL;
	a->Presets = NULL;
	a->AdaptablePreset = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_timg__Capabilities(struct soap *soap, const struct timg__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_timg__Capabilities(struct soap *soap, const char *tag, int id, const struct timg__Capabilities *a, const char *type)
{
	if (a->ImageStabilization)
	{	soap_set_attr(soap, "ImageStabilization", soap_xsd__boolean2s(soap, *a->ImageStabilization), 1);
	}
	if (a->Presets)
	{	soap_set_attr(soap, "Presets", soap_xsd__boolean2s(soap, *a->Presets), 1);
	}
	if (a->AdaptablePreset)
	{	soap_set_attr(soap, "AdaptablePreset", soap_xsd__boolean2s(soap, *a->AdaptablePreset), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_timg__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct timg__Capabilities * SOAP_FMAC4 soap_in_timg__Capabilities(struct soap *soap, const char *tag, struct timg__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct timg__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_timg__Capabilities, sizeof(struct timg__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_timg__Capabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "ImageStabilization", 5, 0);
		if (t)
		{
			if (!(a->ImageStabilization = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->ImageStabilization))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Presets", 5, 0);
		if (t)
		{
			if (!(a->Presets = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Presets))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "AdaptablePreset", 5, 0);
		if (t)
		{
			if (!(a->AdaptablePreset = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->AdaptablePreset))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct timg__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_timg__Capabilities, SOAP_TYPE_timg__Capabilities, sizeof(struct timg__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct timg__Capabilities * SOAP_FMAC4 soap_new_timg__Capabilities(struct soap *soap, int n)
{
	struct timg__Capabilities *p;
	struct timg__Capabilities *a = (struct timg__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct timg__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_timg__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_timg__Capabilities(struct soap *soap, const struct timg__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_timg__Capabilities(soap, tag ? tag : "timg:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct timg__Capabilities * SOAP_FMAC4 soap_get_timg__Capabilities(struct soap *soap, struct timg__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_timg__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetEventBrokersResponse(struct soap *soap, struct _tev__GetEventBrokersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEventBroker = 0;
	a->EventBroker = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetEventBrokersResponse(struct soap *soap, const struct _tev__GetEventBrokersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->EventBroker)
	{	int i;
		for (i = 0; i < (int)a->__sizeEventBroker; i++)
		{
			soap_embedded(soap, a->EventBroker + i, SOAP_TYPE_tev__EventBrokerConfig);
			soap_serialize_tev__EventBrokerConfig(soap, a->EventBroker + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventBrokersResponse(struct soap *soap, const char *tag, int id, const struct _tev__GetEventBrokersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventBrokersResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeEventBroker");
	if (a->EventBroker)
	{	int i;
		for (i = 0; i < (int)a->__sizeEventBroker; i++)
			if (soap_out_tev__EventBrokerConfig(soap, "tev:EventBroker", -1, a->EventBroker + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetEventBrokersResponse * SOAP_FMAC4 soap_in__tev__GetEventBrokersResponse(struct soap *soap, const char *tag, struct _tev__GetEventBrokersResponse *a, const char *type)
{
	struct soap_blist *soap_blist_EventBroker = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__GetEventBrokersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventBrokersResponse, sizeof(struct _tev__GetEventBrokersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetEventBrokersResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:EventBroker", 1, NULL))
			{	if (a->EventBroker == NULL)
				{	if (soap_blist_EventBroker == NULL)
						soap_blist_EventBroker = soap_alloc_block(soap);
					a->EventBroker = (struct tev__EventBrokerConfig *)soap_push_block_max(soap, soap_blist_EventBroker, sizeof(struct tev__EventBrokerConfig));
					if (a->EventBroker == NULL)
						return NULL;
					soap_default_tev__EventBrokerConfig(soap, a->EventBroker);
				}
				soap_revert(soap);
				if (soap_in_tev__EventBrokerConfig(soap, "tev:EventBroker", a->EventBroker, "tev:EventBrokerConfig"))
				{	a->__sizeEventBroker++;
					a->EventBroker = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeEventBroker");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EventBroker)
			soap_pop_block(soap, soap_blist_EventBroker);
		if (a->__sizeEventBroker)
		{	a->EventBroker = (struct tev__EventBrokerConfig *)soap_save_block(soap, soap_blist_EventBroker, NULL, 1);
		}
		else
		{	a->EventBroker = NULL;
			if (soap_blist_EventBroker)
				soap_end_block(soap, soap_blist_EventBroker);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventBrokersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventBrokersResponse, SOAP_TYPE__tev__GetEventBrokersResponse, sizeof(struct _tev__GetEventBrokersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetEventBrokersResponse * SOAP_FMAC4 soap_new__tev__GetEventBrokersResponse(struct soap *soap, int n)
{
	struct _tev__GetEventBrokersResponse *p;
	struct _tev__GetEventBrokersResponse *a = (struct _tev__GetEventBrokersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetEventBrokersResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__GetEventBrokersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetEventBrokersResponse(struct soap *soap, const struct _tev__GetEventBrokersResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetEventBrokersResponse(soap, tag ? tag : "tev:GetEventBrokersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventBrokersResponse * SOAP_FMAC4 soap_get__tev__GetEventBrokersResponse(struct soap *soap, struct _tev__GetEventBrokersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventBrokersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetEventBrokers(struct soap *soap, struct _tev__GetEventBrokers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Address);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetEventBrokers(struct soap *soap, const struct _tev__GetEventBrokers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Address);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventBrokers(struct soap *soap, const char *tag, int id, const struct _tev__GetEventBrokers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventBrokers), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tev:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetEventBrokers * SOAP_FMAC4 soap_in__tev__GetEventBrokers(struct soap *soap, const char *tag, struct _tev__GetEventBrokers *a, const char *type)
{
	size_t soap_flag_Address = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__GetEventBrokers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventBrokers, sizeof(struct _tev__GetEventBrokers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetEventBrokers(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tev:Address", (char**)&a->Address, "xsd:anyURI"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventBrokers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventBrokers, SOAP_TYPE__tev__GetEventBrokers, sizeof(struct _tev__GetEventBrokers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetEventBrokers * SOAP_FMAC4 soap_new__tev__GetEventBrokers(struct soap *soap, int n)
{
	struct _tev__GetEventBrokers *p;
	struct _tev__GetEventBrokers *a = (struct _tev__GetEventBrokers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetEventBrokers));
	for (p = a; p && n--; p++)
		soap_default__tev__GetEventBrokers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetEventBrokers(struct soap *soap, const struct _tev__GetEventBrokers *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetEventBrokers(soap, tag ? tag : "tev:GetEventBrokers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventBrokers * SOAP_FMAC4 soap_get__tev__GetEventBrokers(struct soap *soap, struct _tev__GetEventBrokers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventBrokers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__DeleteEventBrokerResponse(struct soap *soap, struct _tev__DeleteEventBrokerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__DeleteEventBrokerResponse(struct soap *soap, const struct _tev__DeleteEventBrokerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__DeleteEventBrokerResponse(struct soap *soap, const char *tag, int id, const struct _tev__DeleteEventBrokerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__DeleteEventBrokerResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__DeleteEventBrokerResponse * SOAP_FMAC4 soap_in__tev__DeleteEventBrokerResponse(struct soap *soap, const char *tag, struct _tev__DeleteEventBrokerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__DeleteEventBrokerResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__DeleteEventBrokerResponse, sizeof(struct _tev__DeleteEventBrokerResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__DeleteEventBrokerResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__DeleteEventBrokerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__DeleteEventBrokerResponse, SOAP_TYPE__tev__DeleteEventBrokerResponse, sizeof(struct _tev__DeleteEventBrokerResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__DeleteEventBrokerResponse * SOAP_FMAC4 soap_new__tev__DeleteEventBrokerResponse(struct soap *soap, int n)
{
	struct _tev__DeleteEventBrokerResponse *p;
	struct _tev__DeleteEventBrokerResponse *a = (struct _tev__DeleteEventBrokerResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__DeleteEventBrokerResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__DeleteEventBrokerResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__DeleteEventBrokerResponse(struct soap *soap, const struct _tev__DeleteEventBrokerResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__DeleteEventBrokerResponse(soap, tag ? tag : "tev:DeleteEventBrokerResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__DeleteEventBrokerResponse * SOAP_FMAC4 soap_get__tev__DeleteEventBrokerResponse(struct soap *soap, struct _tev__DeleteEventBrokerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__DeleteEventBrokerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__DeleteEventBroker(struct soap *soap, struct _tev__DeleteEventBroker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Address);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__DeleteEventBroker(struct soap *soap, const struct _tev__DeleteEventBroker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Address);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__DeleteEventBroker(struct soap *soap, const char *tag, int id, const struct _tev__DeleteEventBroker *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__DeleteEventBroker), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "tev:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tev:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__DeleteEventBroker * SOAP_FMAC4 soap_in__tev__DeleteEventBroker(struct soap *soap, const char *tag, struct _tev__DeleteEventBroker *a, const char *type)
{
	size_t soap_flag_Address = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__DeleteEventBroker*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__DeleteEventBroker, sizeof(struct _tev__DeleteEventBroker), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__DeleteEventBroker(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tev:Address", (char**)&a->Address, "xsd:anyURI"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__DeleteEventBroker *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__DeleteEventBroker, SOAP_TYPE__tev__DeleteEventBroker, sizeof(struct _tev__DeleteEventBroker), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__DeleteEventBroker * SOAP_FMAC4 soap_new__tev__DeleteEventBroker(struct soap *soap, int n)
{
	struct _tev__DeleteEventBroker *p;
	struct _tev__DeleteEventBroker *a = (struct _tev__DeleteEventBroker*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__DeleteEventBroker));
	for (p = a; p && n--; p++)
		soap_default__tev__DeleteEventBroker(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__DeleteEventBroker(struct soap *soap, const struct _tev__DeleteEventBroker *a, const char *tag, const char *type)
{
	if (soap_out__tev__DeleteEventBroker(soap, tag ? tag : "tev:DeleteEventBroker", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__DeleteEventBroker * SOAP_FMAC4 soap_get__tev__DeleteEventBroker(struct soap *soap, struct _tev__DeleteEventBroker *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__DeleteEventBroker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__AddEventBrokerResponse(struct soap *soap, struct _tev__AddEventBrokerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__AddEventBrokerResponse(struct soap *soap, const struct _tev__AddEventBrokerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__AddEventBrokerResponse(struct soap *soap, const char *tag, int id, const struct _tev__AddEventBrokerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__AddEventBrokerResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__AddEventBrokerResponse * SOAP_FMAC4 soap_in__tev__AddEventBrokerResponse(struct soap *soap, const char *tag, struct _tev__AddEventBrokerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__AddEventBrokerResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__AddEventBrokerResponse, sizeof(struct _tev__AddEventBrokerResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__AddEventBrokerResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__AddEventBrokerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__AddEventBrokerResponse, SOAP_TYPE__tev__AddEventBrokerResponse, sizeof(struct _tev__AddEventBrokerResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__AddEventBrokerResponse * SOAP_FMAC4 soap_new__tev__AddEventBrokerResponse(struct soap *soap, int n)
{
	struct _tev__AddEventBrokerResponse *p;
	struct _tev__AddEventBrokerResponse *a = (struct _tev__AddEventBrokerResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__AddEventBrokerResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__AddEventBrokerResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__AddEventBrokerResponse(struct soap *soap, const struct _tev__AddEventBrokerResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__AddEventBrokerResponse(soap, tag ? tag : "tev:AddEventBrokerResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__AddEventBrokerResponse * SOAP_FMAC4 soap_get__tev__AddEventBrokerResponse(struct soap *soap, struct _tev__AddEventBrokerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__AddEventBrokerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__AddEventBroker(struct soap *soap, struct _tev__AddEventBroker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EventBroker = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__AddEventBroker(struct soap *soap, const struct _tev__AddEventBroker *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotev__EventBrokerConfig(soap, &a->EventBroker);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__AddEventBroker(struct soap *soap, const char *tag, int id, const struct _tev__AddEventBroker *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__AddEventBroker), type))
		return soap->error;
	if (!a->EventBroker)
	{	if (soap_element_empty(soap, "tev:EventBroker", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotev__EventBrokerConfig(soap, "tev:EventBroker", -1, &a->EventBroker, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__AddEventBroker * SOAP_FMAC4 soap_in__tev__AddEventBroker(struct soap *soap, const char *tag, struct _tev__AddEventBroker *a, const char *type)
{
	size_t soap_flag_EventBroker = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__AddEventBroker*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__AddEventBroker, sizeof(struct _tev__AddEventBroker), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__AddEventBroker(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EventBroker && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotev__EventBrokerConfig(soap, "tev:EventBroker", &a->EventBroker, "tev:EventBrokerConfig"))
				{	soap_flag_EventBroker--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->EventBroker))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__AddEventBroker *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__AddEventBroker, SOAP_TYPE__tev__AddEventBroker, sizeof(struct _tev__AddEventBroker), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__AddEventBroker * SOAP_FMAC4 soap_new__tev__AddEventBroker(struct soap *soap, int n)
{
	struct _tev__AddEventBroker *p;
	struct _tev__AddEventBroker *a = (struct _tev__AddEventBroker*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__AddEventBroker));
	for (p = a; p && n--; p++)
		soap_default__tev__AddEventBroker(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__AddEventBroker(struct soap *soap, const struct _tev__AddEventBroker *a, const char *tag, const char *type)
{
	if (soap_out__tev__AddEventBroker(soap, tag ? tag : "tev:AddEventBroker", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__AddEventBroker * SOAP_FMAC4 soap_get__tev__AddEventBroker(struct soap *soap, struct _tev__AddEventBroker *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__AddEventBroker(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetEventPropertiesResponse(struct soap *soap, struct _tev__GetEventPropertiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTopicNamespaceLocation = 0;
	a->TopicNamespaceLocation = NULL;
	a->wsnt__FixedTopicSet = (enum xsd__boolean)1;
	a->wstop__TopicSet = NULL;
	a->__sizeTopicExpressionDialect = 0;
	a->wsnt__TopicExpressionDialect = NULL;
	a->__sizeMessageContentFilterDialect = 0;
	a->MessageContentFilterDialect = NULL;
	a->__sizeProducerPropertiesFilterDialect = 0;
	a->ProducerPropertiesFilterDialect = NULL;
	a->__sizeMessageContentSchemaLocation = 0;
	a->MessageContentSchemaLocation = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetEventPropertiesResponse(struct soap *soap, const struct _tev__GetEventPropertiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->TopicNamespaceLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicNamespaceLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->TopicNamespaceLocation + i));
		}
	}
	soap_embedded(soap, &a->wsnt__FixedTopicSet, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTowstop__TopicSetType(soap, &a->wstop__TopicSet);
	if (a->wsnt__TopicExpressionDialect)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpressionDialect; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->wsnt__TopicExpressionDialect + i));
		}
	}
	if (a->MessageContentFilterDialect)
	{	int i;
		for (i = 0; i < (int)a->__sizeMessageContentFilterDialect; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->MessageContentFilterDialect + i));
		}
	}
	if (a->ProducerPropertiesFilterDialect)
	{	int i;
		for (i = 0; i < (int)a->__sizeProducerPropertiesFilterDialect; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ProducerPropertiesFilterDialect + i));
		}
	}
	if (a->MessageContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeMessageContentSchemaLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->MessageContentSchemaLocation + i));
		}
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, int id, const struct _tev__GetEventPropertiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventPropertiesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeTopicNamespaceLocation");
	if (a->TopicNamespaceLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicNamespaceLocation; i++)
			if (soap_out_string(soap, "tev:TopicNamespaceLocation", -1, (char*const*)(a->TopicNamespaceLocation + i), ""))
				return soap->error;
	}
	if (soap_out_xsd__boolean(soap, "wsnt:FixedTopicSet", -1, &a->wsnt__FixedTopicSet, ""))
		return soap->error;
	if (!a->wstop__TopicSet)
	{	if (soap_element_empty(soap, "wstop:TopicSet", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &a->wstop__TopicSet, ""))
		return soap->error;
	if (a->wsnt__TopicExpressionDialect)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopicExpressionDialect; i++)
			if (soap_out_string(soap, "wsnt:TopicExpressionDialect", -1, (char*const*)(a->wsnt__TopicExpressionDialect + i), ""))
				return soap->error;
	}
	if (a->MessageContentFilterDialect)
	{	int i;
		for (i = 0; i < (int)a->__sizeMessageContentFilterDialect; i++)
			if (soap_out_string(soap, "tev:MessageContentFilterDialect", -1, (char*const*)(a->MessageContentFilterDialect + i), ""))
				return soap->error;
	}
	if (a->ProducerPropertiesFilterDialect)
	{	int i;
		for (i = 0; i < (int)a->__sizeProducerPropertiesFilterDialect; i++)
			if (soap_out_string(soap, "tev:ProducerPropertiesFilterDialect", -1, (char*const*)(a->ProducerPropertiesFilterDialect + i), ""))
				return soap->error;
	}
	if (a->MessageContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeMessageContentSchemaLocation; i++)
			if (soap_out_string(soap, "tev:MessageContentSchemaLocation", -1, (char*const*)(a->MessageContentSchemaLocation + i), ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetEventPropertiesResponse * SOAP_FMAC4 soap_in__tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, struct _tev__GetEventPropertiesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_TopicNamespaceLocation = NULL;
	size_t soap_flag_wsnt__FixedTopicSet = 1;
	size_t soap_flag_wstop__TopicSet = 1;
	struct soap_blist *soap_blist_wsnt__TopicExpressionDialect = NULL;
	struct soap_blist *soap_blist_MessageContentFilterDialect = NULL;
	struct soap_blist *soap_blist_ProducerPropertiesFilterDialect = NULL;
	struct soap_blist *soap_blist_MessageContentSchemaLocation = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__GetEventPropertiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(struct _tev__GetEventPropertiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetEventPropertiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:TopicNamespaceLocation", 1, NULL))
			{	if (a->TopicNamespaceLocation == NULL)
				{	if (soap_blist_TopicNamespaceLocation == NULL)
						soap_blist_TopicNamespaceLocation = soap_alloc_block(soap);
					a->TopicNamespaceLocation = (char **)soap_push_block_max(soap, soap_blist_TopicNamespaceLocation, sizeof(char *));
					if (a->TopicNamespaceLocation == NULL)
						return NULL;
					*a->TopicNamespaceLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tev:TopicNamespaceLocation", (char**)a->TopicNamespaceLocation, "xsd:anyURI"))
				{	a->__sizeTopicNamespaceLocation++;
					a->TopicNamespaceLocation = NULL;
					continue;
				}
			}
			if (soap_flag_wsnt__FixedTopicSet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "wsnt:FixedTopicSet", &a->wsnt__FixedTopicSet, "xsd:boolean"))
				{	soap_flag_wsnt__FixedTopicSet--;
					continue;
				}
			}
			if (soap_flag_wstop__TopicSet && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &a->wstop__TopicSet, "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpressionDialect", 1, NULL))
			{	if (a->wsnt__TopicExpressionDialect == NULL)
				{	if (soap_blist_wsnt__TopicExpressionDialect == NULL)
						soap_blist_wsnt__TopicExpressionDialect = soap_alloc_block(soap);
					a->wsnt__TopicExpressionDialect = (char **)soap_push_block_max(soap, soap_blist_wsnt__TopicExpressionDialect, sizeof(char *));
					if (a->wsnt__TopicExpressionDialect == NULL)
						return NULL;
					*a->wsnt__TopicExpressionDialect = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "wsnt:TopicExpressionDialect", (char**)a->wsnt__TopicExpressionDialect, "xsd:anyURI"))
				{	a->__sizeTopicExpressionDialect++;
					a->wsnt__TopicExpressionDialect = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:MessageContentFilterDialect", 1, NULL))
			{	if (a->MessageContentFilterDialect == NULL)
				{	if (soap_blist_MessageContentFilterDialect == NULL)
						soap_blist_MessageContentFilterDialect = soap_alloc_block(soap);
					a->MessageContentFilterDialect = (char **)soap_push_block_max(soap, soap_blist_MessageContentFilterDialect, sizeof(char *));
					if (a->MessageContentFilterDialect == NULL)
						return NULL;
					*a->MessageContentFilterDialect = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tev:MessageContentFilterDialect", (char**)a->MessageContentFilterDialect, "xsd:anyURI"))
				{	a->__sizeMessageContentFilterDialect++;
					a->MessageContentFilterDialect = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:ProducerPropertiesFilterDialect", 1, NULL))
			{	if (a->ProducerPropertiesFilterDialect == NULL)
				{	if (soap_blist_ProducerPropertiesFilterDialect == NULL)
						soap_blist_ProducerPropertiesFilterDialect = soap_alloc_block(soap);
					a->ProducerPropertiesFilterDialect = (char **)soap_push_block_max(soap, soap_blist_ProducerPropertiesFilterDialect, sizeof(char *));
					if (a->ProducerPropertiesFilterDialect == NULL)
						return NULL;
					*a->ProducerPropertiesFilterDialect = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tev:ProducerPropertiesFilterDialect", (char**)a->ProducerPropertiesFilterDialect, "xsd:anyURI"))
				{	a->__sizeProducerPropertiesFilterDialect++;
					a->ProducerPropertiesFilterDialect = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:MessageContentSchemaLocation", 1, NULL))
			{	if (a->MessageContentSchemaLocation == NULL)
				{	if (soap_blist_MessageContentSchemaLocation == NULL)
						soap_blist_MessageContentSchemaLocation = soap_alloc_block(soap);
					a->MessageContentSchemaLocation = (char **)soap_push_block_max(soap, soap_blist_MessageContentSchemaLocation, sizeof(char *));
					if (a->MessageContentSchemaLocation == NULL)
						return NULL;
					*a->MessageContentSchemaLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tev:MessageContentSchemaLocation", (char**)a->MessageContentSchemaLocation, "xsd:anyURI"))
				{	a->__sizeMessageContentSchemaLocation++;
					a->MessageContentSchemaLocation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeTopicNamespaceLocation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TopicNamespaceLocation)
			soap_pop_block(soap, soap_blist_TopicNamespaceLocation);
		if (a->__sizeTopicNamespaceLocation)
		{	a->TopicNamespaceLocation = (char **)soap_save_block(soap, soap_blist_TopicNamespaceLocation, NULL, 1);
		}
		else
		{	a->TopicNamespaceLocation = NULL;
			if (soap_blist_TopicNamespaceLocation)
				soap_end_block(soap, soap_blist_TopicNamespaceLocation);
		}
		if (a->wsnt__TopicExpressionDialect)
			soap_pop_block(soap, soap_blist_wsnt__TopicExpressionDialect);
		if (a->__sizeTopicExpressionDialect)
		{	a->wsnt__TopicExpressionDialect = (char **)soap_save_block(soap, soap_blist_wsnt__TopicExpressionDialect, NULL, 1);
		}
		else
		{	a->wsnt__TopicExpressionDialect = NULL;
			if (soap_blist_wsnt__TopicExpressionDialect)
				soap_end_block(soap, soap_blist_wsnt__TopicExpressionDialect);
		}
		if (a->MessageContentFilterDialect)
			soap_pop_block(soap, soap_blist_MessageContentFilterDialect);
		if (a->__sizeMessageContentFilterDialect)
		{	a->MessageContentFilterDialect = (char **)soap_save_block(soap, soap_blist_MessageContentFilterDialect, NULL, 1);
		}
		else
		{	a->MessageContentFilterDialect = NULL;
			if (soap_blist_MessageContentFilterDialect)
				soap_end_block(soap, soap_blist_MessageContentFilterDialect);
		}
		if (a->ProducerPropertiesFilterDialect)
			soap_pop_block(soap, soap_blist_ProducerPropertiesFilterDialect);
		if (a->__sizeProducerPropertiesFilterDialect)
		{	a->ProducerPropertiesFilterDialect = (char **)soap_save_block(soap, soap_blist_ProducerPropertiesFilterDialect, NULL, 1);
		}
		else
		{	a->ProducerPropertiesFilterDialect = NULL;
			if (soap_blist_ProducerPropertiesFilterDialect)
				soap_end_block(soap, soap_blist_ProducerPropertiesFilterDialect);
		}
		if (a->MessageContentSchemaLocation)
			soap_pop_block(soap, soap_blist_MessageContentSchemaLocation);
		if (a->__sizeMessageContentSchemaLocation)
		{	a->MessageContentSchemaLocation = (char **)soap_save_block(soap, soap_blist_MessageContentSchemaLocation, NULL, 1);
		}
		else
		{	a->MessageContentSchemaLocation = NULL;
			if (soap_blist_MessageContentSchemaLocation)
				soap_end_block(soap, soap_blist_MessageContentSchemaLocation);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeTopicNamespaceLocation < 1 || soap_flag_wsnt__FixedTopicSet > 0 || !a->wstop__TopicSet || a->__sizeTopicExpressionDialect < 1 || a->__sizeMessageContentFilterDialect < 1 || a->__sizeMessageContentSchemaLocation < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__GetEventPropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventPropertiesResponse, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(struct _tev__GetEventPropertiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetEventPropertiesResponse * SOAP_FMAC4 soap_new__tev__GetEventPropertiesResponse(struct soap *soap, int n)
{
	struct _tev__GetEventPropertiesResponse *p;
	struct _tev__GetEventPropertiesResponse *a = (struct _tev__GetEventPropertiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetEventPropertiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__GetEventPropertiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetEventPropertiesResponse(struct soap *soap, const struct _tev__GetEventPropertiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetEventPropertiesResponse(soap, tag ? tag : "tev:GetEventPropertiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventPropertiesResponse * SOAP_FMAC4 soap_get__tev__GetEventPropertiesResponse(struct soap *soap, struct _tev__GetEventPropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetEventProperties(struct soap *soap, struct _tev__GetEventProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetEventProperties(struct soap *soap, const struct _tev__GetEventProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventProperties(struct soap *soap, const char *tag, int id, const struct _tev__GetEventProperties *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventProperties), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetEventProperties * SOAP_FMAC4 soap_in__tev__GetEventProperties(struct soap *soap, const char *tag, struct _tev__GetEventProperties *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__GetEventProperties*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventProperties, sizeof(struct _tev__GetEventProperties), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetEventProperties(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventProperties, SOAP_TYPE__tev__GetEventProperties, sizeof(struct _tev__GetEventProperties), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetEventProperties * SOAP_FMAC4 soap_new__tev__GetEventProperties(struct soap *soap, int n)
{
	struct _tev__GetEventProperties *p;
	struct _tev__GetEventProperties *a = (struct _tev__GetEventProperties*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetEventProperties));
	for (p = a; p && n--; p++)
		soap_default__tev__GetEventProperties(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetEventProperties(struct soap *soap, const struct _tev__GetEventProperties *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetEventProperties(soap, tag ? tag : "tev:GetEventProperties", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventProperties * SOAP_FMAC4 soap_get__tev__GetEventProperties(struct soap *soap, struct _tev__GetEventProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__SetSynchronizationPointResponse(struct soap *soap, struct _tev__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__SetSynchronizationPointResponse(struct soap *soap, const struct _tev__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, const struct _tev__SetSynchronizationPointResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SetSynchronizationPointResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPointResponse * SOAP_FMAC4 soap_in__tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _tev__SetSynchronizationPointResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__SetSynchronizationPointResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(struct _tev__SetSynchronizationPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__SetSynchronizationPointResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__SetSynchronizationPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SetSynchronizationPointResponse, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(struct _tev__SetSynchronizationPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__SetSynchronizationPointResponse * SOAP_FMAC4 soap_new__tev__SetSynchronizationPointResponse(struct soap *soap, int n)
{
	struct _tev__SetSynchronizationPointResponse *p;
	struct _tev__SetSynchronizationPointResponse *a = (struct _tev__SetSynchronizationPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__SetSynchronizationPointResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__SetSynchronizationPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__SetSynchronizationPointResponse(struct soap *soap, const struct _tev__SetSynchronizationPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__SetSynchronizationPointResponse(soap, tag ? tag : "tev:SetSynchronizationPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPointResponse * SOAP_FMAC4 soap_get__tev__SetSynchronizationPointResponse(struct soap *soap, struct _tev__SetSynchronizationPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__SetSynchronizationPoint(struct soap *soap, struct _tev__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__SetSynchronizationPoint(struct soap *soap, const struct _tev__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const struct _tev__SetSynchronizationPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SetSynchronizationPoint), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPoint * SOAP_FMAC4 soap_in__tev__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _tev__SetSynchronizationPoint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__SetSynchronizationPoint*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(struct _tev__SetSynchronizationPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__SetSynchronizationPoint(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__SetSynchronizationPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SetSynchronizationPoint, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(struct _tev__SetSynchronizationPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__SetSynchronizationPoint * SOAP_FMAC4 soap_new__tev__SetSynchronizationPoint(struct soap *soap, int n)
{
	struct _tev__SetSynchronizationPoint *p;
	struct _tev__SetSynchronizationPoint *a = (struct _tev__SetSynchronizationPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__SetSynchronizationPoint));
	for (p = a; p && n--; p++)
		soap_default__tev__SetSynchronizationPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__SetSynchronizationPoint(struct soap *soap, const struct _tev__SetSynchronizationPoint *a, const char *tag, const char *type)
{
	if (soap_out__tev__SetSynchronizationPoint(soap, tag ? tag : "tev:SetSynchronizationPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPoint * SOAP_FMAC4 soap_get__tev__SetSynchronizationPoint(struct soap *soap, struct _tev__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__SeekResponse(struct soap *soap, struct _tev__SeekResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__SeekResponse(struct soap *soap, const struct _tev__SeekResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SeekResponse(struct soap *soap, const char *tag, int id, const struct _tev__SeekResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SeekResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__SeekResponse * SOAP_FMAC4 soap_in__tev__SeekResponse(struct soap *soap, const char *tag, struct _tev__SeekResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__SeekResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SeekResponse, sizeof(struct _tev__SeekResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__SeekResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__SeekResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SeekResponse, SOAP_TYPE__tev__SeekResponse, sizeof(struct _tev__SeekResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__SeekResponse * SOAP_FMAC4 soap_new__tev__SeekResponse(struct soap *soap, int n)
{
	struct _tev__SeekResponse *p;
	struct _tev__SeekResponse *a = (struct _tev__SeekResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__SeekResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__SeekResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__SeekResponse(struct soap *soap, const struct _tev__SeekResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__SeekResponse(soap, tag ? tag : "tev:SeekResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SeekResponse * SOAP_FMAC4 soap_get__tev__SeekResponse(struct soap *soap, struct _tev__SeekResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SeekResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__Seek(struct soap *soap, struct _tev__Seek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->UtcTime);
	a->Reverse = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__Seek(struct soap *soap, const struct _tev__Seek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->UtcTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerToxsd__boolean(soap, &a->Reverse);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__Seek(struct soap *soap, const char *tag, int id, const struct _tev__Seek *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__Seek), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tev:UtcTime", -1, &a->UtcTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tev:Reverse", -1, &a->Reverse, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__Seek * SOAP_FMAC4 soap_in__tev__Seek(struct soap *soap, const char *tag, struct _tev__Seek *a, const char *type)
{
	size_t soap_flag_UtcTime = 1;
	size_t soap_flag_Reverse = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__Seek*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__Seek, sizeof(struct _tev__Seek), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__Seek(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UtcTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tev:UtcTime", &a->UtcTime, "xsd:dateTime"))
				{	soap_flag_UtcTime--;
					continue;
				}
			}
			if (soap_flag_Reverse && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToxsd__boolean(soap, "tev:Reverse", &a->Reverse, "xsd:boolean"))
				{	soap_flag_Reverse--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__Seek *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__Seek, SOAP_TYPE__tev__Seek, sizeof(struct _tev__Seek), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__Seek * SOAP_FMAC4 soap_new__tev__Seek(struct soap *soap, int n)
{
	struct _tev__Seek *p;
	struct _tev__Seek *a = (struct _tev__Seek*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__Seek));
	for (p = a; p && n--; p++)
		soap_default__tev__Seek(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__Seek(struct soap *soap, const struct _tev__Seek *a, const char *tag, const char *type)
{
	if (soap_out__tev__Seek(soap, tag ? tag : "tev:Seek", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__Seek * SOAP_FMAC4 soap_get__tev__Seek(struct soap *soap, struct _tev__Seek *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__Seek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->MaxTimeout);
	soap_default_int(soap, &a->MaxMessageLimit);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__PullMessagesFaultResponse(struct soap *soap, const struct _tev__PullMessagesFaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__duration(soap, (char*const*)&a->MaxTimeout);
	soap_embedded(soap, &a->MaxMessageLimit, SOAP_TYPE_int);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, int id, const struct _tev__PullMessagesFaultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessagesFaultResponse), type))
		return soap->error;
	if (!a->MaxTimeout)
	{	if (soap_element_empty(soap, "tev:MaxTimeout", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tev:MaxTimeout", -1, (char*const*)&a->MaxTimeout, ""))
		return soap->error;
	if (soap_out_int(soap, "tev:MaxMessageLimit", -1, &a->MaxMessageLimit, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_in__tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, struct _tev__PullMessagesFaultResponse *a, const char *type)
{
	size_t soap_flag_MaxTimeout = 1;
	size_t soap_flag_MaxMessageLimit = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__PullMessagesFaultResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(struct _tev__PullMessagesFaultResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__PullMessagesFaultResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaxTimeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tev:MaxTimeout", (char**)&a->MaxTimeout, "xsd:duration"))
				{	soap_flag_MaxTimeout--;
					continue;
				}
			}
			if (soap_flag_MaxMessageLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tev:MaxMessageLimit", &a->MaxMessageLimit, "xsd:int"))
				{	soap_flag_MaxMessageLimit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->MaxTimeout || soap_flag_MaxMessageLimit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__PullMessagesFaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesFaultResponse, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(struct _tev__PullMessagesFaultResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_new__tev__PullMessagesFaultResponse(struct soap *soap, int n)
{
	struct _tev__PullMessagesFaultResponse *p;
	struct _tev__PullMessagesFaultResponse *a = (struct _tev__PullMessagesFaultResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__PullMessagesFaultResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__PullMessagesFaultResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__PullMessagesFaultResponse(struct soap *soap, const struct _tev__PullMessagesFaultResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__PullMessagesFaultResponse(soap, tag ? tag : "tev:PullMessagesFaultResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_get__tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessagesFaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->CurrentTime);
	soap_default_dateTime(soap, &a->TerminationTime);
	a->__sizeNotificationMessage = 0;
	a->wsnt__NotificationMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__PullMessagesResponse(struct soap *soap, const struct _tev__PullMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->CurrentTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->TerminationTime, SOAP_TYPE_dateTime);
	if (a->wsnt__NotificationMessage)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
		{
			soap_embedded(soap, a->wsnt__NotificationMessage + i, SOAP_TYPE_wsnt__NotificationMessageHolderType);
			soap_serialize_wsnt__NotificationMessageHolderType(soap, a->wsnt__NotificationMessage + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessagesResponse(struct soap *soap, const char *tag, int id, const struct _tev__PullMessagesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessagesResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:CurrentTime");
	if (soap_out_dateTime(soap, "tev:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tev:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (a->wsnt__NotificationMessage)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
			if (soap_out_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, a->wsnt__NotificationMessage + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__PullMessagesResponse * SOAP_FMAC4 soap_in__tev__PullMessagesResponse(struct soap *soap, const char *tag, struct _tev__PullMessagesResponse *a, const char *type)
{
	size_t soap_flag_CurrentTime = 1;
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist_wsnt__NotificationMessage = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__PullMessagesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesResponse, sizeof(struct _tev__PullMessagesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__PullMessagesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tev:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			}
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tev:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
			{	if (a->wsnt__NotificationMessage == NULL)
				{	if (soap_blist_wsnt__NotificationMessage == NULL)
						soap_blist_wsnt__NotificationMessage = soap_alloc_block(soap);
					a->wsnt__NotificationMessage = (struct wsnt__NotificationMessageHolderType *)soap_push_block_max(soap, soap_blist_wsnt__NotificationMessage, sizeof(struct wsnt__NotificationMessageHolderType));
					if (a->wsnt__NotificationMessage == NULL)
						return NULL;
					soap_default_wsnt__NotificationMessageHolderType(soap, a->wsnt__NotificationMessage);
				}
				soap_revert(soap);
				if (soap_in_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", a->wsnt__NotificationMessage, "wsnt:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->wsnt__NotificationMessage = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tev:CurrentTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsnt__NotificationMessage)
			soap_pop_block(soap, soap_blist_wsnt__NotificationMessage);
		if (a->__sizeNotificationMessage)
		{	a->wsnt__NotificationMessage = (struct wsnt__NotificationMessageHolderType *)soap_save_block(soap, soap_blist_wsnt__NotificationMessage, NULL, 1);
		}
		else
		{	a->wsnt__NotificationMessage = NULL;
			if (soap_blist_wsnt__NotificationMessage)
				soap_end_block(soap, soap_blist_wsnt__NotificationMessage);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentTime > 0 || soap_flag_TerminationTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__PullMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesResponse, SOAP_TYPE__tev__PullMessagesResponse, sizeof(struct _tev__PullMessagesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__PullMessagesResponse * SOAP_FMAC4 soap_new__tev__PullMessagesResponse(struct soap *soap, int n)
{
	struct _tev__PullMessagesResponse *p;
	struct _tev__PullMessagesResponse *a = (struct _tev__PullMessagesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__PullMessagesResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__PullMessagesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__PullMessagesResponse(struct soap *soap, const struct _tev__PullMessagesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__PullMessagesResponse(soap, tag ? tag : "tev:PullMessagesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessagesResponse * SOAP_FMAC4 soap_get__tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__PullMessages(struct soap *soap, struct _tev__PullMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->Timeout);
	soap_default_int(soap, &a->MessageLimit);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__PullMessages(struct soap *soap, const struct _tev__PullMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__duration(soap, (char*const*)&a->Timeout);
	soap_embedded(soap, &a->MessageLimit, SOAP_TYPE_int);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessages(struct soap *soap, const char *tag, int id, const struct _tev__PullMessages *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessages), type))
		return soap->error;
	if (!a->Timeout)
	{	if (soap_element_empty(soap, "tev:Timeout", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__duration(soap, "tev:Timeout", -1, (char*const*)&a->Timeout, ""))
		return soap->error;
	if (soap_out_int(soap, "tev:MessageLimit", -1, &a->MessageLimit, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__PullMessages * SOAP_FMAC4 soap_in__tev__PullMessages(struct soap *soap, const char *tag, struct _tev__PullMessages *a, const char *type)
{
	size_t soap_flag_Timeout = 1;
	size_t soap_flag_MessageLimit = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__PullMessages*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessages, sizeof(struct _tev__PullMessages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__PullMessages(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tev:Timeout", (char**)&a->Timeout, "xsd:duration"))
				{	soap_flag_Timeout--;
					continue;
				}
			}
			if (soap_flag_MessageLimit && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tev:MessageLimit", &a->MessageLimit, "xsd:int"))
				{	soap_flag_MessageLimit--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Timeout || soap_flag_MessageLimit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__PullMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessages, SOAP_TYPE__tev__PullMessages, sizeof(struct _tev__PullMessages), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__PullMessages * SOAP_FMAC4 soap_new__tev__PullMessages(struct soap *soap, int n)
{
	struct _tev__PullMessages *p;
	struct _tev__PullMessages *a = (struct _tev__PullMessages*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__PullMessages));
	for (p = a; p && n--; p++)
		soap_default__tev__PullMessages(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__PullMessages(struct soap *soap, const struct _tev__PullMessages *a, const char *tag, const char *type)
{
	if (soap_out__tev__PullMessages(soap, tag ? tag : "tev:PullMessages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessages * SOAP_FMAC4 soap_get__tev__PullMessages(struct soap *soap, struct _tev__PullMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_default_dateTime(soap, &a->wsnt__CurrentTime);
	soap_default_dateTime(soap, &a->wsnt__TerminationTime);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const struct _tev__CreatePullPointSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_embedded(soap, &a->wsnt__CurrentTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->wsnt__TerminationTime, SOAP_TYPE_dateTime);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _tev__CreatePullPointSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:SubscriptionReference");
	if (soap_out_wsa5__EndpointReferenceType(soap, "tev:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:CurrentTime", -1, &a->wsnt__CurrentTime, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:TerminationTime", -1, &a->wsnt__TerminationTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscriptionResponse *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_wsnt__CurrentTime = 1;
	size_t soap_flag_wsnt__TerminationTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__CreatePullPointSubscriptionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(struct _tev__CreatePullPointSubscriptionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__CreatePullPointSubscriptionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsa5__EndpointReferenceType(soap, "tev:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			}
			if (soap_flag_wsnt__CurrentTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:CurrentTime", &a->wsnt__CurrentTime, "xsd:dateTime"))
				{	soap_flag_wsnt__CurrentTime--;
					continue;
				}
			}
			if (soap_flag_wsnt__TerminationTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "wsnt:TerminationTime", &a->wsnt__TerminationTime, "xsd:dateTime"))
				{	soap_flag_wsnt__TerminationTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tev:SubscriptionReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0 || soap_flag_wsnt__CurrentTime > 0 || soap_flag_wsnt__TerminationTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(struct _tev__CreatePullPointSubscriptionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_new__tev__CreatePullPointSubscriptionResponse(struct soap *soap, int n)
{
	struct _tev__CreatePullPointSubscriptionResponse *p;
	struct _tev__CreatePullPointSubscriptionResponse *a = (struct _tev__CreatePullPointSubscriptionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__CreatePullPointSubscriptionResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__CreatePullPointSubscriptionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const struct _tev__CreatePullPointSubscriptionResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__CreatePullPointSubscriptionResponse(soap, tag ? tag : "tev:CreatePullPointSubscriptionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_new__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, int n)
{
	struct _tev__CreatePullPointSubscription_SubscriptionPolicy *p;
	struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy));
	for (p = a; p && n--; p++)
		soap_default__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *tag, const char *type)
{
	if (soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag ? tag : "tev:CreatePullPointSubscription-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Filter = NULL;
	soap_default_wsnt__AbsoluteOrRelativeTimeType(soap, &a->InitialTerminationTime);
	a->SubscriptionPolicy = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__CreatePullPointSubscription(struct soap *soap, const struct _tev__CreatePullPointSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, (char*const*)&a->InitialTerminationTime);
	soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscription(struct soap *soap, const char *tag, int id, const struct _tev__CreatePullPointSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscription), type))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tev:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, "tev:InitialTerminationTime", -1, (char*const*)&a->InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscription(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription *a, const char *type)
{
	size_t soap_flag_Filter = 1;
	size_t soap_flag_InitialTerminationTime = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__CreatePullPointSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(struct _tev__CreatePullPointSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__CreatePullPointSubscription(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "tev:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			}
			if (soap_flag_InitialTerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, "tev:InitialTerminationTime", (char**)&a->InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:SubscriptionPolicy", &a->SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(struct _tev__CreatePullPointSubscription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_new__tev__CreatePullPointSubscription(struct soap *soap, int n)
{
	struct _tev__CreatePullPointSubscription *p;
	struct _tev__CreatePullPointSubscription *a = (struct _tev__CreatePullPointSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__CreatePullPointSubscription));
	for (p = a; p && n--; p++)
		soap_default__tev__CreatePullPointSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__CreatePullPointSubscription(struct soap *soap, const struct _tev__CreatePullPointSubscription *a, const char *tag, const char *type)
{
	if (soap_out__tev__CreatePullPointSubscription(soap, tag ? tag : "tev:CreatePullPointSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tev__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotev__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tev__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tev:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_empty(soap, "tev:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotev__Capabilities(soap, "tev:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tev__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(struct _tev__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotev__Capabilities(soap, "tev:Capabilities", &a->Capabilities, "tev:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			}
			soap_check_result(soap, "tev:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(struct _tev__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tev__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tev__GetServiceCapabilitiesResponse *p;
	struct _tev__GetServiceCapabilitiesResponse *a = (struct _tev__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tev__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetServiceCapabilitiesResponse(soap, tag ? tag : "tev:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetServiceCapabilities(struct soap *soap, const struct _tev__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tev__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities * SOAP_FMAC4 soap_in__tev__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tev__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tev__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(struct _tev__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetServiceCapabilities(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilities, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(struct _tev__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities * SOAP_FMAC4 soap_new__tev__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tev__GetServiceCapabilities *p;
	struct _tev__GetServiceCapabilities *a = (struct _tev__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tev__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetServiceCapabilities(struct soap *soap, const struct _tev__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetServiceCapabilities(soap, tag ? tag : "tev:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities * SOAP_FMAC4 soap_get__tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tev__EventBrokerConfig(struct soap *soap, struct tev__EventBrokerConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Address);
	soap_default_string(soap, &a->TopicPrefix);
	soap_default_string(soap, &a->UserName);
	soap_default_string(soap, &a->Password);
	soap_default_xsd__token(soap, &a->CertificateID);
	a->PublishFilter = NULL;
	a->QoS = NULL;
	soap_default_string(soap, &a->Status);
	a->__size = 0;
	a->__any = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tev__EventBrokerConfig(struct soap *soap, const struct tev__EventBrokerConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Address);
	soap_serialize_string(soap, (char*const*)&a->TopicPrefix);
	soap_serialize_string(soap, (char*const*)&a->UserName);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_serialize_PointerTowsnt__FilterType(soap, &a->PublishFilter);
	soap_serialize_PointerToint(soap, &a->QoS);
	soap_serialize_string(soap, (char*const*)&a->Status);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tev__EventBrokerConfig(struct soap *soap, const char *tag, int id, const struct tev__EventBrokerConfig *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tev__EventBrokerConfig), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "tev:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_xsd__anyURI(soap, "tev:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (!a->TopicPrefix)
	{	if (soap_element_empty(soap, "tev:TopicPrefix", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "tev:TopicPrefix", -1, (char*const*)&a->TopicPrefix, ""))
		return soap->error;
	if (soap_out_string(soap, "tev:UserName", -1, (char*const*)&a->UserName, ""))
		return soap->error;
	if (soap_out_string(soap, "tev:Password", -1, (char*const*)&a->Password, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "tev:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tev:PublishFilter", -1, &a->PublishFilter, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tev:QoS", -1, &a->QoS, ""))
		return soap->error;
	if (soap_out_string(soap, "tev:Status", -1, (char*const*)&a->Status, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tev__EventBrokerConfig * SOAP_FMAC4 soap_in_tev__EventBrokerConfig(struct soap *soap, const char *tag, struct tev__EventBrokerConfig *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_TopicPrefix = 1;
	size_t soap_flag_UserName = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_PublishFilter = 1;
	size_t soap_flag_QoS = 1;
	size_t soap_flag_Status = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tev__EventBrokerConfig*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__EventBrokerConfig, sizeof(struct tev__EventBrokerConfig), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tev__EventBrokerConfig(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tev:Address", (char**)&a->Address, "xsd:anyURI"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_TopicPrefix && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tev:TopicPrefix", (char**)&a->TopicPrefix, "xsd:string"))
				{	soap_flag_TopicPrefix--;
					continue;
				}
			}
			if (soap_flag_UserName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tev:UserName", (char**)&a->UserName, "xsd:string"))
				{	soap_flag_UserName--;
					continue;
				}
			}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tev:Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			}
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tev:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			}
			if (soap_flag_PublishFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "tev:PublishFilter", &a->PublishFilter, "wsnt:FilterType"))
				{	soap_flag_PublishFilter--;
					continue;
				}
			}
			if (soap_flag_QoS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tev:QoS", &a->QoS, "xsd:int"))
				{	soap_flag_QoS--;
					continue;
				}
			}
			if (soap_flag_Status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "tev:Status", (char**)&a->Status, "xsd:string"))
				{	soap_flag_Status--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address || !a->TopicPrefix))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tev__EventBrokerConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__EventBrokerConfig, SOAP_TYPE_tev__EventBrokerConfig, sizeof(struct tev__EventBrokerConfig), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tev__EventBrokerConfig * SOAP_FMAC4 soap_new_tev__EventBrokerConfig(struct soap *soap, int n)
{
	struct tev__EventBrokerConfig *p;
	struct tev__EventBrokerConfig *a = (struct tev__EventBrokerConfig*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tev__EventBrokerConfig));
	for (p = a; p && n--; p++)
		soap_default_tev__EventBrokerConfig(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tev__EventBrokerConfig(struct soap *soap, const struct tev__EventBrokerConfig *a, const char *tag, const char *type)
{
	if (soap_out_tev__EventBrokerConfig(soap, tag ? tag : "tev:EventBrokerConfig", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tev__EventBrokerConfig * SOAP_FMAC4 soap_get_tev__EventBrokerConfig(struct soap *soap, struct tev__EventBrokerConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_tev__EventBrokerConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tev__Capabilities(struct soap *soap, struct tev__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->WSSubscriptionPolicySupport = NULL;
	a->WSPullPointSupport = NULL;
	a->WSPausableSubscriptionManagerInterfaceSupport = NULL;
	a->MaxNotificationProducers = NULL;
	a->MaxPullPoints = NULL;
	a->PersistentNotificationStorage = NULL;
	soap_default_string(soap, &a->EventBrokerProtocols);
	a->MaxEventBrokers = NULL;
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tev__Capabilities(struct soap *soap, const struct tev__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tev__Capabilities(struct soap *soap, const char *tag, int id, const struct tev__Capabilities *a, const char *type)
{
	if (a->WSSubscriptionPolicySupport)
	{	soap_set_attr(soap, "WSSubscriptionPolicySupport", soap_xsd__boolean2s(soap, *a->WSSubscriptionPolicySupport), 1);
	}
	if (a->WSPullPointSupport)
	{	soap_set_attr(soap, "WSPullPointSupport", soap_xsd__boolean2s(soap, *a->WSPullPointSupport), 1);
	}
	if (a->WSPausableSubscriptionManagerInterfaceSupport)
	{	soap_set_attr(soap, "WSPausableSubscriptionManagerInterfaceSupport", soap_xsd__boolean2s(soap, *a->WSPausableSubscriptionManagerInterfaceSupport), 1);
	}
	if (a->MaxNotificationProducers)
	{	soap_set_attr(soap, "MaxNotificationProducers", soap_int2s(soap, *a->MaxNotificationProducers), 1);
	}
	if (a->MaxPullPoints)
	{	soap_set_attr(soap, "MaxPullPoints", soap_int2s(soap, *a->MaxPullPoints), 1);
	}
	if (a->PersistentNotificationStorage)
	{	soap_set_attr(soap, "PersistentNotificationStorage", soap_xsd__boolean2s(soap, *a->PersistentNotificationStorage), 1);
	}
	if (a->EventBrokerProtocols)
		soap_set_attr(soap, "EventBrokerProtocols", soap_string2s(soap, a->EventBrokerProtocols), 1);
	if (a->MaxEventBrokers)
	{	soap_set_attr(soap, "MaxEventBrokers", soap_int2s(soap, *a->MaxEventBrokers), 1);
	}
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tev__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tev__Capabilities * SOAP_FMAC4 soap_in_tev__Capabilities(struct soap *soap, const char *tag, struct tev__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct tev__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tev__Capabilities(soap, a);
	{
		const char *t = soap_attr_value(soap, "WSSubscriptionPolicySupport", 5, 0);
		if (t)
		{
			if (!(a->WSSubscriptionPolicySupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->WSSubscriptionPolicySupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "WSPullPointSupport", 5, 0);
		if (t)
		{
			if (!(a->WSPullPointSupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->WSPullPointSupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "WSPausableSubscriptionManagerInterfaceSupport", 5, 0);
		if (t)
		{
			if (!(a->WSPausableSubscriptionManagerInterfaceSupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->WSPausableSubscriptionManagerInterfaceSupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxNotificationProducers", 5, 0);
		if (t)
		{
			if (!(a->MaxNotificationProducers = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxNotificationProducers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxPullPoints", 5, 0);
		if (t)
		{
			if (!(a->MaxPullPoints = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxPullPoints))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PersistentNotificationStorage", 5, 0);
		if (t)
		{
			if (!(a->PersistentNotificationStorage = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->PersistentNotificationStorage))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "EventBrokerProtocols", 1, 0), &a->EventBrokerProtocols))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "MaxEventBrokers", 5, 0);
		if (t)
		{
			if (!(a->MaxEventBrokers = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxEventBrokers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tev__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__Capabilities, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tev__Capabilities * SOAP_FMAC4 soap_new_tev__Capabilities(struct soap *soap, int n)
{
	struct tev__Capabilities *p;
	struct tev__Capabilities *a = (struct tev__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tev__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tev__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tev__Capabilities(struct soap *soap, const struct tev__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tev__Capabilities(soap, tag ? tag : "tev:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tev__Capabilities * SOAP_FMAC4 soap_get_tev__Capabilities(struct soap *soap, struct tev__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tev__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__DeletePaneConfigurationResponse(struct soap *soap, struct _tls__DeletePaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__DeletePaneConfigurationResponse(struct soap *soap, const struct _tls__DeletePaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__DeletePaneConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tls__DeletePaneConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__DeletePaneConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__DeletePaneConfigurationResponse * SOAP_FMAC4 soap_in__tls__DeletePaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__DeletePaneConfigurationResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__DeletePaneConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__DeletePaneConfigurationResponse, sizeof(struct _tls__DeletePaneConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__DeletePaneConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__DeletePaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__DeletePaneConfigurationResponse, SOAP_TYPE__tls__DeletePaneConfigurationResponse, sizeof(struct _tls__DeletePaneConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__DeletePaneConfigurationResponse * SOAP_FMAC4 soap_new__tls__DeletePaneConfigurationResponse(struct soap *soap, int n)
{
	struct _tls__DeletePaneConfigurationResponse *p;
	struct _tls__DeletePaneConfigurationResponse *a = (struct _tls__DeletePaneConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__DeletePaneConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__DeletePaneConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__DeletePaneConfigurationResponse(struct soap *soap, const struct _tls__DeletePaneConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__DeletePaneConfigurationResponse(soap, tag ? tag : "tls:DeletePaneConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__DeletePaneConfigurationResponse * SOAP_FMAC4 soap_get__tls__DeletePaneConfigurationResponse(struct soap *soap, struct _tls__DeletePaneConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__DeletePaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__DeletePaneConfiguration(struct soap *soap, struct _tls__DeletePaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	soap_default_tt__ReferenceToken(soap, &a->PaneToken);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__DeletePaneConfiguration(struct soap *soap, const struct _tls__DeletePaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PaneToken);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__DeletePaneConfiguration(struct soap *soap, const char *tag, int id, const struct _tls__DeletePaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__DeletePaneConfiguration), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_empty(soap, "tls:VideoOutput", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (!a->PaneToken)
	{	if (soap_element_empty(soap, "tls:PaneToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tls:PaneToken", -1, (char*const*)&a->PaneToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__DeletePaneConfiguration * SOAP_FMAC4 soap_in__tls__DeletePaneConfiguration(struct soap *soap, const char *tag, struct _tls__DeletePaneConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_PaneToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__DeletePaneConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__DeletePaneConfiguration, sizeof(struct _tls__DeletePaneConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__DeletePaneConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			}
			if (soap_flag_PaneToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tls:PaneToken", (char**)&a->PaneToken, "tt:ReferenceToken"))
				{	soap_flag_PaneToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput || !a->PaneToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__DeletePaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__DeletePaneConfiguration, SOAP_TYPE__tls__DeletePaneConfiguration, sizeof(struct _tls__DeletePaneConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__DeletePaneConfiguration * SOAP_FMAC4 soap_new__tls__DeletePaneConfiguration(struct soap *soap, int n)
{
	struct _tls__DeletePaneConfiguration *p;
	struct _tls__DeletePaneConfiguration *a = (struct _tls__DeletePaneConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__DeletePaneConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tls__DeletePaneConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__DeletePaneConfiguration(struct soap *soap, const struct _tls__DeletePaneConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tls__DeletePaneConfiguration(soap, tag ? tag : "tls:DeletePaneConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__DeletePaneConfiguration * SOAP_FMAC4 soap_get__tls__DeletePaneConfiguration(struct soap *soap, struct _tls__DeletePaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__DeletePaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__CreatePaneConfigurationResponse(struct soap *soap, struct _tls__CreatePaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->PaneToken);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__CreatePaneConfigurationResponse(struct soap *soap, const struct _tls__CreatePaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PaneToken);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__CreatePaneConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tls__CreatePaneConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__CreatePaneConfigurationResponse), type))
		return soap->error;
	if (a->PaneToken)
		soap_element_result(soap, "tls:PaneToken");
	if (!a->PaneToken)
	{	if (soap_element_empty(soap, "tls:PaneToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tls:PaneToken", -1, (char*const*)&a->PaneToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__CreatePaneConfigurationResponse * SOAP_FMAC4 soap_in__tls__CreatePaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__CreatePaneConfigurationResponse *a, const char *type)
{
	size_t soap_flag_PaneToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__CreatePaneConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__CreatePaneConfigurationResponse, sizeof(struct _tls__CreatePaneConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__CreatePaneConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PaneToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tls:PaneToken", (char**)&a->PaneToken, "tt:ReferenceToken"))
				{	soap_flag_PaneToken--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tls:PaneToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PaneToken))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__CreatePaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__CreatePaneConfigurationResponse, SOAP_TYPE__tls__CreatePaneConfigurationResponse, sizeof(struct _tls__CreatePaneConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__CreatePaneConfigurationResponse * SOAP_FMAC4 soap_new__tls__CreatePaneConfigurationResponse(struct soap *soap, int n)
{
	struct _tls__CreatePaneConfigurationResponse *p;
	struct _tls__CreatePaneConfigurationResponse *a = (struct _tls__CreatePaneConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__CreatePaneConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__CreatePaneConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__CreatePaneConfigurationResponse(struct soap *soap, const struct _tls__CreatePaneConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__CreatePaneConfigurationResponse(soap, tag ? tag : "tls:CreatePaneConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__CreatePaneConfigurationResponse * SOAP_FMAC4 soap_get__tls__CreatePaneConfigurationResponse(struct soap *soap, struct _tls__CreatePaneConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__CreatePaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__CreatePaneConfiguration(struct soap *soap, struct _tls__CreatePaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->PaneConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__CreatePaneConfiguration(struct soap *soap, const struct _tls__CreatePaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	soap_serialize_PointerTott__PaneConfiguration(soap, &a->PaneConfiguration);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__CreatePaneConfiguration(struct soap *soap, const char *tag, int id, const struct _tls__CreatePaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__CreatePaneConfiguration), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_empty(soap, "tls:VideoOutput", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (!a->PaneConfiguration)
	{	if (soap_element_empty(soap, "tls:PaneConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", -1, &a->PaneConfiguration, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__CreatePaneConfiguration * SOAP_FMAC4 soap_in__tls__CreatePaneConfiguration(struct soap *soap, const char *tag, struct _tls__CreatePaneConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_PaneConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__CreatePaneConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__CreatePaneConfiguration, sizeof(struct _tls__CreatePaneConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__CreatePaneConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			}
			if (soap_flag_PaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", &a->PaneConfiguration, "tt:PaneConfiguration"))
				{	soap_flag_PaneConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput || !a->PaneConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__CreatePaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__CreatePaneConfiguration, SOAP_TYPE__tls__CreatePaneConfiguration, sizeof(struct _tls__CreatePaneConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__CreatePaneConfiguration * SOAP_FMAC4 soap_new__tls__CreatePaneConfiguration(struct soap *soap, int n)
{
	struct _tls__CreatePaneConfiguration *p;
	struct _tls__CreatePaneConfiguration *a = (struct _tls__CreatePaneConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__CreatePaneConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tls__CreatePaneConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__CreatePaneConfiguration(struct soap *soap, const struct _tls__CreatePaneConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tls__CreatePaneConfiguration(soap, tag ? tag : "tls:CreatePaneConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__CreatePaneConfiguration * SOAP_FMAC4 soap_get__tls__CreatePaneConfiguration(struct soap *soap, struct _tls__CreatePaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__CreatePaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetPaneConfigurationResponse(struct soap *soap, struct _tls__SetPaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetPaneConfigurationResponse(struct soap *soap, const struct _tls__SetPaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetPaneConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tls__SetPaneConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetPaneConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationResponse * SOAP_FMAC4 soap_in__tls__SetPaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__SetPaneConfigurationResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__SetPaneConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfigurationResponse, sizeof(struct _tls__SetPaneConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetPaneConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfigurationResponse, SOAP_TYPE__tls__SetPaneConfigurationResponse, sizeof(struct _tls__SetPaneConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationResponse * SOAP_FMAC4 soap_new__tls__SetPaneConfigurationResponse(struct soap *soap, int n)
{
	struct _tls__SetPaneConfigurationResponse *p;
	struct _tls__SetPaneConfigurationResponse *a = (struct _tls__SetPaneConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__SetPaneConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__SetPaneConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetPaneConfigurationResponse(struct soap *soap, const struct _tls__SetPaneConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__SetPaneConfigurationResponse(soap, tag ? tag : "tls:SetPaneConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationResponse * SOAP_FMAC4 soap_get__tls__SetPaneConfigurationResponse(struct soap *soap, struct _tls__SetPaneConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetPaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetPaneConfiguration(struct soap *soap, struct _tls__SetPaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->PaneConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetPaneConfiguration(struct soap *soap, const struct _tls__SetPaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	soap_serialize_PointerTott__PaneConfiguration(soap, &a->PaneConfiguration);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetPaneConfiguration(struct soap *soap, const char *tag, int id, const struct _tls__SetPaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetPaneConfiguration), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_empty(soap, "tls:VideoOutput", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (!a->PaneConfiguration)
	{	if (soap_element_empty(soap, "tls:PaneConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", -1, &a->PaneConfiguration, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetPaneConfiguration * SOAP_FMAC4 soap_in__tls__SetPaneConfiguration(struct soap *soap, const char *tag, struct _tls__SetPaneConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_PaneConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__SetPaneConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfiguration, sizeof(struct _tls__SetPaneConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetPaneConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			}
			if (soap_flag_PaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", &a->PaneConfiguration, "tt:PaneConfiguration"))
				{	soap_flag_PaneConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput || !a->PaneConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfiguration, SOAP_TYPE__tls__SetPaneConfiguration, sizeof(struct _tls__SetPaneConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__SetPaneConfiguration * SOAP_FMAC4 soap_new__tls__SetPaneConfiguration(struct soap *soap, int n)
{
	struct _tls__SetPaneConfiguration *p;
	struct _tls__SetPaneConfiguration *a = (struct _tls__SetPaneConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__SetPaneConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tls__SetPaneConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetPaneConfiguration(struct soap *soap, const struct _tls__SetPaneConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tls__SetPaneConfiguration(soap, tag ? tag : "tls:SetPaneConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfiguration * SOAP_FMAC4 soap_get__tls__SetPaneConfiguration(struct soap *soap, struct _tls__SetPaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetPaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetPaneConfigurationsResponse(struct soap *soap, struct _tls__SetPaneConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetPaneConfigurationsResponse(struct soap *soap, const struct _tls__SetPaneConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetPaneConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tls__SetPaneConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetPaneConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationsResponse * SOAP_FMAC4 soap_in__tls__SetPaneConfigurationsResponse(struct soap *soap, const char *tag, struct _tls__SetPaneConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__SetPaneConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfigurationsResponse, sizeof(struct _tls__SetPaneConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetPaneConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfigurationsResponse, SOAP_TYPE__tls__SetPaneConfigurationsResponse, sizeof(struct _tls__SetPaneConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationsResponse * SOAP_FMAC4 soap_new__tls__SetPaneConfigurationsResponse(struct soap *soap, int n)
{
	struct _tls__SetPaneConfigurationsResponse *p;
	struct _tls__SetPaneConfigurationsResponse *a = (struct _tls__SetPaneConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__SetPaneConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__SetPaneConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetPaneConfigurationsResponse(struct soap *soap, const struct _tls__SetPaneConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__SetPaneConfigurationsResponse(soap, tag ? tag : "tls:SetPaneConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationsResponse * SOAP_FMAC4 soap_get__tls__SetPaneConfigurationsResponse(struct soap *soap, struct _tls__SetPaneConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetPaneConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetPaneConfigurations(struct soap *soap, struct _tls__SetPaneConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->__sizePaneConfiguration = 0;
	a->PaneConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetPaneConfigurations(struct soap *soap, const struct _tls__SetPaneConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	if (a->PaneConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneConfiguration; i++)
		{
			soap_embedded(soap, a->PaneConfiguration + i, SOAP_TYPE_tt__PaneConfiguration);
			soap_serialize_tt__PaneConfiguration(soap, a->PaneConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetPaneConfigurations(struct soap *soap, const char *tag, int id, const struct _tls__SetPaneConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetPaneConfigurations), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_empty(soap, "tls:VideoOutput", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (a->PaneConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneConfiguration; i++)
			if (soap_out_tt__PaneConfiguration(soap, "tls:PaneConfiguration", -1, a->PaneConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurations * SOAP_FMAC4 soap_in__tls__SetPaneConfigurations(struct soap *soap, const char *tag, struct _tls__SetPaneConfigurations *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	struct soap_blist *soap_blist_PaneConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__SetPaneConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfigurations, sizeof(struct _tls__SetPaneConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetPaneConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tls:PaneConfiguration", 1, NULL))
			{	if (a->PaneConfiguration == NULL)
				{	if (soap_blist_PaneConfiguration == NULL)
						soap_blist_PaneConfiguration = soap_alloc_block(soap);
					a->PaneConfiguration = (struct tt__PaneConfiguration *)soap_push_block_max(soap, soap_blist_PaneConfiguration, sizeof(struct tt__PaneConfiguration));
					if (a->PaneConfiguration == NULL)
						return NULL;
					soap_default_tt__PaneConfiguration(soap, a->PaneConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__PaneConfiguration(soap, "tls:PaneConfiguration", a->PaneConfiguration, "tt:PaneConfiguration"))
				{	a->__sizePaneConfiguration++;
					a->PaneConfiguration = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PaneConfiguration)
			soap_pop_block(soap, soap_blist_PaneConfiguration);
		if (a->__sizePaneConfiguration)
		{	a->PaneConfiguration = (struct tt__PaneConfiguration *)soap_save_block(soap, soap_blist_PaneConfiguration, NULL, 1);
		}
		else
		{	a->PaneConfiguration = NULL;
			if (soap_blist_PaneConfiguration)
				soap_end_block(soap, soap_blist_PaneConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput || a->__sizePaneConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfigurations, SOAP_TYPE__tls__SetPaneConfigurations, sizeof(struct _tls__SetPaneConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__SetPaneConfigurations * SOAP_FMAC4 soap_new__tls__SetPaneConfigurations(struct soap *soap, int n)
{
	struct _tls__SetPaneConfigurations *p;
	struct _tls__SetPaneConfigurations *a = (struct _tls__SetPaneConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__SetPaneConfigurations));
	for (p = a; p && n--; p++)
		soap_default__tls__SetPaneConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetPaneConfigurations(struct soap *soap, const struct _tls__SetPaneConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__tls__SetPaneConfigurations(soap, tag ? tag : "tls:SetPaneConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurations * SOAP_FMAC4 soap_get__tls__SetPaneConfigurations(struct soap *soap, struct _tls__SetPaneConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetPaneConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetPaneConfigurationResponse(struct soap *soap, struct _tls__GetPaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PaneConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetPaneConfigurationResponse(struct soap *soap, const struct _tls__GetPaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PaneConfiguration(soap, &a->PaneConfiguration);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetPaneConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetPaneConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetPaneConfigurationResponse), type))
		return soap->error;
	if (a->PaneConfiguration)
		soap_element_result(soap, "tls:PaneConfiguration");
	if (!a->PaneConfiguration)
	{	if (soap_element_empty(soap, "tls:PaneConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", -1, &a->PaneConfiguration, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationResponse * SOAP_FMAC4 soap_in__tls__GetPaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__GetPaneConfigurationResponse *a, const char *type)
{
	size_t soap_flag_PaneConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__GetPaneConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfigurationResponse, sizeof(struct _tls__GetPaneConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetPaneConfigurationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", &a->PaneConfiguration, "tt:PaneConfiguration"))
				{	soap_flag_PaneConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tls:PaneConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->PaneConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfigurationResponse, SOAP_TYPE__tls__GetPaneConfigurationResponse, sizeof(struct _tls__GetPaneConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationResponse * SOAP_FMAC4 soap_new__tls__GetPaneConfigurationResponse(struct soap *soap, int n)
{
	struct _tls__GetPaneConfigurationResponse *p;
	struct _tls__GetPaneConfigurationResponse *a = (struct _tls__GetPaneConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetPaneConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__GetPaneConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetPaneConfigurationResponse(struct soap *soap, const struct _tls__GetPaneConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetPaneConfigurationResponse(soap, tag ? tag : "tls:GetPaneConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationResponse * SOAP_FMAC4 soap_get__tls__GetPaneConfigurationResponse(struct soap *soap, struct _tls__GetPaneConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetPaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetPaneConfiguration(struct soap *soap, struct _tls__GetPaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	soap_default_tt__ReferenceToken(soap, &a->Pane);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetPaneConfiguration(struct soap *soap, const struct _tls__GetPaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Pane);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetPaneConfiguration(struct soap *soap, const char *tag, int id, const struct _tls__GetPaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetPaneConfiguration), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_empty(soap, "tls:VideoOutput", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (!a->Pane)
	{	if (soap_element_empty(soap, "tls:Pane", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tls:Pane", -1, (char*const*)&a->Pane, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetPaneConfiguration * SOAP_FMAC4 soap_in__tls__GetPaneConfiguration(struct soap *soap, const char *tag, struct _tls__GetPaneConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_Pane = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__GetPaneConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfiguration, sizeof(struct _tls__GetPaneConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetPaneConfiguration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			}
			if (soap_flag_Pane && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tls:Pane", (char**)&a->Pane, "tt:ReferenceToken"))
				{	soap_flag_Pane--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput || !a->Pane))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfiguration, SOAP_TYPE__tls__GetPaneConfiguration, sizeof(struct _tls__GetPaneConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetPaneConfiguration * SOAP_FMAC4 soap_new__tls__GetPaneConfiguration(struct soap *soap, int n)
{
	struct _tls__GetPaneConfiguration *p;
	struct _tls__GetPaneConfiguration *a = (struct _tls__GetPaneConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetPaneConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tls__GetPaneConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetPaneConfiguration(struct soap *soap, const struct _tls__GetPaneConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetPaneConfiguration(soap, tag ? tag : "tls:GetPaneConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfiguration * SOAP_FMAC4 soap_get__tls__GetPaneConfiguration(struct soap *soap, struct _tls__GetPaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetPaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetPaneConfigurationsResponse(struct soap *soap, struct _tls__GetPaneConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePaneConfiguration = 0;
	a->PaneConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetPaneConfigurationsResponse(struct soap *soap, const struct _tls__GetPaneConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PaneConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneConfiguration; i++)
		{
			soap_embedded(soap, a->PaneConfiguration + i, SOAP_TYPE_tt__PaneConfiguration);
			soap_serialize_tt__PaneConfiguration(soap, a->PaneConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetPaneConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetPaneConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetPaneConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePaneConfiguration");
	if (a->PaneConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneConfiguration; i++)
			if (soap_out_tt__PaneConfiguration(soap, "tls:PaneConfiguration", -1, a->PaneConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationsResponse * SOAP_FMAC4 soap_in__tls__GetPaneConfigurationsResponse(struct soap *soap, const char *tag, struct _tls__GetPaneConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PaneConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__GetPaneConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfigurationsResponse, sizeof(struct _tls__GetPaneConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetPaneConfigurationsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tls:PaneConfiguration", 1, NULL))
			{	if (a->PaneConfiguration == NULL)
				{	if (soap_blist_PaneConfiguration == NULL)
						soap_blist_PaneConfiguration = soap_alloc_block(soap);
					a->PaneConfiguration = (struct tt__PaneConfiguration *)soap_push_block_max(soap, soap_blist_PaneConfiguration, sizeof(struct tt__PaneConfiguration));
					if (a->PaneConfiguration == NULL)
						return NULL;
					soap_default_tt__PaneConfiguration(soap, a->PaneConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__PaneConfiguration(soap, "tls:PaneConfiguration", a->PaneConfiguration, "tt:PaneConfiguration"))
				{	a->__sizePaneConfiguration++;
					a->PaneConfiguration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePaneConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PaneConfiguration)
			soap_pop_block(soap, soap_blist_PaneConfiguration);
		if (a->__sizePaneConfiguration)
		{	a->PaneConfiguration = (struct tt__PaneConfiguration *)soap_save_block(soap, soap_blist_PaneConfiguration, NULL, 1);
		}
		else
		{	a->PaneConfiguration = NULL;
			if (soap_blist_PaneConfiguration)
				soap_end_block(soap, soap_blist_PaneConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePaneConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfigurationsResponse, SOAP_TYPE__tls__GetPaneConfigurationsResponse, sizeof(struct _tls__GetPaneConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationsResponse * SOAP_FMAC4 soap_new__tls__GetPaneConfigurationsResponse(struct soap *soap, int n)
{
	struct _tls__GetPaneConfigurationsResponse *p;
	struct _tls__GetPaneConfigurationsResponse *a = (struct _tls__GetPaneConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetPaneConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__GetPaneConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetPaneConfigurationsResponse(struct soap *soap, const struct _tls__GetPaneConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetPaneConfigurationsResponse(soap, tag ? tag : "tls:GetPaneConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationsResponse * SOAP_FMAC4 soap_get__tls__GetPaneConfigurationsResponse(struct soap *soap, struct _tls__GetPaneConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetPaneConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetPaneConfigurations(struct soap *soap, struct _tls__GetPaneConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetPaneConfigurations(struct soap *soap, const struct _tls__GetPaneConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetPaneConfigurations(struct soap *soap, const char *tag, int id, const struct _tls__GetPaneConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetPaneConfigurations), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_empty(soap, "tls:VideoOutput", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurations * SOAP_FMAC4 soap_in__tls__GetPaneConfigurations(struct soap *soap, const char *tag, struct _tls__GetPaneConfigurations *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__GetPaneConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfigurations, sizeof(struct _tls__GetPaneConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetPaneConfigurations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfigurations, SOAP_TYPE__tls__GetPaneConfigurations, sizeof(struct _tls__GetPaneConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetPaneConfigurations * SOAP_FMAC4 soap_new__tls__GetPaneConfigurations(struct soap *soap, int n)
{
	struct _tls__GetPaneConfigurations *p;
	struct _tls__GetPaneConfigurations *a = (struct _tls__GetPaneConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetPaneConfigurations));
	for (p = a; p && n--; p++)
		soap_default__tls__GetPaneConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetPaneConfigurations(struct soap *soap, const struct _tls__GetPaneConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetPaneConfigurations(soap, tag ? tag : "tls:GetPaneConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurations * SOAP_FMAC4 soap_get__tls__GetPaneConfigurations(struct soap *soap, struct _tls__GetPaneConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetPaneConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetDisplayOptionsResponse(struct soap *soap, struct _tls__GetDisplayOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->LayoutOptions = NULL;
	a->CodingCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetDisplayOptionsResponse(struct soap *soap, const struct _tls__GetDisplayOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__LayoutOptions(soap, &a->LayoutOptions);
	soap_serialize_PointerTott__CodingCapabilities(soap, &a->CodingCapabilities);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetDisplayOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetDisplayOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetDisplayOptionsResponse), type))
		return soap->error;
	if (a->LayoutOptions)
		soap_element_result(soap, "tls:LayoutOptions");
	if (soap_out_PointerTott__LayoutOptions(soap, "tls:LayoutOptions", -1, &a->LayoutOptions, ""))
		return soap->error;
	if (!a->CodingCapabilities)
	{	if (soap_element_empty(soap, "tls:CodingCapabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__CodingCapabilities(soap, "tls:CodingCapabilities", -1, &a->CodingCapabilities, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetDisplayOptionsResponse * SOAP_FMAC4 soap_in__tls__GetDisplayOptionsResponse(struct soap *soap, const char *tag, struct _tls__GetDisplayOptionsResponse *a, const char *type)
{
	size_t soap_flag_LayoutOptions = 1;
	size_t soap_flag_CodingCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__GetDisplayOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetDisplayOptionsResponse, sizeof(struct _tls__GetDisplayOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetDisplayOptionsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LayoutOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LayoutOptions(soap, "tls:LayoutOptions", &a->LayoutOptions, "tt:LayoutOptions"))
				{	soap_flag_LayoutOptions--;
					continue;
				}
			}
			if (soap_flag_CodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CodingCapabilities(soap, "tls:CodingCapabilities", &a->CodingCapabilities, "tt:CodingCapabilities"))
				{	soap_flag_CodingCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tls:LayoutOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CodingCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetDisplayOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetDisplayOptionsResponse, SOAP_TYPE__tls__GetDisplayOptionsResponse, sizeof(struct _tls__GetDisplayOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetDisplayOptionsResponse * SOAP_FMAC4 soap_new__tls__GetDisplayOptionsResponse(struct soap *soap, int n)
{
	struct _tls__GetDisplayOptionsResponse *p;
	struct _tls__GetDisplayOptionsResponse *a = (struct _tls__GetDisplayOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetDisplayOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__GetDisplayOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetDisplayOptionsResponse(struct soap *soap, const struct _tls__GetDisplayOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetDisplayOptionsResponse(soap, tag ? tag : "tls:GetDisplayOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetDisplayOptionsResponse * SOAP_FMAC4 soap_get__tls__GetDisplayOptionsResponse(struct soap *soap, struct _tls__GetDisplayOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetDisplayOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetDisplayOptions(struct soap *soap, struct _tls__GetDisplayOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetDisplayOptions(struct soap *soap, const struct _tls__GetDisplayOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetDisplayOptions(struct soap *soap, const char *tag, int id, const struct _tls__GetDisplayOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetDisplayOptions), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_empty(soap, "tls:VideoOutput", 0, NULL))
			return soap->error;
	}
	else if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetDisplayOptions * SOAP_FMAC4 soap_in__tls__GetDisplayOptions(struct soap *soap, const char *tag, struct _tls__GetDisplayOptions *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__GetDisplayOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetDisplayOptions, sizeof(struct _tls__GetDisplayOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetDisplayOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VideoOutput))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetDisplayOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetDisplayOptions, SOAP_TYPE__tls__GetDisplayOptions, sizeof(struct _tls__GetDisplayOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetDisplayOptions * SOAP_FMAC4 soap_new__tls__GetDisplayOptions(struct soap *soap, int n)
{
	struct _tls__GetDisplayOptions *p;
	struct _tls__GetDisplayOptions *a = (struct _tls__GetDisplayOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetDisplayOptions));
	for (p = a; p && n--; p++)
		soap_default__tls__GetDisplayOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetDisplayOptions(struct soap *soap, const struct _tls__GetDisplayOptions *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetDisplayOptions(soap, tag ? tag : "tls:GetDisplayOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetDisplayOptions * SOAP_FMAC4 soap_get__tls__GetDisplayOptions(struct soap *soap, struct _tls__GetDisplayOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetDisplayOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetLayoutResponse(struct soap *soap, struct _tls__SetLayoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetLayoutResponse(struct soap *soap, const struct _tls__SetLayoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
		{
			soap_serialize_xsd__anyType(soap, a->__any + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetLayoutResponse(struct soap *soap, const char *tag, int id, const struct _tls__SetLayoutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetLayoutResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_out_xsd__anyType(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetLayoutResponse * SOAP_FMAC4 soap_in__tls__SetLayoutResponse(struct soap *soap, const char *tag, struct _tls__SetLayoutResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct _tls__SetLayoutResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetLayoutResponse, sizeof(struct _tls__SetLayoutResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetLayoutResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (struct soap_dom_element *)soap_push_block_max(soap, soap_blist___any, sizeof(struct soap_dom_element));
					if (a->__any == NULL)
						return NULL;
					soap_default_xsd__anyType(soap, a->__any);
				}
				if (soap_in_xsd__anyType(soap, "-any", a->__any, "xsd:anyType"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (struct soap_dom_element *)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__SetLayoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetLayoutResponse, SOAP_TYPE__tls__SetLayoutResponse, sizeof(struct _tls__SetLayoutResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__SetLayoutResponse * SOAP_FMAC4 soap_new__tls__SetLayoutResponse(struct soap *soap, int n)
{
	struct _tls__SetLayoutResponse *p;
	struct _tls__SetLayoutResponse *a = (struct _tls__SetLayoutResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__SetLayoutResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__SetLayoutResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetLayoutResponse(struct soap *soap, const struct _tls__SetLayoutResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__SetLayoutResponse(soap, tag ? tag : "tls:SetLayoutResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetLayoutResponse * SOAP_FMAC4 soap_get__tls__SetLayoutResponse(struct soap *soap, struct _tls__SetLayoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetLayoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
